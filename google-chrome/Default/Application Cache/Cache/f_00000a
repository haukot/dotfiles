{"sdk/lib/_collection_dev/arrays.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart._collection.dev;\n\n// TODO(ngeoffray): Rename to Lists.\nclass Arrays {\n  static void copy(List src, int srcStart,\n                   List dst, int dstStart, int count) {\n    if (srcStart < dstStart) {\n      for (int i = srcStart + count - 1, j = dstStart + count - 1;\n           i >= srcStart; i--, j--) {\n        dst[j] = src[i];\n      }\n    } else {\n      for (int i = srcStart, j = dstStart; i < srcStart + count; i++, j++) {\n        dst[j] = src[i];\n      }\n    }\n  }\n\n  static bool areEqual(List a, Object b) {\n    if (identical(a, b)) return true;\n    if (!(b is List)) return false;\n    int length = a.length;\n    if (length != b.length) return false;\n\n    for (int i = 0; i < length; i++) {\n      if (!identical(a[i], b[i])) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Returns the index in the list [a] of the given [element], starting\n   * the search at index [startIndex] to [endIndex] (exclusive).\n   * Returns -1 if [element] is not found.\n   */\n  static int indexOf(List a,\n                     Object element,\n                     int startIndex,\n                     int endIndex) {\n    if (startIndex >= a.length) {\n      return -1;\n    }\n    if (startIndex < 0) {\n      startIndex = 0;\n    }\n    for (int i = startIndex; i < endIndex; i++) {\n      if (a[i] == element) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the last index in the list [a] of the given [element], starting\n   * the search at index [startIndex] to 0.\n   * Returns -1 if [element] is not found.\n   */\n  static int lastIndexOf(List a, Object element, int startIndex) {\n    if (startIndex < 0) {\n      return -1;\n    }\n    if (startIndex >= a.length) {\n      startIndex = a.length - 1;\n    }\n    for (int i = startIndex; i >= 0; i--) {\n      if (a[i] == element) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  static void indicesCheck(List a, int start, int end) {\n    if (start < 0 || start > a.length) {\n      throw new RangeError.range(start, 0, a.length);\n    }\n    if (end != null && (end < start || end > a.length)) {\n      throw new RangeError.range(end, start, a.length);\n    }\n  }\n\n  static void rangeCheck(List a, int start, int length) {\n    if (length < 0) {\n      throw new ArgumentError(\"negative length $length\");\n    }\n    if (start < 0 ) {\n      String message = \"$start must be greater than or equal to 0\";\n      throw new RangeError(message);\n    }\n    if (start + length > a.length) {\n      String message = \"$start + $length must be in the range [0..${a.length})\";\n      throw new RangeError(message);\n    }\n  }\n}\n","sdk/lib/_collection_dev/collection_dev.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart._collection.dev;\n\nimport 'dart:collection';\n\nimport 'dart:core' hide Symbol;\nimport 'dart:core' as core;\n\npart 'arrays.dart';\npart 'iterable.dart';\npart 'list.dart';\npart 'sort.dart';\npart 'symbol.dart';\npart 'to_string.dart';\n","sdk/lib/_collection_dev/iterable.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart._collection.dev;\n\n/**\n * An [Iterable] for classes that have efficient [length] and [elementAt].\n *\n * All other methods are implemented in terms of [length] and [elementAt],\n * including [iterator].\n */\nabstract class ListIterable<E> extends IterableBase<E> {\n  int get length;\n  E elementAt(int i);\n\n  const ListIterable();\n\n  Iterator<E> get iterator => new ListIterator<E>(this);\n\n  void forEach(void action(E element)) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      action(elementAt(i));\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n  }\n\n  bool get isEmpty => length == 0;\n\n  E get first {\n    if (length == 0) throw new StateError(\"No elements\");\n    return elementAt(0);\n  }\n\n  E get last {\n    if (length == 0) throw new StateError(\"No elements\");\n    return elementAt(length - 1);\n  }\n\n  E get single {\n    if (length == 0) throw new StateError(\"No elements\");\n    if (length > 1) throw new StateError(\"Too many elements\");\n    return elementAt(0);\n  }\n\n  bool contains(E element) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      if (elementAt(i) == element) return true;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return false;\n  }\n\n  bool every(bool test(E element)) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      if (!test(elementAt(i))) return false;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return true;\n  }\n\n  bool any(bool test(E element)) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      if (test(elementAt(i))) return true;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return false;\n  }\n\n  E firstWhere(bool test(E element), { E orElse() }) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      E element = elementAt(i);\n      if (test(element)) return element;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  E lastWhere(bool test(E element), { E orElse() }) {\n    int length = this.length;\n    for (int i = length - 1; i >= 0; i--) {\n      E element = elementAt(i);\n      if (test(element)) return element;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  E singleWhere(bool test(E element)) {\n    int length = this.length;\n    E match = null;\n    bool matchFound = false;\n    for (int i = 0; i < length; i++) {\n      E element = elementAt(i);\n      if (test(element)) {\n        if (matchFound) {\n          throw new StateError(\"More than one matching element\");\n        }\n        matchFound = true;\n        match = element;\n      }\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    if (matchFound) return match;\n    throw new StateError(\"No matching element\");\n  }\n\n  String join([String separator = \"\"]) {\n    int length = this.length;\n    if (!separator.isEmpty) {\n      if (length == 0) return \"\";\n      String first = \"${elementAt(0)}\";\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n      StringBuffer buffer = new StringBuffer(first);\n      for (int i = 1; i < length; i++) {\n        buffer.write(separator);\n        buffer.write(elementAt(i));\n        if (length != this.length) {\n          throw new ConcurrentModificationError(this);\n        }\n      }\n      return buffer.toString();\n    } else {\n      StringBuffer buffer = new StringBuffer();\n      for (int i = 0; i < length; i++) {\n        buffer.write(elementAt(i));\n        if (length != this.length) {\n          throw new ConcurrentModificationError(this);\n        }\n      }\n      return buffer.toString();\n    }\n  }\n\n  Iterable<E> where(bool test(E element)) => super.where(test);\n\n  Iterable map(f(E element)) => new MappedListIterable(this, f);\n\n  E reduce(E combine(var value, E element)) {\n    if (length == 0) throw new StateError(\"No elements\");\n    E value = elementAt(0);\n    for (int i = 1; i < length; i++) {\n      value = combine(value, elementAt(i));\n    }\n    return value;\n  }\n\n  fold(var initialValue, combine(var previousValue, E element)) {\n    var value = initialValue;\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      value = combine(value, elementAt(i));\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return value;\n  }\n\n  Iterable<E> skip(int count) => new SubListIterable(this, count, null);\n\n  Iterable<E> skipWhile(bool test(E element)) => super.skipWhile(test);\n\n  Iterable<E> take(int count) => new SubListIterable(this, 0, count);\n\n  Iterable<E> takeWhile(bool test(E element)) => super.takeWhile(test);\n\n  List<E> toList({ bool growable: true }) {\n    List<E> result;\n    if (growable) {\n      result = new List<E>()..length = length;\n    } else {\n      result = new List<E>(length);\n    }\n    for (int i = 0; i < length; i++) {\n      result[i] = elementAt(i);\n    }\n    return result;\n  }\n\n  Set<E> toSet() {\n    Set<E> result = new Set<E>();\n    for (int i = 0; i < length; i++) {\n      result.add(elementAt(i));\n    }\n    return result;\n  }\n}\n\nclass SubListIterable<E> extends ListIterable<E> {\n  final Iterable<E> _iterable;\n  final int _start;\n  /** If null, represents the length of the iterable. */\n  final int _endOrLength;\n\n  SubListIterable(this._iterable, this._start, this._endOrLength);\n\n  int get _endIndex {\n    int length = _iterable.length;\n    if (_endOrLength == null || _endOrLength > length) return length;\n    return _endOrLength;\n  }\n\n  int get _startIndex {\n    int length = _iterable.length;\n    if (_start > length) return length;\n    return _start;\n  }\n\n  int get length {\n    int length = _iterable.length;\n    if (_start >= length) return 0;\n    if (_endOrLength == null || _endOrLength >= length) {\n      return length - _start;\n    }\n    return _endOrLength - _start;\n  }\n\n  E elementAt(int index) {\n    int realIndex = _startIndex + index;\n    if (index < 0 || realIndex >= _endIndex) {\n      throw new RangeError.range(index, 0, length);\n    }\n    return _iterable.elementAt(realIndex);\n  }\n\n  Iterable<E> skip(int count) {\n    if (count < 0) throw new ArgumentError(count);\n    return new SubListIterable(_iterable, _start + count, _endOrLength);\n  }\n\n  Iterable<E> take(int count) {\n    if (count < 0) throw new ArgumentError(count);\n    if (_endOrLength == null) {\n      return new SubListIterable(_iterable, _start, _start + count);\n    } else {\n      int newEnd = _start + count;\n      if (_endOrLength < newEnd) return this;\n      return new SubListIterable(_iterable, _start, newEnd);\n    }\n  }\n}\n\n/**\n * An [Iterator] that iterates a list-like [Iterable].\n *\n * All iterations is done in terms of [Iterable.length] and\n * [Iterable.elementAt]. These operations are fast for list-like\n * iterables.\n */\nclass ListIterator<E> implements Iterator<E> {\n  final Iterable<E> _iterable;\n  final int _length;\n  int _index;\n  E _current;\n\n  ListIterator(Iterable<E> iterable)\n      : _iterable = iterable, _length = iterable.length, _index = 0;\n\n  E get current => _current;\n\n  bool moveNext() {\n    if (_length != _iterable.length) {\n      throw new ConcurrentModificationError(_iterable);\n    }\n    if (_index == _length) {\n      _current = null;\n      return false;\n    }\n    _current = _iterable.elementAt(_index);\n    _index++;\n    return true;\n  }\n}\n\ntypedef T _Transformation<S, T>(S value);\n\nclass MappedIterable<S, T> extends IterableBase<T> {\n  final Iterable<S> _iterable;\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  final /* _Transformation<S, T> */ _f;\n\n  MappedIterable(this._iterable, T this._f(S element));\n\n  Iterator<T> get iterator => new MappedIterator<S, T>(_iterable.iterator, _f);\n\n  // Length related functions are independent of the mapping.\n  int get length => _iterable.length;\n  bool get isEmpty => _iterable.isEmpty;\n\n  // Index based lookup can be done before transforming.\n  T get first => _f(_iterable.first);\n  T get last => _f(_iterable.last);\n  T get single => _f(_iterable.single);\n  T elementAt(int index) => _f(_iterable.elementAt(index));\n}\n\nclass MappedIterator<S, T> extends Iterator<T> {\n  T _current;\n  final Iterator<S> _iterator;\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  final /* _Transformation<S, T> */ _f;\n\n  MappedIterator(this._iterator, T this._f(S element));\n\n  bool moveNext() {\n    if (_iterator.moveNext()) {\n      _current = _f(_iterator.current);\n      return true;\n    }\n    _current = null;\n    return false;\n  }\n\n  T get current => _current;\n}\n\n/** Specialized alternative to [MappedIterable] for mapped [List]s. */\nclass MappedListIterable<S, T> extends ListIterable<T> {\n  final Iterable<S> _source;\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  final /* _Transformation<S, T> */ _f;\n\n  MappedListIterable(this._source, T this._f(S value));\n\n  int get length => _source.length;\n  T elementAt(int index) => _f(_source.elementAt(index));\n}\n\n\ntypedef bool _ElementPredicate<E>(E element);\n\nclass WhereIterable<E> extends IterableBase<E> {\n  final Iterable<E> _iterable;\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  final /* _ElementPredicate */ _f;\n\n  WhereIterable(this._iterable, bool this._f(E element));\n\n  Iterator<E> get iterator => new WhereIterator<E>(_iterable.iterator, _f);\n}\n\nclass WhereIterator<E> extends Iterator<E> {\n  final Iterator<E> _iterator;\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  final /* _ElementPredicate */ _f;\n\n  WhereIterator(this._iterator, bool this._f(E element));\n\n  bool moveNext() {\n    while (_iterator.moveNext()) {\n      if (_f(_iterator.current)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  E get current => _iterator.current;\n}\n\ntypedef Iterable<T> _ExpandFunction<S, T>(S sourceElement);\n\nclass ExpandIterable<S, T> extends IterableBase<T> {\n  final Iterable<S> _iterable;\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  final /* _ExpandFunction */ _f;\n\n  ExpandIterable(this._iterable, Iterable<T> this._f(S element));\n\n  Iterator<T> get iterator => new ExpandIterator<S, T>(_iterable.iterator, _f);\n}\n\nclass ExpandIterator<S, T> implements Iterator<T> {\n  final Iterator<S> _iterator;\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  final /* _ExpandFunction */ _f;\n  // Initialize _currentExpansion to an empty iterable. A null value\n  // marks the end of iteration, and we don't want to call _f before\n  // the first moveNext call.\n  Iterator<T> _currentExpansion = const EmptyIterator();\n  T _current;\n\n  ExpandIterator(this._iterator, Iterable<T> this._f(S element));\n\n  void _nextExpansion() {\n  }\n\n  T get current => _current;\n\n  bool moveNext() {\n    if (_currentExpansion == null) return false;\n    while (!_currentExpansion.moveNext()) {\n      _current = null;\n      if (_iterator.moveNext()) {\n        // If _f throws, this ends iteration. Otherwise _currentExpansion and\n        // _current will be set again below.\n        _currentExpansion = null;\n        _currentExpansion = _f(_iterator.current).iterator;\n      } else {\n        return false;\n      }\n    }\n    _current = _currentExpansion.current;\n    return true;\n  }\n}\n\nclass TakeIterable<E> extends IterableBase<E> {\n  final Iterable<E> _iterable;\n  final int _takeCount;\n\n  TakeIterable(this._iterable, this._takeCount) {\n    if (_takeCount is! int || _takeCount < 0) {\n      throw new ArgumentError(_takeCount);\n    }\n  }\n\n  Iterator<E> get iterator {\n    return new TakeIterator<E>(_iterable.iterator, _takeCount);\n  }\n}\n\nclass TakeIterator<E> extends Iterator<E> {\n  final Iterator<E> _iterator;\n  int _remaining;\n\n  TakeIterator(this._iterator, this._remaining) {\n    assert(_remaining is int && _remaining >= 0);\n  }\n\n  bool moveNext() {\n    _remaining--;\n    if (_remaining >= 0) {\n      return _iterator.moveNext();\n    }\n    _remaining = -1;\n    return false;\n  }\n\n  E get current {\n    if (_remaining < 0) return null;\n    return _iterator.current;\n  }\n}\n\nclass TakeWhileIterable<E> extends IterableBase<E> {\n  final Iterable<E> _iterable;\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  final /* _ElementPredicate */ _f;\n\n  TakeWhileIterable(this._iterable, bool this._f(E element));\n\n  Iterator<E> get iterator {\n    return new TakeWhileIterator<E>(_iterable.iterator, _f);\n  }\n}\n\nclass TakeWhileIterator<E> extends Iterator<E> {\n  final Iterator<E> _iterator;\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  final /* _ElementPredicate */ _f;\n  bool _isFinished = false;\n\n  TakeWhileIterator(this._iterator, bool this._f(E element));\n\n  bool moveNext() {\n    if (_isFinished) return false;\n    if (!_iterator.moveNext() || !_f(_iterator.current)) {\n      _isFinished = true;\n      return false;\n    }\n    return true;\n  }\n\n  E get current {\n    if (_isFinished) return null;\n    return _iterator.current;\n  }\n}\n\nclass SkipIterable<E> extends IterableBase<E> {\n  final Iterable<E> _iterable;\n  final int _skipCount;\n\n  SkipIterable(this._iterable, this._skipCount) {\n    if (_skipCount is! int || _skipCount < 0) {\n      throw new ArgumentError(_skipCount);\n    }\n  }\n\n  Iterable<E> skip(int n) {\n    if (n is! int || n < 0) {\n      throw new ArgumentError(n);\n    }\n    return new SkipIterable<E>(_iterable, _skipCount + n);\n  }\n\n  Iterator<E> get iterator {\n    return new SkipIterator<E>(_iterable.iterator, _skipCount);\n  }\n}\n\nclass SkipIterator<E> extends Iterator<E> {\n  final Iterator<E> _iterator;\n  int _skipCount;\n\n  SkipIterator(this._iterator, this._skipCount) {\n    assert(_skipCount is int && _skipCount >= 0);\n  }\n\n  bool moveNext() {\n    for (int i = 0; i < _skipCount; i++) _iterator.moveNext();\n    _skipCount = 0;\n    return _iterator.moveNext();\n  }\n\n  E get current => _iterator.current;\n}\n\nclass SkipWhileIterable<E> extends IterableBase<E> {\n  final Iterable<E> _iterable;\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  final /* _ElementPredicate */ _f;\n\n  SkipWhileIterable(this._iterable, bool this._f(E element));\n\n  Iterator<E> get iterator {\n    return new SkipWhileIterator<E>(_iterable.iterator, _f);\n  }\n}\n\nclass SkipWhileIterator<E> extends Iterator<E> {\n  final Iterator<E> _iterator;\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  final /* _ElementPredicate */ _f;\n  bool _hasSkipped = false;\n\n  SkipWhileIterator(this._iterator, bool this._f(E element));\n\n  bool moveNext() {\n    if (!_hasSkipped) {\n      _hasSkipped = true;\n      while (_iterator.moveNext()) {\n        if (!_f(_iterator.current)) return true;\n      }\n    }\n    return _iterator.moveNext();\n  }\n\n  E get current => _iterator.current;\n}\n\n/**\n * The always empty [Iterable].\n */\nclass EmptyIterable<E> extends IterableBase<E> {\n  const EmptyIterable();\n\n  Iterator<E> get iterator => const EmptyIterator();\n\n  void forEach(void action(E element)) {}\n\n  bool get isEmpty => true;\n\n  int get length => 0;\n\n  E get first { throw new StateError(\"No elements\"); }\n\n  E get last { throw new StateError(\"No elements\"); }\n\n  E get single { throw new StateError(\"No elements\"); }\n\n  E elementAt(int index) { throw new RangeError.value(index); }\n\n  bool contains(E element) => false;\n\n  bool every(bool test(E element)) => true;\n\n  bool any(bool test(E element)) => false;\n\n  E firstWhere(bool test(E element), { E orElse() }) {\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  E lastWhere(bool test(E element), { E orElse() }) {\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  E singleWhere(bool test(E element), { E orElse() }) {\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  String join([String separator = \"\"]) => \"\";\n\n  Iterable<E> where(bool test(E element)) => this;\n\n  Iterable map(f(E element)) => const EmptyIterable();\n\n  E reduce(E combine(E value, E element)) {\n    throw new StateError(\"No elements\");\n  }\n\n  fold(var initialValue, combine(var previousValue, E element)) {\n    return initialValue;\n  }\n\n  Iterable<E> skip(int count) => this;\n\n  Iterable<E> skipWhile(bool test(E element)) => this;\n\n  Iterable<E> take(int count) => this;\n\n  Iterable<E> takeWhile(bool test(E element)) => this;\n\n  List toList({ bool growable: true }) => growable ? <E>[] : new List<E>(0);\n\n  Set toSet() => new Set<E>();\n}\n\n/** The always empty iterator. */\nclass EmptyIterator<E> implements Iterator<E> {\n  const EmptyIterator();\n  bool moveNext() => false;\n  E get current => null;\n}\n\n/** An [Iterator] that can move in both directions. */\nabstract class BidirectionalIterator<T> implements Iterator<T> {\n  bool movePrevious();\n}\n\n/**\n * This class provides default implementations for Iterables (including Lists).\n *\n * The uses of this class will be replaced by mixins.\n */\nclass IterableMixinWorkaround {\n  static bool contains(Iterable iterable, var element) {\n    for (final e in iterable) {\n      if (element == e) return true;\n    }\n    return false;\n  }\n\n  static void forEach(Iterable iterable, void f(o)) {\n    for (final e in iterable) {\n      f(e);\n    }\n  }\n\n  static bool any(Iterable iterable, bool f(o)) {\n    for (final e in iterable) {\n      if (f(e)) return true;\n    }\n    return false;\n  }\n\n  static bool every(Iterable iterable, bool f(o)) {\n    for (final e in iterable) {\n      if (!f(e)) return false;\n    }\n    return true;\n  }\n\n  static dynamic reduce(Iterable iterable,\n                        dynamic combine(previousValue, element)) {\n    Iterator iterator = iterable.iterator;\n    if (!iterator.moveNext()) throw new StateError(\"No elements\");\n    var value = iterator.current;\n    while (iterator.moveNext()) {\n      value = combine(value, iterator.current);\n    }\n    return value;\n  }\n\n  static dynamic fold(Iterable iterable,\n                      dynamic initialValue,\n                      dynamic combine(dynamic previousValue, element)) {\n    for (final element in iterable) {\n      initialValue = combine(initialValue, element);\n    }\n    return initialValue;\n  }\n\n  /**\n   * Removes elements matching [test] from [list].\n   *\n   * This is performed in two steps, to avoid exposing an inconsistent state\n   * to the [test] function. First the elements to retain are found, and then\n   * the original list is updated to contain those elements.\n   */\n  static void removeWhereList(List list, bool test(var element)) {\n    List retained = [];\n    int length = list.length;\n    for (int i = 0; i < length; i++) {\n      var element = list[i];\n      if (!test(element)) {\n        retained.add(element);\n      }\n      if (length != list.length) {\n        throw new ConcurrentModificationError(list);\n      }\n    }\n    if (retained.length == length) return;\n    list.length = retained.length;\n    for (int i = 0; i < retained.length; i++) {\n      list[i] = retained[i];\n    }\n  }\n\n  static bool isEmpty(Iterable iterable) {\n    return !iterable.iterator.moveNext();\n  }\n\n  static dynamic first(Iterable iterable) {\n    Iterator it = iterable.iterator;\n    if (!it.moveNext()) {\n      throw new StateError(\"No elements\");\n    }\n    return it.current;\n  }\n\n  static dynamic last(Iterable iterable) {\n    Iterator it = iterable.iterator;\n    if (!it.moveNext()) {\n      throw new StateError(\"No elements\");\n    }\n    dynamic result;\n    do {\n      result = it.current;\n    } while(it.moveNext());\n    return result;\n  }\n\n  static dynamic single(Iterable iterable) {\n    Iterator it = iterable.iterator;\n    if (!it.moveNext()) throw new StateError(\"No elements\");\n    dynamic result = it.current;\n    if (it.moveNext()) throw new StateError(\"More than one element\");\n    return result;\n  }\n\n  static dynamic firstWhere(Iterable iterable,\n                               bool test(dynamic value),\n                               dynamic orElse()) {\n    for (dynamic element in iterable) {\n      if (test(element)) return element;\n    }\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  static dynamic lastWhere(Iterable iterable,\n                           bool test(dynamic value),\n                           dynamic orElse()) {\n    dynamic result = null;\n    bool foundMatching = false;\n    for (dynamic element in iterable) {\n      if (test(element)) {\n        result = element;\n        foundMatching = true;\n      }\n    }\n    if (foundMatching) return result;\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  static dynamic lastWhereList(List list,\n                               bool test(dynamic value),\n                               dynamic orElse()) {\n    // TODO(floitsch): check that arguments are of correct type?\n    for (int i = list.length - 1; i >= 0; i--) {\n      dynamic element = list[i];\n      if (test(element)) return element;\n    }\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  static dynamic singleWhere(Iterable iterable, bool test(dynamic value)) {\n    dynamic result = null;\n    bool foundMatching = false;\n    for (dynamic element in iterable) {\n      if (test(element)) {\n        if (foundMatching) {\n          throw new StateError(\"More than one matching element\");\n        }\n        result = element;\n        foundMatching = true;\n      }\n    }\n    if (foundMatching) return result;\n    throw new StateError(\"No matching element\");\n  }\n\n  static dynamic elementAt(Iterable iterable, int index) {\n    if (index is! int || index < 0) throw new RangeError.value(index);\n    int remaining = index;\n    for (dynamic element in iterable) {\n      if (remaining == 0) return element;\n      remaining--;\n    }\n    throw new RangeError.value(index);\n  }\n\n  static String join(Iterable iterable, [String separator]) {\n    StringBuffer buffer = new StringBuffer();\n    buffer.writeAll(iterable, separator);\n    return buffer.toString();\n  }\n\n  static String joinList(List list, [String separator]) {\n    if (list.isEmpty) return \"\";\n    if (list.length == 1) return \"${list[0]}\";\n    StringBuffer buffer = new StringBuffer();\n    if (separator.isEmpty) {\n      for (int i = 0; i < list.length; i++) {\n        buffer.write(list[i]);\n      }\n    } else {\n      buffer.write(list[0]);\n      for (int i = 1; i < list.length; i++) {\n        buffer.write(separator);\n        buffer.write(list[i]);\n      }\n    }\n    return buffer.toString();\n  }\n\n  static Iterable where(Iterable iterable, bool f(var element)) {\n    return new WhereIterable(iterable, f);\n  }\n\n  static Iterable map(Iterable iterable, f(var element)) {\n    return new MappedIterable(iterable, f);\n  }\n\n  static Iterable mapList(List list, f(var element)) {\n    return new MappedListIterable(list, f);\n  }\n\n  static Iterable expand(Iterable iterable, Iterable f(var element)) {\n    return new ExpandIterable(iterable, f);\n  }\n\n  static Iterable takeList(List list, int n) {\n    // The generic type is currently lost. It will be fixed with mixins.\n    return new SubListIterable(list, 0, n);\n  }\n\n  static Iterable takeWhile(Iterable iterable, bool test(var value)) {\n    // The generic type is currently lost. It will be fixed with mixins.\n    return new TakeWhileIterable(iterable, test);\n  }\n\n  static Iterable skipList(List list, int n) {\n    // The generic type is currently lost. It will be fixed with mixins.\n    return new SubListIterable(list, n, null);\n  }\n\n  static Iterable skipWhile(Iterable iterable, bool test(var value)) {\n    // The generic type is currently lost. It will be fixed with mixins.\n    return new SkipWhileIterable(iterable, test);\n  }\n\n  static Iterable reversedList(List list) {\n    return new ReversedListIterable(list);\n  }\n\n  static void sortList(List list, int compare(a, b)) {\n    if (compare == null) compare = Comparable.compare;\n    Sort.sort(list, compare);\n  }\n\n  static int indexOfList(List list, var element, int start) {\n    return Arrays.indexOf(list, element, start, list.length);\n  }\n\n  static int lastIndexOfList(List list, var element, int start) {\n    if (start == null) start = list.length - 1;\n    return Arrays.lastIndexOf(list, element, start);\n  }\n\n  static void _rangeCheck(List list, int start, int end) {\n    if (start < 0 || start > list.length) {\n      throw new RangeError.range(start, 0, list.length);\n    }\n    if (end < start || end > list.length) {\n      throw new RangeError.range(end, start, list.length);\n    }\n  }\n\n  static Iterable getRangeList(List list, int start, int end) {\n    _rangeCheck(list, start, end);\n    // The generic type is currently lost. It will be fixed with mixins.\n    return new SubListIterable(list, start, end);\n  }\n\n  static void setRangeList(List list, int start, int end,\n                           Iterable from, int skipCount) {\n    _rangeCheck(list, start, end);\n    int length = end - start;\n    if (length == 0) return;\n\n    if (skipCount < 0) throw new ArgumentError(skipCount);\n\n    // TODO(floitsch): Make this accept more.\n    List otherList;\n    int otherStart;\n    if (from is List) {\n      otherList = from;\n      otherStart = skipCount;\n    } else {\n      otherList = from.skip(skipCount).toList(growable: false);\n      otherStart = 0;\n    }\n    if (otherStart + length > otherList.length) {\n      throw new StateError(\"Not enough elements\");\n    }\n    Arrays.copy(otherList, otherStart, list, start, length);\n  }\n\n  static void replaceRangeList(List list, int start, int end,\n                               Iterable iterable) {\n    _rangeCheck(list, start, end);\n    // TODO(floitsch): optimize this.\n    list.removeRange(start, end);\n    list.insertAll(start, iterable);\n  }\n\n  static void fillRangeList(List list, int start, int end, fillValue) {\n    _rangeCheck(list, start, end);\n    for (int i = start; i < end; i++) {\n      list[i] = fillValue;\n    }\n  }\n\n  static void insertAllList(List list, int index, Iterable iterable) {\n    if (index < 0 || index > list.length) {\n      throw new RangeError.range(index, 0, list.length);\n    }\n    if (iterable is! List && iterable is! Set) {\n      iterable = iterable.toList(growable: false);\n    }\n    int insertionLength = iterable.length;\n    list.length += insertionLength;\n    list.setRange(index + insertionLength, list.length, list, index);\n    for (var element in iterable) {\n      list[index++] = element;\n    }\n  }\n\n  static void setAllList(List list, int index, Iterable iterable) {\n    if (index < 0 || index > list.length) {\n      throw new RangeError.range(index, 0, list.length);\n    }\n    for (var element in iterable) {\n      list[index++] = element;\n    }\n  }\n\n  static Map<int, dynamic> asMapList(List l) {\n    return new ListMapView(l);\n  }\n\n  static bool setContainsAll(Set set, Iterable other) {\n    for (var element in other) {\n      if (!set.contains(element)) return false;\n    }\n    return true;\n  }\n\n  static Set setIntersection(Set set, Set other, Set result) {\n    Set smaller;\n    Set larger;\n    if (set.length < other.length) {\n      smaller = set;\n      larger = other;\n    } else {\n      smaller = other;\n      larger = set;\n    }\n    for (var element in smaller) {\n      if (larger.contains(element)) {\n        result.add(element);\n      }\n    }\n    return result;\n  }\n\n  static Set setUnion(Set set, Set other, Set result) {\n    result.addAll(set);\n    result.addAll(other);\n    return result;\n  }\n\n  static Set setDifference(Set set, Set other, Set result) {\n    for (var element in set) {\n      if (!other.contains(element)) {\n        result.add(element);\n      }\n    }\n    return result;\n  }\n}\n","sdk/lib/_collection_dev/list.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart._collection.dev;\n\n/**\n * Mixin that throws on the length changing operations of [List].\n *\n * Intended to mix-in on top of [ListMixin] for fixed-length lists.\n */\nabstract class FixedLengthListMixin<E>  {\n  void set length(int newLength) {\n    throw new UnsupportedError(\n        \"Cannot change the length of a fixed-length list\");\n  }\n\n  void add(E value) {\n    throw new UnsupportedError(\n        \"Cannot add to a fixed-length list\");\n  }\n\n  void insert(int index, E value) {\n    throw new UnsupportedError(\n        \"Cannot add to a fixed-length list\");\n  }\n\n  void insertAll(int at, Iterable<E> iterable) {\n    throw new UnsupportedError(\n        \"Cannot add to a fixed-length list\");\n  }\n\n  void addAll(Iterable<E> iterable) {\n    throw new UnsupportedError(\n        \"Cannot add to a fixed-length list\");\n  }\n\n  bool remove(E element) {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n\n  void removeAll(Iterable elements) {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n\n  void retainAll(Iterable elements) {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n\n  void removeWhere(bool test(E element)) {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n\n  void retainWhere(bool test(E element)) {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\n        \"Cannot clear a fixed-length list\");\n  }\n\n  E removeAt(int index) {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n\n  E removeLast() {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n\n  void replaceRange(int start, int end, Iterable<E> iterable) {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n}\n\n/**\n * Mixin for an unmodifiable [List] class.\n *\n * This overrides all mutating methods with methods that throw.\n * This mixin is intended to be mixed in on top of [ListMixin] on\n * unmodifiable lists.\n */\nabstract class UnmodifiableListMixin<E> {\n\n  void operator []=(int index, E value) {\n    throw new UnsupportedError(\n        \"Cannot modify an unmodifiable list\");\n  }\n\n  void set length(int newLength) {\n    throw new UnsupportedError(\n        \"Cannot change the length of an unmodifiable list\");\n  }\n\n  void setAll(int at, Iterable<E> iterable) {\n    throw new UnsupportedError(\n        \"Cannot modify an unmodifiable list\");\n  }\n\n  void add(E value) {\n    throw new UnsupportedError(\n      \"Cannot add to an unmodifiable list\");\n  }\n\n  E insert(int index, E value) {\n    throw new UnsupportedError(\n        \"Cannot add to an unmodifiable list\");\n  }\n\n  void insertAll(int at, Iterable<E> iterable) {\n    throw new UnsupportedError(\n        \"Cannot add to an unmodifiable list\");\n  }\n\n  void addAll(Iterable<E> iterable) {\n    throw new UnsupportedError(\n        \"Cannot add to an unmodifiable list\");\n  }\n\n  bool remove(E element) {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  void removeAll(Iterable elements) {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  void retainAll(Iterable elements) {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  void removeWhere(bool test(E element)) {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  void retainWhere(bool test(E element)) {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  void sort([Comparator<E> compare]) {\n    throw new UnsupportedError(\n        \"Cannot modify an unmodifiable list\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\n        \"Cannot clear an unmodifiable list\");\n  }\n\n  E removeAt(int index) {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  E removeLast() {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) {\n    throw new UnsupportedError(\n        \"Cannot modify an unmodifiable list\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  void replaceRange(int start, int end, Iterable<E> iterable) {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  void fillRange(int start, int end, [E fillValue]) {\n    throw new UnsupportedError(\n        \"Cannot modify an unmodifiable list\");\n  }\n}\n\n/**\n * Abstract implementation of a fixed-length list.\n *\n * All operations are defined in terms of `length`, `operator[]` and\n * `operator[]=`, which need to be implemented.\n */\ntypedef FixedLengthListBase<E> = ListBase<E> with FixedLengthListMixin<E>;\n\n/**\n * Abstract implementation of an unmodifiable list.\n *\n * All operations are defined in terms of `length` and `operator[]`,\n * which need to be implemented.\n */\ntypedef UnmodifiableListBase<E> = ListBase<E> with UnmodifiableListMixin<E>;\n\nclass _ListIndicesIterable extends ListIterable<int> {\n  List _backedList;\n\n  _ListIndicesIterable(this._backedList);\n\n  int get length => _backedList.length;\n  int elementAt(int index) {\n    if (index < 0 || index >= length) {\n      throw new RangeError.range(index, 0, length);\n    }\n    return index;\n  }\n}\n\nclass ListMapView<E> implements Map<int, E> {\n  List<E> _values;\n\n  ListMapView(this._values);\n\n  E operator[] (int key) => containsKey(key) ? _values[key] : null;\n  int get length => _values.length;\n\n  Iterable<E> get values => new SubListIterable<E>(_values, 0, null);\n  Iterable<int> get keys => new _ListIndicesIterable(_values);\n\n  bool get isEmpty => _values.isEmpty;\n  bool containsValue(E value) => _values.contains(value);\n  bool containsKey(int key) => key is int && key >= 0 && key < length;\n\n  void forEach(void f(int key, E value)) {\n    int length = _values.length;\n    for (int i = 0; i < length; i++) {\n      f(i, _values[i]);\n      if (length != _values.length) {\n        throw new ConcurrentModificationError(_values);\n      }\n    }\n  }\n\n  void operator[]= (int key, E value) {\n    throw new UnsupportedError(\"Cannot modify an unmodifiable map\");\n  }\n\n  E putIfAbsent(int key, E ifAbsent()) {\n    throw new UnsupportedError(\"Cannot modify an unmodifiable map\");\n  }\n\n  E remove(int key) {\n    throw new UnsupportedError(\"Cannot modify an unmodifiable map\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot modify an unmodifiable map\");\n  }\n}\n\nclass ReversedListIterable<E> extends ListIterable<E> {\n  Iterable<E> _source;\n  ReversedListIterable(this._source);\n\n  int get length => _source.length;\n\n  E elementAt(int index) => _source.elementAt(_source.length - 1 - index);\n}\n","sdk/lib/_collection_dev/sort.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart._collection.dev;\n\n/**\n * Dual-Pivot Quicksort algorithm.\n *\n * This class implements the dual-pivot quicksort algorithm as presented in\n * Vladimir Yaroslavskiy's paper.\n *\n * Some improvements have been copied from Android's implementation.\n */\nclass Sort {\n  // When a list has less then [:_INSERTION_SORT_THRESHOLD:] elements it will\n  // be sorted by an insertion sort.\n  static const int _INSERTION_SORT_THRESHOLD = 32;\n\n  /**\n   * Sorts all elements of the given list [:a:] according to the given\n   * [:compare:] function.\n   *\n   * The [:compare:] function takes two arguments [:x:] and [:y:] and returns\n   *  -1 if [:x < y:],\n   *   0 if [:x == y:], and\n   *   1 if [:x > y:].\n   *\n   * The function's behavior must be consistent. It must not return different\n   * results for the same values.\n   */\n  static void sort(List a, int compare(a, b)) {\n    _doSort(a, 0, a.length - 1, compare);\n  }\n\n  /**\n   * Sorts all elements in the range [:from:] (inclusive) to [:to:] (exclusive)\n   * of the given list [:a:].\n   *\n   * If the given range is invalid an \"OutOfRange\" error is raised.\n   * TODO(floitsch): do we want an error?\n   *\n   * See [:sort:] for requirements of the [:compare:] function.\n   */\n  static void sortRange(List a, int from, int to, int compare(a, b)) {\n    if ((from < 0) || (to > a.length) || (to < from)) {\n      throw \"OutOfRange\";\n    }\n    _doSort(a, from, to - 1, compare);\n  }\n\n  /**\n   * Sorts the list in the interval [:left:] to [:right:] (both inclusive).\n   */\n  static void _doSort(List a, int left, int right, int compare(a, b)) {\n    if ((right - left) <= _INSERTION_SORT_THRESHOLD) {\n      insertionSort_(a, left, right, compare);\n    } else {\n      _dualPivotQuicksort(a, left, right, compare);\n    }\n  }\n\n  static void insertionSort_(List a, int left, int right, int compare(a, b)) {\n    for (int i = left + 1; i <= right; i++) {\n      var el = a[i];\n      int j = i;\n      while ((j > left) && (compare(a[j - 1], el) > 0)) {\n        a[j] = a[j - 1];\n        j--;\n      }\n      a[j] = el;\n    }\n  }\n\n  static void _dualPivotQuicksort(List a,\n                                  int left, int right,\n                                  int compare(a, b)) {\n    assert(right - left > _INSERTION_SORT_THRESHOLD);\n\n    // Compute the two pivots by looking at 5 elements.\n    int sixth = (right - left + 1) ~/ 6;\n    int index1 = left + sixth;\n    int index5 = right - sixth;\n    int index3 = (left + right) ~/ 2;  // The midpoint.\n    int index2 = index3 - sixth;\n    int index4 = index3 + sixth;\n\n    var el1 = a[index1];\n    var el2 = a[index2];\n    var el3 = a[index3];\n    var el4 = a[index4];\n    var el5 = a[index5];\n\n    // Sort the selected 5 elements using a sorting network.\n    if (compare(el1, el2) > 0) { var t = el1; el1 = el2; el2 = t; }\n    if (compare(el4, el5) > 0) { var t = el4; el4 = el5; el5 = t; }\n    if (compare(el1, el3) > 0) { var t = el1; el1 = el3; el3 = t; }\n    if (compare(el2, el3) > 0) { var t = el2; el2 = el3; el3 = t; }\n    if (compare(el1, el4) > 0) { var t = el1; el1 = el4; el4 = t; }\n    if (compare(el3, el4) > 0) { var t = el3; el3 = el4; el4 = t; }\n    if (compare(el2, el5) > 0) { var t = el2; el2 = el5; el5 = t; }\n    if (compare(el2, el3) > 0) { var t = el2; el2 = el3; el3 = t; }\n    if (compare(el4, el5) > 0) { var t = el4; el4 = el5; el5 = t; }\n\n    var pivot1 = el2;\n    var pivot2 = el4;\n\n    // el2 and el4 have been saved in the pivot variables. They will be written\n    // back, once the partioning is finished.\n    a[index1] = el1;\n    a[index3] = el3;\n    a[index5] = el5;\n\n    a[index2] = a[left];\n    a[index4] = a[right];\n\n    int less = left + 1;    // First element in the middle partition.\n    int great = right - 1;  // Last element in the middle partition.\n\n    bool pivots_are_equal = (compare(pivot1, pivot2) == 0);\n    if (pivots_are_equal) {\n      var pivot = pivot1;\n      // Degenerated case where the partioning becomes a dutch national flag\n      // problem.\n      //\n      // [ |  < pivot  | == pivot | unpartitioned | > pivot  | ]\n      //  ^             ^          ^             ^            ^\n      // left         less         k           great         right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1) for x in ]left, less[ : x < pivot.\n      //   2) for x in [less, k[ : x == pivot.\n      //   3) for x in ]great, right[ : x > pivot.\n      for (int k = less; k <= great; k++) {\n        var ak = a[k];\n        int comp = compare(ak, pivot);\n        if (comp == 0) continue;\n        if (comp < 0) {\n          if (k != less) {\n            a[k] = a[less];\n            a[less] = ak;\n          }\n          less++;\n        } else {\n          // comp > 0.\n          //\n          // Find the first element <= pivot in the range [k - 1, great] and\n          // put [:ak:] there. We know that such an element must exist:\n          // When k == less, then el3 (which is equal to pivot) lies in the\n          // interval. Otherwise a[k - 1] == pivot and the search stops at k-1.\n          // Note that in the latter case invariant 2 will be violated for a\n          // short amount of time. The invariant will be restored when the\n          // pivots are put into their final positions.\n          while (true) {\n            comp = compare(a[great], pivot);\n            if (comp > 0) {\n              great--;\n              // This is the only location in the while-loop where a new\n              // iteration is started.\n              continue;\n            } else if (comp < 0) {\n              // Triple exchange.\n              a[k] = a[less];\n              a[less++] = a[great];\n              a[great--] = ak;\n              break;\n            } else {\n              // comp == 0;\n              a[k] = a[great];\n              a[great--] = ak;\n              // Note: if great < k then we will exit the outer loop and fix\n              // invariant 2 (which we just violated).\n              break;\n            }\n          }\n        }\n      }\n    } else {\n      // We partition the list into three parts:\n      //  1. < pivot1\n      //  2. >= pivot1 && <= pivot2\n      //  3. > pivot2\n      //\n      // During the loop we have:\n      // [ | < pivot1 | >= pivot1 && <= pivot2 | unpartitioned  | > pivot2  | ]\n      //  ^            ^                        ^              ^             ^\n      // left         less                     k              great        right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1. for x in ]left, less[ : x < pivot1\n      //   2. for x in [less, k[ : pivot1 <= x && x <= pivot2\n      //   3. for x in ]great, right[ : x > pivot2\n      for (int k = less; k <= great; k++) {\n        var ak = a[k];\n        int comp_pivot1 = compare(ak, pivot1);\n        if (comp_pivot1 < 0) {\n          if (k != less) {\n            a[k] = a[less];\n            a[less] = ak;\n          }\n          less++;\n        } else {\n          int comp_pivot2 = compare(ak, pivot2);\n          if (comp_pivot2 > 0) {\n            while (true) {\n              int comp = compare(a[great], pivot2);\n              if (comp > 0) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] <= pivot2.\n                comp = compare(a[great], pivot1);\n                if (comp < 0) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ak;\n                } else {\n                  // a[great] >= pivot1.\n                  a[k] = a[great];\n                  a[great--] = ak;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Move pivots into their final positions.\n    // We shrunk the list from both sides (a[left] and a[right] have\n    // meaningless values in them) and now we move elements from the first\n    // and third partition into these locations so that we can store the\n    // pivots.\n    a[left] = a[less - 1];\n    a[less - 1] = pivot1;\n    a[right] = a[great + 1];\n    a[great + 1] = pivot2;\n\n    // The list is now partitioned into three partitions:\n    // [ < pivot1   | >= pivot1 && <= pivot2   |  > pivot2   ]\n    //  ^            ^                        ^             ^\n    // left         less                     great        right\n\n    // Recursive descent. (Don't include the pivot values.)\n    _doSort(a, left, less - 2, compare);\n    _doSort(a, great + 2, right, compare);\n\n    if (pivots_are_equal) {\n      // All elements in the second partition are equal to the pivot. No\n      // need to sort them.\n      return;\n    }\n\n    // In theory it should be enough to call _doSort recursively on the second\n    // partition.\n    // The Android source however removes the pivot elements from the recursive\n    // call if the second partition is too large (more than 2/3 of the list).\n    if (less < index1 && great > index5) {\n      while (compare(a[less], pivot1) == 0) { less++; }\n      while (compare(a[great], pivot2) == 0) { great--; }\n\n      // Copy paste of the previous 3-way partitioning with adaptions.\n      //\n      // We partition the list into three parts:\n      //  1. == pivot1\n      //  2. > pivot1 && < pivot2\n      //  3. == pivot2\n      //\n      // During the loop we have:\n      // [ == pivot1 | > pivot1 && < pivot2 | unpartitioned  | == pivot2 ]\n      //              ^                      ^              ^\n      //            less                     k              great\n      //\n      // Invariants:\n      //   1. for x in [ *, less[ : x == pivot1\n      //   2. for x in [less, k[ : pivot1 < x && x < pivot2\n      //   3. for x in ]great, * ] : x == pivot2\n      for (int k = less; k <= great; k++) {\n        var ak = a[k];\n        int comp_pivot1 = compare(ak, pivot1);\n        if (comp_pivot1 == 0) {\n          if (k != less) {\n            a[k] = a[less];\n            a[less] = ak;\n          }\n          less++;\n        } else {\n          int comp_pivot2 = compare(ak, pivot2);\n          if (comp_pivot2 == 0) {\n            while (true) {\n              int comp = compare(a[great], pivot2);\n              if (comp == 0) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] < pivot2.\n                comp = compare(a[great], pivot1);\n                if (comp < 0) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ak;\n                } else {\n                  // a[great] == pivot1.\n                  a[k] = a[great];\n                  a[great--] = ak;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n      // The second partition has now been cleared of pivot elements and looks\n      // as follows:\n      // [  *  |  > pivot1 && < pivot2  | * ]\n      //        ^                      ^\n      //       less                  great\n      // Sort the second partition using recursive descent.\n      _doSort(a, less, great, compare);\n    } else {\n      // The second partition looks as follows:\n      // [  *  |  >= pivot1 && <= pivot2  | * ]\n      //        ^                        ^\n      //       less                    great\n      // Simply sort it by recursive descent.\n      _doSort(a, less, great, compare);\n    }\n  }\n}\n","sdk/lib/_collection_dev/symbol.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart._collection.dev;\n\n/**\n * Implementation of [core.Symbol].  This class uses the same name as\n * a core class so a user can't tell the difference.\n *\n * The purpose of this class is to hide [_name] from user code, but\n * make it accessible to Dart platform code via the static method\n * [getName].\n */\nclass Symbol implements core.Symbol {\n  final String _name;\n\n  static final RegExp validationPattern =\n      new RegExp(r'^(?:[a-zA-Z$][a-zA-Z$0-9_]*\\.)*(?:[a-zA-Z$][a-zA-Z$0-9_]*=?|'\n                 r'-|'\n                 r'unary-|'\n                 r'\\[\\]=|'\n                 r'~|'\n                 r'==|'\n                 r'\\[\\]|'\n                 r'\\*|'\n                 r'/|'\n                 r'%|'\n                 r'~/|'\n                 r'\\+|'\n                 r'<<|'\n                 r'>>|'\n                 r'>=|'\n                 r'>|'\n                 r'<=|'\n                 r'<|'\n                 r'&|'\n                 r'\\^|'\n                 r'\\|'\n                 r')$');\n\n  external const Symbol(String name);\n\n  /**\n   * Platform-private method used by the mirror system to create\n   * otherwise invalid names.\n   */\n  const Symbol.unvalidated(this._name);\n\n  // This is called by dart2js.\n  Symbol.validated(String name)\n      : this._name = validate(name);\n\n  bool operator ==(other) => other is Symbol && _name == other._name;\n\n  int get hashCode {\n    const arbitraryPrime = 664597;\n    return 0x1fffffff & (arbitraryPrime * _name.hashCode);\n  }\n\n  toString() => 'Symbol(\"$_name\")';\n\n  /// Platform-private accessor which cannot be called from user libraries.\n  static String getName(Symbol symbol) => symbol._name;\n\n  static String validate(String name) {\n    if (name.isEmpty) return name;\n    if (name.startsWith('_')) {\n      throw new ArgumentError('\"$name\" is a private identifier');\n    }\n    if (!validationPattern.hasMatch(name)) {\n      throw new ArgumentError(\n          '\"$name\" is not an identifier or an empty String');\n    }\n    return name;\n  }\n}\n","sdk/lib/_collection_dev/to_string.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart._collection.dev;\n\n/**\n * Temporary move `toString` methods into this class.\n */\nclass ToString {\n  // TODO(jjb): visiting list should be an identityHashSet when it exists\n\n  /**\n   * Returns a string representing the specified iterable. If the\n   * iterable is a [List], the returned string looks like this:\n   * [:'[element0, element1, ... elementN]':]. The value returned by its\n   * [toString] method is used to represent each element. If the specified\n   * iterable is not a list, the returned string looks like this:\n   * [:{element0, element1, ... elementN}:]. In other words, the strings\n   * returned for lists are surrounded by square brackets, while the strings\n   * returned for other iterables are surrounded by curly braces.\n   *\n   * If the specified iterable contains a reference to itself, either\n   * directly or indirectly through other iterables or maps, the contained\n   * reference is rendered as [:'[...]':] if it is a list, or [:'{...}':] if\n   * it is not. This prevents the infinite regress that would otherwise occur.\n   * So, for example, calling this method on a list whose sole element is a\n   * reference to itself would return [:'[[...]]':].\n   *\n   * A typical implementation of a iterable's [toString] method will\n   * simply return the results of this method applied to the iterable.\n   */\n  static String iterableToString(Iterable i) {\n    var result = new StringBuffer();\n    _emitValue(i, result, new List());\n    return result.toString();\n  }\n\n  /**\n   * Appends a string representing the specified iterable to the specified\n   * string buffer. The string is formatted as per [iterableToString].\n   * The [:visiting:] list contains references to all of the enclosing\n   * iterables and maps (which are currently in the process of being\n   * emitted into [:result:]). The [:visiting:] parameter allows this method to\n   * generate a [:'[...]':] or [:'{...}':] where required. In other words,\n   * it allows this method and [_emitMap] to identify recursive iterables\n   * and maps.\n   */\n  static void _emitValue(Iterable i,\n                         StringBuffer result,\n                         List visiting) {\n    visiting.add(i);\n    bool isList = i is List;\n    result.write(isList ? '[' : '{');\n\n    bool first = true;\n    for (var e in i) {\n      if (!first) {\n        result.write(', ');\n      }\n      first = false;\n      _emitObject(e, result, visiting);\n    }\n\n    result.write(isList ? ']' : '}');\n    visiting.removeLast();\n  }\n\n  /**\n   * Appends a string representing the specified object to the specified\n   * string buffer. If the object is a [iterable] or [Map], it is formatted\n   * as per [iterableToString] or [mapToString]; otherwise, it is formatted\n   * by invoking its own [toString] method.\n   *\n   * The [:visiting:] list contains references to all of the enclosing\n   * collections and maps (which are currently in the process of being\n   * emitted into [:result:]). The [:visiting:] parameter allows this method\n   * to generate a [:'[...]':] or [:'{...}':] where required. In other words,\n   * it allows this method and [_emitCollection] to identify recursive maps\n   * and collections.\n   */\n  static void _emitObject(Object o, StringBuffer result, List visiting) {\n    if (o is Iterable) {\n      if (_containsRef(visiting, o)) {\n        result.write(o is List ? '[...]' : '{...}');\n      } else {\n        _emitValue(o, result, visiting);\n      }\n    } else if (o is Map) {\n      if (_containsRef(visiting, o)) {\n        result.write('{...}');\n      } else {\n        _emitPair(o, result, visiting);\n      }\n    } else { // o is neither a collection nor a map\n      result.write(o);\n    }\n  }\n\n  /**\n   * Returns true if the specified collection contains the specified object\n   * reference.\n   */\n  static _containsRef(Iterable i, Object ref) {\n    for (var e in i) {\n      if (identical(e, ref)) return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns a string representing the specified map. The returned string\n   * looks like this: [:'{key0: value0, key1: value1, ... keyN: valueN}':].\n   * The value returned by its [toString] method is used to represent each\n   * key or value.\n   *\n   * If the map collection contains a reference to itself, either\n   * directly as a key or value, or indirectly through other collections\n   * or maps, the contained reference is rendered as [:'{...}':]. This\n   * prevents the infinite regress that would otherwise occur. So, for example,\n   * calling this method on a map whose sole entry maps the string key 'me'\n   * to a reference to the map would return [:'{me: {...}}':].\n   *\n   * A typical implementation of a map's [toString] method will\n   * simply return the results of this method applied to the collection.\n   */\n  static String mapToString(Map m) {\n    var result = new StringBuffer();\n    _emitPair(m, result, new List());\n    return result.toString();\n  }\n\n  /**\n   * Appends a string representing the specified map to the specified\n   * string buffer. The string is formatted as per [mapToString].\n   * The [:visiting:] list contains references to all of the enclosing\n   * collections and maps (which are currently in the process of being\n   * emitted into [:result:]). The [:visiting:] parameter allows this method\n   * to generate a [:'[...]':] or [:'{...}':] where required. In other words,\n   * it allows this method and [_emitCollection] to identify recursive maps\n   * and collections.\n   */\n  static void _emitPair(Map m, StringBuffer result, List visiting) {\n    visiting.add(m);\n    result.write('{');\n\n    bool first = true;\n    m.forEach((k, v) {\n      if (!first) {\n        result.write(', ');\n      }\n      first = false;\n      _emitObject(k, result, visiting);\n      result.write(': ');\n      _emitObject(v, result, visiting);\n    });\n\n    result.write('}');\n    visiting.removeLast();\n  }\n}\n","sdk/lib/_internal/compiler/implementation/lib/async_patch.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Patch file for the dart:async library.\n\nimport 'dart:_isolate_helper' show IsolateNatives, TimerImpl;\nimport 'dart:_foreign_helper' show JS, DART_CLOSURE_TO_JS;\n\npatch class Timer {\n  patch factory Timer(Duration duration, void callback()) {\n    int milliseconds = duration.inMilliseconds;\n    if (milliseconds < 0) milliseconds = 0;\n    return new TimerImpl(milliseconds, callback);\n  }\n\n  patch factory Timer.periodic(Duration duration, void callback(Timer timer)) {\n    int milliseconds = duration.inMilliseconds;\n    if (milliseconds < 0) milliseconds = 0;\n    return new TimerImpl.periodic(milliseconds, callback);\n  }\n}\n\npatch class _AsyncRun {\n  patch static void _enqueueImmediate(void callback()) {\n    // TODO(9002): don't use the Timer to enqueue the immediate callback.\n    Timer.run(callback);\n  }\n}\n\npatch class DeferredLibrary {\n  patch Future<bool> load() {\n    return _load(libraryName, uri);\n  }\n}\n\n// TODO(ahe): This should not only apply to this isolate.\nfinal _loadedLibraries = <String, Completer<bool>>{};\n\nFuture<bool> _load(String libraryName, String uri) {\n  // TODO(ahe): Validate libraryName.  Kasper points out that you want\n  // to be able to experiment with the effect of toggling @DeferLoad,\n  // so perhaps we should silently ignore \"bad\" library names.\n  Completer completer = new Completer<bool>();\n  Future<bool> future = _loadedLibraries[libraryName];\n  if (future != null) {\n    future.then((_) { completer.complete(false); });\n    return completer.future;\n  }\n  _loadedLibraries[libraryName] = completer.future;\n\n  if (uri == null) {\n    uri = IsolateNatives.thisScript;\n    int index = uri.lastIndexOf('/');\n    uri = '${uri.substring(0, index + 1)}part.js';\n  }\n\n  if (_hasDocument) {\n    // Inject a script tag.\n    var script = JS('', 'document.createElement(\"script\")');\n    JS('', '#.type = \"text/javascript\"', script);\n    JS('', '#.async = \"async\"', script);\n    JS('', '#.src = #', script, uri);\n    var onLoad = JS('', '#.bind(null, #)',\n                    DART_CLOSURE_TO_JS(_onDeferredLibraryLoad), completer);\n    JS('', '#.addEventListener(\"load\", #, false)', script, onLoad);\n    JS('', 'document.body.appendChild(#)', script);\n  } else if (JS('String', 'typeof load') == 'function') {\n    Timer.run(() {\n      JS('void', 'load(#)', uri);\n      completer.complete(true);\n    });\n  } else if (JS('String', 'typeof importScripts') == 'function') {\n    // Load a script into a Web Worker.\n    Timer.run(() {\n      JS('void', 'importScripts(#)', uri);\n      completer.complete(true);\n    });\n  } else {\n    throw new UnsupportedError('load not supported');\n  }\n  return completer.future;\n}\n\n/// Used to implement deferred loading. Used as callback on \"load\"\n/// event above in [load].\n_onDeferredLibraryLoad(Completer<bool> completer, event) {\n  completer.complete(true);\n}\n\nbool get _hasDocument => JS('String', 'typeof document') == 'object';\n","sdk/lib/_internal/compiler/implementation/lib/collection_dev_patch.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npatch class Symbol implements core.Symbol {\n  patch const Symbol(String name)\n      : this._name = name;\n}\n","sdk/lib/_internal/compiler/implementation/lib/collection_patch.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Patch file for dart:collection classes.\nimport 'dart:_foreign_helper' show JS;\n\npatch class HashMap<K, V> {\n  int _length = 0;\n\n  // The hash map contents are divided into three parts: one part for\n  // string keys, one for numeric keys, and one for the rest. String\n  // and numeric keys map directly to their values, but the rest of\n  // the entries are stored in bucket lists of the form:\n  //\n  //    [key-0, value-0, key-1, value-1, ...]\n  //\n  // where all keys in the same bucket share the same hash code.\n  var _strings;\n  var _nums;\n  var _rest;\n\n  // When iterating over the hash map, it is very convenient to have a\n  // list of all the keys. We cache that on the instance and clear the\n  // the cache whenever the key set changes. This is also used to\n  // guard against concurrent modifications.\n  List _keys;\n\n  patch HashMap();\n\n  patch int get length => _length;\n  patch bool get isEmpty => _length == 0;\n\n  patch Iterable<K> get keys {\n    return new HashMapKeyIterable<K>(this);\n  }\n\n  patch Iterable<V> get values {\n    return keys.map((each) => this[each]);\n  }\n\n  patch bool containsKey(K key) {\n    if (_isStringKey(key)) {\n      var strings = _strings;\n      return (strings == null) ? false : _hasTableEntry(strings, key);\n    } else if (_isNumericKey(key)) {\n      var nums = _nums;\n      return (nums == null) ? false : _hasTableEntry(nums, key);\n    } else {\n      var rest = _rest;\n      if (rest == null) return false;\n      var bucket = _getBucket(rest, key);\n      return _findBucketIndex(bucket, key) >= 0;\n    }\n  }\n\n  patch bool containsValue(V value) {\n    return _computeKeys().any((each) => this[each] == value);\n  }\n\n  patch void addAll(Map<K, V> other) {\n    other.forEach((K key, V value) {\n      this[key] = value;\n    });\n  }\n\n  patch V operator[](K key) {\n    if (_isStringKey(key)) {\n      var strings = _strings;\n      return (strings == null) ? null : _getTableEntry(strings, key);\n    } else if (_isNumericKey(key)) {\n      var nums = _nums;\n      return (nums == null) ? null : _getTableEntry(nums, key);\n    } else {\n      var rest = _rest;\n      if (rest == null) return null;\n      var bucket = _getBucket(rest, key);\n      int index = _findBucketIndex(bucket, key);\n      return (index < 0) ? null : JS('var', '#[#]', bucket, index + 1);\n    }\n  }\n\n  patch void operator[]=(K key, V value) {\n    if (_isStringKey(key)) {\n      var strings = _strings;\n      if (strings == null) _strings = strings = _newHashTable();\n      _addHashTableEntry(strings, key, value);\n    } else if (_isNumericKey(key)) {\n      var nums = _nums;\n      if (nums == null) _nums = nums = _newHashTable();\n      _addHashTableEntry(nums, key, value);\n    } else {\n      var rest = _rest;\n      if (rest == null) _rest = rest = _newHashTable();\n      var hash = _computeHashCode(key);\n      var bucket = JS('var', '#[#]', rest, hash);\n      if (bucket == null) {\n        _setTableEntry(rest, hash, JS('var', '[#, #]', key, value));\n        _length++;\n        _keys = null;\n      } else {\n        int index = _findBucketIndex(bucket, key);\n        if (index >= 0) {\n          JS('void', '#[#] = #', bucket, index + 1, value);\n        } else {\n          JS('void', '#.push(#, #)', bucket, key, value);\n          _length++;\n          _keys = null;\n        }\n      }\n    }\n  }\n\n  patch V putIfAbsent(K key, V ifAbsent()) {\n    if (containsKey(key)) return this[key];\n    V value = ifAbsent();\n    this[key] = value;\n    return value;\n  }\n\n  patch V remove(K key) {\n    if (_isStringKey(key)) {\n      return _removeHashTableEntry(_strings, key);\n    } else if (_isNumericKey(key)) {\n      return _removeHashTableEntry(_nums, key);\n    } else {\n      var rest = _rest;\n      if (rest == null) return null;\n      var bucket = _getBucket(rest, key);\n      int index = _findBucketIndex(bucket, key);\n      if (index < 0) return null;\n      // TODO(kasperl): Consider getting rid of the bucket list when\n      // the length reaches zero.\n      _length--;\n      _keys = null;\n      // Use splice to remove the two [key, value] elements at the\n      // index and return the value.\n      return JS('var', '#.splice(#, 2)[1]', bucket, index);\n    }\n  }\n\n  patch void clear() {\n    if (_length > 0) {\n      _strings = _nums = _rest = _keys = null;\n      _length = 0;\n    }\n  }\n\n  patch void forEach(void action(K key, V value)) {\n    List keys = _computeKeys();\n    for (int i = 0, length = keys.length; i < length; i++) {\n      var key = JS('var', '#[#]', keys, i);\n      action(key, this[key]);\n      if (JS('bool', '# !== #', keys, _keys)) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n  }\n\n  List _computeKeys() {\n    if (_keys != null) return _keys;\n    List result = new List(_length);\n    int index = 0;\n\n    // Add all string keys to the list.\n    var strings = _strings;\n    if (strings != null) {\n      var names = JS('var', 'Object.getOwnPropertyNames(#)', strings);\n      int entries = JS('int', '#.length', names);\n      for (int i = 0; i < entries; i++) {\n        String key = JS('String', '#[#]', names, i);\n        JS('void', '#[#] = #', result, index, key);\n        index++;\n      }\n    }\n\n    // Add all numeric keys to the list.\n    var nums = _nums;\n    if (nums != null) {\n      var names = JS('var', 'Object.getOwnPropertyNames(#)', nums);\n      int entries = JS('int', '#.length', names);\n      for (int i = 0; i < entries; i++) {\n        // Object.getOwnPropertyNames returns a list of strings, so we\n        // have to convert the keys back to numbers (+).\n        num key = JS('num', '+#[#]', names, i);\n        JS('void', '#[#] = #', result, index, key);\n        index++;\n      }\n    }\n\n    // Add all the remaining keys to the list.\n    var rest = _rest;\n    if (rest != null) {\n      var names = JS('var', 'Object.getOwnPropertyNames(#)', rest);\n      int entries = JS('int', '#.length', names);\n      for (int i = 0; i < entries; i++) {\n        var key = JS('String', '#[#]', names, i);\n        var bucket = JS('var', '#[#]', rest, key);\n        int length = JS('int', '#.length', bucket);\n        for (int i = 0; i < length; i += 2) {\n          var key = JS('var', '#[#]', bucket, i);\n          JS('void', '#[#] = #', result, index, key);\n          index++;\n        }\n      }\n    }\n    assert(index == _length);\n    return _keys = result;\n  }\n\n  void _addHashTableEntry(var table, K key, V value) {\n    if (!_hasTableEntry(table, key)) {\n      _length++;\n      _keys = null;\n    }\n    _setTableEntry(table, key, value);\n  }\n\n  V _removeHashTableEntry(var table, K key) {\n    if (table != null && _hasTableEntry(table, key)) {\n      V value = _getTableEntry(table, key);\n      _deleteTableEntry(table, key);\n      _length--;\n      _keys = null;\n      return value;\n    } else {\n      return null;\n    }\n  }\n\n  static bool _isStringKey(var key) {\n    return key is String && key != '__proto__';\n  }\n\n  static bool _isNumericKey(var key) {\n    // Only treat unsigned 30-bit integers as numeric keys. This way,\n    // we avoid converting them to strings when we use them as keys in\n    // the JavaScript hash table object.\n    return key is num && JS('bool', '(# & 0x3ffffff) === #', key, key);\n  }\n\n  static int _computeHashCode(var key) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic keys like '__proto__'. Another option\n    // would be to throw an exception if the hash code isn't a number.\n    return JS('int', '# & 0x3ffffff', key.hashCode);\n  }\n\n  static bool _hasTableEntry(var table, var key) {\n    var entry = JS('var', '#[#]', table, key);\n    // We take care to only store non-null entries in the table, so we\n    // can check if the table has an entry for the given key with a\n    // simple null check.\n    return entry != null;\n  }\n\n  static _getTableEntry(var table, var key) {\n    var entry = JS('var', '#[#]', table, key);\n    // We store the table itself as the entry to signal that it really\n    // is a null value, so we have to map back to null here.\n    return JS('bool', '# === #', entry, table) ? null : entry;\n  }\n\n  static void _setTableEntry(var table, var key, var value) {\n    // We only store non-null entries in the table, so we have to\n    // change null values to refer to the table itself. Such values\n    // will be recognized and mapped back to null on access.\n    if (value == null) {\n      // Do not update [value] with [table], otherwise our\n      // optimizations could be confused by this opaque object being\n      // now used for more things than storing and fetching from it.\n      JS('void', '#[#] = #', table, key, table);\n    } else {\n      JS('void', '#[#] = #', table, key, value);\n    }\n  }\n\n  static void _deleteTableEntry(var table, var key) {\n    JS('void', 'delete #[#]', table, key);\n  }\n\n  static List _getBucket(var table, var key) {\n    var hash = _computeHashCode(key);\n    return JS('var', '#[#]', table, hash);\n  }\n\n  static int _findBucketIndex(var bucket, var key) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i += 2) {\n      if (JS('var', '#[#]', bucket, i) == key) return i;\n    }\n    return -1;\n  }\n\n  static _newHashTable() {\n    // Create a new JavaScript object to be used as a hash table. Use\n    // Object.create to avoid the properties on Object.prototype\n    // showing up as entries.\n    var table = JS('var', 'Object.create(null)');\n    // Attempt to force the hash table into 'dictionary' mode by\n    // adding a property to it and deleting it again.\n    var temporaryKey = '<non-identifier-key>';\n    _setTableEntry(table, temporaryKey, table);\n    _deleteTableEntry(table, temporaryKey);\n    return table;\n  }\n}\n\nclass HashMapKeyIterable<E> extends IterableBase<E> {\n  final _map;\n  HashMapKeyIterable(this._map);\n\n  int get length => _map._length;\n  bool get isEmpty => _map._length == 0;\n\n  Iterator<E> get iterator {\n    return new HashMapKeyIterator<E>(_map, _map._computeKeys());\n  }\n\n  bool contains(E element) {\n    return _map.containsKey(element);\n  }\n\n  void forEach(void f(E element)) {\n    List keys = _map._computeKeys();\n    for (int i = 0, length = JS('int', '#.length', keys); i < length; i++) {\n      f(JS('var', '#[#]', keys, i));\n      if (JS('bool', '# !== #', keys, _map._keys)) {\n        throw new ConcurrentModificationError(_map);\n      }\n    }\n  }\n}\n\nclass HashMapKeyIterator<E> implements Iterator<E> {\n  final _map;\n  final List _keys;\n  int _offset = 0;\n  E _current;\n\n  HashMapKeyIterator(this._map, this._keys);\n\n  E get current => _current;\n\n  bool moveNext() {\n    var keys = _keys;\n    int offset = _offset;\n    if (JS('bool', '# !== #', keys, _map._keys)) {\n      throw new ConcurrentModificationError(_map);\n    } else if (offset >= JS('int', '#.length', keys)) {\n      _current = null;\n      return false;\n    } else {\n      _current = JS('var', '#[#]', keys, offset);\n      // TODO(kasperl): For now, we have to tell the type inferrer to\n      // treat the result of doing offset + 1 as an int. Otherwise, we\n      // get unnecessary bailout code.\n      _offset = JS('int', '#', offset + 1);\n      return true;\n    }\n  }\n}\n\npatch class LinkedHashMap<K, V> {\n  int _length = 0;\n\n  // The hash map contents are divided into three parts: one part for\n  // string keys, one for numeric keys, and one for the rest. String\n  // and numeric keys map directly to their linked cells, but the rest\n  // of the entries are stored in bucket lists of the form:\n  //\n  //    [cell-0, cell-1, ...]\n  //\n  // where all keys in the same bucket share the same hash code.\n  var _strings;\n  var _nums;\n  var _rest;\n\n  // The keys and values are stored in cells that are linked together\n  // to form a double linked list.\n  LinkedHashMapCell _first;\n  LinkedHashMapCell _last;\n\n  // We track the number of modifications done to the key set of the\n  // hash map to be able to throw when the map is modified while being\n  // iterated over.\n  int _modifications = 0;\n\n  patch LinkedHashMap();\n\n  patch int get length => _length;\n  patch bool get isEmpty => _length == 0;\n\n  patch Iterable<K> get keys {\n    return new LinkedHashMapKeyIterable<K>(this);\n  }\n\n  patch Iterable<V> get values {\n    return keys.map((each) => this[each]);\n  }\n\n  patch bool containsKey(K key) {\n    if (_isStringKey(key)) {\n      var strings = _strings;\n      if (strings == null) return false;\n      LinkedHashMapCell cell = _getTableEntry(strings, key);\n      return cell != null;\n    } else if (_isNumericKey(key)) {\n      var nums = _nums;\n      if (nums == null) return false;\n      LinkedHashMapCell cell = _getTableEntry(nums, key);\n      return cell != null;\n    } else {\n      var rest = _rest;\n      if (rest == null) return false;\n      var bucket = _getBucket(rest, key);\n      return _findBucketIndex(bucket, key) >= 0;\n    }\n  }\n\n  patch bool containsValue(V value) {\n    return keys.any((each) => this[each] == value);\n  }\n\n  patch void addAll(Map<K, V> other) {\n    other.forEach((K key, V value) {\n      this[key] = value;\n    });\n  }\n\n  patch V operator[](K key) {\n    if (_isStringKey(key)) {\n      var strings = _strings;\n      if (strings == null) return null;\n      LinkedHashMapCell cell = _getTableEntry(strings, key);\n      return (cell == null) ? null : cell._value;\n    } else if (_isNumericKey(key)) {\n      var nums = _nums;\n      if (nums == null) return null;\n      LinkedHashMapCell cell = _getTableEntry(nums, key);\n      return (cell == null) ? null : cell._value;\n    } else {\n      var rest = _rest;\n      if (rest == null) return null;\n      var bucket = _getBucket(rest, key);\n      int index = _findBucketIndex(bucket, key);\n      if (index < 0) return null;\n      LinkedHashMapCell cell = JS('var', '#[#]', bucket, index);\n      return cell._value;\n    }\n  }\n\n  patch void operator[]=(K key, V value) {\n    if (_isStringKey(key)) {\n      var strings = _strings;\n      if (strings == null) _strings = strings = _newHashTable();\n      _addHashTableEntry(strings, key, value);\n    } else if (_isNumericKey(key)) {\n      var nums = _nums;\n      if (nums == null) _nums = nums = _newHashTable();\n      _addHashTableEntry(nums, key, value);\n    } else {\n      var rest = _rest;\n      if (rest == null) _rest = rest = _newHashTable();\n      var hash = _computeHashCode(key);\n      var bucket = JS('var', '#[#]', rest, hash);\n      if (bucket == null) {\n        LinkedHashMapCell cell = _newLinkedCell(key, value);\n        _setTableEntry(rest, hash, JS('var', '[#]', cell));\n      } else {\n        int index = _findBucketIndex(bucket, key);\n        if (index >= 0) {\n          LinkedHashMapCell cell = JS('var', '#[#]', bucket, index);\n          cell._value = value;\n        } else {\n          LinkedHashMapCell cell = _newLinkedCell(key, value);\n          JS('void', '#.push(#)', bucket, cell);\n        }\n      }\n    }\n  }\n\n  patch V putIfAbsent(K key, V ifAbsent()) {\n    if (containsKey(key)) return this[key];\n    V value = ifAbsent();\n    this[key] = value;\n    return value;\n  }\n\n  patch V remove(K key) {\n    if (_isStringKey(key)) {\n      return _removeHashTableEntry(_strings, key);\n    } else if (_isNumericKey(key)) {\n      return _removeHashTableEntry(_nums, key);\n    } else {\n      var rest = _rest;\n      if (rest == null) return null;\n      var bucket = _getBucket(rest, key);\n      int index = _findBucketIndex(bucket, key);\n      if (index < 0) return null;\n      // Use splice to remove the [cell] element at the index and\n      // unlink the cell before returning its value.\n      LinkedHashMapCell cell = JS('var', '#.splice(#, 1)[0]', bucket, index);\n      _unlinkCell(cell);\n      // TODO(kasperl): Consider getting rid of the bucket list when\n      // the length reaches zero.\n      return cell._value;\n    }\n  }\n\n  patch void clear() {\n    if (_length > 0) {\n      _strings = _nums = _rest = _first = _last = null;\n      _length = 0;\n      _modified();\n    }\n  }\n\n  patch void forEach(void action(K key, V value)) {\n    LinkedHashMapCell cell = _first;\n    int modifications = _modifications;\n    while (cell != null) {\n      action(cell._key, cell._value);\n      if (modifications != _modifications) {\n        throw new ConcurrentModificationError(this);\n      }\n      cell = cell._next;\n    }\n  }\n\n  void _addHashTableEntry(var table, K key, V value) {\n    LinkedHashMapCell cell = _getTableEntry(table, key);\n    if (cell == null) {\n      _setTableEntry(table, key, _newLinkedCell(key, value));\n    } else {\n      cell._value = value;\n    }\n  }\n\n  V _removeHashTableEntry(var table, K key) {\n    if (table == null) return null;\n    LinkedHashMapCell cell = _getTableEntry(table, key);\n    if (cell == null) return null;\n    _unlinkCell(cell);\n    _deleteTableEntry(table, key);\n    return cell._value;\n  }\n\n  void _modified() {\n    // Value cycles after 2^30 modifications. If you keep hold of an\n    // iterator for that long, you might miss a modification\n    // detection, and iteration can go sour. Don't do that.\n    _modifications = (_modifications + 1) & 0x3ffffff;\n  }\n\n  // Create a new cell and link it in as the last one in the list.\n  LinkedHashMapCell _newLinkedCell(K key, V value) {\n    LinkedHashMapCell cell = new LinkedHashMapCell(key, value);\n    if (_first == null) {\n      _first = _last = cell;\n    } else {\n      LinkedHashMapCell last = _last;\n      cell._previous = last;\n      _last = last._next = cell;\n    }\n    _length++;\n    _modified();\n    return cell;\n  }\n\n  // Unlink the given cell from the linked list of cells.\n  void _unlinkCell(LinkedHashMapCell cell) {\n    LinkedHashMapCell previous = cell._previous;\n    LinkedHashMapCell next = cell._next;\n    if (previous == null) {\n      assert(cell == _first);\n      _first = next;\n    } else {\n      previous._next = next;\n    }\n    if (next == null) {\n      assert(cell == _last);\n      _last = previous;\n    } else {\n      next._previous = previous;\n    }\n    _length--;\n    _modified();\n  }\n\n  static bool _isStringKey(var key) {\n    return key is String && key != '__proto__';\n  }\n\n  static bool _isNumericKey(var key) {\n    // Only treat unsigned 30-bit integers as numeric keys. This way,\n    // we avoid converting them to strings when we use them as keys in\n    // the JavaScript hash table object.\n    return key is num && JS('bool', '(# & 0x3ffffff) === #', key, key);\n  }\n\n  static int _computeHashCode(var key) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic keys like '__proto__'. Another option\n    // would be to throw an exception if the hash code isn't a number.\n    return JS('int', '# & 0x3ffffff', key.hashCode);\n  }\n\n  static _getTableEntry(var table, var key) {\n    return JS('var', '#[#]', table, key);\n  }\n\n  static void _setTableEntry(var table, var key, var value) {\n    assert(value != null);\n    JS('void', '#[#] = #', table, key, value);\n  }\n\n  static void _deleteTableEntry(var table, var key) {\n    JS('void', 'delete #[#]', table, key);\n  }\n\n  static List _getBucket(var table, var key) {\n    var hash = _computeHashCode(key);\n    return JS('var', '#[#]', table, hash);\n  }\n\n  static int _findBucketIndex(var bucket, var key) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i++) {\n      LinkedHashMapCell cell = JS('var', '#[#]', bucket, i);\n      if (cell._key == key) return i;\n    }\n    return -1;\n  }\n\n  static _newHashTable() {\n    // Create a new JavaScript object to be used as a hash table. Use\n    // Object.create to avoid the properties on Object.prototype\n    // showing up as entries.\n    var table = JS('var', 'Object.create(null)');\n    // Attempt to force the hash table into 'dictionary' mode by\n    // adding a property to it and deleting it again.\n    var temporaryKey = '<non-identifier-key>';\n    _setTableEntry(table, temporaryKey, table);\n    _deleteTableEntry(table, temporaryKey);\n    return table;\n  }\n}\n\nclass LinkedHashMapCell {\n  final _key;\n  var _value;\n\n  LinkedHashMapCell _next;\n  LinkedHashMapCell _previous;\n\n  LinkedHashMapCell(this._key, this._value);\n}\n\nclass LinkedHashMapKeyIterable<E> extends IterableBase<E> {\n  final _map;\n  LinkedHashMapKeyIterable(this._map);\n\n  int get length => _map._length;\n  bool get isEmpty => _map._length == 0;\n\n  Iterator<E> get iterator {\n    return new LinkedHashMapKeyIterator<E>(_map, _map._modifications);\n  }\n\n  bool contains(E element) {\n    return _map.containsKey(element);\n  }\n\n  void forEach(void f(E element)) {\n    LinkedHashMapCell cell = _map._first;\n    int modifications = _map._modifications;\n    while (cell != null) {\n      f(cell._key);\n      if (modifications != _map._modifications) {\n        throw new ConcurrentModificationError(_map);\n      }\n      cell = cell._next;\n    }\n  }\n}\n\nclass LinkedHashMapKeyIterator<E> implements Iterator<E> {\n  final _map;\n  final int _modifications;\n  LinkedHashMapCell _cell;\n  E _current;\n\n  LinkedHashMapKeyIterator(this._map, this._modifications) {\n    _cell = _map._first;\n  }\n\n  E get current => _current;\n\n  bool moveNext() {\n    if (_modifications != _map._modifications) {\n      throw new ConcurrentModificationError(_map);\n    } else if (_cell == null) {\n      _current = null;\n      return false;\n    } else {\n      _current = _cell._key;\n      _cell = _cell._next;\n      return true;\n    }\n  }\n}\n\npatch class HashSet<E> {\n  int _length = 0;\n\n  // The hash set contents are divided into three parts: one part for\n  // string elements, one for numeric elements, and one for the\n  // rest. String and numeric elements map directly to a sentinel\n  // value, but the rest of the entries are stored in bucket lists of\n  // the form:\n  //\n  //    [element-0, element-1, element-2, ...]\n  //\n  // where all elements in the same bucket share the same hash code.\n  var _strings;\n  var _nums;\n  var _rest;\n\n  // When iterating over the hash set, it is very convenient to have a\n  // list of all the elements. We cache that on the instance and clear\n  // the the cache whenever the set changes. This is also used to\n  // guard against concurrent modifications.\n  List _elements;\n\n  patch HashSet();\n\n  // Iterable.\n  patch Iterator<E> get iterator {\n    return new HashSetIterator<E>(this, _computeElements());\n  }\n\n  patch int get length => _length;\n  patch bool get isEmpty => _length == 0;\n\n  patch bool contains(Object object) {\n    if (_isStringElement(object)) {\n      var strings = _strings;\n      return (strings == null) ? false : _hasTableEntry(strings, object);\n    } else if (_isNumericElement(object)) {\n      var nums = _nums;\n      return (nums == null) ? false : _hasTableEntry(nums, object);\n    } else {\n      var rest = _rest;\n      if (rest == null) return false;\n      var bucket = _getBucket(rest, object);\n      return _findBucketIndex(bucket, object) >= 0;\n    }\n  }\n\n  // Collection.\n  patch void add(E element) {\n    if (_isStringElement(element)) {\n      var strings = _strings;\n      if (strings == null) _strings = strings = _newHashTable();\n      _addHashTableEntry(strings, element);\n    } else if (_isNumericElement(element)) {\n      var nums = _nums;\n      if (nums == null) _nums = nums = _newHashTable();\n      _addHashTableEntry(nums, element);\n    } else {\n      var rest = _rest;\n      if (rest == null) _rest = rest = _newHashTable();\n      var hash = _computeHashCode(element);\n      var bucket = JS('var', '#[#]', rest, hash);\n      if (bucket == null) {\n        _setTableEntry(rest, hash, JS('var', '[#]', element));\n      } else {\n        int index = _findBucketIndex(bucket, element);\n        if (index >= 0) return;\n        JS('void', '#.push(#)', bucket, element);\n      }\n      _length++;\n      _elements = null;\n    }\n  }\n\n  patch void addAll(Iterable<E> objects) {\n    for (E each in objects) {\n      add(each);\n    }\n  }\n\n  patch bool remove(Object object) {\n    if (_isStringElement(object)) {\n      return _removeHashTableEntry(_strings, object);\n    } else if (_isNumericElement(object)) {\n      return _removeHashTableEntry(_nums, object);\n    } else {\n      var rest = _rest;\n      if (rest == null) return false;\n      var bucket = _getBucket(rest, object);\n      int index = _findBucketIndex(bucket, object);\n      if (index < 0) return false;\n      // TODO(kasperl): Consider getting rid of the bucket list when\n      // the length reaches zero.\n      _length--;\n      _elements = null;\n      // TODO(kasperl): It would probably be faster to move the\n      // element to the end and reduce the length of the bucket list.\n      JS('void', '#.splice(#, 1)', bucket, index);\n      return true;\n    }\n  }\n\n  patch void removeAll(Iterable objectsToRemove) {\n    for (var each in objectsToRemove) {\n      remove(each);\n    }\n  }\n\n  patch void removeWhere(bool test(E element)) {\n    removeAll(_computeElements().where(test));\n  }\n\n  patch void retainWhere(bool test(E element)) {\n    removeAll(_computeElements().where((E element) => !test(element)));\n  }\n\n  patch void clear() {\n    if (_length > 0) {\n      _strings = _nums = _rest = _elements = null;\n      _length = 0;\n    }\n  }\n\n  List _computeElements() {\n    if (_elements != null) return _elements;\n    List result = new List(_length);\n    int index = 0;\n\n    // Add all string elements to the list.\n    var strings = _strings;\n    if (strings != null) {\n      var names = JS('var', 'Object.getOwnPropertyNames(#)', strings);\n      int entries = JS('int', '#.length', names);\n      for (int i = 0; i < entries; i++) {\n        String element = JS('String', '#[#]', names, i);\n        JS('void', '#[#] = #', result, index, element);\n        index++;\n      }\n    }\n\n    // Add all numeric elements to the list.\n    var nums = _nums;\n    if (nums != null) {\n      var names = JS('var', 'Object.getOwnPropertyNames(#)', nums);\n      int entries = JS('int', '#.length', names);\n      for (int i = 0; i < entries; i++) {\n        // Object.getOwnPropertyNames returns a list of strings, so we\n        // have to convert the elements back to numbers (+).\n        num element = JS('num', '+#[#]', names, i);\n        JS('void', '#[#] = #', result, index, element);\n        index++;\n      }\n    }\n\n    // Add all the remaining elements to the list.\n    var rest = _rest;\n    if (rest != null) {\n      var names = JS('var', 'Object.getOwnPropertyNames(#)', rest);\n      int entries = JS('int', '#.length', names);\n      for (int i = 0; i < entries; i++) {\n        var entry = JS('String', '#[#]', names, i);\n        var bucket = JS('var', '#[#]', rest, entry);\n        int length = JS('int', '#.length', bucket);\n        for (int i = 0; i < length; i++) {\n          JS('void', '#[#] = #[#]', result, index, bucket, i);\n          index++;\n        }\n      }\n    }\n    assert(index == _length);\n    return _elements = result;\n  }\n\n  void _addHashTableEntry(var table, E element) {\n    if (_hasTableEntry(table, element)) return;\n    _setTableEntry(table, element, 0);\n    _length++;\n    _elements = null;\n  }\n\n  bool _removeHashTableEntry(var table, E element) {\n    if (table != null && _hasTableEntry(table, element)) {\n      _deleteTableEntry(table, element);\n      _length--;\n      _elements = null;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  static bool _isStringElement(var element) {\n    return element is String && element != '__proto__';\n  }\n\n  static bool _isNumericElement(var element) {\n    // Only treat unsigned 30-bit integers as numeric elements. This\n    // way, we avoid converting them to strings when we use them as\n    // keys in the JavaScript hash table object.\n    return element is num &&\n        JS('bool', '(# & 0x3ffffff) === #', element, element);\n  }\n\n  static int _computeHashCode(var element) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic elements like '__proto__'. Another\n    // option would be to throw an exception if the hash code isn't a\n    // number.\n    return JS('int', '# & 0x3ffffff', element.hashCode);\n  }\n\n  static bool _hasTableEntry(var table, var key) {\n    var entry = JS('var', '#[#]', table, key);\n    // We take care to only store non-null entries in the table, so we\n    // can check if the table has an entry for the given key with a\n    // simple null check.\n    return entry != null;\n  }\n\n  static void _setTableEntry(var table, var key, var value) {\n    assert(value != null);\n    JS('void', '#[#] = #', table, key, value);\n  }\n\n  static void _deleteTableEntry(var table, var key) {\n    JS('void', 'delete #[#]', table, key);\n  }\n\n  static List _getBucket(var table, var element) {\n    var hash = _computeHashCode(element);\n    return JS('var', '#[#]', table, hash);\n  }\n\n  static int _findBucketIndex(var bucket, var element) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i++) {\n      if (JS('var', '#[#]', bucket, i) == element) return i;\n    }\n    return -1;\n  }\n\n  static _newHashTable() {\n    // Create a new JavaScript object to be used as a hash table. Use\n    // Object.create to avoid the properties on Object.prototype\n    // showing up as entries.\n    var table = JS('var', 'Object.create(null)');\n    // Attempt to force the hash table into 'dictionary' mode by\n    // adding a property to it and deleting it again.\n    var temporaryKey = '<non-identifier-key>';\n    _setTableEntry(table, temporaryKey, table);\n    _deleteTableEntry(table, temporaryKey);\n    return table;\n  }\n}\n\n// TODO(kasperl): Share this code with HashMapKeyIterator<E>?\nclass HashSetIterator<E> implements Iterator<E> {\n  final _set;\n  final List _elements;\n  int _offset = 0;\n  E _current;\n\n  HashSetIterator(this._set, this._elements);\n\n  E get current => _current;\n\n  bool moveNext() {\n    var elements = _elements;\n    int offset = _offset;\n    if (JS('bool', '# !== #', elements, _set._elements)) {\n      throw new ConcurrentModificationError(_set);\n    } else if (offset >= JS('int', '#.length', elements)) {\n      _current = null;\n      return false;\n    } else {\n      _current = JS('var', '#[#]', elements, offset);\n      // TODO(kasperl): For now, we have to tell the type inferrer to\n      // treat the result of doing offset + 1 as an int. Otherwise, we\n      // get unnecessary bailout code.\n      _offset = JS('int', '#', offset + 1);\n      return true;\n    }\n  }\n}\n\npatch class LinkedHashSet<E> extends _HashSetBase<E> {\n  int _length = 0;\n\n  // The hash set contents are divided into three parts: one part for\n  // string elements, one for numeric elements, and one for the\n  // rest. String and numeric elements map directly to their linked\n  // cells, but the rest of the entries are stored in bucket lists of\n  // the form:\n  //\n  //    [cell-0, cell-1, ...]\n  //\n  // where all elements in the same bucket share the same hash code.\n  var _strings;\n  var _nums;\n  var _rest;\n\n  // The elements are stored in cells that are linked together\n  // to form a double linked list.\n  LinkedHashSetCell _first;\n  LinkedHashSetCell _last;\n\n  // We track the number of modifications done to the element set to\n  // be able to throw when the set is modified while being iterated\n  // over.\n  int _modifications = 0;\n\n  patch LinkedHashSet();\n\n  void _unsupported(String operation) {\n    throw 'LinkedHashSet: unsupported $operation';\n  }\n\n  // Iterable.\n  patch Iterator<E> get iterator {\n    return new LinkedHashSetIterator(this, _modifications);\n  }\n\n  patch int get length => _length;\n  patch bool get isEmpty => _length == 0;\n\n  patch bool contains(Object object) {\n    if (_isStringElement(object)) {\n      var strings = _strings;\n      if (strings == null) return false;\n      LinkedHashSetCell cell = _getTableEntry(strings, object);\n      return cell != null;\n    } else if (_isNumericElement(object)) {\n      var nums = _nums;\n      if (nums == null) return false;\n      LinkedHashSetCell cell = _getTableEntry(nums, object);\n      return cell != null;\n    } else {\n      var rest = _rest;\n      if (rest == null) return false;\n      var bucket = _getBucket(rest, object);\n      return _findBucketIndex(bucket, object) >= 0;\n    }\n  }\n\n  patch void forEach(void action(E element)) {\n    LinkedHashSetCell cell = _first;\n    int modifications = _modifications;\n    while (cell != null) {\n      action(cell._element);\n      if (modifications != _modifications) {\n        throw new ConcurrentModificationError(this);\n      }\n      cell = cell._next;\n    }\n  }\n\n  patch E get first {\n    if (_first == null) throw new StateError(\"No elements\");\n    return _first._element;\n  }\n\n  patch E get last {\n    if (_last == null) throw new StateError(\"No elements\");\n    return _last._element;\n  }\n\n  // Collection.\n  patch void add(E element) {\n    if (_isStringElement(element)) {\n      var strings = _strings;\n      if (strings == null) _strings = strings = _newHashTable();\n      _addHashTableEntry(strings, element);\n    } else if (_isNumericElement(element)) {\n      var nums = _nums;\n      if (nums == null) _nums = nums = _newHashTable();\n      _addHashTableEntry(nums, element);\n    } else {\n      var rest = _rest;\n      if (rest == null) _rest = rest = _newHashTable();\n      var hash = _computeHashCode(element);\n      var bucket = JS('var', '#[#]', rest, hash);\n      if (bucket == null) {\n        LinkedHashSetCell cell = _newLinkedCell(element);\n        _setTableEntry(rest, hash, JS('var', '[#]', cell));\n      } else {\n        int index = _findBucketIndex(bucket, element);\n        if (index >= 0) return;\n        LinkedHashSetCell cell = _newLinkedCell(element);\n        JS('void', '#.push(#)', bucket, cell);\n      }\n    }\n  }\n\n  patch void addAll(Iterable<E> objects) {\n    for (E object in objects) {\n      add(object);\n    }\n  }\n\n  patch bool remove(Object object) {\n    if (_isStringElement(object)) {\n      return _removeHashTableEntry(_strings, object);\n    } else if (_isNumericElement(object)) {\n      return _removeHashTableEntry(_nums, object);\n    } else {\n      var rest = _rest;\n      if (rest == null) return false;\n      var bucket = _getBucket(rest, object);\n      int index = _findBucketIndex(bucket, object);\n      if (index < 0) return false;\n      // Use splice to remove the [cell] element at the index and\n      // unlink it.\n      LinkedHashSetCell cell = JS('var', '#.splice(#, 1)[0]', bucket, index);\n      _unlinkCell(cell);\n      return true;\n    }\n  }\n\n  patch void removeAll(Iterable objectsToRemove) {\n    for (var each in objectsToRemove) {\n      remove(each);\n    }\n  }\n\n  patch void removeWhere(bool test(E element)) {\n    _filterWhere(test, true);\n  }\n\n  patch void retainWhere(bool test(E element)) {\n    _filterWhere(test, false);\n  }\n\n  void _filterWhere(bool test(E element), bool removeMatching) {\n    LinkedHashSetCell cell = _first;\n    while (cell != null) {\n      E element = cell._element;\n      LinkedHashSetCell next = cell._next;\n      int modifications = _modifications;\n      bool shouldRemove = (removeMatching == test(element));\n      if (modifications != _modifications) {\n        throw new ConcurrentModificationError(this);\n      }\n      if (shouldRemove) remove(element);\n      cell = next;\n    }\n  }\n\n  patch void clear() {\n    if (_length > 0) {\n      _strings = _nums = _rest = _first = _last = null;\n      _length = 0;\n      _modified();\n    }\n  }\n\n  void _addHashTableEntry(var table, E element) {\n    LinkedHashSetCell cell = _getTableEntry(table, element);\n    if (cell != null) return;\n    _setTableEntry(table, element, _newLinkedCell(element));\n  }\n\n  bool _removeHashTableEntry(var table, E element) {\n    if (table == null) return false;\n    LinkedHashSetCell cell = _getTableEntry(table, element);\n    if (cell == null) return false;\n    _unlinkCell(cell);\n    _deleteTableEntry(table, element);\n    return true;\n  }\n\n  void _modified() {\n    // Value cycles after 2^30 modifications. If you keep hold of an\n    // iterator for that long, you might miss a modification\n    // detection, and iteration can go sour. Don't do that.\n    _modifications = (_modifications + 1) & 0x3ffffff;\n  }\n\n  // Create a new cell and link it in as the last one in the list.\n  LinkedHashSetCell _newLinkedCell(E element) {\n    LinkedHashSetCell cell = new LinkedHashSetCell(element);\n    if (_first == null) {\n      _first = _last = cell;\n    } else {\n      LinkedHashSetCell last = _last;\n      cell._previous = last;\n      _last = last._next = cell;\n    }\n    _length++;\n    _modified();\n    return cell;\n  }\n\n  // Unlink the given cell from the linked list of cells.\n  void _unlinkCell(LinkedHashSetCell cell) {\n    LinkedHashSetCell previous = cell._previous;\n    LinkedHashSetCell next = cell._next;\n    if (previous == null) {\n      assert(cell == _first);\n      _first = next;\n    } else {\n      previous._next = next;\n    }\n    if (next == null) {\n      assert(cell == _last);\n      _last = previous;\n    } else {\n      next._previous = previous;\n    }\n    _length--;\n    _modified();\n  }\n\n  static bool _isStringElement(var element) {\n    return element is String && element != '__proto__';\n  }\n\n  static bool _isNumericElement(var element) {\n    // Only treat unsigned 30-bit integers as numeric elements. This\n    // way, we avoid converting them to strings when we use them as\n    // keys in the JavaScript hash table object.\n    return element is num &&\n        JS('bool', '(# & 0x3ffffff) === #', element, element);\n  }\n\n  static int _computeHashCode(var element) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic elements like '__proto__'. Another\n    // option would be to throw an exception if the hash code isn't a\n    // number.\n    return JS('int', '# & 0x3ffffff', element.hashCode);\n  }\n\n  static _getTableEntry(var table, var key) {\n    return JS('var', '#[#]', table, key);\n  }\n\n  static void _setTableEntry(var table, var key, var value) {\n    assert(value != null);\n    JS('void', '#[#] = #', table, key, value);\n  }\n\n  static void _deleteTableEntry(var table, var key) {\n    JS('void', 'delete #[#]', table, key);\n  }\n\n  static List _getBucket(var table, var element) {\n    var hash = _computeHashCode(element);\n    return JS('var', '#[#]', table, hash);\n  }\n\n  static int _findBucketIndex(var bucket, var element) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i++) {\n      LinkedHashSetCell cell = JS('var', '#[#]', bucket, i);\n      if (cell._element == element) return i;\n    }\n    return -1;\n  }\n\n  static _newHashTable() {\n    // Create a new JavaScript object to be used as a hash table. Use\n    // Object.create to avoid the properties on Object.prototype\n    // showing up as entries.\n    var table = JS('var', 'Object.create(null)');\n    // Attempt to force the hash table into 'dictionary' mode by\n    // adding a property to it and deleting it again.\n    var temporaryKey = '<non-identifier-key>';\n    _setTableEntry(table, temporaryKey, table);\n    _deleteTableEntry(table, temporaryKey);\n    return table;\n  }\n}\n\nclass LinkedHashSetCell {\n  final _element;\n\n  LinkedHashSetCell _next;\n  LinkedHashSetCell _previous;\n\n  LinkedHashSetCell(this._element);\n}\n\n// TODO(kasperl): Share this code with LinkedHashMapKeyIterator<E>?\nclass LinkedHashSetIterator<E> implements Iterator<E> {\n  final _set;\n  final int _modifications;\n  LinkedHashSetCell _cell;\n  E _current;\n\n  LinkedHashSetIterator(this._set, this._modifications) {\n    _cell = _set._first;\n  }\n\n  E get current => _current;\n\n  bool moveNext() {\n    if (_modifications != _set._modifications) {\n      throw new ConcurrentModificationError(_set);\n    } else if (_cell == null) {\n      _current = null;\n      return false;\n    } else {\n      _current = _cell._element;\n      _cell = _cell._next;\n      return true;\n    }\n  }\n}\n","sdk/lib/_internal/compiler/implementation/lib/constant_map.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _js_helper;\n\n// This class has no constructor. This is on purpose since the instantiation\n// is shortcut by the compiler.\nclass ConstantMap<V> implements Map<String, V> {\n  final int length;\n  // A constant map is backed by a JavaScript object.\n  final _jsObject;\n  final List<String> _keys;\n\n  bool containsValue(V needle) {\n    return values.any((V value) => value == needle);\n  }\n\n  bool containsKey(String key) {\n    if (key == '__proto__') return false;\n    return jsHasOwnProperty(_jsObject, key);\n  }\n\n  V operator [](String key) {\n    if (!containsKey(key)) return null;\n    return jsPropertyAccess(_jsObject, key);\n  }\n\n  void forEach(void f(String key, V value)) {\n    _keys.forEach((String key) => f(key, this[key]));\n  }\n\n  Iterable<String> get keys {\n    return new _ConstantMapKeyIterable(this);\n  }\n\n  Iterable<V> get values {\n    return _keys.map((String key) => this[key]);\n  }\n\n  bool get isEmpty => length == 0;\n\n  String toString() => Maps.mapToString(this);\n\n  _throwUnmodifiable() {\n    throw new UnsupportedError(\"Cannot modify unmodifiable Map\");\n  }\n  void operator []=(String key, V val) => _throwUnmodifiable();\n  V putIfAbsent(String key, V ifAbsent()) => _throwUnmodifiable();\n  V remove(String key) => _throwUnmodifiable();\n  void clear() => _throwUnmodifiable();\n}\n\n// This class has no constructor. This is on purpose since the instantiation\n// is shortcut by the compiler.\nclass ConstantProtoMap<V> extends ConstantMap<V> {\n  final V _protoValue;\n\n  bool containsKey(String key) {\n    if (key == '__proto__') return true;\n    return super.containsKey(key);\n  }\n\n  V operator [](String key) {\n    if (key == '__proto__') return _protoValue;\n    return super[key];\n  }\n}\n\nclass _ConstantMapKeyIterable extends IterableBase<String> {\n  ConstantMap _map;\n  _ConstantMapKeyIterable(this._map);\n\n  Iterator<String> get iterator => _map._keys.iterator;\n}\n","sdk/lib/_internal/compiler/implementation/lib/core_patch.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Patch file for dart:core classes.\nimport 'dart:_interceptors';\nimport 'dart:_js_helper' show checkNull,\n                              getRuntimeType,\n                              isJsArray,\n                              JSSyntaxRegExp,\n                              Primitives,\n                              stringJoinUnchecked;\nimport \"dart:_collection-dev\" as _symbol_dev;\n\nString _symbolToString(Symbol symbol) => _symbol_dev.Symbol.getName(symbol);\n\n_symbolMapToStringMap(Map<Symbol, dynamic> map) {\n  var result = new Map<String, dynamic>();\n  map.forEach((Symbol key, value) {\n    result[_symbolToString(key)] = value;\n  });\n  return result;\n}\n\npatch void print(var object) {\n  Primitives.printString(object.toString());\n}\n\n// Patch for Object implementation.\npatch class Object {\n  patch int get hashCode => Primitives.objectHashCode(this);\n\n  patch String toString() => Primitives.objectToString(this);\n\n  patch dynamic noSuchMethod(Invocation invocation) {\n    throw new NoSuchMethodError(\n        this,\n        _symbolToString(invocation.memberName),\n        invocation.positionalArguments,\n        _symbolMapToStringMap(invocation.namedArguments));\n  }\n\n  patch Type get runtimeType => getRuntimeType(this);\n}\n\n// Patch for Function implementation.\npatch class Function {\n  patch static apply(Function function,\n                     List positionalArguments,\n                     [Map<Symbol, dynamic> namedArguments]) {\n    return Primitives.applyFunction(\n        function, positionalArguments, _toMangledNames(namedArguments));\n  }\n\n  static Map<String, dynamic> _toMangledNames(\n      Map<Symbol, dynamic> namedArguments) {\n    if (namedArguments == null) return null;\n    Map<String, dynamic> result = {};\n    namedArguments.forEach((symbol, value) {\n      result[_symbolToString(symbol)] = value;\n    });\n    return result;\n  }\n}\n\n// Patch for Expando implementation.\npatch class Expando<T> {\n  patch Expando([String name]) : this.name = name;\n\n  patch T operator[](Object object) {\n    var values = Primitives.getProperty(object, _EXPANDO_PROPERTY_NAME);\n    return (values == null) ? null : Primitives.getProperty(values, _getKey());\n  }\n\n  patch void operator[]=(Object object, T value) {\n    var values = Primitives.getProperty(object, _EXPANDO_PROPERTY_NAME);\n    if (values == null) {\n      values = new Object();\n      Primitives.setProperty(object, _EXPANDO_PROPERTY_NAME, values);\n    }\n    Primitives.setProperty(values, _getKey(), value);\n  }\n\n  String _getKey() {\n    String key = Primitives.getProperty(this, _KEY_PROPERTY_NAME);\n    if (key == null) {\n      key = \"expando\\$key\\$${_keyCount++}\";\n      Primitives.setProperty(this, _KEY_PROPERTY_NAME, key);\n    }\n    return key;\n  }\n\n  static const String _KEY_PROPERTY_NAME = 'expando\\$key';\n  static const String _EXPANDO_PROPERTY_NAME = 'expando\\$values';\n  static int _keyCount = 0;\n}\n\npatch class int {\n  patch static int parse(String source,\n                         { int radix,\n                           int onError(String source) }) {\n    return Primitives.parseInt(source, radix, onError);\n  }\n}\n\npatch class double {\n  patch static double parse(String source, [int handleError(String source)]) {\n    return Primitives.parseDouble(source, handleError);\n  }\n}\n\npatch class Error {\n  patch static String _objectToString(Object object) {\n    return Primitives.objectToString(object);\n  }\n}\n\n\n// Patch for DateTime implementation.\npatch class DateTime {\n  patch DateTime._internal(int year,\n                           int month,\n                           int day,\n                           int hour,\n                           int minute,\n                           int second,\n                           int millisecond,\n                           bool isUtc)\n      : this.isUtc = checkNull(isUtc),\n        millisecondsSinceEpoch = Primitives.valueFromDecomposedDate(\n            year, month, day, hour, minute, second, millisecond, isUtc) {\n    Primitives.lazyAsJsDate(this);\n  }\n\n  patch DateTime._now()\n      : isUtc = false,\n        millisecondsSinceEpoch = Primitives.dateNow() {\n    Primitives.lazyAsJsDate(this);\n  }\n\n  patch static int _brokenDownDateToMillisecondsSinceEpoch(\n      int year, int month, int day, int hour, int minute, int second,\n      int millisecond, bool isUtc) {\n    return Primitives.valueFromDecomposedDate(\n        year, month, day, hour, minute, second, millisecond, isUtc);\n  }\n\n  patch String get timeZoneName {\n    if (isUtc) return \"UTC\";\n    return Primitives.getTimeZoneName(this);\n  }\n\n  patch Duration get timeZoneOffset {\n    if (isUtc) return new Duration();\n    return new Duration(minutes: Primitives.getTimeZoneOffsetInMinutes(this));\n  }\n\n  patch int get year => Primitives.getYear(this);\n\n  patch int get month => Primitives.getMonth(this);\n\n  patch int get day => Primitives.getDay(this);\n\n  patch int get hour => Primitives.getHours(this);\n\n  patch int get minute => Primitives.getMinutes(this);\n\n  patch int get second => Primitives.getSeconds(this);\n\n  patch int get millisecond => Primitives.getMilliseconds(this);\n\n  patch int get weekday => Primitives.getWeekday(this);\n}\n\n\n// Patch for Stopwatch implementation.\npatch class Stopwatch {\n  patch static int _frequency() => 1000000;\n  patch static int _now() => Primitives.numMicroseconds();\n}\n\n\n// Patch for List implementation.\npatch class List<E> {\n  patch factory List([int length]) {\n    if (!?length) return Primitives.newGrowableList(0);\n    // Explicit type test is necessary to protect Primitives.newFixedList in\n    // unchecked mode.\n    if ((length is !int) || (length < 0)) {\n      throw new ArgumentError(\"Length must be a positive integer: $length.\");\n    }\n    return Primitives.newFixedList(length);\n  }\n\n  patch factory List.filled(int length, E fill) {\n    // Explicit type test is necessary to protect Primitives.newFixedList in\n    // unchecked mode.\n    if ((length is !int) || (length < 0)) {\n      throw new ArgumentError(\"Length must be a positive integer: $length.\");\n    }\n    List result = Primitives.newFixedList(length);\n    if (length != 0 && fill != null) {\n      for (int i = 0; i < result.length; i++) {\n        result[i] = fill;\n      }\n    }\n    return result;\n  }\n}\n\n\npatch class String {\n  patch factory String.fromCharCodes(Iterable<int> charCodes) {\n    if (!isJsArray(charCodes)) {\n      charCodes = new List.from(charCodes);\n    }\n    return Primitives.stringFromCharCodes(charCodes);\n  }\n}\n\npatch class RegExp {\n  patch factory RegExp(String pattern,\n                       {bool multiLine: false,\n                        bool caseSensitive: true})\n    => new JSSyntaxRegExp(pattern,\n                          multiLine: multiLine,\n                          caseSensitive: caseSensitive);\n}\n\n// Patch for 'identical' function.\npatch bool identical(Object a, Object b) {\n  return Primitives.identicalImplementation(a, b);\n}\n\npatch class StringBuffer {\n  String _contents = \"\";\n\n  patch StringBuffer([Object content = \"\"]) {\n    if (content is String) {\n      _contents = content;\n    } else {\n      write(content);\n    }\n  }\n\n  patch int get length => _contents.length;\n\n  patch void write(Object obj) {\n    String str = obj is String ? obj : \"$obj\";\n    _contents = Primitives.stringConcatUnchecked(_contents, str);\n  }\n\n  patch void writeCharCode(int charCode) {\n    write(new String.fromCharCode(charCode));\n  }\n\n  patch void clear() {\n    _contents = \"\";\n  }\n\n  patch String toString() => _contents;\n}\n\npatch class NoSuchMethodError {\n  patch String toString() {\n    StringBuffer sb = new StringBuffer();\n    int i = 0;\n    if (_arguments != null) {\n      for (; i < _arguments.length; i++) {\n        if (i > 0) {\n          sb.write(\", \");\n        }\n        sb.write(Error.safeToString(_arguments[i]));\n      }\n    }\n    if (_namedArguments != null) {\n      _namedArguments.forEach((String key, var value) {\n        if (i > 0) {\n          sb.write(\", \");\n        }\n        sb.write(key);\n        sb.write(\": \");\n        sb.write(Error.safeToString(value));\n        i++;\n      });\n    }\n    if (_existingArgumentNames == null) {\n      return \"NoSuchMethodError : method not found: '$_memberName'\\n\"\n          \"Receiver: ${Error.safeToString(_receiver)}\\n\"\n          \"Arguments: [$sb]\";\n    } else {\n      String actualParameters = sb.toString();\n      sb = new StringBuffer();\n      for (int i = 0; i < _existingArgumentNames.length; i++) {\n        if (i > 0) {\n          sb.write(\", \");\n        }\n        sb.write(_existingArgumentNames[i]);\n      }\n      String formalParameters = sb.toString();\n      return \"NoSuchMethodError: incorrect number of arguments passed to \"\n          \"method named '$_memberName'\\n\"\n          \"Receiver: ${Error.safeToString(_receiver)}\\n\"\n          \"Tried calling: $_memberName($actualParameters)\\n\"\n          \"Found: $_memberName($formalParameters)\";\n    }\n  }\n}\n","sdk/lib/_internal/compiler/implementation/lib/foreign_helper.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary _foreign_helper;\n\n/**\n * Emits a JavaScript code fragment parameterized by arguments.\n *\n * Hash characters `#` in the [codeTemplate] are replaced in left-to-right order\n * with expressions that contain the values of, or evaluate to, the arguments.\n * The number of hash marks must match the number or arguments.  Although\n * declared with arguments [arg0] through [arg2], the form actually has no limit\n * on the number of arguments.\n *\n * The [typeDescription] argument is interpreted as a description of the\n * behavior of the JavaScript code.  Currently it describes the types that may\n * be returned by the expression, with the additional behavior that the returned\n * values may be fresh instances of the types.  The type information must be\n * correct as it is trusted by the compiler in optimizations, and it must be\n * precise as possible since it is used for native live type analysis to\n * tree-shake large parts of the DOM libraries.  If poorly written, the\n * [typeDescription] will cause unnecessarily bloated programs.  (You can check\n * for this by compiling with `--verbose`; there is an info message describing\n * the number of native (DOM) types that can be removed, which usually should be\n * greater than zero.)\n *\n * The [typeDescription] is a [String] which contains a union of types separated\n * by vertical bar `|` symbols, e.g.  `\"num|String\"` describes the union of\n * numbers and Strings.  There is no type in Dart that is this precise.  The\n * Dart alternative would be `Object` or `dynamic`, but these types imply that\n * the JS-code might also be creating instances of all the DOM types.  If `null`\n * is possible, it must be specified explicitly, e.g. `\"String|Null\"`.\n * [typeDescription] has several extensions to help describe the behavior more\n * accurately.  In addition to the union type already described:\n *\n *  + `=List` is the JavaScript array type.  This is more precise than `List`,\n *     which includes about fifty DOM types that also implement the List\n *     interface.\n *\n *  + `=Object` is a plain JavaScript object.  Some DOM methods return instances\n *     that have no corresponing Dart type (e.g. cross-frame documents),\n *     `=Object` can be used to describe these untyped' values.\n *\n *  + `var`.  If the entire [typeDescription] is `var` then the type is\n *    `dynamic` but the code is known to not create any instances.\n *\n * Examples:\n *\n *     // Create a JavaScript Array.\n *     List a = JS('=List', 'new Array(#)', length);\n *\n *     // Parent window might be an opaque cross-frame window.\n *     var thing = JS('=Object|Window', '#.parent', myWindow);\n *\n * Guidelines:\n *\n *  + Do not use any parameter, local, method or field names in the\n *    [codeTemplate].  These names are all subject to arbitrary renaming by the\n *    compiler.  Pass the values in via `#` substition, and test with the\n *    `--minify` dart2js command-line option.\n *\n *  + The substituted expressions are values, not locations.\n *\n *        JS('void', '# += \"x\"', this.field);\n *\n *    `this.field` might not be a substituted as a reference to the field.  The\n *    generated code might accidentally work as intended, but it also might be\n *\n *        var t1 = this.field;\n *        t1 += \"x\";\n *\n *    or\n *\n *        this.get$field() += \"x\";\n *\n *    The remedy in this case is to expand the `+=` operator, leaving all\n *    references to the Dart field as Dart code:\n *\n *        this.field = JS('String', '# + \"x\"', this.field);\n *\n *\n * Additional notes.\n *\n * In the future we may extend [typeDescription] to include other aspects of the\n * behavior, for example, separating the returned types from the instantiated\n * types, or including effects to allow the compiler to perform more\n * optimizations around the code.  This might be an extension of [JS] or a new\n * function similar to [JS] with additional arguments for the new information.\n */\n// Add additional optional arguments if needed. The method is treated internally\n// as a variable argument method.\ndynamic JS(String typeDescription, String codeTemplate,\n    [var arg0, var arg1, var arg2, var arg3, var arg4, var arg5, var arg6,\n     var arg7, var arg8, var arg9, var arg10, var arg11]) {}\n\n/**\n * Returns the isolate in which this code is running.\n */\nIsolateContext JS_CURRENT_ISOLATE() {}\n\nabstract class IsolateContext {\n  /// Holds a (native) JavaScript instance of Isolate, see\n  /// finishIsolateConstructorFunction in emitter.dart.\n  get isolateStatics;\n}\n\n/**\n * Invokes [function] in the context of [isolate].\n */\ndynamic JS_CALL_IN_ISOLATE(var isolate, Function function) {}\n\n/**\n * Converts the Dart closure [function] into a JavaScript closure.\n */\ndynamic DART_CLOSURE_TO_JS(Function function) {}\n\n/**\n * Returns a raw reference to the JavaScript function which implements\n * [function].\n *\n * Warning: this is dangerous, you should probably use\n * [DART_CLOSURE_TO_JS] instead. The returned object is not a valid\n * Dart closure, does not store the isolate context or arity.\n *\n * A valid example of where this can be used is as the second argument\n * to V8's Error.captureStackTrace. See\n * https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi.\n */\ndynamic RAW_DART_FUNCTION_REF(Function function) {}\n\n/**\n * Sets the current isolate to [isolate].\n */\nvoid JS_SET_CURRENT_ISOLATE(var isolate) {}\n\n/**\n * Creates an isolate and returns it.\n */\ndynamic JS_CREATE_ISOLATE() {}\n\n/**\n * Returns the JavaScript constructor function for Dart's Object class.\n * This can be used for type tests, as in\n *\n *     if (JS('bool', '# instanceof #', obj, JS_DART_OBJECT_CONSTRUCTOR()))\n *       ...\n */\ndynamic JS_DART_OBJECT_CONSTRUCTOR() {}\n\n/**\n * Returns the prefix used for generated is checks on classes.\n */\nString JS_OPERATOR_IS_PREFIX() {}\n\n/**\n * Returns the prefix used for generated type argument substitutions on classes.\n */\nString JS_OPERATOR_AS_PREFIX() {}\n","sdk/lib/_internal/compiler/implementation/lib/interceptors.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary _interceptors;\n\nimport 'dart:collection';\nimport 'dart:_collection-dev';\nimport 'dart:_js_helper' show allMatchesInStringUnchecked,\n                              Null,\n                              JSSyntaxRegExp,\n                              Primitives,\n                              checkGrowable,\n                              checkMutable,\n                              checkNull,\n                              checkNum,\n                              checkString,\n                              getRuntimeType,\n                              regExpGetNative,\n                              stringContainsUnchecked,\n                              stringLastIndexOfUnchecked,\n                              stringReplaceAllFuncUnchecked,\n                              stringReplaceAllUnchecked,\n                              stringReplaceFirstUnchecked,\n                              lookupDispatchRecord;\nimport 'dart:_foreign_helper' show JS;\n\npart 'js_array.dart';\npart 'js_number.dart';\npart 'js_string.dart';\n\n/**\n * Get the interceptor for [object]. Called by the compiler when it needs\n * to emit a call to an intercepted method, that is a method that is\n * defined in an interceptor class.\n */\ngetInterceptor(object) {\n  // This is a magic method: the compiler does specialization of it\n  // depending on the uses of intercepted methods and instantiated\n  // primitive types.\n}\n\n/**\n * The name of the property used on native classes and `Object.prototype` to get\n * the interceptor for a native class instance.\n * TODO(sra): The value should be initialized on isolate startup to a\n * cryptographic hash to prevent collisions.\n */\nvar dispatchPropertyName = '_zzyzx';\n\ngetDispatchProperty(object) {\n  // TODO(sra): Implement the magic.\n  // This is a magic method: the compiler replaces it with a runtime generated\n  // function\n  //\n  //     function(object){return object._zzyzx;}\n  //\n  // where _zzyzx is replaced with the actual [dispatchPropertyName].\n  //\n  // The body is the CSP compliant version.\n  return JS('', '#[#]', object, dispatchPropertyName);\n}\n\nsetDispatchProperty(object, value) {\n  // TODO(sra): Implement the magic.\n  // This is a magic method: the compiler replaces it with a runtime generated\n  // function\n  //\n  //     function(object, value){object._zzyzx = value;}\n  //\n  // where _zzyzx is replaced with the actual [dispatchPropertyName].\n  //\n  // The body is the CSP compliant version.\n  JS('void', '#[#] = #', object, dispatchPropertyName, value);\n}\n\nmakeDispatchRecord(interceptor, proto, extension) {\n  // Dispatch records are stored in the prototype chain, and in some cases, on\n  // instances.\n  //\n  // The record layout and field usage is designed to minimize the number of\n  // operations on the common paths.\n  //\n  // [interceptor] is the interceptor - a holder of methods for the object,\n  // i.e. the prototype of the interceptor class.\n  //\n  // [proto] is usually the prototype, used to check that the dispatch record\n  // matches the object and is not the dispatch record of a superclass.  Other\n  // values:\n  //  - `false` for leaf classes that need no check.\n  //  - `true` for Dart classes where the object is its own interceptor (unused)\n  //  - a function used to continue matching.\n  //\n  // [extension] is used for irregular cases.\n  //\n  //     proto  interceptor extension action\n  //     -----  ----------- --------- ------\n  //     false  I                     use interceptor I\n  //     true   -                     use object\n  //     P      I                     if object's prototype is P, use I\n  //     F      -           P         if object's prototype is P, call F\n\n  return JS('', '{i: #, p: #, e: #}', interceptor, proto, extension);\n}\n\ndispatchRecordInterceptor(record) => JS('', '#.i', record);\ndispatchRecordProto(record) => JS('', '#.p', record);\ndispatchRecordExtension(record) => JS('', '#.e', record);\n\n/**\n * Returns the interceptor for a native class instance. Used by\n * [getInterceptor].\n */\ngetNativeInterceptor(object) {\n  var record = getDispatchProperty(object);\n\n  if (record != null) {\n    var proto = dispatchRecordProto(record);\n    if (false == proto) return dispatchRecordInterceptor(record);\n    if (true == proto) return object;\n    var objectProto = JS('', 'Object.getPrototypeOf(#)', object);\n    if (JS('bool', '# === #', proto, objectProto)) {\n      return dispatchRecordInterceptor(record);\n    }\n\n    var extension = dispatchRecordExtension(record);\n    if (JS('bool', '# === #', extension, objectProto)) {\n      // The extension handler will do any required patching.  A typical use\n      // case is where one native class represents two Dart classes.  The\n      // extension method will inspect the native object instance to determine\n      // its class and patch the instance.  Needed to fix dartbug.com/9654.\n      return JS('', '(#)(#, #)', proto, object, record);\n    }\n  }\n\n  record = lookupDispatchRecord(object);\n  setDispatchProperty(JS('', 'Object.getPrototypeOf(#)', object), record);\n  return getNativeInterceptor(object);\n}\n\n/**\n * If [JSInvocationMirror._invokeOn] is being used, this variable\n * contains a JavaScript array with the names of methods that are\n * intercepted.\n */\nvar interceptedNames;\n\n/**\n * The base interceptor class.\n *\n * The code `r.foo(a)` is compiled to `getInterceptor(r).foo$1(r, a)`.  The\n * value returned by [getInterceptor] holds the methods separately from the\n * state of the instance.  The compiler converts the methods on an interceptor\n * to take the Dart `this` argument as an explicit `receiver` argument.  The\n * JavaScript `this` parameter is bound to the interceptor.\n *\n * In order to have uniform call sites, if a method is defined on an\n * interceptor, methods of that name on plain unintercepted classes also use the\n * interceptor calling convention.  The plain classes are _self-interceptors_,\n * and for them, `getInterceptor(r)` returns `r`.  Methods on plain\n * unintercepted classes have a redundant `receiver` argument and should ignore\n * it in favour of `this`.\n *\n * In the case of mixins, a method may be placed on both an intercepted class\n * and an unintercepted class.  In this case, the method must use the `receiver`\n * parameter.\n *\n *\n * There are various optimizations of the general call pattern.\n *\n * When the interceptor can be statically determined, it can be used directly:\n *\n *     CONSTANT_INTERCEPTOR.foo$1(r, a)\n *\n * If there are only a few classes, [getInterceptor] can be specialized with a\n * more efficient dispatch:\n *\n *     getInterceptor$specialized(r).foo$1(r, a)\n *\n * If it can be determined that the receiver is an unintercepted class, it can\n * be called directly:\n *\n *     r.foo$1(r, a)\n *\n * If, further, it is known that the call site cannot call a foo that is\n * mixed-in to a native class, then it is known that the explicit receiver is\n * ignored, and space-saving dummy value can be passed instead:\n *\n *     r.foo$1(0, a)\n *\n * This class defines implementations of *all* methods on [Object] so no\n * interceptor inherits an implementation from [Object].  This enables the\n * implementations on Object to ignore the explicit receiver argument, which\n * allows dummy receiver optimization.\n */\nabstract class Interceptor {\n  const Interceptor();\n\n  bool operator ==(other) => identical(this, other);\n\n  int get hashCode => Primitives.objectHashCode(this);\n\n  String toString() => Primitives.objectToString(this);\n\n  dynamic noSuchMethod(Invocation invocation) {\n    throw new NoSuchMethodError(this,\n                                invocation.memberName,\n                                invocation.positionalArguments,\n                                invocation.namedArguments);\n  }\n\n  Type get runtimeType => getRuntimeType(this);\n}\n\n/**\n * The interceptor class for tear-off static methods. Unlike\n * tear-off instance methods, tear-off static methods are just the JS\n * function, and methods inherited from Object must therefore be\n * intercepted.\n */\nclass JSFunction extends Interceptor implements Function {\n  const JSFunction();\n  String toString() => 'Closure';\n}\n\n/**\n * The interceptor class for [bool].\n */\nclass JSBool extends Interceptor implements bool {\n  const JSBool();\n\n  // Note: if you change this, also change the function [S].\n  String toString() => JS('String', r'String(#)', this);\n\n  // The values here are SMIs, co-prime and differ about half of the bit\n  // positions, including the low bit, so they are different mod 2^k.\n  int get hashCode => this ? (2 * 3 * 23 * 3761) : (269 * 811);\n\n  Type get runtimeType => bool;\n}\n\n/**\n * The interceptor class for [Null].\n *\n * This class defines implementations for *all* methods on [Object] since the\n * the methods on Object assume the receiver is non-null.  This means that\n * JSNull will always be in the interceptor set for methods defined on Object.\n */\nclass JSNull extends Interceptor implements Null {\n  const JSNull();\n\n  bool operator ==(other) => identical(null, other);\n\n  // Note: if you change this, also change the function [S].\n  String toString() => 'null';\n\n  int get hashCode => 0;\n\n  Type get runtimeType => Null;\n}\n\n\n/**\n * The supertype for JSString and JSArray. Used by the backend as to\n * have a type mask that contains the objects that we can use the\n * native JS [] operator and length on.\n */\nabstract class JSIndexable {\n  int get length;\n  operator[](int index);\n}\n\n/**\n * The supertype for JSMutableArray and\n * JavaScriptIndexingBehavior. Used by the backend to have a type mask\n * that contains the objects we can use the JS []= operator on.\n */\nabstract class JSMutableIndexable extends JSIndexable {\n  operator[]=(int index, var value);\n}\n","sdk/lib/_internal/compiler/implementation/lib/io_patch.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npatch class _BufferUtils {\n  patch static bool _isBuiltinList(List buffer) {\n    throw new UnsupportedError(\"_isBuiltinList\");\n  }\n}\n\npatch class _Directory {\n  patch static String _current() {\n    throw new UnsupportedError(\"Directory._current\");\n  }\n  patch static _createTemp(String template) {\n    throw new UnsupportedError(\"Directory._createTemp\");\n  }\n  patch static int _exists(String path) {\n    throw new UnsupportedError(\"Directory._exists\");\n  }\n  patch static _create(String path) {\n    throw new UnsupportedError(\"Directory._create\");\n  }\n  patch static _delete(String path, bool recursive) {\n    throw new UnsupportedError(\"Directory._delete\");\n  }\n  patch static _rename(String path, String newPath) {\n    throw new UnsupportedError(\"Directory._rename\");\n  }\n  patch static List _list(String path, bool recursive, bool followLinks) {\n    throw new UnsupportedError(\"Directory._list\");\n  }\n  patch static SendPort _newServicePort() {\n    throw new UnsupportedError(\"Directory._newServicePort\");\n  }\n}\n\npatch class _EventHandler {\n  patch static void _start() {\n    throw new UnsupportedError(\"EventHandler._start\");\n  }\n\n  patch static _sendData(Object sender,\n                         ReceivePort receivePort,\n                         int data) {\n    throw new UnsupportedError(\"EventHandler._sendData\");\n  }\n}\n\npatch class _FileUtils {\n  patch static SendPort _newServicePort() {\n    throw new UnsupportedError(\"FileUtils._newServicePort\");\n  }\n}\n\npatch class FileSystemEntity {\n  patch static int _getType(String path, bool followLinks) {\n    throw new UnsupportedError(\"FileSystemEntity._getType\");\n  }\n  patch static bool _identical(String path1, String path2) {\n    throw new UnsupportedError(\"FileSystemEntity._identical\");\n  }\n}\n\npatch class _File {\n  patch static _exists(String path) {\n    throw new UnsupportedError(\"File._exists\");\n  }\n  patch static _create(String path) {\n    throw new UnsupportedError(\"File._create\");\n  }\n  patch static _createLink(String path, String target) {\n    throw new UnsupportedError(\"File._createLink\");\n  }\n  patch static _linkTarget(String path) {\n    throw new UnsupportedError(\"File._linkTarget\");\n  }\n  patch static _delete(String path) {\n    throw new UnsupportedError(\"File._delete\");\n  }\n  patch static _deleteLink(String path) {\n    throw new UnsupportedError(\"File._deleteLink\");\n  }\n  patch static _directory(String path) {\n    throw new UnsupportedError(\"File._directory\");\n  }\n  patch static _lengthFromPath(String path) {\n    throw new UnsupportedError(\"File._lengthFromPath\");\n  }\n  patch static _lastModified(String path) {\n    throw new UnsupportedError(\"File._lastModified\");\n  }\n  patch static _open(String path, int mode) {\n    throw new UnsupportedError(\"File._open\");\n  }\n  patch static int _openStdio(int fd) {\n    throw new UnsupportedError(\"File._openStdio\");\n  }\n  patch static _fullPath(String path) {\n    throw new UnsupportedError(\"File._fullPath\");\n  }\n}\n\npatch class _RandomAccessFile {\n  patch static int _close(int id) {\n    throw new UnsupportedError(\"RandomAccessFile._close\");\n  }\n  patch static _readByte(int id) {\n    throw new UnsupportedError(\"RandomAccessFile._readByte\");\n  }\n  patch static _read(int id, int bytes) {\n    throw new UnsupportedError(\"RandomAccessFile._read\");\n  }\n  patch static _readInto(int id, List<int> buffer, int start, int end) {\n    throw new UnsupportedError(\"RandomAccessFile._readInto\");\n  }\n  patch static _writeByte(int id, int value) {\n    throw new UnsupportedError(\"RandomAccessFile._writeByte\");\n  }\n  patch static _writeFrom(int id, List<int> buffer, int start, int end) {\n    throw new UnsupportedError(\"RandomAccessFile._writeFrom\");\n  }\n  patch static _position(int id) {\n    throw new UnsupportedError(\"RandomAccessFile._position\");\n  }\n  patch static _setPosition(int id, int position) {\n    throw new UnsupportedError(\"RandomAccessFile._setPosition\");\n  }\n  patch static _truncate(int id, int length) {\n    throw new UnsupportedError(\"RandomAccessFile._truncate\");\n  }\n  patch static _length(int id) {\n    throw new UnsupportedError(\"RandomAccessFile._length\");\n  }\n  patch static _flush(int id) {\n    throw new UnsupportedError(\"RandomAccessFile._flush\");\n  }\n}\n\npatch class _IOCrypto {\n  patch static Uint8List getRandomBytes(int count) {\n    throw new UnsupportedError(\"_IOCrypto.getRandomBytes\");\n  }\n}\n\npatch class _Platform {\n  patch static int _numberOfProcessors() {\n    throw new UnsupportedError(\"Platform._numberOfProcessors\");\n  }\n  patch static String _pathSeparator() {\n    throw new UnsupportedError(\"Platform._pathSeparator\");\n  }\n  patch static String _operatingSystem() {\n    throw new UnsupportedError(\"Platform._operatingSystem\");\n  }\n  patch static _localHostname() {\n    throw new UnsupportedError(\"Platform._localHostname\");\n  }\n  patch static _environment() {\n    throw new UnsupportedError(\"Platform._environment\");\n  }\n}\n\npatch class _ProcessUtils {\n  patch static void _exit(int status) {\n    throw new UnsupportedError(\"ProcessUtils._exit\");\n  }\n  patch static void _setExitCode(int status) {\n    throw new UnsupportedError(\"ProcessUtils._setExitCode\");\n  }\n  patch static void _sleep(int millis) {\n    throw new UnsupportedError(\"ProcessUtils._sleep\");\n  }\n  patch static int _pid(Process process) {\n    throw new UnsupportedError(\"ProcessUtils._pid\");\n  }\n}\n\npatch class Process {\n  patch static Future<Process> start(String executable,\n                                     List<String> arguments,\n                                     [ProcessOptions options]) {\n    throw new UnsupportedError(\"Process.start\");\n  }\n\n  patch static Future<ProcessResult> run(String executable,\n                                         List<String> arguments,\n                                         [ProcessOptions options]) {\n    throw new UnsupportedError(\"Process.run\");\n  }\n}\n\npatch class InternetAddress {\n  patch static Future<List<InternetAddress>> lookup(\n      String host, {InternetAddressType type: InternetAddressType.IPv4}) {\n    throw new UnsupportedError(\"InternetAddress.lookup\");\n  }\n}\n\npatch class RawServerSocket {\n  patch static Future<RawServerSocket> bind([String address = \"127.0.0.1\",\n                                             int port = 0,\n                                             int backlog = 0]) {\n    throw new UnsupportedError(\"RawServerSocket.bind\");\n  }\n}\n\npatch class ServerSocket {\n  patch static Future<ServerSocket> bind([String address = \"127.0.0.1\",\n                                          int port = 0,\n                                          int backlog = 0]) {\n    throw new UnsupportedError(\"ServerSocket.bind\");\n  }\n}\n\npatch class RawSocket {\n  patch static Future<RawSocket> connect(String host, int port) {\n    throw new UnsupportedError(\"RawSocket constructor\");\n  }\n}\n\npatch class Socket {\n  patch static Future<Socket> connect(String host, int port) {\n    throw new UnsupportedError(\"Socket constructor\");\n  }\n}\n\npatch class SecureSocket {\n  patch factory SecureSocket._(RawSecureSocket rawSocket) {\n    throw new UnsupportedError(\"SecureSocket constructor\");\n  }\n\n  patch static void initialize({String database,\n                                String password,\n                                bool useBuiltinRoots: true}) {\n    throw new UnsupportedError(\"SecureSocket.initialize\");\n  }\n}\n\npatch class _SecureFilter {\n  patch factory _SecureFilter() {\n    throw new UnsupportedError(\"_SecureFilter._SecureFilter\");\n  }\n}\n\npatch class _StdIOUtils {\n  patch static Stream<List<int>> _getStdioInputStream() {\n    throw new UnsupportedError(\"StdIOUtils._getStdioInputStream\");\n  }\n  patch static IOSink _getStdioOutputStream(int fd) {\n    throw new UnsupportedError(\"StdIOUtils._getStdioOutputStream\");\n  }\n  patch static int _socketType(nativeSocket) {\n    throw new UnsupportedError(\"StdIOUtils._socketType\");\n  }\n}\n\npatch class _WindowsCodePageDecoder {\n  patch static String _decodeBytes(List<int> bytes) {\n    throw new UnsupportedError(\"_WindowsCodePageDecoder._decodeBytes\");\n  }\n}\n\npatch class _WindowsCodePageEncoder {\n  patch static List<int> _encodeString(String string) {\n    throw new UnsupportedError(\"_WindowsCodePageEncoder._encodeString\");\n  }\n}\n\npatch class _Filter {\n  patch static _Filter newZLibDeflateFilter(bool gzip, int level) {\n    throw new UnsupportedError(\"newZLibDeflateFilter\");\n  }\n  patch static _Filter newZLibInflateFilter() {\n    throw new UnsupportedError(\"newZLibInflateFilter\");\n  }\n}\n","sdk/lib/_internal/compiler/implementation/lib/isolate_helper.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary _isolate_helper;\n\nimport 'dart:async';\nimport 'dart:collection' show Queue, HashMap;\nimport 'dart:isolate';\nimport 'dart:_js_helper' show convertDartClosureToJS,\n                              Null;\nimport 'dart:_foreign_helper' show DART_CLOSURE_TO_JS,\n                                   JS,\n                                   JS_CREATE_ISOLATE,\n                                   JS_CURRENT_ISOLATE,\n                                   JS_SET_CURRENT_ISOLATE,\n                                   IsolateContext;\n\nReceivePort lazyPort;\n\nclass CloseToken {\n  /// This token is sent from [IsolateSink]s to [IsolateStream]s to ask them to\n  /// close themselves.\n  const CloseToken();\n}\n\nclass JsIsolateSink extends EventSink<dynamic> implements IsolateSink {\n  bool _isClosed = false;\n  final SendPort _port;\n  JsIsolateSink.fromPort(this._port);\n\n  void add(dynamic message) {\n    _port.send(message);\n  }\n\n  void addError(errorEvent) {\n    throw new UnimplementedError(\"addError on isolate streams\");\n  }\n\n  void close() {\n    if (_isClosed) return;\n    add(const CloseToken());\n    _isClosed = true;\n  }\n\n  bool operator==(var other) {\n    return other is IsolateSink && _port == other._port;\n  }\n\n  int get hashCode => _port.hashCode + 499;\n}\n\n/**\n * Called by the compiler to support switching\n * between isolates when we get a callback from the DOM.\n */\n_callInIsolate(_IsolateContext isolate, Function function) {\n  var result = isolate.eval(function);\n  _globalState.topEventLoop.run();\n  return result;\n}\n\n/**\n * Called by the compiler to fetch the current isolate context.\n */\n_IsolateContext _currentIsolate() => _globalState.currentContext;\n\n/**\n * Wrapper that takes the dart entry point and runs it within an isolate. The\n * dart2js compiler will inject a call of the form\n * [: startRootIsolate(main); :] when it determines that this wrapping\n * is needed. For single-isolate applications (e.g. hello world), this\n * call is not emitted.\n */\nvoid startRootIsolate(entry) {\n  _globalState = new _Manager();\n\n  // Don't start the main loop again, if we are in a worker.\n  if (_globalState.isWorker) return;\n  final rootContext = new _IsolateContext();\n  _globalState.rootContext = rootContext;\n\n  // BUG(5151491): Setting currentContext should not be necessary, but\n  // because closures passed to the DOM as event handlers do not bind their\n  // isolate automatically we try to give them a reasonable context to live in\n  // by having a \"default\" isolate (the first one created).\n  _globalState.currentContext = rootContext;\n\n  rootContext.eval(entry);\n  _globalState.topEventLoop.run();\n}\n\n/********************************************************\n  Inserted from lib/isolate/dart2js/isolateimpl.dart\n ********************************************************/\n\n/**\n * Concepts used here:\n *\n * \"manager\" - A manager contains one or more isolates, schedules their\n * execution, and performs other plumbing on their behalf.  The isolate\n * present at the creation of the manager is designated as its \"root isolate\".\n * A manager may, for example, be implemented on a web Worker.\n *\n * [_Manager] - State present within a manager (exactly once, as a global).\n *\n * [_ManagerStub] - A handle held within one manager that allows interaction\n * with another manager.  A target manager may be addressed by zero or more\n * [_ManagerStub]s.\n *\n */\n\n/**\n * A native object that is shared across isolates. This object is visible to all\n * isolates running under the same manager (either UI or background web worker).\n *\n * This is code that is intended to 'escape' the isolate boundaries in order to\n * implement the semantics of isolates in JavaScript. Without this we would have\n * been forced to implement more code (including the top-level event loop) in\n * JavaScript itself.\n */\n// TODO(eub, sigmund): move the \"manager\" to be entirely in JS.\n// Running any Dart code outside the context of an isolate gives it\n// the chance to break the isolate abstraction.\n_Manager get _globalState => JS(\"_Manager\", r\"$globalState\");\n\nset _globalState(_Manager val) {\n  JS(\"void\", r\"$globalState = #\", val);\n}\n\n/** State associated with the current manager. See [globalState]. */\n// TODO(sigmund): split in multiple classes: global, thread, main-worker states?\nclass _Manager {\n\n  /** Next available isolate id within this [_Manager]. */\n  int nextIsolateId = 0;\n\n  /** id assigned to this [_Manager]. */\n  int currentManagerId = 0;\n\n  /**\n   * Next available manager id. Only used by the main manager to assign a unique\n   * id to each manager created by it.\n   */\n  int nextManagerId = 1;\n\n  /** Context for the currently running [Isolate]. */\n  _IsolateContext currentContext = null;\n\n  /** Context for the root [Isolate] that first run in this [_Manager]. */\n  _IsolateContext rootContext = null;\n\n  /** The top-level event loop. */\n  _EventLoop topEventLoop;\n\n  /** Whether this program is running from the command line. */\n  bool fromCommandLine;\n\n  /** Whether this [_Manager] is running as a web worker. */\n  bool isWorker;\n\n  /** Whether we support spawning web workers. */\n  bool supportsWorkers;\n\n  /**\n   * Whether to use web workers when implementing isolates. Set to false for\n   * debugging/testing.\n   */\n  bool get useWorkers => supportsWorkers;\n\n  /**\n   * Whether to use the web-worker JSON-based message serialization protocol. By\n   * default this is only used with web workers. For debugging, you can force\n   * using this protocol by changing this field value to [true].\n   */\n  bool get needSerialization => useWorkers;\n\n  /**\n   * Registry of isolates. Isolates must be registered if, and only if, receive\n   * ports are alive.  Normally no open receive-ports means that the isolate is\n   * dead, but DOM callbacks could resurrect it.\n   */\n  Map<int, _IsolateContext> isolates;\n\n  /** Reference to the main [_Manager].  Null in the main [_Manager] itself. */\n  _ManagerStub mainManager;\n\n  /** Registry of active [_ManagerStub]s.  Only used in the main [_Manager]. */\n  Map<int, _ManagerStub> managers;\n\n  _Manager() {\n    _nativeDetectEnvironment();\n    topEventLoop = new _EventLoop();\n    isolates = new Map<int, _IsolateContext>();\n    managers = new Map<int, _ManagerStub>();\n    if (isWorker) {  // \"if we are not the main manager ourself\" is the intent.\n      mainManager = new _MainManagerStub();\n      _nativeInitWorkerMessageHandler();\n    }\n  }\n\n  void _nativeDetectEnvironment() {\n    bool isWindowDefined = globalWindow != null;\n    bool isWorkerDefined = globalWorker != null;\n\n    isWorker = !isWindowDefined && globalPostMessageDefined;\n    supportsWorkers = isWorker\n       || (isWorkerDefined && IsolateNatives.thisScript != null);\n    fromCommandLine = !isWindowDefined && !isWorker;\n  }\n\n  void _nativeInitWorkerMessageHandler() {\n    var function = JS('',\n                      \"function (e) { #(#, e); }\",\n                      DART_CLOSURE_TO_JS(IsolateNatives._processWorkerMessage),\n                      mainManager);\n    JS(\"void\", r\"#.onmessage = #\", globalThis, function);\n    // We define dartPrint so that the implementation of the Dart\n    // print method knows what to call.\n    // TODO(ngeoffray): Should we forward to the main isolate? What if\n    // it exited?\n    JS('void', r'#.dartPrint = function (object) {}', globalThis);\n  }\n\n\n  /**\n   * Close the worker running this code if all isolates are done and\n   * there is no active timer.\n   */\n  void maybeCloseWorker() {\n    if (isWorker\n        && isolates.isEmpty\n        && topEventLoop.activeTimerCount == 0) {\n      mainManager.postMessage(_serializeMessage({'command': 'close'}));\n    }\n  }\n}\n\n/** Context information tracked for each isolate. */\nclass _IsolateContext implements IsolateContext {\n  /** Current isolate id. */\n  int id;\n\n  /** Registry of receive ports currently active on this isolate. */\n  Map<int, ReceivePort> ports;\n\n  /** Holds isolate globals (statics and top-level properties). */\n  var isolateStatics; // native object containing all globals of an isolate.\n\n  _IsolateContext() {\n    id = _globalState.nextIsolateId++;\n    ports = new Map<int, ReceivePort>();\n    isolateStatics = JS_CREATE_ISOLATE();\n  }\n\n  /**\n   * Run [code] in the context of the isolate represented by [this].\n   */\n  dynamic eval(Function code) {\n    var old = _globalState.currentContext;\n    _globalState.currentContext = this;\n    this._setGlobals();\n    var result = null;\n    try {\n      result = code();\n    } finally {\n      _globalState.currentContext = old;\n      if (old != null) old._setGlobals();\n    }\n    return result;\n  }\n\n  void _setGlobals() {\n    JS_SET_CURRENT_ISOLATE(isolateStatics);\n  }\n\n  /** Lookup a port registered for this isolate. */\n  ReceivePort lookup(int portId) => ports[portId];\n\n  /** Register a port on this isolate. */\n  void register(int portId, ReceivePort port)  {\n    if (ports.containsKey(portId)) {\n      throw new Exception(\"Registry: ports must be registered only once.\");\n    }\n    ports[portId] = port;\n    _globalState.isolates[id] = this; // indicate this isolate is active\n  }\n\n  /** Unregister a port on this isolate. */\n  void unregister(int portId) {\n    ports.remove(portId);\n    if (ports.isEmpty) {\n      _globalState.isolates.remove(id); // indicate this isolate is not active\n    }\n  }\n}\n\n/** Represent the event loop on a javascript thread (DOM or worker). */\nclass _EventLoop {\n  final Queue<_IsolateEvent> events = new Queue<_IsolateEvent>();\n  int activeTimerCount = 0;\n\n  _EventLoop();\n\n  void enqueue(isolate, fn, msg) {\n    events.addLast(new _IsolateEvent(isolate, fn, msg));\n  }\n\n  _IsolateEvent dequeue() {\n    if (events.isEmpty) return null;\n    return events.removeFirst();\n  }\n\n  void checkOpenReceivePortsFromCommandLine() {\n    if (_globalState.rootContext != null\n        && _globalState.isolates.containsKey(_globalState.rootContext.id)\n        && _globalState.fromCommandLine\n        && _globalState.rootContext.ports.isEmpty) {\n      // We want to reach here only on the main [_Manager] and only\n      // on the command-line.  In the browser the isolate might\n      // still be alive due to DOM callbacks, but the presumption is\n      // that on the command-line, no future events can be injected\n      // into the event queue once it's empty.  Node has setTimeout\n      // so this presumption is incorrect there.  We think(?) that\n      // in d8 this assumption is valid.\n      throw new Exception(\"Program exited with open ReceivePorts.\");\n    }\n  }\n\n  /** Process a single event, if any. */\n  bool runIteration() {\n    final event = dequeue();\n    if (event == null) {\n      checkOpenReceivePortsFromCommandLine();\n      _globalState.maybeCloseWorker();\n      return false;\n    }\n    event.process();\n    return true;\n  }\n\n  /**\n   * Runs multiple iterations of the run-loop. If possible, each iteration is\n   * run asynchronously.\n   */\n  void _runHelper() {\n    if (globalWindow != null) {\n      // Run each iteration from the browser's top event loop.\n      void next() {\n        if (!runIteration()) return;\n        Timer.run(next);\n      }\n      next();\n    } else {\n      // Run synchronously until no more iterations are available.\n      while (runIteration()) {}\n    }\n  }\n\n  /**\n   * Call [_runHelper] but ensure that worker exceptions are propragated.\n   */\n  void run() {\n    if (!_globalState.isWorker) {\n      _runHelper();\n    } else {\n      try {\n        _runHelper();\n      } catch (e, trace) {\n        _globalState.mainManager.postMessage(_serializeMessage(\n            {'command': 'error', 'msg': '$e\\n$trace' }));\n      }\n    }\n  }\n}\n\n/** An event in the top-level event queue. */\nclass _IsolateEvent {\n  _IsolateContext isolate;\n  Function fn;\n  String message;\n\n  _IsolateEvent(this.isolate, this.fn, this.message);\n\n  void process() {\n    isolate.eval(fn);\n  }\n}\n\n/** An interface for a stub used to interact with a manager. */\nabstract class _ManagerStub {\n  get id;\n  void set id(int i);\n  void set onmessage(Function f);\n  void postMessage(msg);\n  void terminate();\n}\n\n/** A stub for interacting with the main manager. */\nclass _MainManagerStub implements _ManagerStub {\n  get id => 0;\n  void set id(int i) { throw new UnimplementedError(); }\n  void set onmessage(f) {\n    throw new Exception(\"onmessage should not be set on MainManagerStub\");\n  }\n  void postMessage(msg) {\n    JS(\"void\", r\"#.postMessage(#)\", globalThis, msg);\n  }\n  void terminate() {}  // Nothing useful to do here.\n}\n\nconst String _SPAWNED_SIGNAL = \"spawned\";\n\nvar globalThis = IsolateNatives.computeGlobalThis();\nvar globalWindow = JS('', \"#.window\", globalThis);\nvar globalWorker = JS('', \"#.Worker\", globalThis);\nbool globalPostMessageDefined =\n    JS('', \"#.postMessage !== (void 0)\", globalThis);\n\nclass IsolateNatives {\n\n  static String thisScript = computeThisScript();\n\n  /**\n   * The src url for the script tag that loaded this code. Used to create\n   * JavaScript workers.\n   */\n  static String computeThisScript() {\n    var currentScript = JS('', r'$.$currentScript');\n    if (currentScript != null) {\n      return JS('String', 'String(#.src)', currentScript);\n    }\n\n    // TODO(ahe): The following is for supporting command-line engines\n    // such as d8 and jsshell. We should move this code to a helper\n    // library that is only loaded when testing on those engines.\n\n    var stack = JS('String|Null', 'new Error().stack');\n    if (stack == null) {\n      // According to Internet Explorer documentation, the stack\n      // property is not set until the exception is thrown. The stack\n      // property was not provided until IE10.\n      stack = JS('String',\n                 '(function() {'\n                 'try { throw new Error() } catch(e) { return e.stack }'\n                 '})()');\n    }\n    var pattern, matches;\n\n    // This pattern matches V8, Chrome, and Internet Explorer stack\n    // traces that look like this:\n    // Error\n    //     at methodName (URI:LINE:COLUMN)\n    pattern = JS('',\n                 r'new RegExp(\"^ *at [^(]*\\\\((.*):[0-9]*:[0-9]*\\\\)$\", \"m\")');\n\n\n    matches = JS('=List|Null', '#.match(#)', stack, pattern);\n    if (matches != null) return JS('String', '#[1]', matches);\n\n    // This pattern matches Firefox stack traces that look like this:\n    // methodName@URI:LINE\n    pattern = JS('', r'new RegExp(\"^[^@]*@(.*):[0-9]*$\", \"m\")');\n\n    matches = JS('=List|Null', '#.match(#)', stack, pattern);\n    if (matches != null) return JS('String', '#[1]', matches);\n\n    throw new UnsupportedError('Cannot extract URI from \"$stack\"');\n  }\n\n  static computeGlobalThis() => JS('', 'function() { return this; }()');\n\n  /**\n   * Assume that [e] is a browser message event and extract its message data.\n   * We don't import the dom explicitly so, when workers are disabled, this\n   * library can also run on top of nodejs.\n   */\n  static _getEventData(e) => JS(\"\", \"#.data\", e);\n\n  /**\n   * Process messages on a worker, either to control the worker instance or to\n   * pass messages along to the isolate running in the worker.\n   */\n  static void _processWorkerMessage(sender, e) {\n    var msg = _deserializeMessage(_getEventData(e));\n    switch (msg['command']) {\n      case 'start':\n        _globalState.currentManagerId = msg['id'];\n        Function entryPoint = _getJSFunctionFromName(msg['functionName']);\n        var replyTo = _deserializeMessage(msg['replyTo']);\n        var context = new _IsolateContext();\n        _globalState.topEventLoop.enqueue(context, () {\n          _startIsolate(entryPoint, replyTo);\n        }, 'worker-start');\n        // Make sure we always have a current context in this worker.\n        // TODO(7907): This is currently needed because we're using\n        // Timers to implement Futures, and this isolate library\n        // implementation uses Futures. We should either stop using\n        // Futures in this library, or re-adapt if Futures get a\n        // different implementation.\n        _globalState.currentContext = context;\n        _globalState.topEventLoop.run();\n        break;\n      case 'spawn-worker':\n        _spawnWorker(msg['functionName'], msg['uri'], msg['replyPort']);\n        break;\n      case 'message':\n        SendPort port = msg['port'];\n        // If the port has been closed, we ignore the message.\n        if (port != null) {\n          msg['port'].send(msg['msg'], msg['replyTo']);\n        }\n        _globalState.topEventLoop.run();\n        break;\n      case 'close':\n        _log(\"Closing Worker\");\n        _globalState.managers.remove(getId(sender));\n        doTerminate(sender);\n        _globalState.topEventLoop.run();\n        break;\n      case 'log':\n        _log(msg['msg']);\n        break;\n      case 'print':\n        if (_globalState.isWorker) {\n          _globalState.mainManager.postMessage(\n              _serializeMessage({'command': 'print', 'msg': msg}));\n        } else {\n          print(msg['msg']);\n        }\n        break;\n      case 'error':\n        throw msg['msg'];\n    }\n  }\n\n\n  static getId(/* Worker or _ManagerStub */ worker) {\n    if (worker is _ManagerStub) return worker.id;\n    return JS('', '#.id', worker);\n  }\n\n  static doTerminate(/* Worker or _ManagerStub */ worker) {\n    if (worker is _ManagerStub) return worker.terminate();\n    return JS('', '#.terminate()', worker);\n  }\n\n  static doPostMessage(/* Worker or _ManagerStub */ worker, message) {\n    if (worker is _ManagerStub) return worker.postMessage(message);\n    return JS('', '#.postMessage(#)', worker, message);\n  }\n\n  /** Log a message, forwarding to the main [_Manager] if appropriate. */\n  static _log(msg) {\n    if (_globalState.isWorker) {\n      _globalState.mainManager.postMessage(\n          _serializeMessage({'command': 'log', 'msg': msg }));\n    } else {\n      try {\n        _consoleLog(msg);\n      } catch (e, trace) {\n        throw new Exception(trace);\n      }\n    }\n  }\n\n  static void _consoleLog(msg) {\n    JS(\"void\", r\"#.console.log(#)\", globalThis, msg);\n  }\n\n  /** Find a constructor given its name. */\n  static dynamic _getJSConstructorFromName(String factoryName) {\n    return JS(\"\", r\"$[#]\", factoryName);\n  }\n\n  static dynamic _getJSFunctionFromName(String functionName) {\n    return JS(\"\", r\"$[#]\", functionName);\n  }\n\n  /**\n   * Get a string name for the function, if possible.  The result for\n   * anonymous functions is browser-dependent -- it may be \"\" or \"anonymous\"\n   * but you should probably not count on this.\n   */\n  static String _getJSFunctionName(Function f) {\n    return JS(\"String|Null\", r\"(#['$name'] || #)\", f, null);\n  }\n\n  /** Create a new JavaScript object instance given its constructor. */\n  static dynamic _allocate(var ctor) {\n    return JS(\"\", \"new #()\", ctor);\n  }\n\n  static SendPort spawnFunction(void topLevelFunction()) {\n    final name = _getJSFunctionName(topLevelFunction);\n    if (name == null) {\n      throw new UnsupportedError(\n          \"only top-level functions can be spawned.\");\n    }\n    return spawn(name, null, false);\n  }\n\n  static SendPort spawnDomFunction(void topLevelFunction()) {\n    final name = _getJSFunctionName(topLevelFunction);\n    if (name == null) {\n      throw new UnsupportedError(\n          \"only top-level functions can be spawned.\");\n    }\n    return spawn(name, null, true);\n  }\n\n  // TODO(sigmund): clean up above, after we make the new API the default:\n\n  static spawn(String functionName, String uri, bool isLight) {\n    Completer<SendPort> completer = new Completer<SendPort>();\n    ReceivePort port = new ReceivePort();\n    port.receive((msg, SendPort replyPort) {\n      port.close();\n      assert(msg == _SPAWNED_SIGNAL);\n      completer.complete(replyPort);\n    });\n\n    SendPort signalReply = port.toSendPort();\n\n    if (_globalState.useWorkers && !isLight) {\n      _startWorker(functionName, uri, signalReply);\n    } else {\n      _startNonWorker(functionName, uri, signalReply);\n    }\n    return new _BufferingSendPort(\n        _globalState.currentContext.id, completer.future);\n  }\n\n  static SendPort _startWorker(\n      String functionName, String uri, SendPort replyPort) {\n    if (_globalState.isWorker) {\n      _globalState.mainManager.postMessage(_serializeMessage({\n          'command': 'spawn-worker',\n          'functionName': functionName,\n          'uri': uri,\n          'replyPort': replyPort}));\n    } else {\n      _spawnWorker(functionName, uri, replyPort);\n    }\n  }\n\n  static SendPort _startNonWorker(\n      String functionName, String uri, SendPort replyPort) {\n    // TODO(eub): support IE9 using an iframe -- Dart issue 1702.\n    if (uri != null) throw new UnsupportedError(\n            \"Currently spawnUri is not supported without web workers.\");\n    _globalState.topEventLoop.enqueue(new _IsolateContext(), () {\n      final func = _getJSFunctionFromName(functionName);\n      _startIsolate(func, replyPort);\n    }, 'nonworker start');\n  }\n\n  static void _startIsolate(Function topLevel, SendPort replyTo) {\n    lazyPort = new ReceivePort();\n    replyTo.send(_SPAWNED_SIGNAL, port.toSendPort());\n    topLevel();\n  }\n\n  /**\n   * Spawns an isolate in a worker. [factoryName] is the Javascript constructor\n   * name for the isolate entry point class.\n   */\n  static void _spawnWorker(functionName, uri, replyPort) {\n    if (functionName == null) functionName = 'main';\n    if (uri == null) uri = thisScript;\n    final worker = JS('var', 'new Worker(#)', uri);\n\n    var processWorkerMessageTrampoline =\n      JS('', 'function(e) { #(#, e); }',\n         DART_CLOSURE_TO_JS(_processWorkerMessage),\n         worker);\n    JS('void', '#.onmessage = #', worker, processWorkerMessageTrampoline);\n    var workerId = _globalState.nextManagerId++;\n    // We also store the id on the worker itself so that we can unregister it.\n    JS('void', '#.id = #', worker, workerId);\n    _globalState.managers[workerId] = worker;\n    JS('void', '#.postMessage(#)', worker, _serializeMessage({\n        'command': 'start',\n        'id': workerId,\n        // Note: we serialize replyPort twice because the child worker needs to\n        // first deserialize the worker id, before it can correctly deserialize\n        // the port (port deserialization is sensitive to what is the current\n        // workerId).\n        'replyTo': _serializeMessage(replyPort),\n        'functionName': functionName }));\n  }\n}\n\n/********************************************************\n  Inserted from lib/isolate/dart2js/ports.dart\n ********************************************************/\n\n/** Common functionality to all send ports. */\nclass _BaseSendPort implements SendPort {\n  /** Id for the destination isolate. */\n  final int _isolateId;\n\n  const _BaseSendPort(this._isolateId);\n\n  void _checkReplyTo(SendPort replyTo) {\n    if (replyTo != null\n        && replyTo is! _NativeJsSendPort\n        && replyTo is! _WorkerSendPort\n        && replyTo is! _BufferingSendPort) {\n      throw new Exception(\"SendPort.send: Illegal replyTo port type\");\n    }\n  }\n\n  Future call(var message) {\n    final completer = new Completer();\n    final port = new ReceivePortImpl();\n    send(message, port.toSendPort());\n    port.receive((value, ignoreReplyTo) {\n      port.close();\n      if (value is Exception) {\n        completer.completeError(value);\n      } else {\n        completer.complete(value);\n      }\n    });\n    return completer.future;\n  }\n\n  void send(var message, [SendPort replyTo]);\n  bool operator ==(var other);\n  int get hashCode;\n}\n\n/** A send port that delivers messages in-memory via native JavaScript calls. */\nclass _NativeJsSendPort extends _BaseSendPort implements SendPort {\n  final ReceivePortImpl _receivePort;\n\n  const _NativeJsSendPort(this._receivePort, int isolateId) : super(isolateId);\n\n  void send(var message, [SendPort replyTo = null]) {\n    _waitForPendingPorts([message, replyTo], () {\n      _checkReplyTo(replyTo);\n      // Check that the isolate still runs and the port is still open\n      final isolate = _globalState.isolates[_isolateId];\n      if (isolate == null) return;\n      if (_receivePort._callback == null) return;\n\n      // We force serialization/deserialization as a simple way to ensure\n      // isolate communication restrictions are respected between isolates that\n      // live in the same worker. [_NativeJsSendPort] delivers both messages\n      // from the same worker and messages from other workers. In particular,\n      // messages sent from a worker via a [_WorkerSendPort] are received at\n      // [_processWorkerMessage] and forwarded to a native port. In such cases,\n      // here we'll see [_globalState.currentContext == null].\n      final shouldSerialize = _globalState.currentContext != null\n          && _globalState.currentContext.id != _isolateId;\n      var msg = message;\n      var reply = replyTo;\n      if (shouldSerialize) {\n        msg = _serializeMessage(msg);\n        reply = _serializeMessage(reply);\n      }\n      _globalState.topEventLoop.enqueue(isolate, () {\n        if (_receivePort._callback != null) {\n          if (shouldSerialize) {\n            msg = _deserializeMessage(msg);\n            reply = _deserializeMessage(reply);\n          }\n          _receivePort._callback(msg, reply);\n        }\n      }, 'receive $message');\n    });\n  }\n\n  bool operator ==(var other) => (other is _NativeJsSendPort) &&\n      (_receivePort == other._receivePort);\n\n  int get hashCode => _receivePort._id;\n}\n\n/** A send port that delivers messages via worker.postMessage. */\n// TODO(eub): abstract this for iframes.\nclass _WorkerSendPort extends _BaseSendPort implements SendPort {\n  final int _workerId;\n  final int _receivePortId;\n\n  const _WorkerSendPort(this._workerId, int isolateId, this._receivePortId)\n      : super(isolateId);\n\n  void send(var message, [SendPort replyTo = null]) {\n    _waitForPendingPorts([message, replyTo], () {\n      _checkReplyTo(replyTo);\n      final workerMessage = _serializeMessage({\n          'command': 'message',\n          'port': this,\n          'msg': message,\n          'replyTo': replyTo});\n\n      if (_globalState.isWorker) {\n        // Communication from one worker to another go through the\n        // main worker.\n        _globalState.mainManager.postMessage(workerMessage);\n      } else {\n        // Deliver the message only if the worker is still alive.\n        _ManagerStub manager = _globalState.managers[_workerId];\n        if (manager != null) {\n          IsolateNatives.doPostMessage(manager, workerMessage);\n        }\n      }\n    });\n  }\n\n  bool operator ==(var other) {\n    return (other is _WorkerSendPort) &&\n        (_workerId == other._workerId) &&\n        (_isolateId == other._isolateId) &&\n        (_receivePortId == other._receivePortId);\n  }\n\n  int get hashCode {\n    // TODO(sigmund): use a standard hash when we get one available in corelib.\n    return (_workerId << 16) ^ (_isolateId << 8) ^ _receivePortId;\n  }\n}\n\n/** A port that buffers messages until an underlying port gets resolved. */\nclass _BufferingSendPort extends _BaseSendPort implements SendPort {\n  /** Internal counter to assign unique ids to each port. */\n  static int _idCount = 0;\n\n  /** For implementing equals and hashcode. */\n  final int _id;\n\n  /** Underlying port, when resolved. */\n  SendPort _port;\n\n  /**\n   * Future.sync the underlying port, so that we can detect when this port can be\n   * sent on messages.\n   */\n  Future<SendPort> _futurePort;\n\n  /** Pending messages (and reply ports). */\n  List pending;\n\n  _BufferingSendPort(isolateId, this._futurePort)\n      : super(isolateId), _id = _idCount, pending = [] {\n    _idCount++;\n    _futurePort.then((p) {\n      _port = p;\n      for (final item in pending) {\n        p.send(item['message'], item['replyTo']);\n      }\n      pending = null;\n    });\n  }\n\n  _BufferingSendPort.fromPort(isolateId, this._port)\n      : super(isolateId), _id = _idCount {\n    _idCount++;\n  }\n\n  void send(var message, [SendPort replyTo]) {\n    if (_port != null) {\n      _port.send(message, replyTo);\n    } else {\n      pending.add({'message': message, 'replyTo': replyTo});\n    }\n  }\n\n  bool operator ==(var other) =>\n      other is _BufferingSendPort && _id == other._id;\n  int get hashCode => _id;\n}\n\n/** Implementation of a multi-use [ReceivePort] on top of JavaScript. */\nclass ReceivePortImpl implements ReceivePort {\n  int _id;\n  Function _callback;\n  static int _nextFreeId = 1;\n\n  ReceivePortImpl()\n      : _id = _nextFreeId++ {\n    _globalState.currentContext.register(_id, this);\n  }\n\n  void receive(void onMessage(var message, SendPort replyTo)) {\n    _callback = onMessage;\n  }\n\n  void close() {\n    _callback = null;\n    _globalState.currentContext.unregister(_id);\n  }\n\n  SendPort toSendPort() {\n    return new _NativeJsSendPort(this, _globalState.currentContext.id);\n  }\n}\n\n/** Wait until all ports in a message are resolved. */\n_waitForPendingPorts(var message, void callback()) {\n  final finder = new _PendingSendPortFinder();\n  finder.traverse(message);\n  Future.wait(finder.ports).then((_) => callback());\n}\n\n\n/** Visitor that finds all unresolved [SendPort]s in a message. */\nclass _PendingSendPortFinder extends _MessageTraverser {\n  List<Future<SendPort>> ports;\n  _PendingSendPortFinder() : super(), ports = [] {\n    _visited = new _JsVisitedMap();\n  }\n\n  visitPrimitive(x) {}\n\n  visitList(List list) {\n    final seen = _visited[list];\n    if (seen != null) return;\n    _visited[list] = true;\n    // TODO(sigmund): replace with the following: (bug #1660)\n    // list.forEach(_dispatch);\n    list.forEach((e) => _dispatch(e));\n  }\n\n  visitMap(Map map) {\n    final seen = _visited[map];\n    if (seen != null) return;\n\n    _visited[map] = true;\n    // TODO(sigmund): replace with the following: (bug #1660)\n    // map.values.forEach(_dispatch);\n    map.values.forEach((e) => _dispatch(e));\n  }\n\n  visitSendPort(SendPort port) {\n    if (port is _BufferingSendPort && port._port == null) {\n      ports.add(port._futurePort);\n    }\n  }\n\n  visitIsolateSink(IsolateSink sink) {\n    visitSendPort(sink._port);\n  }\n\n  visitCloseToken(CloseToken token) {\n    // Do nothing.\n  }\n}\n\n/********************************************************\n  Inserted from lib/isolate/dart2js/messages.dart\n ********************************************************/\n\n// Defines message visitors, serialization, and deserialization.\n\n/** Serialize [message] (or simulate serialization). */\n_serializeMessage(message) {\n  if (_globalState.needSerialization) {\n    return new _JsSerializer().traverse(message);\n  } else {\n    return new _JsCopier().traverse(message);\n  }\n}\n\n/** Deserialize [message] (or simulate deserialization). */\n_deserializeMessage(message) {\n  if (_globalState.needSerialization) {\n    return new _JsDeserializer().deserialize(message);\n  } else {\n    // Nothing more to do.\n    return message;\n  }\n}\n\nclass _JsSerializer extends _Serializer {\n\n  _JsSerializer() : super() { _visited = new _JsVisitedMap(); }\n\n  visitSendPort(SendPort x) {\n    if (x is _NativeJsSendPort) return visitNativeJsSendPort(x);\n    if (x is _WorkerSendPort) return visitWorkerSendPort(x);\n    if (x is _BufferingSendPort) return visitBufferingSendPort(x);\n    throw \"Illegal underlying port $x\";\n  }\n\n  visitNativeJsSendPort(_NativeJsSendPort port) {\n    return ['sendport', _globalState.currentManagerId,\n        port._isolateId, port._receivePort._id];\n  }\n\n  visitWorkerSendPort(_WorkerSendPort port) {\n    return ['sendport', port._workerId, port._isolateId, port._receivePortId];\n  }\n\n  visitBufferingSendPort(_BufferingSendPort port) {\n    if (port._port != null) {\n      return visitSendPort(port._port);\n    } else {\n      // TODO(floitsch): Use real exception (which one?).\n      throw\n          \"internal error: must call _waitForPendingPorts to ensure all\"\n          \" ports are resolved at this point.\";\n    }\n  }\n\n  visitIsolateSink(IsolateSink sink) {\n    SendPort port = sink._port;\n    bool isClosed = sink._isClosed;\n    return ['isolateSink', visitSendPort(port), isClosed];\n  }\n\n  visitCloseToken(CloseToken token) {\n    return ['closeToken'];\n  }\n}\n\n\nclass _JsCopier extends _Copier {\n\n  _JsCopier() : super() { _visited = new _JsVisitedMap(); }\n\n  visitSendPort(SendPort x) {\n    if (x is _NativeJsSendPort) return visitNativeJsSendPort(x);\n    if (x is _WorkerSendPort) return visitWorkerSendPort(x);\n    if (x is _BufferingSendPort) return visitBufferingSendPort(x);\n    throw \"Illegal underlying port $p\";\n  }\n\n  SendPort visitNativeJsSendPort(_NativeJsSendPort port) {\n    return new _NativeJsSendPort(port._receivePort, port._isolateId);\n  }\n\n  SendPort visitWorkerSendPort(_WorkerSendPort port) {\n    return new _WorkerSendPort(\n        port._workerId, port._isolateId, port._receivePortId);\n  }\n\n  SendPort visitBufferingSendPort(_BufferingSendPort port) {\n    if (port._port != null) {\n      return visitSendPort(port._port);\n    } else {\n      // TODO(floitsch): Use real exception (which one?).\n      throw\n          \"internal error: must call _waitForPendingPorts to ensure all\"\n          \" ports are resolved at this point.\";\n    }\n  }\n\n  IsolateSink visitIsolateSink(IsolateSink sink) {\n    SendPort port = sink._port;\n    bool isClosed = sink._isClosed;\n    IsolateSink result = new JsIsolateSink.fromPort(visitSendPort(port));\n    result._isClosed = isClosed;\n    return result;\n  }\n\n  CloseToken visitCloseToken(CloseToken token) {\n    return token;  // Can be shared.\n  }\n}\n\nclass _JsDeserializer extends _Deserializer {\n\n  SendPort deserializeSendPort(List list) {\n    int managerId = list[1];\n    int isolateId = list[2];\n    int receivePortId = list[3];\n    // If two isolates are in the same manager, we use NativeJsSendPorts to\n    // deliver messages directly without using postMessage.\n    if (managerId == _globalState.currentManagerId) {\n      var isolate = _globalState.isolates[isolateId];\n      if (isolate == null) return null; // Isolate has been closed.\n      var receivePort = isolate.lookup(receivePortId);\n      if (receivePort == null) return null; // Port has been closed.\n      return new _NativeJsSendPort(receivePort, isolateId);\n    } else {\n      return new _WorkerSendPort(managerId, isolateId, receivePortId);\n    }\n  }\n\n  IsolateSink deserializeIsolateSink(List list) {\n    SendPort port = deserializeSendPort(list[1]);\n    bool isClosed = list[2];\n    IsolateSink result = new JsIsolateSink.fromPort(port);\n    result._isClosed = isClosed;\n    return result;\n  }\n\n  CloseToken deserializeCloseToken(List list) {\n    return const CloseToken();\n  }\n}\n\nclass _JsVisitedMap implements _MessageTraverserVisitedMap {\n  List tagged;\n\n  /** Retrieves any information stored in the native object [object]. */\n  operator[](var object) {\n    return _getAttachedInfo(object);\n  }\n\n  /** Injects some information into the native [object]. */\n  void operator[]=(var object, var info) {\n    tagged.add(object);\n    _setAttachedInfo(object, info);\n  }\n\n  /** Get ready to rumble. */\n  void reset() {\n    assert(tagged == null);\n    tagged = new List();\n  }\n\n  /** Remove all information injected in the native objects. */\n  void cleanup() {\n    for (int i = 0, length = tagged.length; i < length; i++) {\n      _clearAttachedInfo(tagged[i]);\n    }\n    tagged = null;\n  }\n\n  void _clearAttachedInfo(var o) {\n    JS(\"void\", \"#['__MessageTraverser__attached_info__'] = #\", o, null);\n  }\n\n  void _setAttachedInfo(var o, var info) {\n    JS(\"void\", \"#['__MessageTraverser__attached_info__'] = #\", o, info);\n  }\n\n  _getAttachedInfo(var o) {\n    return JS(\"\", \"#['__MessageTraverser__attached_info__']\", o);\n  }\n}\n\n// only visible for testing purposes\n// TODO(sigmund): remove once we can disable privacy for testing (bug #1882)\nclass TestingOnly {\n  static copy(x) {\n    return new _JsCopier().traverse(x);\n  }\n\n  // only visible for testing purposes\n  static serialize(x) {\n    _Serializer serializer = new _JsSerializer();\n    _Deserializer deserializer = new _JsDeserializer();\n    return deserializer.deserialize(serializer.traverse(x));\n  }\n}\n\n/********************************************************\n  Inserted from lib/isolate/serialization.dart\n ********************************************************/\n\nclass _MessageTraverserVisitedMap {\n\n  operator[](var object) => null;\n  void operator[]=(var object, var info) { }\n\n  void reset() { }\n  void cleanup() { }\n\n}\n\n/** Abstract visitor for dart objects that can be sent as isolate messages. */\nclass _MessageTraverser {\n\n  _MessageTraverserVisitedMap _visited;\n  _MessageTraverser() : _visited = new _MessageTraverserVisitedMap();\n\n  /** Visitor's entry point. */\n  traverse(var x) {\n    if (isPrimitive(x)) return visitPrimitive(x);\n    _visited.reset();\n    var result;\n    try {\n      result = _dispatch(x);\n    } finally {\n      _visited.cleanup();\n    }\n    return result;\n  }\n\n  _dispatch(var x) {\n    if (isPrimitive(x)) return visitPrimitive(x);\n    if (x is List) return visitList(x);\n    if (x is Map) return visitMap(x);\n    if (x is SendPort) return visitSendPort(x);\n    if (x is SendPortSync) return visitSendPortSync(x);\n    if (x is JsIsolateSink) return visitIsolateSink(x);\n    if (x is CloseToken) return visitCloseToken(x);\n\n    // Overridable fallback.\n    return visitObject(x);\n  }\n\n  visitPrimitive(x);\n  visitList(List x);\n  visitMap(Map x);\n  visitSendPort(SendPort x);\n  visitSendPortSync(SendPortSync x);\n  visitIsolateSink(IsolateSink x);\n  visitCloseToken(CloseToken x);\n\n  visitObject(Object x) {\n    // TODO(floitsch): make this a real exception. (which one)?\n    throw \"Message serialization: Illegal value $x passed\";\n  }\n\n  static bool isPrimitive(x) {\n    return (x == null) || (x is String) || (x is num) || (x is bool);\n  }\n}\n\n\n/** A visitor that recursively copies a message. */\nclass _Copier extends _MessageTraverser {\n\n  visitPrimitive(x) => x;\n\n  List visitList(List list) {\n    List copy = _visited[list];\n    if (copy != null) return copy;\n\n    int len = list.length;\n\n    // TODO(floitsch): we loose the generic type of the List.\n    copy = new List(len);\n    _visited[list] = copy;\n    for (int i = 0; i < len; i++) {\n      copy[i] = _dispatch(list[i]);\n    }\n    return copy;\n  }\n\n  Map visitMap(Map map) {\n    Map copy = _visited[map];\n    if (copy != null) return copy;\n\n    // TODO(floitsch): we loose the generic type of the map.\n    copy = new Map();\n    _visited[map] = copy;\n    map.forEach((key, val) {\n      copy[_dispatch(key)] = _dispatch(val);\n    });\n    return copy;\n  }\n\n}\n\n/** Visitor that serializes a message as a JSON array. */\nclass _Serializer extends _MessageTraverser {\n  int _nextFreeRefId = 0;\n\n  visitPrimitive(x) => x;\n\n  visitList(List list) {\n    int copyId = _visited[list];\n    if (copyId != null) return ['ref', copyId];\n\n    int id = _nextFreeRefId++;\n    _visited[list] = id;\n    var jsArray = _serializeList(list);\n    // TODO(floitsch): we are losing the generic type.\n    return ['list', id, jsArray];\n  }\n\n  visitMap(Map map) {\n    int copyId = _visited[map];\n    if (copyId != null) return ['ref', copyId];\n\n    int id = _nextFreeRefId++;\n    _visited[map] = id;\n    var keys = _serializeList(map.keys.toList());\n    var values = _serializeList(map.values.toList());\n    // TODO(floitsch): we are losing the generic type.\n    return ['map', id, keys, values];\n  }\n\n  _serializeList(List list) {\n    int len = list.length;\n    var result = new List(len);\n    for (int i = 0; i < len; i++) {\n      result[i] = _dispatch(list[i]);\n    }\n    return result;\n  }\n}\n\n/** Deserializes arrays created with [_Serializer]. */\nclass _Deserializer {\n  Map<int, dynamic> _deserialized;\n\n  _Deserializer();\n\n  static bool isPrimitive(x) {\n    return (x == null) || (x is String) || (x is num) || (x is bool);\n  }\n\n  deserialize(x) {\n    if (isPrimitive(x)) return x;\n    // TODO(floitsch): this should be new HashMap<int, dynamic>()\n    _deserialized = new HashMap();\n    return _deserializeHelper(x);\n  }\n\n  _deserializeHelper(x) {\n    if (isPrimitive(x)) return x;\n    assert(x is List);\n    switch (x[0]) {\n      case 'ref': return _deserializeRef(x);\n      case 'list': return _deserializeList(x);\n      case 'map': return _deserializeMap(x);\n      case 'sendport': return deserializeSendPort(x);\n      case 'isolateSink': return deserializeIsolateSink(x);\n      case 'closeToken': return deserializeCloseToken(x);\n      default: return deserializeObject(x);\n    }\n  }\n\n  _deserializeRef(List x) {\n    int id = x[1];\n    var result = _deserialized[id];\n    assert(result != null);\n    return result;\n  }\n\n  List _deserializeList(List x) {\n    int id = x[1];\n    // We rely on the fact that Dart-lists are directly mapped to Js-arrays.\n    List dartList = x[2];\n    _deserialized[id] = dartList;\n    int len = dartList.length;\n    for (int i = 0; i < len; i++) {\n      dartList[i] = _deserializeHelper(dartList[i]);\n    }\n    return dartList;\n  }\n\n  Map _deserializeMap(List x) {\n    Map result = new Map();\n    int id = x[1];\n    _deserialized[id] = result;\n    List keys = x[2];\n    List values = x[3];\n    int len = keys.length;\n    assert(len == values.length);\n    for (int i = 0; i < len; i++) {\n      var key = _deserializeHelper(keys[i]);\n      var value = _deserializeHelper(values[i]);\n      result[key] = value;\n    }\n    return result;\n  }\n\n  deserializeSendPort(List x);\n\n  deserializeIsolateSink(List x);\n\n  deserializeCloseToken(List x);\n\n  deserializeObject(List x) {\n    // TODO(floitsch): Use real exception (which one?).\n    throw \"Unexpected serialized object\";\n  }\n}\n\nclass TimerImpl implements Timer {\n  final bool _once;\n  bool _inEventLoop = false;\n  int _handle;\n\n  TimerImpl(int milliseconds, void callback())\n      : _once = true {\n    if (milliseconds == 0 && (!hasTimer() || _globalState.isWorker)) {\n      // This makes a dependency between the async library and the\n      // event loop of the isolate library. The compiler makes sure\n      // that the event loop is compiled if [Timer] is used.\n      // TODO(7907): In case of web workers, we need to use the event\n      // loop instead of setTimeout, to make sure the futures get executed in\n      // order.\n      _globalState.topEventLoop.enqueue(\n          _globalState.currentContext, callback, 'timer');\n      _inEventLoop = true;\n    } else if (hasTimer()) {\n      _globalState.topEventLoop.activeTimerCount++;\n      void internalCallback() {\n        callback();\n        _handle = null;\n        _globalState.topEventLoop.activeTimerCount--;\n      }\n      _handle = JS('int', '#.setTimeout(#, #)',\n                   globalThis,\n                   convertDartClosureToJS(internalCallback, 0),\n                   milliseconds);\n    } else {\n      assert(milliseconds > 0);\n      throw new UnsupportedError(\"Timer greater than 0.\");\n    }\n  }\n\n  TimerImpl.periodic(int milliseconds, void callback(Timer timer))\n      : _once = false {\n    if (hasTimer()) {\n      _globalState.topEventLoop.activeTimerCount++;\n      _handle = JS('int', '#.setInterval(#, #)',\n                   globalThis,\n                   convertDartClosureToJS(() { callback(this); }, 0),\n                   milliseconds);\n    } else {\n      throw new UnsupportedError(\"Periodic timer.\");\n    }\n  }\n\n  void cancel() {\n    if (hasTimer()) {\n      if (_inEventLoop) {\n        throw new UnsupportedError(\"Timer in event loop cannot be canceled.\");\n      }\n      if (_handle == null) return;\n      _globalState.topEventLoop.activeTimerCount--;\n      if (_once) {\n        JS('void', '#.clearTimeout(#)', globalThis, _handle);\n      } else {\n        JS('void', '#.clearInterval(#)', globalThis, _handle);\n      }\n      _handle = null;\n    } else {\n      throw new UnsupportedError(\"Canceling a timer.\");\n    }\n  }\n}\n\nbool hasTimer() => JS('', '#.setTimeout', globalThis) != null;\n","sdk/lib/_internal/compiler/implementation/lib/isolate_patch.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Patch file for the dart:isolate library.\n\nimport 'dart:_isolate_helper' show IsolateNatives,\n                                   lazyPort,\n                                   ReceivePortImpl,\n                                   CloseToken,\n                                   JsIsolateSink;\n\npatch class _Isolate {\n  patch static ReceivePort get port {\n    if (lazyPort == null) {\n      lazyPort = new ReceivePort();\n    }\n    return lazyPort;\n  }\n\n  patch static SendPort spawnFunction(void topLevelFunction(),\n      [bool unhandledExceptionCallback(IsolateUnhandledException e)]) {\n    if (unhandledExceptionCallback != null) {\n      // TODO(9012): Implement the UnhandledExceptionCallback.\n      throw new UnimplementedError(\n          \"spawnFunction with unhandledExceptionCallback\");\n    }\n    return IsolateNatives.spawnFunction(topLevelFunction);\n  }\n\n  patch static SendPort spawnUri(String uri) {\n    return IsolateNatives.spawn(null, uri, false);\n  }\n}\n\npatch bool _isCloseToken(var object) {\n  return identical(object, const CloseToken());\n}\n\n/** Default factory for receive ports. */\npatch class ReceivePort {\n  patch factory ReceivePort() {\n    return new ReceivePortImpl();\n  }\n}\n\npatch class MessageBox {\n  patch MessageBox.oneShot() : this._oneShot(new ReceivePort());\n  MessageBox._oneShot(ReceivePort receivePort)\n      : stream = new IsolateStream._fromOriginalReceivePortOneShot(receivePort),\n        sink = new JsIsolateSink.fromPort(receivePort.toSendPort());\n\n  patch MessageBox() : this._(new ReceivePort());\n  MessageBox._(ReceivePort receivePort)\n      : stream = new IsolateStream._fromOriginalReceivePort(receivePort),\n        sink = new JsIsolateSink.fromPort(receivePort.toSendPort());\n}\n\npatch IsolateSink streamSpawnFunction(\n    void topLevelFunction(),\n    [bool unhandledExceptionCallback(IsolateUnhandledException e)]) {\n  SendPort sendPort = spawnFunction(topLevelFunction,\n                                    unhandledExceptionCallback);\n  return new JsIsolateSink.fromPort(sendPort);\n}\n","sdk/lib/_internal/compiler/implementation/lib/js_array.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _interceptors;\n\n/**\n * The interceptor class for [List]. The compiler recognizes this\n * class as an interceptor, and changes references to [:this:] to\n * actually use the receiver of the method, which is generated as an extra\n * argument added to each member.\n */\nclass JSArray<E> extends Interceptor implements List<E>, JSIndexable {\n  const JSArray();\n\n  void add(E value) {\n    checkGrowable(this, 'add');\n    JS('void', r'#.push(#)', this, value);\n  }\n\n  E removeAt(int index) {\n    if (index is !int) throw new ArgumentError(index);\n    if (index < 0 || index >= length) {\n      throw new RangeError.value(index);\n    }\n    checkGrowable(this, 'removeAt');\n    return JS('var', r'#.splice(#, 1)[0]', this, index);\n  }\n\n  void insert(int index, E value) {\n    if (index is !int) throw new ArgumentError(index);\n    if (index < 0 || index > length) {\n      throw new RangeError.value(index);\n    }\n    checkGrowable(this, 'insert');\n    JS('void', r'#.splice(#, 0, #)', this, index, value);\n  }\n\n  void insertAll(int index, Iterable<E> iterable) {\n    checkGrowable(this, 'insertAll');\n    IterableMixinWorkaround.insertAllList(this, index, iterable);\n  }\n\n  void setAll(int index, Iterable<E> iterable) {\n    checkMutable(this, 'setAll');\n    IterableMixinWorkaround.setAllList(this, index, iterable);\n  }\n\n  E removeLast() {\n    checkGrowable(this, 'removeLast');\n    if (length == 0) throw new RangeError.value(-1);\n    return JS('var', r'#.pop()', this);\n  }\n\n  bool remove(Object element) {\n    checkGrowable(this, 'remove');\n    for (int i = 0; i < this.length; i++) {\n      if (this[i] == element) {\n        JS('var', r'#.splice(#, 1)', this, i);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  void removeWhere(bool test(E element)) {\n    // This could, and should, be optimized.\n    IterableMixinWorkaround.removeWhereList(this, test);\n  }\n\n  void retainWhere(bool test(E element)) {\n    IterableMixinWorkaround.removeWhereList(this,\n                                            (E element) => !test(element));\n  }\n\n  Iterable<E> where(bool f(E element)) {\n    return IterableMixinWorkaround.where(this, f);\n  }\n\n  Iterable expand(Iterable f(E element)) {\n    return IterableMixinWorkaround.expand(this, f);\n  }\n\n  void addAll(Iterable<E> collection) {\n    for (E e in collection) {\n      this.add(e);\n    }\n  }\n\n  void clear() {\n    length = 0;\n  }\n\n  void forEach(void f(E element)) {\n    return IterableMixinWorkaround.forEach(this, f);\n  }\n\n  Iterable map(f(E element)) {\n    return IterableMixinWorkaround.mapList(this, f);\n  }\n\n  String join([String separator = \"\"]) {\n    var list = new List(this.length);\n    for (int i = 0; i < this.length; i++) {\n      list[i] = \"${this[i]}\";\n    }\n    return JS('String', \"#.join(#)\", list, separator);\n  }\n\n  Iterable<E> take(int n) {\n    return IterableMixinWorkaround.takeList(this, n);\n  }\n\n  Iterable<E> takeWhile(bool test(E value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<E> skip(int n) {\n    return IterableMixinWorkaround.skipList(this, n);\n  }\n\n  Iterable<E> skipWhile(bool test(E value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  E reduce(E combine(E value, E element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  fold(initialValue, combine(previousValue, E element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  E firstWhere(bool test(E value), {E orElse()}) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  E lastWhere(bool test(E value), {E orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  E singleWhere(bool test(E value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  E elementAt(int index) {\n    return this[index];\n  }\n\n  List<E> sublist(int start, [int end]) {\n    checkNull(start); // TODO(ahe): This is not specified but co19 tests it.\n    if (start is !int) throw new ArgumentError(start);\n    if (start < 0 || start > length) {\n      throw new RangeError.range(start, 0, length);\n    }\n    if (end == null) {\n      end = length;\n    } else {\n      if (end is !int) throw new ArgumentError(end);\n      if (end < start || end > length) {\n        throw new RangeError.range(end, start, length);\n      }\n    }\n    // TODO(ngeoffray): Parameterize the return value.\n    if (start == end) return [];\n    return JS('=List', r'#.slice(#, #)', this, start, end);\n  }\n\n\n  Iterable<E> getRange(int start, int end) {\n    return IterableMixinWorkaround.getRangeList(this, start, end);\n  }\n\n  E get first {\n    if (length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  E get last {\n    if (length > 0) return this[length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  E get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void removeRange(int start, int end) {\n    checkGrowable(this, 'removeRange');\n    int receiverLength = this.length;\n    if (start < 0 || start > receiverLength) {\n      throw new RangeError.range(start, 0, receiverLength);\n    }\n    if (end < start || end > receiverLength) {\n      throw new RangeError.range(end, start, receiverLength);\n    }\n    Arrays.copy(this,\n                end,\n                this,\n                start,\n                receiverLength - end);\n    this.length = receiverLength - (end - start);\n  }\n\n  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) {\n    checkMutable(this, 'set range');\n    IterableMixinWorkaround.setRangeList(this, start, end, iterable, skipCount);\n  }\n\n  void fillRange(int start, int end, [E fillValue]) {\n    checkMutable(this, 'fill range');\n    IterableMixinWorkaround.fillRangeList(this, start, end, fillValue);\n  }\n\n  void replaceRange(int start, int end, Iterable<E> iterable) {\n    checkGrowable(this, 'removeRange');\n    IterableMixinWorkaround.replaceRangeList(this, start, end, iterable);\n  }\n\n  bool any(bool f(E element)) => IterableMixinWorkaround.any(this, f);\n\n  bool every(bool f(E element)) => IterableMixinWorkaround.every(this, f);\n\n  Iterable<E> get reversed => IterableMixinWorkaround.reversedList(this);\n\n  void sort([int compare(E a, E b)]) {\n    checkMutable(this, 'sort');\n    IterableMixinWorkaround.sortList(this, compare);\n  }\n\n  int indexOf(E element, [int start = 0]) {\n    return IterableMixinWorkaround.indexOfList(this, element, start);\n  }\n\n  int lastIndexOf(E element, [int start]) {\n    return IterableMixinWorkaround.lastIndexOfList(this, element, start);\n  }\n\n  bool contains(E other) {\n    for (int i = 0; i < length; i++) {\n      if (other == this[i]) return true;\n    }\n    return false;\n  }\n\n  bool get isEmpty => length == 0;\n\n  String toString() => ToString.iterableToString(this);\n\n  List<E> toList({ bool growable: true }) =>\n      new List<E>.from(this, growable: growable);\n\n  Set<E> toSet() => new Set<E>.from(this);\n\n  Iterator<E> get iterator => new ListIterator<E>(this);\n\n  int get hashCode => Primitives.objectHashCode(this);\n\n  int get length => JS('int', r'#.length', this);\n\n  void set length(int newLength) {\n    if (newLength is !int) throw new ArgumentError(newLength);\n    if (newLength < 0) throw new RangeError.value(newLength);\n    checkGrowable(this, 'set length');\n    JS('void', r'#.length = #', this, newLength);\n  }\n\n  E operator [](int index) {\n    if (index is !int) throw new ArgumentError(index);\n    if (index >= length || index < 0) throw new RangeError.value(index);\n    return JS('var', '#[#]', this, index);\n  }\n\n  void operator []=(int index, E value) {\n    checkMutable(this, 'indexed set');\n    if (index is !int) throw new ArgumentError(index);\n    if (index >= length || index < 0) throw new RangeError.value(index);\n    JS('void', r'#[#] = #', this, index, value);\n  }\n\n  Map<int, E> asMap() {\n    return IterableMixinWorkaround.asMapList(this);\n  }\n}\n\n/**\n * Dummy subclasses that allow the backend to track more precise\n * information about arrays through their type.\n */\nclass JSMutableArray extends JSArray implements JSMutableIndexable {}\nclass JSFixedArray extends JSMutableArray {}\nclass JSExtendableArray extends JSMutableArray {}\n","sdk/lib/_internal/compiler/implementation/lib/js_helper.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary _js_helper;\n\nimport 'dart:collection';\nimport 'dart:_foreign_helper' show DART_CLOSURE_TO_JS,\n                                   JS,\n                                   JS_CALL_IN_ISOLATE,\n                                   JS_CURRENT_ISOLATE,\n                                   JS_DART_OBJECT_CONSTRUCTOR,\n                                   JS_OPERATOR_IS_PREFIX,\n                                   JS_OPERATOR_AS_PREFIX,\n                                   RAW_DART_FUNCTION_REF;\nimport 'dart:_interceptors' show getInterceptor,\n                                 interceptedNames,\n                                 dispatchPropertyName,\n                                 makeDispatchRecord,\n                                 setDispatchProperty,\n                                 Interceptor,\n                                 JSMutableIndexable;\nimport \"dart:_collection-dev\" as _symbol_dev;\n\npart 'constant_map.dart';\npart 'native_helper.dart';\npart 'regexp_helper.dart';\npart 'string_helper.dart';\npart 'js_rti.dart';\n\nbool isJsArray(var value) {\n  return value != null && JS('bool', r'(#.constructor === Array)', value);\n}\n\ncheckMutable(list, reason) {\n  if (JS('bool', r'!!(#.immutable$list)', list)) {\n    throw new UnsupportedError(reason);\n  }\n}\n\ncheckGrowable(list, reason) {\n  if (JS('bool', r'!!(#.fixed$length)', list)) {\n    throw new UnsupportedError(reason);\n  }\n}\n\nString S(value) {\n  if (value is String) return value;\n  if (value is num) {\n    if (value != 0) {\n      // \"\"+x is faster than String(x) for integers on most browsers.\n      return JS('String', r'\"\" + (#)', value);\n    }\n  } else if (true == value) {\n    return 'true';\n  } else if (false == value) {\n    return 'false';\n  } else if (value == null) {\n    return 'null';\n  }\n  var res = value.toString();\n  if (res is !String) throw new ArgumentError(value);\n  return res;\n}\n\ncreateInvocationMirror(name, internalName, type, arguments, argumentNames) {\n  return new JSInvocationMirror(new _symbol_dev.Symbol.unvalidated(name),\n                                internalName,\n                                type,\n                                arguments,\n                                argumentNames);\n}\n\nclass JSInvocationMirror implements Invocation {\n  static const METHOD = 0;\n  static const GETTER = 1;\n  static const SETTER = 2;\n\n  final Symbol memberName;\n  final String _internalName;\n  final int _kind;\n  final List _arguments;\n  final List _namedArgumentNames;\n  /** Map from argument name to index in _arguments. */\n  Map<String,dynamic> _namedIndices = null;\n\n  JSInvocationMirror(this.memberName,\n                     this._internalName,\n                     this._kind,\n                     this._arguments,\n                     this._namedArgumentNames);\n\n  bool get isMethod => _kind == METHOD;\n  bool get isGetter => _kind == GETTER;\n  bool get isSetter => _kind == SETTER;\n  bool get isAccessor => _kind != METHOD;\n\n  List get positionalArguments {\n    if (isGetter) return null;\n    var list = [];\n    var argumentCount =\n        _arguments.length - _namedArgumentNames.length;\n    for (var index = 0 ; index < argumentCount ; index++) {\n      list.add(_arguments[index]);\n    }\n    return list;\n  }\n\n  Map<Symbol,dynamic> get namedArguments {\n    if (isAccessor) return null;\n    var map = new Map<Symbol, dynamic>();\n    int namedArgumentCount = _namedArgumentNames.length;\n    int namedArgumentsStartIndex = _arguments.length - namedArgumentCount;\n    for (int i = 0; i < namedArgumentCount; i++) {\n      map[new _symbol_dev.Symbol.unvalidated(_namedArgumentNames[i])] =\n          _arguments[namedArgumentsStartIndex + i];\n    }\n    return map;\n  }\n\n  _invokeOn(Object object) {\n    var interceptor = getInterceptor(object);\n    var receiver = object;\n    var name = _internalName;\n    var arguments = _arguments;\n    // TODO(ngeoffray): If this functionality ever become performance\n    // critical, we might want to dynamically change [interceptedNames]\n    // to be a JavaScript object with intercepted names as property\n    // instead of a JavaScript array.\n    if (JS('int', '#.indexOf(#)', interceptedNames, name) == -1) {\n      if (!isJsArray(arguments)) arguments = new List.from(arguments);\n    } else {\n      arguments = [object]..addAll(arguments);\n      receiver = interceptor;\n    }\n    return JS(\"var\", \"#[#].apply(#, #)\", receiver, name, receiver, arguments);\n  }\n\n  /// This method is called by [InstanceMirror.delegate].\n  static invokeFromMirror(JSInvocationMirror invocation, victim) {\n    return invocation._invokeOn(victim);\n  }\n}\n\nclass Primitives {\n  static int hashCodeSeed = 0;\n\n  static int objectHashCode(object) {\n    int hash = JS('var', r'#.$identityHash', object);\n    if (hash == null) {\n      // TOOD(ahe): We should probably randomize this somehow.\n      hash = ++hashCodeSeed;\n      JS('void', r'#.$identityHash = #', object, hash);\n    }\n    return hash;\n  }\n\n  /**\n   * This is the low-level method that is used to implement\n   * [print]. It is possible to override this function from JavaScript\n   * by defining a function in JavaScript called \"dartPrint\".\n   */\n  static void printString(String string) {\n    if (JS('bool', r'typeof dartPrint == \"function\"')) {\n      // Support overriding print from JavaScript.\n      JS('void', r'dartPrint(#)', string);\n      return;\n    }\n\n    // Inside browser.\n    if (JS('bool', r'typeof window == \"object\"')) {\n      // On IE, the console is only defined if dev tools is open.\n      if (JS('bool', r'typeof console == \"object\"')) {\n        JS('void', r'console.log(#)', string);\n      }\n      return;\n    }\n\n    // Running in d8, the V8 developer shell, or in Firefox' js-shell.\n    if (JS('bool', r'typeof print == \"function\"')) {\n      JS('void', r'print(#)', string);\n      return;\n    }\n\n    // This is somewhat nasty, but we don't want to drag in a bunch of\n    // dependencies to handle a situation that cannot happen. So we\n    // avoid using Dart [:throw:] and Dart [toString].\n    JS('void', 'throw \"Unable to print message: \" + String(#)', string);\n  }\n\n  static void _throwFormatException(String string) {\n    throw new FormatException(string);\n  }\n\n  static int parseInt(String source,\n                      int radix,\n                      int handleError(String source)) {\n    if (handleError == null) handleError = _throwFormatException;\n\n    checkString(source);\n    var match = JS('=List|Null',\n        r'/^\\s*[+-]?((0x[a-f0-9]+)|(\\d+)|([a-z0-9]+))\\s*$/i.exec(#)',\n        source);\n    int digitsIndex = 1;\n    int hexIndex = 2;\n    int decimalIndex = 3;\n    int nonDecimalHexIndex = 4;\n    if (radix == null) {\n      radix = 10;\n      if (match != null) {\n        if (match[hexIndex] != null) {\n          // Cannot fail because we know that the digits are all hex.\n          return JS('num', r'parseInt(#, 16)', source);\n        }\n        if (match[decimalIndex] != null) {\n          // Cannot fail because we know that the digits are all decimal.\n          return JS('num', r'parseInt(#, 10)', source);\n        }\n        return handleError(source);\n      }\n    } else {\n      if (radix is! int) throw new ArgumentError(\"Radix is not an integer\");\n      if (radix < 2 || radix > 36) {\n        throw new RangeError(\"Radix $radix not in range 2..36\");\n      }\n      if (match != null) {\n        if (radix == 10 && match[decimalIndex] != null) {\n          // Cannot fail because we know that the digits are all decimal.\n          return JS('num', r'parseInt(#, 10)', source);\n        }\n        if (radix < 10 || match[decimalIndex] == null) {\n          // We know that the characters must be ASCII as otherwise the\n          // regexp wouldn't have matched. Calling toLowerCase is thus\n          // guaranteed to be a safe operation. If it wasn't ASCII, then\n          // \"\" would become \"i\", and we would accept it for radices greater\n          // than 18.\n          int maxCharCode;\n          if (radix <= 10) {\n            // Allow all digits less than the radix. For example 0, 1, 2 for\n            // radix 3.\n            // \"0\".codeUnitAt(0) + radix - 1;\n            maxCharCode = 0x30 + radix - 1;\n          } else {\n            // Characters are located after the digits in ASCII. Therefore we\n            // only check for the character code. The regexp above made already\n            // sure that the string does not contain anything but digits or\n            // characters.\n            // \"0\".codeUnitAt(0) + radix - 1;\n            maxCharCode = 0x61 + radix - 10 - 1;\n          }\n          String digitsPart = match[digitsIndex].toLowerCase();\n          for (int i = 0; i < digitsPart.length; i++) {\n            if (digitsPart.codeUnitAt(i) > maxCharCode) {\n              return handleError(source);\n            }\n          }\n        }\n      }\n    }\n    if (match == null) return handleError(source);\n    return JS('num', r'parseInt(#, #)', source, radix);\n  }\n\n  static double parseDouble(String source, int handleError(String source)) {\n    checkString(source);\n    if (handleError == null) handleError = _throwFormatException;\n    // Notice that JS parseFloat accepts garbage at the end of the string.\n    // Accept only:\n    // - NaN\n    // - [+/-]Infinity\n    // - a Dart double literal\n    // We do not allow leading or trailing whitespace.\n    if (!JS('bool',\n            r'/^\\s*(?:NaN|[+-]?(?:Infinity|'\n                r'(?:\\.\\d+|\\d+(?:\\.\\d+)?)(?:[eE][+-]?\\d+)?))\\s*$/.test(#)',\n            source)) {\n      return handleError(source);\n    }\n    var result = JS('num', r'parseFloat(#)', source);\n    if (result.isNaN && source != 'NaN') {\n      return handleError(source);\n    }\n    return result;\n  }\n\n  /** [: r\"$\".codeUnitAt(0) :] */\n  static const int DOLLAR_CHAR_VALUE = 36;\n\n  static String objectTypeName(Object object) {\n    String name = constructorNameFallback(object);\n    if (name == 'Object') {\n      // Try to decompile the constructor by turning it into a string\n      // and get the name out of that. If the decompiled name is a\n      // string, we use that instead of the very generic 'Object'.\n      var decompiled = JS('var', r'#.match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1]',\n                          JS('var', r'String(#.constructor)', object));\n      if (decompiled is String) name = decompiled;\n    }\n    // TODO(kasperl): If the namer gave us a fresh global name, we may\n    // want to remove the numeric suffix that makes it unique too.\n    if (identical(name.codeUnitAt(0), DOLLAR_CHAR_VALUE)) name = name.substring(1);\n    return name;\n  }\n\n  static String objectToString(Object object) {\n    String name = objectTypeName(object);\n    return \"Instance of '$name'\";\n  }\n\n  static List newGrowableList(length) {\n    return JS('=List', r'new Array(#)', length);\n  }\n\n  static List newFixedList(length) {\n    var result = JS('=List', r'new Array(#)', length);\n    JS('void', r'#.fixed$length = #', result, true);\n    return result;\n  }\n\n  static num dateNow() => JS('num', r'Date.now()');\n\n  static num numMicroseconds() {\n    if (JS('bool', 'typeof window != \"undefined\" && window !== null')) {\n      var performance = JS('var', 'window.performance');\n      if (performance != null &&\n          JS('bool', 'typeof #.webkitNow == \"function\"', performance)) {\n        return (1000 * JS('num', '#.webkitNow()', performance)).floor();\n      }\n    }\n    return 1000 * dateNow();\n  }\n\n  // This is to avoid stack overflows due to very large argument arrays in\n  // apply().  It fixes http://dartbug.com/6919\n  static String _fromCharCodeApply(List<int> array) {\n    String result = \"\";\n    const kMaxApply = 500;\n    int end = array.length;\n    for (var i = 0; i < end; i += kMaxApply) {\n      var subarray;\n      if (end <= kMaxApply) {\n        subarray = array;\n      } else {\n        subarray = JS('=List', r'#.slice(#, #)', array,\n                      i, i + kMaxApply < end ? i + kMaxApply : end);\n      }\n      result = JS('String', '# + String.fromCharCode.apply(#, #)',\n                  result, null, subarray);\n    }\n    return result;\n  }\n\n  static String stringFromCodePoints(codePoints) {\n    List<int> a = <int>[];\n    for (var i in codePoints) {\n      if (i is !int) throw new ArgumentError(i);\n      if (i <= 0xffff) {\n        a.add(i);\n      } else if (i <= 0x10ffff) {\n        a.add(0xd800 + ((((i - 0x10000) >> 10) & 0x3ff)));\n        a.add(0xdc00 + (i & 0x3ff));\n      } else {\n        throw new ArgumentError(i);\n      }\n    }\n    return _fromCharCodeApply(a);\n  }\n\n  static String stringFromCharCodes(charCodes) {\n    for (var i in charCodes) {\n      if (i is !int) throw new ArgumentError(i);\n      if (i < 0) throw new ArgumentError(i);\n      if (i > 0xffff) return stringFromCodePoints(charCodes);\n    }\n    return _fromCharCodeApply(charCodes);\n  }\n\n  static String stringConcatUnchecked(String string1, String string2) {\n    return JS('String', r'# + #', string1, string2);\n  }\n\n  static String getTimeZoneName(receiver) {\n    // When calling toString on a Date it will emit the timezone in parenthesis.\n    // Example: \"Wed May 16 2012 21:13:00 GMT+0200 (CEST)\".\n    // We extract this name using a regexp.\n    var d = lazyAsJsDate(receiver);\n    return JS('String', r'/\\((.*)\\)/.exec(#.toString())[1]', d);\n  }\n\n  static int getTimeZoneOffsetInMinutes(receiver) {\n    // Note that JS and Dart disagree on the sign of the offset.\n    return -JS('int', r'#.getTimezoneOffset()', lazyAsJsDate(receiver));\n  }\n\n  static valueFromDecomposedDate(years, month, day, hours, minutes, seconds,\n                                 milliseconds, isUtc) {\n    final int MAX_MILLISECONDS_SINCE_EPOCH = 8640000000000000;\n    checkInt(years);\n    checkInt(month);\n    checkInt(day);\n    checkInt(hours);\n    checkInt(minutes);\n    checkInt(seconds);\n    checkInt(milliseconds);\n    checkBool(isUtc);\n    var jsMonth = month - 1;\n    var value;\n    if (isUtc) {\n      value = JS('num', r'Date.UTC(#, #, #, #, #, #, #)',\n                 years, jsMonth, day, hours, minutes, seconds, milliseconds);\n    } else {\n      value = JS('num', r'new Date(#, #, #, #, #, #, #).valueOf()',\n                 years, jsMonth, day, hours, minutes, seconds, milliseconds);\n    }\n    if (value.isNaN ||\n        value < -MAX_MILLISECONDS_SINCE_EPOCH ||\n        value > MAX_MILLISECONDS_SINCE_EPOCH) {\n      throw new ArgumentError();\n    }\n    if (years <= 0 || years < 100) return patchUpY2K(value, years, isUtc);\n    return value;\n  }\n\n  static patchUpY2K(value, years, isUtc) {\n    var date = JS('', r'new Date(#)', value);\n    if (isUtc) {\n      JS('num', r'#.setUTCFullYear(#)', date, years);\n    } else {\n      JS('num', r'#.setFullYear(#)', date, years);\n    }\n    return JS('num', r'#.valueOf()', date);\n  }\n\n  // Lazily keep a JS Date stored in the JS object.\n  static lazyAsJsDate(receiver) {\n    if (JS('bool', r'#.date === (void 0)', receiver)) {\n      JS('void', r'#.date = new Date(#)', receiver,\n         receiver.millisecondsSinceEpoch);\n    }\n    return JS('var', r'#.date', receiver);\n  }\n\n  // The getters for date and time parts below add a positive integer to ensure\n  // that the result is really an integer, because the JavaScript implementation\n  // may return -0.0 instead of 0.\n\n  static getYear(receiver) {\n    return (receiver.isUtc)\n      ? JS('int', r'(#.getUTCFullYear() + 0)', lazyAsJsDate(receiver))\n      : JS('int', r'(#.getFullYear() + 0)', lazyAsJsDate(receiver));\n  }\n\n  static getMonth(receiver) {\n    return (receiver.isUtc)\n      ? JS('int', r'#.getUTCMonth() + 1', lazyAsJsDate(receiver))\n      : JS('int', r'#.getMonth() + 1', lazyAsJsDate(receiver));\n  }\n\n  static getDay(receiver) {\n    return (receiver.isUtc)\n      ? JS('int', r'(#.getUTCDate() + 0)', lazyAsJsDate(receiver))\n      : JS('int', r'(#.getDate() + 0)', lazyAsJsDate(receiver));\n  }\n\n  static getHours(receiver) {\n    return (receiver.isUtc)\n      ? JS('int', r'(#.getUTCHours() + 0)', lazyAsJsDate(receiver))\n      : JS('int', r'(#.getHours() + 0)', lazyAsJsDate(receiver));\n  }\n\n  static getMinutes(receiver) {\n    return (receiver.isUtc)\n      ? JS('int', r'(#.getUTCMinutes() + 0)', lazyAsJsDate(receiver))\n      : JS('int', r'(#.getMinutes() + 0)', lazyAsJsDate(receiver));\n  }\n\n  static getSeconds(receiver) {\n    return (receiver.isUtc)\n      ? JS('int', r'(#.getUTCSeconds() + 0)', lazyAsJsDate(receiver))\n      : JS('int', r'(#.getSeconds() + 0)', lazyAsJsDate(receiver));\n  }\n\n  static getMilliseconds(receiver) {\n    return (receiver.isUtc)\n      ? JS('int', r'(#.getUTCMilliseconds() + 0)', lazyAsJsDate(receiver))\n      : JS('int', r'(#.getMilliseconds() + 0)', lazyAsJsDate(receiver));\n  }\n\n  static getWeekday(receiver) {\n    int weekday = (receiver.isUtc)\n      ? JS('int', r'#.getUTCDay() + 0', lazyAsJsDate(receiver))\n      : JS('int', r'#.getDay() + 0', lazyAsJsDate(receiver));\n    // Adjust by one because JS weeks start on Sunday.\n    return (weekday + 6) % 7 + 1;\n  }\n\n  static valueFromDateString(str) {\n    if (str is !String) throw new ArgumentError(str);\n    var value = JS('num', r'Date.parse(#)', str);\n    if (value.isNaN) throw new ArgumentError(str);\n    return value;\n  }\n\n  static getProperty(object, key) {\n    if (object == null || object is bool || object is num || object is String) {\n      throw new ArgumentError(object);\n    }\n    return JS('var', '#[#]', object, key);\n  }\n\n  static void setProperty(object, key, value) {\n    if (object == null || object is bool || object is num || object is String) {\n      throw new ArgumentError(object);\n    }\n    JS('void', '#[#] = #', object, key, value);\n  }\n\n  static applyFunction(Function function,\n                       List positionalArguments,\n                       Map<Symbol, dynamic> namedArguments) {\n    int argumentCount = 0;\n    StringBuffer buffer = new StringBuffer();\n    List arguments = [];\n\n    if (positionalArguments != null) {\n      argumentCount += positionalArguments.length;\n      arguments.addAll(positionalArguments);\n    }\n\n    // Sort the named arguments to get the right selector name and\n    // arguments order.\n    if (namedArguments != null && !namedArguments.isEmpty) {\n      // Call new List.from to make sure we get a JavaScript array.\n      List<String> listOfNamedArguments =\n          new List<String>.from(namedArguments.keys);\n      argumentCount += namedArguments.length;\n      // We're sorting on strings, and the behavior is the same between\n      // Dart string sort and JS string sort. To avoid needing the Dart\n      // sort implementation, we use the JavaScript one instead.\n      JS('void', '#.sort()', listOfNamedArguments);\n      listOfNamedArguments.forEach((String name) {\n        buffer.write('\\$$name');\n        arguments.add(namedArguments[name]);\n      });\n    }\n\n    String selectorName = 'call\\$$argumentCount$buffer';\n    var jsFunction = JS('var', '#[#]', function, selectorName);\n    if (jsFunction == null) {\n      throw new NoSuchMethodError(function, selectorName, arguments, {});\n    }\n    // We bound 'this' to [function] because of how we compile\n    // closures: escaped local variables are stored and accessed through\n    // [function].\n    return JS('var', '#.apply(#, #)', jsFunction, function, arguments);\n  }\n\n  static getConstructor(String className) {\n    // TODO(ahe): How to safely access $?\n    return JS('var', r'$[#]', className);\n  }\n\n  static bool identicalImplementation(a, b) {\n    return JS('bool', '# == null', a)\n      ? JS('bool', '# == null', b)\n      : JS('bool', '# === #', a, b);\n  }\n}\n\n/**\n * Called by generated code to throw an illegal-argument exception,\n * for example, if a non-integer index is given to an optimized\n * indexed access.\n */\niae(argument) {\n  throw new ArgumentError(argument);\n}\n\n/**\n * Called by generated code to throw an index-out-of-range exception,\n * for example, if a bounds check fails in an optimized indexed\n * access.  This may also be called when the index is not an integer, in\n * which case it throws an illegal-argument exception instead, like [iae].\n */\nioore(index) {\n  if (index is !int) iae(index);\n  throw new RangeError.value(index);\n}\n\nstringLastIndexOfUnchecked(receiver, element, start)\n  => JS('int', r'#.lastIndexOf(#, #)', receiver, element, start);\n\n\ncheckNull(object) {\n  if (object == null) throw new ArgumentError(null);\n  return object;\n}\n\ncheckNum(value) {\n  if (value is !num) {\n    throw new ArgumentError(value);\n  }\n  return value;\n}\n\ncheckInt(value) {\n  if (value is !int) {\n    throw new ArgumentError(value);\n  }\n  return value;\n}\n\ncheckBool(value) {\n  if (value is !bool) {\n    throw new ArgumentError(value);\n  }\n  return value;\n}\n\ncheckString(value) {\n  if (value is !String) {\n    throw new ArgumentError(value);\n  }\n  return value;\n}\n\n/**\n * Wrap the given Dart object and record a stack trace.\n *\n * The code in [unwrapException] deals with getting the original Dart\n * object out of the wrapper again.\n */\nwrapException(ex) {\n  if (ex == null) ex = const NullThrownError();\n  var wrapper = new DartError(ex);\n\n  if (JS('bool', '!!Error.captureStackTrace')) {\n    // Use V8 API for recording a \"fast\" stack trace (this installs a\n    // \"stack\" property getter on [wrapper]).\n    JS('void', r'Error.captureStackTrace(#, #)',\n       wrapper, RAW_DART_FUNCTION_REF(wrapException));\n  } else {\n    // Otherwise, produce a stack trace and record it in the wrapper.\n    // This is a slower way to create a stack trace which works on\n    // some browsers, but may simply evaluate to null.\n    String stackTrace = JS('', 'new Error().stack');\n    JS('void', '#.stack = #', wrapper, stackTrace);\n  }\n  return wrapper;\n}\n\n/**\n * This wraps the exception and does the throw.  It is possible to call this in\n * a JS expression context, where the throw statement is not allowed.  Helpers\n * are never inlined, so we don't risk inlining the throw statement into an\n * expression context.\n */\nthrowExpression(ex) {\n  JS('void', 'throw #', wrapException(ex));\n}\n\n/**\n * Wrapper class for throwing exceptions.\n */\nclass DartError {\n  /// The Dart object (or primitive JavaScript value) which was thrown is\n  /// attached to this object as a field named 'dartException'.  We do this\n  /// only in raw JS so that we can use the 'in' operator and so that the\n  /// minifier does not rename the field.  Therefore it is not declared as a\n  /// real field.\n\n  DartError(var dartException) {\n    JS('void', '#.dartException = #', this, dartException);\n    // Install a toString method that the JavaScript system will call\n    // to format uncaught exceptions.\n    JS('void', '#.toString = #', this, DART_CLOSURE_TO_JS(toStringWrapper));\n  }\n\n  /**\n   * V8/Chrome installs a property getter, \"stack\", when calling\n   * Error.captureStackTrace (see [wrapException]). In [wrapException], we make\n   * sure that this property is always set.\n   */\n  String get stack => JS('', '#.stack', this);\n\n  /**\n   * This method can be invoked by calling toString from\n   * JavaScript. See the constructor of this class.\n   *\n   * We only expect this method to be called (indirectly) by the\n   * browser when an uncaught exception occurs. Instance of this class\n   * should never escape into Dart code (except for [wrapException] above).\n   */\n  String toString() {\n    // If Error.captureStackTrace is available, accessing stack from\n    // this method would cause recursion because the stack property\n    // (on this object) is actually a getter which calls toString on\n    // this object (via the wrapper installed in this class'\n    // constructor). Fortunately, both Chrome and d8 prints the stack\n    // trace and Chrome even applies source maps to the stack\n    // trace. Remeber, this method is only ever invoked by the browser\n    // when an uncaught exception occurs.\n    var dartException = JS('var', r'#.dartException', this);\n    if (JS('bool', '!!Error.captureStackTrace') || (stack == null)) {\n      return dartException.toString();\n    } else {\n      return '$dartException\\n$stack';\n    }\n  }\n\n  /**\n   * This method is installed as JavaScript toString method on\n   * [DartError].  So JavaScript 'this' binds to an instance of\n   * DartError.\n   */\n  static toStringWrapper() => JS('', r'this').toString();\n}\n\nmakeLiteralListConst(list) {\n  JS('bool', r'#.immutable$list = #', list, true);\n  JS('bool', r'#.fixed$length = #', list, true);\n  return list;\n}\n\nthrowRuntimeError(message) {\n  throw new RuntimeError(message);\n}\n\n/**\n * The SSA builder generates a call to this method when a malformed type is used\n * in a subtype test.\n */\nthrowMalformedSubtypeError(value, type, reasons) {\n  throw new TypeErrorImplementation.malformedSubtype(value, type, reasons);\n}\n\nthrowAbstractClassInstantiationError(className) {\n  throw new AbstractClassInstantiationError(className);\n}\n\n/**\n * Called from catch blocks in generated code to extract the Dart\n * exception from the thrown value. The thrown value may have been\n * created by [wrapException] or it may be a 'native' JS exception.\n *\n * Some native exceptions are mapped to new Dart instances, others are\n * returned unmodified.\n */\nunwrapException(ex) {\n  // Note that we are checking if the object has the property. If it\n  // has, it could be set to null if the thrown value is null.\n  if (JS('bool', r'\"dartException\" in #', ex)) {\n    return JS('', r'#.dartException', ex);\n  }\n\n  // Grab hold of the exception message. This field is available on\n  // all supported browsers.\n  var message = JS('var', r'#.message', ex);\n\n  if (JS('bool', r'# instanceof TypeError', ex)) {\n    // The type and arguments fields are Chrome specific but they\n    // allow us to get very detailed information about what kind of\n    // exception occurred.\n    var type = JS('var', r'#.type', ex);\n    var name = JS('var', r'#.arguments ? #.arguments[0] : \"\"', ex, ex);\n    if (contains(message, 'JSNull') ||\n        type == 'property_not_function' ||\n        type == 'called_non_callable' ||\n        type == 'non_object_property_call' ||\n        type == 'non_object_property_load') {\n      return new NoSuchMethodError(null, name, [], {});\n    } else if (type == 'undefined_method') {\n      return new NoSuchMethodError('', name, [], {});\n    }\n\n    var ieErrorCode = JS('int', '#.number & 0xffff', ex);\n    var ieFacilityNumber = JS('int', '#.number>>16 & 0x1FFF', ex);\n    // If we cannot use [type] to determine what kind of exception\n    // we're dealing with we fall back on looking at the exception\n    // message if it is available and a string.\n    if (message is String) {\n      if (message == 'null has no properties' ||\n          message == \"'null' is not an object\" ||\n          message == \"'undefined' is not an object\" ||\n          message.endsWith('is null') ||\n          message.endsWith('is undefined') ||\n          message.endsWith('is null or undefined') ||\n          message.endsWith('of undefined') ||\n          message.endsWith('of null')) {\n        return new NoSuchMethodError(null, message, [], {});\n      } else if (contains(message, ' has no method ') ||\n                 contains(message, ' is not a function') ||\n                 (ieErrorCode == 438 && ieFacilityNumber == 10)) {\n        // Examples:\n        //  x.foo is not a function\n        //  'undefined' is not a function (evaluating 'x.foo(1,2,3)')\n        // Object doesn't support property or method 'foo' which sets the error\n        // code 438 in IE.\n        // TODO(kasperl): Compute the right name if possible.\n        return new NoSuchMethodError('', message, [], {});\n      }\n    }\n\n    // If we cannot determine what kind of error this is, we fall back\n    // to reporting this as a generic exception. It's probably better\n    // than nothing.\n    return new Exception(message is String ? message : '');\n  }\n\n  if (JS('bool', r'# instanceof RangeError', ex)) {\n    if (message is String && contains(message, 'call stack')) {\n      return new StackOverflowError();\n    }\n\n    // In general, a RangeError is thrown when trying to pass a number\n    // as an argument to a function that does not allow a range that\n    // includes that number.\n    return new ArgumentError();\n  }\n\n  // Check for the Firefox specific stack overflow signal.\n  if (JS('bool',\n         r'typeof InternalError == \"function\" && # instanceof InternalError',\n         ex)) {\n    if (message is String && message == 'too much recursion') {\n      return new StackOverflowError();\n    }\n  }\n\n  if (isBackedByNativeClass(ex)) {\n    // Just return the exception. We should not wrap it because in case\n    // the exception comes from the DOM, it is a JavaScript\n    // object backed by a native Dart class.\n    return ex;\n  } else {\n    return new Exception(JS(\"String\", \"String(#)\", ex));\n  }\n}\n\nisBackedByNativeClass(exception) {\n  // TODO(ahe): Find a better way to determine if [ex] is backed by\n  // a native Dart class.\n  bool threw = true;\n  try {\n    var result = exception.toString != null;\n    threw = false;\n    return result;\n  } finally {\n    if (threw) return false;\n  }\n  return false; // Cannot happen.\n}\n\n/**\n * Called by generated code to fetch the stack trace from an\n * exception.\n */\nStackTrace getTraceFromException(exception) {\n  return new _StackTrace(JS(\"var\", r\"#.stack\", exception));\n}\n\nclass _StackTrace implements StackTrace {\n  var _stack;\n  _StackTrace(this._stack);\n  String toString() => _stack != null ? _stack : '';\n}\n\n\n/**\n * Called by generated code to build a map literal. [keyValuePairs] is\n * a list of key, value, key, value, ..., etc.\n */\nmakeLiteralMap(List keyValuePairs) {\n  Iterator iterator = keyValuePairs.iterator;\n  Map result = new LinkedHashMap();\n  while (iterator.moveNext()) {\n    String key = iterator.current;\n    iterator.moveNext();\n    var value = iterator.current;\n    result[key] = value;\n  }\n  return result;\n}\n\ninvokeClosure(Function closure,\n              var isolate,\n              int numberOfArguments,\n              var arg1,\n              var arg2) {\n  if (numberOfArguments == 0) {\n    return JS_CALL_IN_ISOLATE(isolate, () => closure());\n  } else if (numberOfArguments == 1) {\n    return JS_CALL_IN_ISOLATE(isolate, () => closure(arg1));\n  } else if (numberOfArguments == 2) {\n    return JS_CALL_IN_ISOLATE(isolate, () => closure(arg1, arg2));\n  } else {\n    throw new Exception(\n        'Unsupported number of arguments for wrapped closure');\n  }\n}\n\n/**\n * Called by generated code to convert a Dart closure to a JS\n * closure when the Dart closure is passed to the DOM.\n */\nconvertDartClosureToJS(closure, int arity) {\n  if (closure == null) return null;\n  var function = JS('var', r'#.$identity', closure);\n  if (JS('bool', r'!!#', function)) return function;\n\n  // We use $0 and $1 to not clash with variable names used by the\n  // compiler and/or minifier.\n  function = JS('var',\n                r'(function ($2, $3) {'\n                    r' return function($0, $1) { '\n                        r'return $3(#, $2, #, $0, $1) }})(#, #)',\n                closure,\n                arity,\n                // Capture the current isolate now.  Remember that \"#\"\n                // in JS is simply textual substitution of compiled\n                // expressions.\n                JS_CURRENT_ISOLATE(),\n                DART_CLOSURE_TO_JS(invokeClosure));\n\n  JS('void', r'#.$identity = #', closure, function);\n  return function;\n}\n\n/**\n * Super class for Dart closures.\n */\nclass Closure implements Function {\n  String toString() => \"Closure\";\n}\n\nbool jsHasOwnProperty(var jsObject, String property) {\n  return JS('bool', r'#.hasOwnProperty(#)', jsObject, property);\n}\n\njsPropertyAccess(var jsObject, String property) {\n  return JS('var', r'#[#]', jsObject, property);\n}\n\n/**\n * Called at the end of unaborted switch cases to get the singleton\n * FallThroughError exception that will be thrown.\n */\ngetFallThroughError() => const FallThroughErrorImplementation();\n\n/**\n * Represents the type dynamic. The compiler treats this specially.\n */\nabstract class Dynamic_ {\n}\n\n/**\n * A metadata annotation describing the types instantiated by a native element.\n *\n * The annotation is valid on a native method and a field of a native class.\n *\n * By default, a field of a native class is seen as an instantiation point for\n * all native classes that are a subtype of the field's type, and a native\n * method is seen as an instantiation point fo all native classes that are a\n * subtype of the method's return type, or the argument types of the declared\n * type of the method's callback parameter.\n *\n * An @[Creates] annotation overrides the default set of instantiated types.  If\n * one or more @[Creates] annotations are present, the type of the native\n * element is ignored, and the union of @[Creates] annotations is used instead.\n * The names in the strings are resolved and the program will fail to compile\n * with dart2js if they do not name types.\n *\n * The argument to [Creates] is a string.  The string is parsed as the names of\n * one or more types, separated by vertical bars `|`.  There are some special\n * names:\n *\n * * `=List`. This means 'exactly List', which is the JavaScript Array\n *   implementation of [List] and no other implementation.\n *\n * * `=Object`. This means 'exactly Object', which is a plain JavaScript object\n *   with properties and none of the subtypes of Object.\n *\n * Example: we may know that a method always returns a specific implementation:\n *\n *     @Creates('_NodeList')\n *     List<Node> getElementsByTagName(String tag) native;\n *\n * Useful trick: A method can be marked as not instantiating any native classes\n * with the annotation `@Creates('Null')`.  This is useful for fields on native\n * classes that are used only in Dart code.\n *\n *     @Creates('Null')\n *     var _cachedFoo;\n */\nclass Creates {\n  final String types;\n  const Creates(this.types);\n}\n\n/**\n * A metadata annotation describing the types returned or yielded by a native\n * element.\n *\n * The annotation is valid on a native method and a field of a native class.\n *\n * By default, a native method or field is seen as returning or yielding all\n * subtypes if the method return type or field type.  This annotation allows a\n * more precise set of types to be specified.\n *\n * See [Creates] for the syntax of the argument.\n *\n * Example: IndexedDB keys are numbers, strings and JavaScript Arrays of keys.\n *\n *     @Returns('String|num|=List')\n *     dynamic key;\n *\n *     // Equivalent:\n *     @Returns('String') @Returns('num') @Returns('=List')\n *     dynamic key;\n */\nclass Returns {\n  final String types;\n  const Returns(this.types);\n}\n\n/**\n * A metadata annotation placed on native methods and fields of native classes\n * to specify the JavaScript name.\n *\n * This example declares a Dart field + getter + setter called `$dom_title` that\n * corresponds to the JavaScript property `title`.\n *\n *     class Docmument native \"*Foo\" {\n *       @JSName('title')\n *       String $dom_title;\n *     }\n */\nclass JSName {\n  final String name;\n  const JSName(this.name);\n}\n\n/**\n * Represents the type of Null. The compiler treats this specially.\n * TODO(lrn): Null should be defined in core. It's a class, like int.\n * It just happens to act differently in assignability tests and,\n * like int, can't be extended or implemented.\n */\nclass Null {\n  factory Null() {\n    throw new UnsupportedError('new Null()');\n  }\n}\n\n/**\n * The following methods are called by the runtime to implement\n * checked mode and casts. We specialize each primitive type (eg int, bool), and\n * use the compiler's convention to do is-checks on regular objects.\n */\nboolConversionCheck(value) {\n  boolTypeCheck(value);\n  assert(value != null);\n  return value;\n}\n\nstringTypeCheck(value) {\n  if (value == null) return value;\n  if (value is String) return value;\n  throw new TypeErrorImplementation(value, 'String');\n}\n\nstringTypeCast(value) {\n  if (value is String || value == null) return value;\n  // TODO(lrn): When reified types are available, pass value.class and String.\n  throw new CastErrorImplementation(\n      Primitives.objectTypeName(value), 'String');\n}\n\ndoubleTypeCheck(value) {\n  if (value == null) return value;\n  if (value is double) return value;\n  throw new TypeErrorImplementation(value, 'double');\n}\n\ndoubleTypeCast(value) {\n  if (value is double || value == null) return value;\n  throw new CastErrorImplementation(\n      Primitives.objectTypeName(value), 'double');\n}\n\nnumTypeCheck(value) {\n  if (value == null) return value;\n  if (value is num) return value;\n  throw new TypeErrorImplementation(value, 'num');\n}\n\nnumTypeCast(value) {\n  if (value is num || value == null) return value;\n  throw new CastErrorImplementation(\n      Primitives.objectTypeName(value), 'num');\n}\n\nboolTypeCheck(value) {\n  if (value == null) return value;\n  if (value is bool) return value;\n  throw new TypeErrorImplementation(value, 'bool');\n}\n\nboolTypeCast(value) {\n  if (value is bool || value == null) return value;\n  throw new CastErrorImplementation(\n      Primitives.objectTypeName(value), 'bool');\n}\n\nfunctionTypeCheck(value) {\n  if (value == null) return value;\n  if (value is Function) return value;\n  throw new TypeErrorImplementation(value, 'Function');\n}\n\nfunctionTypeCast(value) {\n  if (value is Function || value == null) return value;\n  throw new CastErrorImplementation(\n      Primitives.objectTypeName(value), 'Function');\n}\n\nintTypeCheck(value) {\n  if (value == null) return value;\n  if (value is int) return value;\n  throw new TypeErrorImplementation(value, 'int');\n}\n\nintTypeCast(value) {\n  if (value is int || value == null) return value;\n  throw new CastErrorImplementation(\n      Primitives.objectTypeName(value), 'int');\n}\n\nvoid propertyTypeError(value, property) {\n  // Cuts the property name to the class name.\n  String name = property.substring(3, property.length);\n  throw new TypeErrorImplementation(value, name);\n}\n\nvoid propertyTypeCastError(value, property) {\n  // Cuts the property name to the class name.\n  String actualType = Primitives.objectTypeName(value);\n  String expectedType = property.substring(3, property.length);\n  throw new CastErrorImplementation(actualType, expectedType);\n}\n\n/**\n * For types that are not supertypes of native (eg DOM) types,\n * we emit a simple property check to check that an object implements\n * that type.\n */\npropertyTypeCheck(value, property) {\n  if (value == null) return value;\n  if (JS('bool', '!!#[#]', value, property)) return value;\n  propertyTypeError(value, property);\n}\n\n/**\n * For types that are not supertypes of native (eg DOM) types,\n * we emit a simple property check to check that an object implements\n * that type.\n */\npropertyTypeCast(value, property) {\n  if (value == null || JS('bool', '!!#[#]', value, property)) return value;\n  propertyTypeCastError(value, property);\n}\n\n/**\n * For types that are supertypes of native (eg DOM) types, we use the\n * interceptor for the class because we cannot add a JS property to the\n * prototype at load time.\n */\ninterceptedTypeCheck(value, property) {\n  if (value == null) return value;\n  if ((identical(JS('String', 'typeof #', value), 'object'))\n      && JS('bool', '#[#]', getInterceptor(value), property)) {\n    return value;\n  }\n  propertyTypeError(value, property);\n}\n\n/**\n * For types that are supertypes of native (eg DOM) types, we use the\n * interceptor for the class because we cannot add a JS property to the\n * prototype at load time.\n */\ninterceptedTypeCast(value, property) {\n  if (value == null\n      || ((JS('bool', 'typeof # === \"object\"', value))\n          && JS('bool', '#[#]', getInterceptor(value), property))) {\n    return value;\n  }\n  propertyTypeCastError(value, property);\n}\n\n/**\n * Specialization of the type check for num and String and their\n * supertype since [value] can be a JS primitive.\n */\nnumberOrStringSuperTypeCheck(value, property) {\n  if (value == null) return value;\n  if (value is String) return value;\n  if (value is num) return value;\n  if (JS('bool', '!!#[#]', value, property)) return value;\n  propertyTypeError(value, property);\n}\n\nnumberOrStringSuperTypeCast(value, property) {\n  if (value is String) return value;\n  if (value is num) return value;\n  return propertyTypeCast(value, property);\n}\n\nnumberOrStringSuperNativeTypeCheck(value, property) {\n  if (value == null) return value;\n  if (value is String) return value;\n  if (value is num) return value;\n  if (JS('bool', '#[#]', getInterceptor(value), property)) return value;\n  propertyTypeError(value, property);\n}\n\nnumberOrStringSuperNativeTypeCast(value, property) {\n  if (value == null) return value;\n  if (value is String) return value;\n  if (value is num) return value;\n  if (JS('bool', '#[#]', getInterceptor(value), property)) return value;\n  propertyTypeCastError(value, property);\n}\n\n/**\n * Specialization of the type check for String and its supertype\n * since [value] can be a JS primitive.\n */\nstringSuperTypeCheck(value, property) {\n  if (value == null) return value;\n  if (value is String) return value;\n  if (JS('bool', '!!#[#]', value, property)) return value;\n  propertyTypeError(value, property);\n}\n\nstringSuperTypeCast(value, property) {\n  if (value is String) return value;\n  return propertyTypeCast(value, property);\n}\n\nstringSuperNativeTypeCheck(value, property) {\n  if (value == null) return value;\n  if (value is String) return value;\n  if (JS('bool', '#[#]', getInterceptor(value), property)) return value;\n  propertyTypeError(value, property);\n}\n\nstringSuperNativeTypeCast(value, property) {\n  if (value is String || value == null) return value;\n  if (JS('bool', '#[#]', getInterceptor(value), property)) return value;\n  propertyTypeCastError(value, property);\n}\n\n/**\n * Specialization of the type check for List and its supertypes,\n * since [value] can be a JS array.\n */\nlistTypeCheck(value) {\n  if (value == null) return value;\n  if (value is List) return value;\n  throw new TypeErrorImplementation(value, 'List');\n}\n\nlistTypeCast(value) {\n  if (value is List || value == null) return value;\n  throw new CastErrorImplementation(\n      Primitives.objectTypeName(value), 'List');\n}\n\nlistSuperTypeCheck(value, property) {\n  if (value == null) return value;\n  if (value is List) return value;\n  if (JS('bool', '!!#[#]', value, property)) return value;\n  propertyTypeError(value, property);\n}\n\nlistSuperTypeCast(value, property) {\n  if (value is List) return value;\n  return propertyTypeCast(value, property);\n}\n\nlistSuperNativeTypeCheck(value, property) {\n  if (value == null) return value;\n  if (value is List) return value;\n  if (JS('bool', '#[#]', getInterceptor(value), property)) return value;\n  propertyTypeError(value, property);\n}\n\nlistSuperNativeTypeCast(value, property) {\n  if (value is List || value == null) return value;\n  if (JS('bool', '#[#]', getInterceptor(value), property)) return value;\n  propertyTypeCastError(value, property);\n}\n\nvoidTypeCheck(value) {\n  if (value == null) return value;\n  throw new TypeErrorImplementation(value, 'void');\n}\n\nmalformedTypeCheck(value, type, reasons) {\n  if (value == null) return value;\n  throwMalformedSubtypeError(value, type, reasons);\n}\n\nmalformedTypeCast(value, type, reasons) {\n  if (value == null) return value;\n  throw new CastErrorImplementation.malformedTypeCast(value, type, reasons);\n}\n\n/**\n * Special interface recognized by the compiler and implemented by DOM\n * objects that support integer indexing. This interface is not\n * visible to anyone, and is only injected into special libraries.\n */\nabstract class JavaScriptIndexingBehavior extends JSMutableIndexable {\n}\n\n// TODO(lrn): These exceptions should be implemented in core.\n// When they are, remove the 'Implementation' here.\n\n/** Thrown by type assertions that fail. */\nclass TypeErrorImplementation implements TypeError {\n  final String message;\n\n  /**\n   * Normal type error caused by a failed subtype test.\n   */\n  TypeErrorImplementation(Object value, String type)\n      : message = \"type '${Primitives.objectTypeName(value)}' is not a subtype \"\n                  \"of type '$type'\";\n\n  /**\n   * Type error caused by a subtype test on a malformed type.\n   */\n  TypeErrorImplementation.malformedSubtype(Object value,\n                                           String type, String reasons)\n      : message = \"type '${Primitives.objectTypeName(value)}' is not a subtype \"\n                  \"of type '$type' because '$type' is malformed: $reasons.\";\n\n  String toString() => message;\n}\n\n/** Thrown by the 'as' operator if the cast isn't valid. */\nclass CastErrorImplementation implements CastError {\n  // TODO(lrn): Rename to CastError (and move implementation into core).\n  final String message;\n\n  /**\n   * Normal cast error caused by a failed type cast.\n   */\n  CastErrorImplementation(Object actualType, Object expectedType)\n      : message = \"CastError: Casting value of type $actualType to\"\n                  \" incompatible type $expectedType\";\n\n\n  /**\n   * Cast error caused by a type cast to a malformed type.\n   */\n  CastErrorImplementation.malformedTypeCast(Object value,\n                                            String type, String reasons)\n      : message = \"CastError: Type '${Primitives.objectTypeName(value)}' \"\n                  \"cannot be cast to type '$type' because '$type' is \"\n                  \"malformed: $reasons.\";\n\n\n  String toString() => message;\n}\n\nclass FallThroughErrorImplementation implements FallThroughError {\n  const FallThroughErrorImplementation();\n  String toString() => \"Switch case fall-through.\";\n}\n\n/**\n * Helper function for implementing asserts. The compiler treats this specially.\n */\nvoid assertHelper(condition) {\n  if (condition is Function) condition = condition();\n  if (condition is !bool) {\n    throw new TypeErrorImplementation(condition, 'bool');\n  }\n  // Compare to true to avoid boolean conversion check in checked\n  // mode.\n  if (!identical(condition, true)) throw new AssertionError();\n}\n\n/**\n * Called by generated code when a method that must be statically\n * resolved cannot be found.\n */\nvoid throwNoSuchMethod(obj, name, arguments, expectedArgumentNames) {\n  throw new NoSuchMethodError(obj, name, arguments, const {},\n                              expectedArgumentNames);\n}\n\n/**\n * Called by generated code when a static field's initializer references the\n * field that is currently being initialized.\n */\nvoid throwCyclicInit(String staticName) {\n  throw new RuntimeError(\"Cyclic initialization for static $staticName\");\n}\n","sdk/lib/_internal/compiler/implementation/lib/js_number.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _interceptors;\n\n/**\n * The super interceptor class for [JSInt] and [JSDouble]. The compiler\n * recognizes this class as an interceptor, and changes references to\n * [:this:] to actually use the receiver of the method, which is\n * generated as an extra argument added to each member.\n *\n * Note that none of the methods here delegate to a method defined on JSInt or\n * JSDouble.  This is exploited in [tryComputeConstantInterceptor].\n */\nclass JSNumber extends Interceptor implements num {\n  const JSNumber();\n\n  int compareTo(num b) {\n    if (b is! num) throw new ArgumentError(b);\n    if (this < b) {\n      return -1;\n    } else if (this > b) {\n      return 1;\n    } else if (this == b) {\n      if (this == 0) {\n        bool bIsNegative = b.isNegative;\n        if (isNegative == bIsNegative) return 0;\n        if (isNegative) return -1;\n        return 1;\n      }\n      return 0;\n    } else if (isNaN) {\n      if (b.isNaN) {\n        return 0;\n      }\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  bool get isNegative => (this == 0) ? (1 / this) < 0 : this < 0;\n\n  bool get isNaN => JS('bool', r'isNaN(#)', this);\n\n  bool get isInfinite {\n    return JS('bool', r'# == Infinity', this)\n        || JS('bool', r'# == -Infinity', this);\n  }\n\n  num remainder(num b) {\n    checkNull(b); // TODO(ngeoffray): This is not specified but co19 tests it.\n    if (b is! num) throw new ArgumentError(b);\n    return JS('num', r'# % #', this, b);\n  }\n\n  num abs() => JS('num', r'Math.abs(#)', this);\n\n  int toInt() {\n    if (isNaN) throw new UnsupportedError('NaN');\n    if (isInfinite) throw new UnsupportedError('Infinity');\n    num truncated = truncateToDouble();\n    return JS('bool', r'# == -0.0', truncated) ? 0 : truncated;\n  }\n\n  int truncate() => toInt();\n  int ceil() => ceilToDouble().toInt();\n  int floor() => floorToDouble().toInt();\n  int round() => roundToDouble().toInt();\n\n  double ceilToDouble() => JS('num', r'Math.ceil(#)', this);\n\n  double floorToDouble() => JS('num', r'Math.floor(#)', this);\n\n  double roundToDouble() {\n    if (this < 0) {\n      return JS('num', r'-Math.round(-#)', this);\n    } else {\n      return JS('num', r'Math.round(#)', this);\n    }\n  }\n\n  double truncateToDouble() => this < 0 ? ceilToDouble() : floorToDouble();\n\n  num clamp(lowerLimit, upperLimit) {\n    if (lowerLimit is! num) throw new ArgumentError(lowerLimit);\n    if (upperLimit is! num) throw new ArgumentError(upperLimit);\n    if (lowerLimit.compareTo(upperLimit) > 0) {\n      throw new ArgumentError(lowerLimit);\n    }\n    if (this.compareTo(lowerLimit) < 0) return lowerLimit;\n    if (this.compareTo(upperLimit) > 0) return upperLimit;\n    return this;\n  }\n\n  double toDouble() => this;\n\n  String toStringAsFixed(int fractionDigits) {\n    checkNum(fractionDigits);\n    // TODO(floitsch): fractionDigits must be an integer.\n    if (fractionDigits < 0 || fractionDigits > 20) {\n      throw new RangeError(fractionDigits);\n    }\n    String result = JS('String', r'#.toFixed(#)', this, fractionDigits);\n    if (this == 0 && isNegative) return \"-$result\";\n    return result;\n  }\n\n  String toStringAsExponential([int fractionDigits]) {\n    String result;\n    if (fractionDigits != null) {\n      // TODO(floitsch): fractionDigits must be an integer.\n      checkNum(fractionDigits);\n      if (fractionDigits < 0 || fractionDigits > 20) {\n        throw new RangeError(fractionDigits);\n      }\n      result = JS('String', r'#.toExponential(#)', this, fractionDigits);\n    } else {\n      result = JS('String', r'#.toExponential()', this);\n    }\n    if (this == 0 && isNegative) return \"-$result\";\n    return result;\n  }\n\n  String toStringAsPrecision(int precision) {\n    // TODO(floitsch): precision must be an integer.\n    checkNum(precision);\n    if (precision < 1 || precision > 21) {\n      throw new RangeError(precision);\n    }\n    String result = JS('String', r'#.toPrecision(#)',\n                       this, precision);\n    if (this == 0 && isNegative) return \"-$result\";\n    return result;\n  }\n\n  String toRadixString(int radix) {\n    checkNum(radix);\n    if (radix < 2 || radix > 36) throw new RangeError(radix);\n    return JS('String', r'#.toString(#)', this, radix);\n  }\n\n  // Note: if you change this, also change the function [S].\n  String toString() {\n    if (this == 0 && JS('bool', '(1 / #) < 0', this)) {\n      return '-0.0';\n    } else {\n      return JS('String', r'\"\" + (#)', this);\n    }\n  }\n\n  int get hashCode => JS('int', '# & 0x1FFFFFFF', this);\n\n  num operator -() => JS('num', r'-#', this);\n\n  num operator +(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('num', '# + #', this, other);\n  }\n\n  num operator -(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('num', '# - #', this, other);\n  }\n\n  num operator /(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('num', '# / #', this, other);\n  }\n\n  num operator *(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('num', '# * #', this, other);\n  }\n\n  num operator %(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    // Euclidean Modulo.\n    num result = JS('num', r'# % #', this, other);\n    if (result == 0) return 0;  // Make sure we don't return -0.0.\n    if (result > 0) return result;\n    if (JS('num', '#', other) < 0) {\n      return result - JS('num', '#', other);\n    } else {\n      return result + JS('num', '#', other);\n    }\n  }\n\n  num operator ~/(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return (JS('num', r'# / #', this, other)).truncate();\n  }\n\n  // TODO(ngeoffray): Move the bit operations below to [JSInt] and\n  // make them take an int. Because this will make operations slower,\n  // we define these methods on number for now but we need to decide\n  // the grain at which we do the type checks.\n\n  num operator <<(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    if (JS('num', '#', other) < 0) throw new ArgumentError(other);\n    // JavaScript only looks at the last 5 bits of the shift-amount. Shifting\n    // by 33 is hence equivalent to a shift by 1.\n    if (JS('bool', r'# > 31', other)) return 0;\n    return JS('int', r'(# << #) >>> 0', this, other);\n  }\n\n  num operator >>(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    if (JS('num', '#', other) < 0) throw new ArgumentError(other);\n    if (JS('num', '#', this) > 0) {\n      // JavaScript only looks at the last 5 bits of the shift-amount. In JS\n      // shifting by 33 is hence equivalent to a shift by 1. Shortcut the\n      // computation when that happens.\n      if (JS('bool', r'# > 31', other)) return 0;\n      // Given that 'a' is positive we must not use '>>'. Otherwise a number\n      // that has the 31st bit set would be treated as negative and shift in\n      // ones.\n      return JS('int', r'# >>> #', this, other);\n    }\n    // For negative numbers we just clamp the shift-by amount. 'a' could be\n    // negative but not have its 31st bit set. The \">>\" would then shift in\n    // 0s instead of 1s. Therefore we cannot simply return 0xFFFFFFFF.\n    if (JS('num', '#', other) > 31) other = 31;\n    return JS('int', r'(# >> #) >>> 0', this, other);\n  }\n\n  num operator &(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('int', r'(# & #) >>> 0', this, other);\n  }\n\n  num operator |(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('int', r'(# | #) >>> 0', this, other);\n  }\n\n  num operator ^(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('int', r'(# ^ #) >>> 0', this, other);\n  }\n\n  bool operator <(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('bool', '# < #', this, other);\n  }\n\n  bool operator >(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('bool', '# > #', this, other);\n  }\n\n  bool operator <=(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('bool', '# <= #', this, other);\n  }\n\n  bool operator >=(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('bool', '# >= #', this, other);\n  }\n}\n\nclass JSInt extends JSNumber implements int {\n  const JSInt();\n\n  bool get isEven => (this & 1) == 0;\n\n  bool get isOdd => (this & 1) == 1;\n\n  Type get runtimeType => int;\n\n  int operator ~() => JS('int', r'(~#) >>> 0', this);\n}\n\nclass JSDouble extends JSNumber implements double {\n  const JSDouble();\n  Type get runtimeType => double;\n}\n","sdk/lib/_internal/compiler/implementation/lib/js_rti.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _js_helper;\n\nsetRuntimeTypeInfo(target, typeInfo) {\n  assert(typeInfo == null || isJsArray(typeInfo));\n  // We have to check for null because factories may return null.\n  if (target != null) JS('var', r'#.$builtinTypeInfo = #', target, typeInfo);\n}\n\ngetRuntimeTypeInfo(target) {\n  if (target == null) return null;\n  return JS('var', r'#.$builtinTypeInfo', target);\n}\n\ngetRuntimeTypeArgument(target, substitution, index) {\n  var arguments = substitute(substitution, getRuntimeTypeInfo(target));\n  return (arguments == null) ? null : getField(arguments, index);\n}\n\nclass TypeImpl implements Type {\n  final String typeName;\n  TypeImpl(this.typeName);\n  toString() => typeName;\n  int get hashCode => typeName.hashCode;\n  bool operator ==(other) {\n    if (other is !TypeImpl) return false;\n    return typeName == other.typeName;\n  }\n}\n\nString getClassName(var object) {\n  return JS('String', r'#.constructor.builtin$cls', getInterceptor(object));\n}\n\nString getRuntimeTypeAsString(List runtimeType) {\n  String className = getConstructorName(runtimeType[0]);\n  return '$className${joinArguments(runtimeType, 1)}';\n}\n\nString getConstructorName(type) => JS('String', r'#.builtin$cls', type);\n\nString runtimeTypeToString(type) {\n  if (type == null) {\n    return 'dynamic';\n  } else if (isJsArray(type)) {\n    // A list representing a type with arguments.\n    return getRuntimeTypeAsString(type);\n  } else {\n    // A reference to the constructor.\n    return getConstructorName(type);\n  }\n}\n\nString joinArguments(var types, int startIndex) {\n  if (types == null) return '';\n  bool firstArgument = true;\n  bool allDynamic = true;\n  StringBuffer buffer = new StringBuffer();\n  for (int index = startIndex; index < types.length; index++) {\n    if (firstArgument) {\n      firstArgument = false;\n    } else {\n      buffer.write(', ');\n    }\n    var argument = types[index];\n    if (argument != null) {\n      allDynamic = false;\n    }\n    buffer.write(runtimeTypeToString(argument));\n  }\n  return allDynamic ? '' : '<$buffer>';\n}\n\nString getRuntimeTypeString(var object) {\n  String className = isJsArray(object) ? 'List' : getClassName(object);\n  var typeInfo = JS('var', r'#.$builtinTypeInfo', object);\n  return \"$className${joinArguments(typeInfo, 0)}\";\n}\n\nType getRuntimeType(var object) {\n  String type = getRuntimeTypeString(object);\n  return new TypeImpl(type);\n}\n\nbool isJsFunction(var o) => JS('bool', r'typeof # == \"function\"', o);\n\nObject invoke(function, arguments) {\n  return JS('var', r'#.apply(null, #)', function, arguments);\n}\n\nObject call(target, name) => JS('var', r'#[#]()', target, name);\n\nsubstitute(var substitution, var arguments) {\n  if (isJsArray(substitution)) {\n    arguments = substitution;\n  } else if (isJsFunction(substitution)) {\n    arguments = invoke(substitution, arguments);\n  }\n  return arguments;\n}\n\n/**\n * Perform a type check with arguments on the Dart object [object].\n *\n * Parameters:\n * - [isField]: the name of the flag/function to check if the object\n *   is of the correct class.\n * - [checks]: the (JavaScript) list of type representations for the\n *   arguments to check against.\n * - [asField]: the name of the function that transforms the type\n *   arguments of [objects] to an instance of the class that we check\n *   against.\n */\nbool checkSubtype(Object object, String isField, List checks, String asField) {\n  if (object == null) return false;\n  var arguments = getRuntimeTypeInfo(object);\n  // Interceptor is needed for JSArray and native classes.\n  // TODO(sra): It could be a more specialized interceptor since [object] is not\n  // `null` or a primitive.\n  // TODO(9586): Move type info for static functions onto an interceptor.\n  var interceptor = isJsFunction(object) ? object : getInterceptor(object);\n  bool isSubclass = getField(interceptor, isField);\n  // When we read the field and it is not there, [isSubclass] will be [:null:].\n  if (isSubclass == null || !isSubclass) return false;\n  // Should the asField function be passed the receiver?\n  var substitution = getField(interceptor, asField);\n  return checkArguments(substitution, arguments, checks);\n}\n\n/**\n * Check that the types in the list [arguments] are subtypes of the types in\n * list [checks] (at the respective positions), possibly applying [substitution]\n * to the arguments before the check.\n *\n * See [:RuntimeTypes.getSubtypeSubstitution:] for a description of the possible\n * values for [substitution].\n */\nbool checkArguments(var substitution, var arguments, var checks) {\n  return areSubtypes(substitute(substitution, arguments), checks);\n}\n\nbool areSubtypes(List s, List t) {\n  // [:null:] means a raw type.\n  if (s == null || t == null) return true;\n\n  assert(isJsArray(s));\n  assert(isJsArray(t));\n  assert(s.length == t.length);\n\n  int len = s.length;\n  for (int i = 0; i < len; i++) {\n    if (!isSubtype(s[i], t[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\ngetArguments(var type) {\n  return isJsArray(type) ? JS('var', r'#.slice(1)', type) : null;\n}\n\ngetField(var object, var name) => JS('var', r'#[#]', object, name);\n\n/**\n * Tests whether the Dart object [o] is a subtype of the runtime type\n * representation [t], which is a type representation as described in the\n * comment on [isSubtype].\n */\nbool objectIsSubtype(Object o, var t) {\n  if (JS('bool', '# == null', o) || JS('bool', '# == null', t)) return true;\n  // Get the runtime type information from the object here, because we may\n  // overwrite o with the interceptor below.\n  var rti = getRuntimeTypeInfo(o);\n  // Check for native objects and use the interceptor instead of the object.\n  // TODO(9586): Move type info for static functions onto an interceptor.\n  o = isJsFunction(o) ? o : getInterceptor(o);\n  // We can use the object as its own type representation because we install\n  // the subtype flags and the substitution on the prototype, so they are\n  // properties of the object in JS.\n  var type;\n  if (JS('bool', '# != null', rti)) {\n    // If the type has type variables (that is, [:rti != null:]), make a copy of\n    // the type arguments and insert [o] in the first position to create a\n    // compound type representation.\n    type = JS('List', '#.slice()', rti);\n    JS('', '#.splice(0, 0, #)', type, o);\n  } else {\n    // Use the object as representation of the raw type.\n    type = o;\n  }\n  return isSubtype(type, t);\n}\n\n/**\n * Check whether the type represented by [s] is a subtype of the type\n * represented by [t].\n *\n * Type representations can be:\n *  1) a JavaScript constructor for a class C: the represented type is the raw\n *     type C.\n *  2) a Dart object: this is the interceptor instance for a native type.\n *  3) a JavaScript object: this represents a class for which there is no\n *     JavaScript constructor, because it is only used in type arguments or it\n *     is native. The represented type is the raw type of this class.\n *  4) a JavaScript array: the first entry is of type 1, 2 or 3 and contains the\n *     subtyping flags and the substitution of the type and the rest of the\n *     array are the type arguments.\n *  5) [:null:]: the dynamic type.\n */\nbool isSubtype(var s, var t) {\n  // If either type is dynamic, [s] is a subtype of [t].\n  if (JS('bool', '# == null', s) || JS('bool', '# == null', t)) return true;\n  // Subtyping is reflexive.\n  if (JS('bool', '# === #', s, t)) return true;\n  // Get the object describing the class and check for the subtyping flag\n  // constructed from the type of [t].\n  var typeOfS = isJsArray(s) ? s[0] : s;\n  var typeOfT = isJsArray(t) ? t[0] : t;\n  // Check for a subtyping flag.\n  var test = '${JS_OPERATOR_IS_PREFIX()}${runtimeTypeToString(typeOfT)}';\n  if (getField(typeOfS, test) == null) return false;\n  // Get the necessary substitution of the type arguments, if there is one.\n  var substitution;\n  if (JS('bool', '# !== #', typeOfT, typeOfS)) {\n    var field = '${JS_OPERATOR_AS_PREFIX()}${runtimeTypeToString(typeOfT)}';\n    substitution = getField(typeOfS, field);\n  }\n  // The class of [s] is a subclass of the class of [t].  If [s] has no type\n  // arguments and no substitution, it is used as raw type.  If [t] has no\n  // type arguments, it used as a raw type.  In both cases, [s] is a subtype\n  // of [t].\n  if ((!isJsArray(s) && JS('bool', '# == null', substitution)) ||\n      !isJsArray(t)) {\n    return true;\n  }\n  // Recursively check the type arguments.\n  return checkArguments(substitution, getArguments(s), getArguments(t));\n}\n\ncreateRuntimeType(String name) => new TypeImpl(name);\n","sdk/lib/_internal/compiler/implementation/lib/js_string.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _interceptors;\n\n/**\n * The interceptor class for [String]. The compiler recognizes this\n * class as an interceptor, and changes references to [:this:] to\n * actually use the receiver of the method, which is generated as an extra\n * argument added to each member.\n */\nclass JSString extends Interceptor implements String, JSIndexable {\n  const JSString();\n\n  int codeUnitAt(int index) {\n    if (index is !num) throw new ArgumentError(index);\n    if (index < 0) throw new RangeError.value(index);\n    if (index >= length) throw new RangeError.value(index);\n    return JS('int', r'#.charCodeAt(#)', this, index);\n  }\n\n  Iterable<Match> allMatches(String str) {\n    checkString(str);\n    return allMatchesInStringUnchecked(this, str);\n  }\n\n  String operator +(String other) {\n    if (other is !String) throw new ArgumentError(other);\n    return JS('String', r'# + #', this, other);\n  }\n\n  String concat(String other) => this + other;\n\n  bool endsWith(String other) {\n    checkString(other);\n    int otherLength = other.length;\n    if (otherLength > length) return false;\n    return other == substring(length - otherLength);\n  }\n\n  String replaceAll(Pattern from, String to) {\n    checkString(to);\n    return stringReplaceAllUnchecked(this, from, to);\n  }\n\n  String replaceAllMapped(Pattern from, String convert(Match match)) {\n    return this.splitMapJoin(from, onMatch: convert);\n  }\n\n  String splitMapJoin(Pattern from,\n                      {String onMatch(Match match),\n                       String onNonMatch(String nonMatch)}) {\n    return stringReplaceAllFuncUnchecked(this, from, onMatch, onNonMatch);\n  }\n\n  String replaceFirst(Pattern from, String to) {\n    checkString(to);\n    return stringReplaceFirstUnchecked(this, from, to);\n  }\n\n  List<String> split(Pattern pattern) {\n    checkNull(pattern);\n    if (pattern is String) {\n      return JS('=List', r'#.split(#)', this, pattern);\n    } else if (pattern is JSSyntaxRegExp) {\n      var re = regExpGetNative(pattern);\n      return JS('=List', r'#.split(#)', this, re);\n    } else {\n      throw \"String.split(Pattern) UNIMPLEMENTED\";\n    }\n  }\n\n  bool startsWith(String other) {\n    checkString(other);\n    int otherLength = other.length;\n    if (otherLength > length) return false;\n    return JS('bool', r'# == #', other,\n              JS('String', r'#.substring(0, #)', this, otherLength));\n  }\n\n  String substring(int startIndex, [int endIndex]) {\n    checkNum(startIndex);\n    if (endIndex == null) endIndex = length;\n    checkNum(endIndex);\n    if (startIndex < 0 ) throw new RangeError.value(startIndex);\n    if (startIndex > endIndex) throw new RangeError.value(startIndex);\n    if (endIndex > length) throw new RangeError.value(endIndex);\n    return JS('String', r'#.substring(#, #)', this, startIndex, endIndex);\n  }\n\n  String toLowerCase() {\n    return JS('String', r'#.toLowerCase()', this);\n  }\n\n  String toUpperCase() {\n    return JS('String', r'#.toUpperCase()', this);\n  }\n\n  String trim() {\n    return JS('String', r'#.trim()', this);\n  }\n\n  List<int> get codeUnits => new _CodeUnits(this);\n\n  Runes get runes => new Runes(this);\n\n  int indexOf(String other, [int start = 0]) {\n    checkNull(other);\n    if (start is !int) throw new ArgumentError(start);\n    if (other is !String) throw new ArgumentError(other);\n    if (start < 0) return -1;\n    return JS('int', r'#.indexOf(#, #)', this, other, start);\n  }\n\n  int lastIndexOf(String other, [int start]) {\n    checkNull(other);\n    if (other is !String) throw new ArgumentError(other);\n    if (start != null) {\n      if (start is !num) throw new ArgumentError(start);\n      if (start < 0) return -1;\n      if (start >= length) {\n        if (other == \"\") return length;\n        start = length - 1;\n      }\n    } else {\n      start = length - 1;\n    }\n    return stringLastIndexOfUnchecked(this, other, start);\n  }\n\n  bool contains(Pattern other, [int startIndex = 0]) {\n    checkNull(other);\n    return stringContainsUnchecked(this, other, startIndex);\n  }\n\n  bool get isEmpty => length == 0;\n\n  int compareTo(String other) {\n    if (other is !String) throw new ArgumentError(other);\n    return this == other ? 0\n      : JS('bool', r'# < #', this, other) ? -1 : 1;\n  }\n\n  // Note: if you change this, also change the function [S].\n  String toString() => this;\n\n  /**\n   * This is the [Jenkins hash function][1] but using masking to keep\n   * values in SMI range.\n   *\n   * [1]: http://en.wikipedia.org/wiki/Jenkins_hash_function\n   */\n  int get hashCode {\n    // TODO(ahe): This method shouldn't have to use JS. Update when our\n    // optimizations are smarter.\n    int hash = 0;\n    for (int i = 0; i < length; i++) {\n      hash = 0x1fffffff & (hash + JS('int', r'#.charCodeAt(#)', this, i));\n      hash = 0x1fffffff & (hash + ((0x0007ffff & hash) << 10));\n      hash = JS('int', '# ^ (# >> 6)', hash, hash);\n    }\n    hash = 0x1fffffff & (hash + ((0x03ffffff & hash) <<  3));\n    hash = JS('int', '# ^ (# >> 11)', hash, hash);\n    return 0x1fffffff & (hash + ((0x00003fff & hash) << 15));\n  }\n\n  Type get runtimeType => String;\n\n  int get length => JS('int', r'#.length', this);\n\n  String operator [](int index) {\n    if (index is !int) throw new ArgumentError(index);\n    if (index >= length || index < 0) throw new RangeError.value(index);\n    return JS('String', '#[#]', this, index);\n  }\n}\n\n/**\n * An [Iterable] of the UTF-16 code units of a [String] in index order.\n */\nclass _CodeUnits extends UnmodifiableListBase<int> {\n  /** The string that this is the code units of. */\n  String _string;\n\n  _CodeUnits(this._string);\n\n  int get length => _string.length;\n  int operator[](int i) => _string.codeUnitAt(i);\n}\n","sdk/lib/_internal/compiler/implementation/lib/json_patch.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Patch file for dart:json library.\n\nimport 'dart:_foreign_helper' show JS;\n\n/**\n * Parses [json] and builds the corresponding parsed JSON value.\n *\n * Parsed JSON values are of the types [num], [String], [bool], [Null],\n * [List]s of parsed JSON values or [Map]s from [String] to parsed\n * JSON values.\n *\n * The optional [reviver] function, if provided, is called once for each object\n * or list property parsed. The arguments are the property name ([String]) or\n * list index ([int]), and the value is the parsed value.  The return value of\n * the reviver will be used as the value of that property instead of the parsed\n * value.  The top level value is passed to the reviver with the empty string as\n * a key.\n *\n * Throws [FormatException] if the input is not valid JSON text.\n */\npatch parse(String json, [reviver(var key, var value)]) {\n  if (json is! String) throw new ArgumentError(json);\n\n  var parsed;\n  try {\n    parsed = JS('=Object|=List|Null|bool|num|String', 'JSON.parse(#)', json);\n  } catch (e) {\n    throw new FormatException(JS('String', 'String(#)', e));\n  }\n\n  return _convertJsonToDart(parsed, reviver);\n}\n\n/**\n * Walks the raw JavaScript value [json], replacing JavaScript Objects with\n * Maps. [json] is expected to be freshly allocated so elements can be replaced\n * in-place.\n */\n_convertJsonToDart(json, reviver(key, value)) {\n\n  var revive = reviver == null ? (key, value) => value : reviver;\n\n  walk(e) {\n    // JavaScript null, string, number, bool are in the correct representation.\n    if (JS('bool', '# == null', e) || JS('bool', 'typeof # != \"object\"', e)) {\n      return e;\n    }\n\n    // This test is needed to avoid identifing '{\"__proto__\":[]}' as an Array.\n    // TODO(sra): Replace this test with cheaper '#.constructor === Array' when\n    // bug 621 below is fixed.\n    if (JS('bool', 'Object.getPrototypeOf(#) === Array.prototype', e)) {\n      var list = JS('=List', '#', e);  // Teach compiler the type is known.\n      // In-place update of the elements since JS Array is a Dart List.\n      for (int i = 0; i < list.length; i++) {\n        // Use JS indexing to avoid range checks.  We know this is the only\n        // reference to the list, but the compiler will likely never be able to\n        // tell that this instance of the list cannot have its length changed by\n        // the reviver even though it later will be passed to the reviver at the\n        // outer level.\n        var item = JS('', '#[#]', list, i);\n        JS('', '#[#]=#', list, i, revive(i, walk(item)));\n      }\n      return list;\n    }\n\n    // Otherwise it is a plain Object, so copy to a Map.\n    var keys = JS('=List', 'Object.keys(#)', e);\n    Map map = {};\n    for (int i = 0; i < keys.length; i++) {\n      String key = keys[i];\n      map[key] = revive(key, walk(JS('', '#[#]', e, key)));\n    }\n    // V8 has a bug with properties named \"__proto__\"\n    // https://code.google.com/p/v8/issues/detail?id=621\n    var proto = JS('', '#.__proto__', e);\n    // __proto__ can be undefined on IE9.\n    if (JS('bool',\n           'typeof # !== \"undefined\" && # !== Object.prototype',\n           proto, proto)) {\n      map['__proto__'] = revive('__proto__', walk(proto));\n    }\n    return map;\n  }\n\n  return revive('', walk(json));\n}\n","sdk/lib/_internal/compiler/implementation/lib/math_patch.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Patch file for dart:math library.\nimport 'dart:_foreign_helper' show JS;\n\npatch double sqrt(num x)\n  => JS('double', r'Math.sqrt(#)', checkNum(x));\n\npatch double sin(num x)\n  => JS('double', r'Math.sin(#)', checkNum(x));\n\npatch double cos(num x)\n  => JS('double', r'Math.cos(#)', checkNum(x));\n\npatch double tan(num x)\n  => JS('double', r'Math.tan(#)', checkNum(x));\n\npatch double acos(num x)\n  => JS('double', r'Math.acos(#)', checkNum(x));\n\npatch double asin(num x)\n  => JS('double', r'Math.asin(#)', checkNum(x));\n\npatch double atan(num x)\n  => JS('double', r'Math.atan(#)', checkNum(x));\n\npatch double atan2(num a, num b)\n  => JS('double', r'Math.atan2(#, #)', checkNum(a), checkNum(b));\n\npatch double exp(num x)\n  => JS('double', r'Math.exp(#)', checkNum(x));\n\npatch double log(num x)\n  => JS('double', r'Math.log(#)', checkNum(x));\n\npatch num pow(num x, num exponent) {\n  checkNum(x);\n  checkNum(exponent);\n  return JS('num', r'Math.pow(#, #)', x, exponent);\n}\n\npatch class Random {\n  patch factory Random([int seed]) => const _Random();\n}\n\nclass _Random implements Random {\n  // The Dart2JS implementation of Random doesn't use a seed.\n  const _Random();\n\n  int nextInt(int max) {\n    if (max < 0) throw new ArgumentError(\"negative max: $max\");\n    if (max > 0xFFFFFFFF) max = 0xFFFFFFFF;\n    return JS(\"int\", \"(Math.random() * #) >>> 0\", max);\n  }\n\n  /**\n   * Generates a positive random floating point value uniformly distributed on\n   * the range from 0.0, inclusive, to 1.0, exclusive.\n   */\n  double nextDouble() => JS(\"double\", \"Math.random()\");\n\n  /**\n   * Generates a random boolean value.\n   */\n  bool nextBool() => JS(\"bool\", \"Math.random() < 0.5\");\n}\n","sdk/lib/_internal/compiler/implementation/lib/mirrors_patch.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Patch library for dart:mirrors.\n\nimport 'dart:_foreign_helper' show JS;\nimport \"dart:_collection-dev\" as _symbol_dev;\n\n// Yeah, seriously: mirrors in dart2js are experimental...\nconst String _MIRROR_OPT_IN_MESSAGE = \"\"\"\n\nThis program is using an experimental feature called \\\"mirrors\\\".  As\ncurrently implemented, mirrors do not work with minification, and will\ncause spurious errors depending on how code was optimized.\n\nThe authors of this program are aware of these problems and have\ndecided the thrill of using an experimental feature is outweighing the\nrisks.  Furthermore, the authors of this program understand that\nlong-term, to fix the problems mentioned above, mirrors may have\nnegative impact on size and performance of Dart programs compiled to\nJavaScript.\n\"\"\";\n\nbool _mirrorsEnabled = false;\n\npatch class MirrorSystem {\n  patch static String getName(Symbol symbol) {\n    return _symbol_dev.Symbol.getName(symbol);\n  }\n}\n\n/**\n * Stub class for the mirror system.\n */\npatch MirrorSystem currentMirrorSystem() {\n  _ensureEnabled();\n  throw new UnsupportedError(\"MirrorSystem not implemented\");\n}\n\npatch Future<MirrorSystem> mirrorSystemOf(SendPort port) {\n  _ensureEnabled();\n  throw new UnsupportedError(\"MirrorSystem not implemented\");\n}\n\npatch InstanceMirror reflect(Object reflectee) {\n  if (!_mirrorsEnabled && (_MIRROR_OPT_IN_MESSAGE == reflectee)) {\n    // Turn on mirrors and warn that it is an experimental feature.\n    _mirrorsEnabled = true;\n    print(reflectee);\n  }\n  return new _InstanceMirror(reflectee);\n}\n\npatch ClassMirror reflectClass(Type key) {\n  throw new UnimplementedError('reflectClass is not yet implemented'\n                               'in dart2js');\n}\n\nclass _InstanceMirror extends InstanceMirror {\n  static final Expando<ClassMirror> classMirrors = new Expando<ClassMirror>();\n\n  final reflectee;\n\n  _InstanceMirror(this.reflectee);\n\n  bool get hasReflectee => true;\n\n  ClassMirror get type {\n    _ensureEnabled();\n    String className = Primitives.objectTypeName(reflectee);\n    var constructor = Primitives.getConstructor(className);\n    var mirror = classMirrors[constructor];\n    if (mirror == null) {\n      mirror = new _ClassMirror(className, constructor);\n      classMirrors[constructor] = mirror;\n    }\n    return mirror;\n  }\n\n  Future<InstanceMirror> invokeAsync(String memberName,\n                                     List<Object> positionalArguments,\n                                     [Map<String,Object> namedArguments]) {\n    _ensureEnabled();\n    if (namedArguments != null && !namedArguments.isEmpty) {\n      throw new UnsupportedError('Named arguments are not implemented');\n    }\n    // Copy the list to ensure that it can safely be passed to\n    // JavaScript.\n    var jsList = new List.from(positionalArguments);\n    var mangledName = '${memberName}\\$${positionalArguments.length}';\n    var method = JS('var', '#[#]', reflectee, mangledName);\n    var completer = new Completer<InstanceMirror>();\n    // TODO(ahe): [Completer] or [Future] should have API to create a\n    // delayed action.  Simulating with a [Timer].\n    Timer.run(() {\n      if (JS('String', 'typeof #', method) == 'function') {\n        var result =\n            JS('var', '#.apply(#, #)', method, reflectee, jsList);\n        completer.complete(new _InstanceMirror(result));\n      } else {\n        completer.completeError('not a method $memberName');\n      }\n    });\n    return completer.future;\n  }\n\n  delegate(Invocation invocation) {\n    return JSInvocationMirror.invokeFromMirror(invocation, reflectee);\n  }\n\n  String toString() => 'InstanceMirror($reflectee)';\n}\n\nclass _ClassMirror extends ClassMirror {\n  final String _name;\n  final _jsConstructor;\n\n  _ClassMirror(this._name, this._jsConstructor) {\n    _ensureEnabled();\n  }\n\n  String toString() => 'ClassMirror($_name)';\n}\n\n_ensureEnabled() {\n  if (_mirrorsEnabled) return;\n  throw new UnsupportedError('dart:mirrors is an experimental feature');\n}\n","sdk/lib/_internal/compiler/implementation/lib/native_helper.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _js_helper;\n\nString typeNameInChrome(obj) {\n  String name = JS('String', \"#.constructor.name\", obj);\n  return typeNameInWebKitCommon(name);\n}\n\nString typeNameInSafari(obj) {\n  String name = JS('String', '#', constructorNameFallback(obj));\n  // Safari is very similar to Chrome.\n  return typeNameInWebKitCommon(name);\n}\n\nString typeNameInWebKitCommon(tag) {\n  String name = JS('String', '#', tag);\n  if (name == 'CanvasPixelArray') return 'Uint8ClampedArray';\n  if (name == 'AudioChannelMerger') return 'ChannelMergerNode';\n  if (name == 'AudioChannelSplitter') return 'ChannelSplitterNode';\n  if (name == 'AudioGainNode') return 'GainNode';\n  if (name == 'AudioPannerNode') return 'PannerNode';\n  if (name == 'JavaScriptAudioNode') return 'ScriptProcessorNode';\n  if (name == 'Oscillator') return 'OscillatorNode';\n  if (name == 'RealtimeAnalyserNode') return 'AnalyserNode';\n  if (name == 'IDBVersionChangeRequest') return 'IDBOpenDBRequest';\n  return name;\n}\n\nString typeNameInOpera(obj) {\n  String name = JS('String', '#', constructorNameFallback(obj));\n  return name;\n}\n\nString typeNameInFirefox(obj) {\n  String name = JS('String', '#', constructorNameFallback(obj));\n  if (name == 'BeforeUnloadEvent') return 'Event';\n  if (name == 'CSS2Properties') return 'CSSStyleDeclaration';\n  if (name == 'DataTransfer') return 'Clipboard';\n  if (name == 'DragEvent') return 'MouseEvent';\n  if (name == 'GeoGeolocation') return 'Geolocation';\n  if (name == 'WorkerMessageEvent') return 'MessageEvent';\n  if (name == 'WorkerErrorEvent') return 'ErrorEvent';\n  if (name == 'XMLDocument') return 'Document';\n  return name;\n}\n\nString typeNameInIE(obj) {\n  String name = JS('String', '#', constructorNameFallback(obj));\n  if (name == 'Document') {\n    // IE calls both HTML and XML documents 'Document', so we check for the\n    // xmlVersion property, which is the empty string on HTML documents.\n    if (JS('bool', '!!#.xmlVersion', obj)) return 'Document';\n    return 'HTMLDocument';\n  }\n  if (name == 'BeforeUnloadEvent') return 'Event';\n  if (name == 'CanvasPixelArray') return 'Uint8ClampedArray';\n  if (name == 'DataTransfer') return 'Clipboard';\n  if (name == 'DragEvent') return 'MouseEvent';\n  if (name == 'HTMLDDElement') return 'HTMLElement';\n  if (name == 'HTMLDTElement') return 'HTMLElement';\n  if (name == 'HTMLTableDataCellElement') return 'HTMLTableCellElement';\n  if (name == 'HTMLTableHeaderCellElement') return 'HTMLTableCellElement';\n  if (name == 'HTMLPhraseElement') return 'HTMLElement';\n  if (name == 'MSStyleCSSProperties') return 'CSSStyleDeclaration';\n  if (name == 'Position') return 'Geoposition';\n\n  // Patches for types which report themselves as Objects.\n  if (name == 'Object') {\n    if (JS('bool', 'window.DataView && (# instanceof window.DataView)', obj)) {\n      return 'DataView';\n    }\n  }\n  return name;\n}\n\nString constructorNameFallback(object) {\n  if (object == null) return 'Null';\n  var constructor = JS('var', \"#.constructor\", object);\n  if (identical(JS('String', \"typeof(#)\", constructor), 'function')) {\n    // The constructor isn't null or undefined at this point. Try\n    // to grab hold of its name.\n    var name = JS('var', '#.name', constructor);\n    // If the name is a non-empty string, we use that as the type\n    // name of this object. On Firefox, we often get 'Object' as\n    // the constructor name even for more specialized objects so\n    // we have to fall through to the toString() based implementation\n    // below in that case.\n    if (name is String\n        && !identical(name, '')\n        && !identical(name, 'Object')\n        && !identical(name, 'Function.prototype')) {  // Can happen in Opera.\n      return name;\n    }\n  }\n  String string = JS('String', 'Object.prototype.toString.call(#)', object);\n  return JS('String', '#.substring(8, # - 1)', string, string.length);\n}\n\n/**\n * If a lookup on an object [object] that has [tag] fails, this function is\n * called to provide an alternate tag.  This allows us to fail gracefully if we\n * can make a good guess, for example, when browsers add novel kinds of\n * HTMLElement that we have never heard of.\n */\nString alternateTag(object, String tag) {\n  // Does it smell like some kind of HTML element?\n  if (JS('bool', r'!!/^HTML[A-Z].*Element$/.test(#)', tag)) {\n    // Check that it is not a simple JavaScript object.\n    String string = JS('String', 'Object.prototype.toString.call(#)', object);\n    if (string == '[object Object]') return null;\n    return 'HTMLElement';\n  }\n  return null;\n}\n\n// TODO(ngeoffray): stop using this method once our optimizers can\n// change str1.contains(str2) into str1.indexOf(str2) != -1.\nbool contains(String userAgent, String name) {\n  return JS('int', '#.indexOf(#)', userAgent, name) != -1;\n}\n\nint arrayLength(List array) {\n  return JS('int', '#.length', array);\n}\n\narrayGet(List array, int index) {\n  return JS('var', '#[#]', array, index);\n}\n\nvoid arraySet(List array, int index, var value) {\n  JS('var', '#[#] = #', array, index, value);\n}\n\npropertyGet(var object, String property) {\n  return JS('var', '#[#]', object, property);\n}\n\nbool callHasOwnProperty(var function, var object, String property) {\n  return JS('bool', '#.call(#, #)', function, object, property);\n}\n\nvoid propertySet(var object, String property, var value) {\n  JS('var', '#[#] = #', object, property, value);\n}\n\ngetPropertyFromPrototype(var object, String name) {\n  return JS('var', 'Object.getPrototypeOf(#)[#]', object, name);\n}\n\nnewJsObject() {\n  return JS('var', '{}');\n}\n\n/**\n * Returns the function to use to get the type name of an object.\n */\nFunction getFunctionForTypeNameOf() {\n  // If we're not in the browser, we're almost certainly running on v8.\n  if (!identical(JS('String', 'typeof(navigator)'), 'object')) return typeNameInChrome;\n\n  String userAgent = JS('String', \"navigator.userAgent\");\n  if (contains(userAgent, 'Chrome') || contains(userAgent, 'DumpRenderTree')) {\n    return typeNameInChrome;\n  } else if (contains(userAgent, 'Firefox')) {\n    return typeNameInFirefox;\n  } else if (contains(userAgent, 'MSIE')) {\n    return typeNameInIE;\n  } else if (contains(userAgent, 'Opera')) {\n    return typeNameInOpera;\n  } else if (contains(userAgent, 'AppleWebKit')) {\n    // Chrome matches 'AppleWebKit' too, but we test for Chrome first, so this\n    // is not a problem.\n    // Note: Just testing for \"Safari\" doesn't work when the page is embedded\n    // in a UIWebView on iOS 6.\n    return typeNameInSafari;\n  } else {\n    return constructorNameFallback;\n  }\n}\n\n\n/**\n * Cached value for the function to use to get the type name of an\n * object.\n */\nFunction _getTypeNameOf;\n\n/**\n * Returns the type name of [obj].\n */\nString getTypeNameOf(var obj) {\n  if (_getTypeNameOf == null) _getTypeNameOf = getFunctionForTypeNameOf();\n  return _getTypeNameOf(obj);\n}\n\nString toStringForNativeObject(var obj) {\n  String name = JS('String', '#', getTypeNameOf(obj));\n  return 'Instance of $name';\n}\n\nint hashCodeForNativeObject(object) => Primitives.objectHashCode(object);\n\n/**\n * Sets a JavaScript property on an object.\n */\nvoid defineProperty(var obj, String property, var value) {\n  JS('void',\n      'Object.defineProperty(#, #, '\n          '{value: #, enumerable: false, writable: true, configurable: true})',\n      obj,\n      property,\n      value);\n}\n\n\n// Is [obj] an instance of a Dart-defined class?\nbool isDartObject(obj) {\n  // Some of the extra parens here are necessary.\n  return JS('bool', '((#) instanceof (#))', obj, JS_DART_OBJECT_CONSTRUCTOR());\n}\n\n/// A JavaScript object mapping tags to interceptors.\nvar interceptorsByTag;\n\n/// A JavaScript object mapping tags to `true` or `false`.\nvar leafTags;\n\n/**\n * Associates tags with an interceptor.  Called from generated code.  The tags\n * are all 'leaf' tags representing classes that have no subclasses with\n * different behaviour.\n *\n * [tags] is a string of `|`-separated tags.\n */\nvoid defineNativeMethods(String tags, interceptorClass) {\n  defineNativeMethodsCommon(tags, interceptorClass, true);\n}\n\n/**\n * Associates tags with an interceptor.  Called from generated code.  The tags\n * are all non-'leaf' tags, representing classes that have a subclass with\n * different behaviour.\n */\nvoid defineNativeMethodsNonleaf(String tags, interceptorClass) {\n  defineNativeMethodsCommon(tags, interceptorClass, false);\n}\n\nvoid defineNativeMethodsCommon(String tags, var interceptorClass, bool isLeaf) {\n  var methods = JS('', '#.prototype', interceptorClass);\n  if (interceptorsByTag == null) interceptorsByTag = JS('=Object', '{}');\n  if (leafTags == null) leafTags = JS('=Object', '{}');\n\n  var tagsList = JS('=List', '#.split(\"|\")', tags);\n  for (int i = 0; i < tagsList.length; i++) {\n    var tag = tagsList[i];\n    JS('void', '#[#] = #', interceptorsByTag, tag, methods);\n    JS('void', '#[#] = #', leafTags, tag, isLeaf);\n  }\n}\n\nvoid defineNativeMethodsFinish() {\n  // TODO(sra): Investigate placing a dispatch record on Object.prototype that\n  // returns an interceptor for JavaScript objects.  This avoids needing a test\n  // in every interceptor, and prioritizes the performance of known native\n  // classes over unknown.\n}\n\nlookupInterceptor(var hasOwnPropertyFunction, String tag) {\n  var map = interceptorsByTag;\n  return callHasOwnProperty(hasOwnPropertyFunction, map, tag)\n      ? propertyGet(map, tag)\n      : null;\n}\n\nlookupDispatchRecord(obj) {\n  var hasOwnPropertyFunction = JS('var', 'Object.prototype.hasOwnProperty');\n  var interceptor = null;\n  assert(!isDartObject(obj));\n  String tag = getTypeNameOf(obj);\n\n  interceptor = lookupInterceptor(hasOwnPropertyFunction, tag);\n  if (interceptor == null) {\n    String secondTag = alternateTag(obj, tag);\n    if (secondTag != null) {\n      interceptor = lookupInterceptor(hasOwnPropertyFunction, secondTag);\n    }\n  }\n  if (interceptor == null) {\n    // TODO(sra): Think about the error case.\n    interceptor = JS('', '{__what: \"interceptor not found\", __tag: #}', tag);\n  }\n  var isLeaf = JS('', '#[#]', leafTags, tag);\n  if (true == isLeaf) {\n    return makeDispatchRecord(interceptor, false, null);\n  } else {\n    var proto = JS('', 'Object.getPrototypeOf(#)', obj);\n    return makeDispatchRecord(interceptor, proto, null);\n  }\n}\n","sdk/lib/_internal/compiler/implementation/lib/regexp_helper.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _js_helper;\n\n// Helper method used by internal libraries.\nregExpGetNative(JSSyntaxRegExp regexp) => regexp._nativeRegExp;\n\nclass JSSyntaxRegExp implements RegExp {\n  final String _pattern;\n  final bool _isMultiLine;\n  final bool _isCaseSensitive;\n  var _nativeRegExp;\n\n  JSSyntaxRegExp._internal(String pattern,\n                           bool multiLine,\n                           bool caseSensitive,\n                           bool global)\n      : _nativeRegExp = makeNative(pattern, multiLine, caseSensitive, global),\n        this._pattern = pattern,\n        this._isMultiLine = multiLine,\n        this._isCaseSensitive = caseSensitive;\n\n  JSSyntaxRegExp(String pattern,\n                 {bool multiLine: false,\n                  bool caseSensitive: true})\n      : this._internal(pattern, multiLine, caseSensitive, false);\n\n  JSSyntaxRegExp._globalVersionOf(JSSyntaxRegExp other)\n      : this._internal(other.pattern,\n                       other.isMultiLine,\n                       other.isCaseSensitive,\n                       true);\n\n  static makeNative(\n      String pattern, bool multiLine, bool caseSensitive, bool global) {\n    checkString(pattern);\n    String m = multiLine ? 'm' : '';\n    String i = caseSensitive ? '' : 'i';\n    String g = global ? 'g' : '';\n    // We're using the JavaScript's try catch instead of the Dart one\n    // to avoid dragging in Dart runtime support just because of using\n    // RegExp.\n    var regexp = JS('',\n        '(function() {'\n         'try {'\n          'return new RegExp(#, # + # + #);'\n         '} catch (e) {'\n           'return e;'\n         '}'\n        '})()', pattern, m, i, g);\n    if (JS('bool', '# instanceof RegExp', regexp)) return regexp;\n    // The returned value is the JavaScript exception. Turn it into a\n    // Dart exception.\n    String errorMessage = JS('String', r'String(#)', regexp);\n    throw new FormatException(\n        \"Illegal RegExp pattern: $pattern, $errorMessage\");\n  }\n\n  Match firstMatch(String str) {\n    List<String> m =\n        JS('=List|Null', r'#.exec(#)', _nativeRegExp, checkString(str));\n    if (m == null) return null;\n    var matchStart = JS('int', r'#.index', m);\n    // m.lastIndex only works with flag 'g'.\n    var matchEnd = matchStart + m[0].length;\n    return new _MatchImplementation(pattern, str, matchStart, matchEnd, m);\n  }\n\n  bool hasMatch(String str) {\n    return JS('bool', r'#.test(#)', _nativeRegExp, checkString(str));\n  }\n\n  String stringMatch(String str) {\n    var match = firstMatch(str);\n    return match == null ? null : match.group(0);\n  }\n\n  Iterable<Match> allMatches(String str) {\n    checkString(str);\n    return new _AllMatchesIterable(this, str);\n  }\n\n  String get pattern => _pattern;\n  bool get isMultiLine => _isMultiLine;\n  bool get isCaseSensitive => _isCaseSensitive;\n}\n\nclass _MatchImplementation implements Match {\n  final String pattern;\n  final String str;\n  final int start;\n  final int end;\n  final List<String> _groups;\n\n  const _MatchImplementation(\n      String this.pattern,\n      String this.str,\n      int this.start,\n      int this.end,\n      List<String> this._groups);\n\n  String group(int index) => _groups[index];\n  String operator [](int index) => group(index);\n  int get groupCount => _groups.length - 1;\n\n  List<String> groups(List<int> groups) {\n    List<String> out = [];\n    for (int i in groups) {\n      out.add(group(i));\n    }\n    return out;\n  }\n}\n\nclass _AllMatchesIterable extends IterableBase<Match> {\n  final JSSyntaxRegExp _re;\n  final String _str;\n\n  const _AllMatchesIterable(this._re, this._str);\n\n  Iterator<Match> get iterator => new _AllMatchesIterator(_re, _str);\n}\n\nclass _AllMatchesIterator implements Iterator<Match> {\n  final RegExp _re;\n  final String _str;\n  Match _current;\n\n  _AllMatchesIterator(JSSyntaxRegExp re, String this._str)\n    : _re = new JSSyntaxRegExp._globalVersionOf(re);\n\n  Match get current => _current;\n\n  bool moveNext() {\n    // firstMatch actually acts as nextMatch because of\n    // hidden global flag.\n    _current = _re.firstMatch(_str);\n    return _current != null;\n  }\n}\n","sdk/lib/_internal/compiler/implementation/lib/scalarlist_patch.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// This is an empty dummy patch file for the VM dart:scalarlist library.\n// This is needed in order to be able to generate documentation for the\n// scalarlist library.\n\npatch class Int8List {\n  patch factory Int8List(int length) {\n    throw new UnsupportedError('Int8List');\n  }\n\n  patch factory Int8List.view(ByteArray array, [int start = 0, int length]) {\n    throw new UnsupportedError('Int8List.view');\n  }\n}\n\n\npatch class Uint8List {\n  patch factory Uint8List(int length) {\n    throw new UnsupportedError('Uint8List');\n  }\n\n  patch factory Uint8List.view(ByteArray array,\n                               [int start = 0, int length]) {\n    throw new UnsupportedError('Uint8List.view');\n  }\n}\n\n\npatch class Uint8ClampedList {\n  patch factory Uint8ClampedList(int length) {\n    throw new UnsupportedError('Uint8ClampedList');\n  }\n\n  patch factory Uint8ClampedList.view(ByteArray array,\n                                      [int start = 0, int length]) {\n    throw new UnsupportedError('Uint8ClampedList.view');\n  }\n}\n\n\npatch class Int16List {\n  patch factory Int16List(int length) {\n    throw new UnsupportedError('Int16List');\n\n  }\n\n  patch factory Int16List.view(ByteArray array, [int start = 0, int length]) {\n    throw new UnsupportedError('Int16List.view');\n  }\n}\n\n\npatch class Uint16List {\n  patch factory Uint16List(int length) {\n    throw new UnsupportedError('Uint16List');\n  }\n\n  patch factory Uint16List.view(ByteArray array, [int start = 0, int length]) {\n    throw new UnsupportedError('Uint16List.view');\n  }\n}\n\n\npatch class Int32List {\n  patch factory Int32List(int length) {\n    throw new UnsupportedError('Int32List');\n  }\n\n  patch factory Int32List.view(ByteArray array, [int start = 0, int length]) {\n    throw new UnsupportedError('Int32List.view');\n  }\n}\n\n\npatch class Uint32List {\n  patch factory Uint32List(int length) {\n    throw new UnsupportedError('Uint32List');\n  }\n\n  patch factory Uint32List.view(ByteArray array, [int start = 0, int length]) {\n    throw new UnsupportedError('Uint32List.view');\n  }\n}\n\n\npatch class Int64List {\n  patch factory Int64List(int length) {\n    throw new UnsupportedError('Int64List');\n  }\n\n  patch factory Int64List.view(ByteArray array, [int start = 0, int length]) {\n    throw new UnsupportedError('Int64List.view');\n  }\n}\n\n\npatch class Uint64List {\n  patch factory Uint64List(int length) {\n    throw new UnsupportedError('Uint64List');\n  }\n\n  patch factory Uint64List.view(ByteArray array, [int start = 0, int length]) {\n    throw new UnsupportedError('Uint64List.view');\n  }\n}\n\n\npatch class Float32List {\n  patch factory Float32List(int length) {\n    throw new UnsupportedError('Float32List');\n  }\n\n  patch factory Float32List.view(ByteArray array, [int start = 0, int length]) {\n    throw new UnsupportedError('Float32List.view');\n  }\n}\n\n\npatch class Float64List {\n  patch factory Float64List(int length) {\n    throw new UnsupportedError('Float64List');\n  }\n\n  patch factory Float64List.view(ByteArray array, [int start = 0, int length]) {\n    throw new UnsupportedError('Float64List.view');\n  }\n}\n","sdk/lib/_internal/compiler/implementation/lib/string_helper.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _js_helper;\n\nclass StringMatch implements Match {\n  const StringMatch(int this.start,\n                    String this.str,\n                    String this.pattern);\n\n  int get end => start + pattern.length;\n  String operator[](int g) => group(g);\n  int get groupCount => 0;\n\n  String group(int group_) {\n    if (group_ != 0) {\n      throw new RangeError.value(group_);\n    }\n    return pattern;\n  }\n\n  List<String> groups(List<int> groups_) {\n    List<String> result = new List<String>();\n    for (int g in groups_) {\n      result.add(group(g));\n    }\n    return result;\n  }\n\n  final int start;\n  final String str;\n  final String pattern;\n}\n\nList<Match> allMatchesInStringUnchecked(String needle, String haystack) {\n  // Copied from StringBase.allMatches in\n  // /runtime/lib/string_base.dart\n  List<Match> result = new List<Match>();\n  int length = haystack.length;\n  int patternLength = needle.length;\n  int startIndex = 0;\n  while (true) {\n    int position = haystack.indexOf(needle, startIndex);\n    if (position == -1) {\n      break;\n    }\n    result.add(new StringMatch(position, haystack, needle));\n    int endIndex = position + patternLength;\n    if (endIndex == length) {\n      break;\n    } else if (position == endIndex) {\n      ++startIndex;  // empty match, advance and restart\n    } else {\n      startIndex = endIndex;\n    }\n  }\n  return result;\n}\n\nstringContainsUnchecked(receiver, other, startIndex) {\n  if (other is String) {\n    return receiver.indexOf(other, startIndex) != -1;\n  } else if (other is JSSyntaxRegExp) {\n    return other.hasMatch(receiver.substring(startIndex));\n  } else {\n    var substr = receiver.substring(startIndex);\n    return other.allMatches(substr).iterator.moveNext();\n  }\n}\n\nstringReplaceJS(receiver, replacer, to) {\n  // The JavaScript String.replace method recognizes replacement\n  // patterns in the replacement string. Dart does not have that\n  // behavior.\n  to = JS('String', r'#.replace(\"$\", \"$$$$\")', to);\n  return JS('String', r'#.replace(#, #)', receiver, replacer, to);\n}\n\nstringReplaceAllUnchecked(receiver, from, to) {\n  checkString(to);\n  if (from is String) {\n    if (from == \"\") {\n      if (receiver == \"\") {\n        return to;\n      } else {\n        StringBuffer result = new StringBuffer();\n        int length = receiver.length;\n        result.write(to);\n        for (int i = 0; i < length; i++) {\n          result.write(receiver[i]);\n          result.write(to);\n        }\n        return result.toString();\n      }\n    } else {\n      var quoter = JS('', \"new RegExp(#, 'g')\", r'[-[\\]{}()*+?.,\\\\^$|#\\s]');\n      var quoted = JS('String', r'#.replace(#, \"\\\\$&\")', from, quoter);\n      var replacer = JS('', \"new RegExp(#, 'g')\", quoted);\n      return stringReplaceJS(receiver, replacer, to);\n    }\n  } else if (from is JSSyntaxRegExp) {\n    var re = new JSSyntaxRegExp._globalVersionOf(from);\n    return stringReplaceJS(receiver, re._nativeRegExp, to);\n  } else {\n    checkNull(from);\n    // TODO(floitsch): implement generic String.replace (with patterns).\n    throw \"String.replaceAll(Pattern) UNIMPLEMENTED\";\n  }\n}\n\nString _matchString(Match match) => match[0];\nString _stringIdentity(String string) => string;\n\nstringReplaceAllFuncUnchecked(receiver, pattern, onMatch, onNonMatch) {\n  if (pattern is! Pattern) {\n    throw new ArgumentError(\"${pattern} is not a Pattern\");\n  }\n  if (onMatch == null) onMatch = _matchString;\n  if (onNonMatch == null) onNonMatch = _stringIdentity;\n  if (pattern is String) {\n    return stringReplaceAllStringFuncUnchecked(receiver, pattern,\n                                               onMatch, onNonMatch);\n  }\n  StringBuffer buffer = new StringBuffer();\n  int startIndex = 0;\n  for (Match match in pattern.allMatches(receiver)) {\n    buffer.write(onNonMatch(receiver.substring(startIndex, match.start)));\n    buffer.write(onMatch(match));\n    startIndex = match.end;\n  }\n  buffer.write(onNonMatch(receiver.substring(startIndex)));\n  return buffer.toString();\n}\n\nstringReplaceAllEmptyFuncUnchecked(receiver, onMatch, onNonMatch) {\n  // Pattern is the empty string.\n  StringBuffer buffer = new StringBuffer();\n  int length = receiver.length;\n  int i = 0;\n  buffer.write(onNonMatch(\"\"));\n  while (i < length) {\n    buffer.write(onMatch(new StringMatch(i, receiver, \"\")));\n    // Special case to avoid splitting a surrogate pair.\n    int code = receiver.codeUnitAt(i);\n    if ((code & ~0x3FF) == 0xD800 && length > i + 1) {\n      // Leading surrogate;\n      code = receiver.codeUnitAt(i + 1);\n      if ((code & ~0x3FF) == 0xDC00) {\n        // Matching trailing surrogate.\n        buffer.write(onNonMatch(receiver.substring(i, i + 2)));\n        i += 2;\n        continue;\n      }\n    }\n    buffer.write(onNonMatch(receiver[i]));\n    i++;\n  }\n  buffer.write(onMatch(new StringMatch(i, receiver, \"\")));\n  buffer.write(onNonMatch(\"\"));\n  return buffer.toString();\n}\n\nstringReplaceAllStringFuncUnchecked(receiver, pattern, onMatch, onNonMatch) {\n  int patternLength = pattern.length;\n  if (patternLength == 0) {\n    return stringReplaceAllEmptyFuncUnchecked(receiver, onMatch, onNonMatch);\n  }\n  int length = receiver.length;\n  StringBuffer buffer = new StringBuffer();\n  int startIndex = 0;\n  while (startIndex < length) {\n    int position = receiver.indexOf(pattern, startIndex);\n    if (position == -1) {\n      break;\n    }\n    buffer.write(onNonMatch(receiver.substring(startIndex, position)));\n    buffer.write(onMatch(new StringMatch(position, receiver, pattern)));\n    startIndex = position + patternLength;\n  }\n  buffer.write(onNonMatch(receiver.substring(startIndex)));\n  return buffer.toString();\n}\n\n\nstringReplaceFirstUnchecked(receiver, from, to) {\n  if (from is String) {\n    return stringReplaceJS(receiver, from, to);\n  } else if (from is JSSyntaxRegExp) {\n    var re = regExpGetNative(from);\n    return stringReplaceJS(receiver, re, to);\n  } else {\n    checkNull(from);\n    // TODO(floitsch): implement generic String.replace (with patterns).\n    throw \"String.replace(Pattern) UNIMPLEMENTED\";\n  }\n}\n\nstringJoinUnchecked(array, separator) {\n  return JS('String', r'#.join(#)', array, separator);\n}\n","sdk/lib/_internal/compiler/implementation/lib/typed_data_patch.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// This is an empty dummy patch file for the VM dart:typed_data library.\n// This is needed in order to be able to generate documentation for the\n// typed_data library.\n\npatch class Int8List {\n  patch factory Int8List(int length) {\n    throw new UnsupportedError('Int8List');\n  }\n\n  patch factory Int8List.fromList(List<int> elements) {\n    throw new UnsupportedError('Int8List.fromList');\n  }\n\n  patch factory Int8List.view(ByteBuffer buffer,\n                              [int offsetInBytes = 0, int length]) {\n    throw new UnsupportedError('Int8List.view');\n  }\n}\n\n\npatch class Uint8List {\n  patch factory Uint8List(int length) {\n    throw new UnsupportedError('Uint8List');\n  }\n\n  patch factory Uint8List.fromList(List<int> elements) {\n    throw new UnsupportedError('Uint8List.fromList');\n  }\n\n  patch factory Uint8List.view(ByteBuffer buffer,\n                               [int offsetInBytes = 0, int length]) {\n    throw new UnsupportedError('Uint8List.view');\n  }\n}\n\n\npatch class Uint8ClampedList {\n  patch factory Uint8ClampedList(int length) {\n    throw new UnsupportedError('Uint8ClampedList');\n  }\n\n  patch factory Uint8ClampedList.fromList(List<int> elements) {\n    throw new UnsupportedError('Uint8ClampedList.fromList');\n  }\n\n  patch factory Uint8ClampedList.view(ByteBuffer buffer,\n                                      [int offsetInBytes = 0, int length]) {\n    throw new UnsupportedError('Uint8ClampedList.view');\n  }\n}\n\n\npatch class Int16List {\n  patch factory Int16List(int length) {\n    throw new UnsupportedError('Int16List');\n\n  }\n\n  patch factory Int16List.fromList(List<int> elements) {\n    throw new UnsupportedError('Int16List.fromList');\n  }\n\n  patch factory Int16List.view(ByteBuffer buffer,\n                               [int offsetInBytes = 0, int length]) {\n    throw new UnsupportedError('Int16List.view');\n  }\n}\n\n\npatch class Uint16List {\n  patch factory Uint16List(int length) {\n    throw new UnsupportedError('Uint16List');\n  }\n\n  patch factory Uint16List.fromList(List<int> elements) {\n    throw new UnsupportedError('Uint16List.fromList');\n  }\n\n  patch factory Uint16List.view(ByteBuffer buffer,\n                                [int offsetInBytes = 0, int length]) {\n    throw new UnsupportedError('Uint16List.view');\n  }\n}\n\n\npatch class Int32List {\n  patch factory Int32List(int length) {\n    throw new UnsupportedError('Int32List');\n  }\n\n  patch factory Int32List.fromList(List<int> elements) {\n    throw new UnsupportedError('Int32List.fromList');\n  }\n\n  patch factory Int32List.view(ByteBuffer buffer,\n                               [int offsetInBytes = 0, int length]) {\n    throw new UnsupportedError('Int32List.view');\n  }\n}\n\n\npatch class Uint32List {\n  patch factory Uint32List(int length) {\n    throw new UnsupportedError('Uint32List');\n  }\n\n  patch factory Uint32List.fromList(List<int> elements) {\n    throw new UnsupportedError('Uint32List.fromList');\n  }\n\n  patch factory Uint32List.view(ByteBuffer buffer,\n                                [int offsetInBytes = 0, int length]) {\n    throw new UnsupportedError('Uint32List.view');\n  }\n}\n\n\npatch class Int64List {\n  patch factory Int64List(int length) {\n    throw new UnsupportedError('Int64List');\n  }\n\n  patch factory Int64List.fromList(List<int> elements) {\n    throw new UnsupportedError('Int64List.fromList');\n  }\n\n  patch factory Int64List.view(ByteBuffer buffer,\n                               [int offsetInBytes = 0, int length]) {\n    throw new UnsupportedError('Int64List.view');\n  }\n}\n\n\npatch class Uint64List {\n  patch factory Uint64List(int length) {\n    throw new UnsupportedError('Uint64List');\n  }\n\n  patch factory Uint64List.fromList(List<int> elements) {\n    throw new UnsupportedError('Uint64List.fromList');\n  }\n\n  patch factory Uint64List.view(ByteBuffer buffer,\n                                [int offsetInBytes = 0, int length]) {\n    throw new UnsupportedError('Uint64List.view');\n  }\n}\n\n\npatch class Float32List {\n  patch factory Float32List(int length) {\n    throw new UnsupportedError('Float32List');\n  }\n\n  patch factory Float32List.fromList(List<double> elements) {\n    throw new UnsupportedError('Float32List.fromList');\n  }\n\n  patch factory Float32List.view(ByteBuffer buffer,\n                                 [int offsetInBytes = 0, int length]) {\n    throw new UnsupportedError('Float32List.view');\n  }\n}\n\n\npatch class Float64List {\n  patch factory Float64List(int length) {\n    throw new UnsupportedError('Float64List');\n  }\n\n  patch factory Float64List.fromList(List<double> elements) {\n    throw new UnsupportedError('Float64List.fromList');\n  }\n\n  patch factory Float64List.view(ByteBuffer buffer,\n                                 [int offsetInBytes = 0, int length]) {\n    throw new UnsupportedError('Float64List.view');\n  }\n}\n\n\npatch class Float32x4List {\n  patch factory Float32x4List(int length) {\n    throw new UnsupportedError('Float32x4List');\n  }\n\n  patch factory Float32x4List.view(ByteBuffer buffer,\n                                      [int offsetInBytes = 0, int length]) {\n    throw new UnsupportedError('Float32x4List.view');\n  }\n}\n\n\npatch class Float32x4 {\n  patch factory Float32x4(double x, double y, double z, double w) {\n    throw new UnsupportedError('Float32x4');\n  }\n  patch factory Float32x4.zero() {\n    throw new UnsupportedError('Float32x4.zero');\n  }\n}\n\n\npatch class Uint32x4 {\n  patch factory Uint32x4(int x, int y, int z, int w) {\n    throw new UnsupportedError('Uint32x4');\n  }\n  patch factory Uint32x4.bool(bool x, bool y, bool z, bool w) {\n    throw new UnsupportedError('Uint32x4.bool');\n  }\n}\n\n\npatch class ByteData {\n  patch factory ByteData(int length) {\n    throw new UnsupportedError('ByteData');\n  }\n\n  patch factory ByteData.view(ByteBuffer buffer,\n                              [int offsetInBytes = 0, int length]) {\n    throw new UnsupportedError('ByteData.view');\n  }\n}\n","sdk/lib/_internal/libraries.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary libraries;\n\n/**\n * A bit flag used by [LibraryInfo] indicating that a library is used by dart2js\n */\nconst int DART2JS_PLATFORM = 1;\n\n/**\n * A bit flag used by [LibraryInfo] indicating that a library is used by the VM\n */\nconst int VM_PLATFORM = 2;\n\n/**\n * Mapping of \"dart:\" library name (e.g. \"core\") to information about that library.\n * This information is structured such that Dart Editor can parse this file\n * and extract the necessary information without executing it\n * while other tools can access via execution.\n */\nconst Map<String, LibraryInfo> LIBRARIES = const {\n\n  \"async\": const LibraryInfo(\n      \"async/async.dart\",\n      dart2jsPatchPath: \"_internal/compiler/implementation/lib/async_patch.dart\"),\n\n  \"chrome\": const LibraryInfo(\n      \"chrome/dart2js/chrome_dart2js.dart\",\n      category: \"Client\"),\n\n  \"collection\": const LibraryInfo(\n      \"collection/collection.dart\",\n      dart2jsPatchPath: \"_internal/compiler/implementation/lib/collection_patch.dart\"),\n\n  \"core\": const LibraryInfo(\n      \"core/core.dart\",\n      dart2jsPatchPath: \"_internal/compiler/implementation/lib/core_patch.dart\"),\n\n  \"crypto\": const LibraryInfo(\n      \"crypto/crypto.dart\"),\n\n  \"html\": const LibraryInfo(\n      \"html/dartium/html_dartium.dart\",\n      category: \"Client\",\n      dart2jsPath: \"html/dart2js/html_dart2js.dart\"),\n\n  \"html_common\": const LibraryInfo(\n      \"html/html_common/html_common.dart\",\n      category: \"Client\",\n      dart2jsPath: \"html/html_common/html_common_dart2js.dart\",\n      documented: false,\n      implementation: true),\n\n  \"indexed_db\": const LibraryInfo(\n      \"indexed_db/dartium/indexed_db_dartium.dart\",\n      category: \"Client\",\n      dart2jsPath: \"indexed_db/dart2js/indexed_db_dart2js.dart\"),\n\n  \"io\": const LibraryInfo(\n      \"io/io.dart\",\n      category: \"Server\",\n      dart2jsPatchPath: \"_internal/compiler/implementation/lib/io_patch.dart\"),\n\n  \"isolate\": const LibraryInfo(\n      \"isolate/isolate.dart\",\n      dart2jsPatchPath: \"_internal/compiler/implementation/lib/isolate_patch.dart\"),\n\n  \"json\": const LibraryInfo(\n      \"json/json.dart\",\n      dart2jsPatchPath: \"_internal/compiler/implementation/lib/json_patch.dart\"),\n\n  \"math\": const LibraryInfo(\n      \"math/math.dart\",\n      dart2jsPatchPath: \"_internal/compiler/implementation/lib/math_patch.dart\"),\n\n  \"mirrors\": const LibraryInfo(\n      \"mirrors/mirrors.dart\",\n      dart2jsPatchPath: \"_internal/compiler/implementation/lib/mirrors_patch.dart\"),\n\n  \"nativewrappers\": const LibraryInfo(\n      \"html/dartium/nativewrappers.dart\",\n      category: \"Client\",\n      implementation: true,\n      documented: false,\n      platforms: VM_PLATFORM),\n\n  \"typed_data\": const LibraryInfo(\n      \"typed_data/typed_data.dart\",\n      dart2jsPath: \"typed_data/dart2js/typed_data_dart2js.dart\"),\n\n  \"svg\": const LibraryInfo(\n        \"svg/dartium/svg_dartium.dart\",\n        category: \"Client\",\n        dart2jsPath: \"svg/dart2js/svg_dart2js.dart\"),\n\n  \"uri\": const LibraryInfo(\n      \"uri/uri.dart\"),\n\n  \"utf\": const LibraryInfo(\n      \"utf/utf.dart\"),\n\n  \"web_audio\": const LibraryInfo(\n        \"web_audio/dartium/web_audio_dartium.dart\",\n        category: \"Client\",\n        dart2jsPath: \"web_audio/dart2js/web_audio_dart2js.dart\"),\n\n  \"web_gl\": const LibraryInfo(\n        \"web_gl/dartium/web_gl_dartium.dart\",\n        category: \"Client\",\n        dart2jsPath: \"web_gl/dart2js/web_gl_dart2js.dart\"),\n\n  \"web_sql\": const LibraryInfo(\n        \"web_sql/dartium/web_sql_dartium.dart\",\n        category: \"Client\",\n        dart2jsPath: \"web_sql/dart2js/web_sql_dart2js.dart\"),\n\n  \"_collection-dev\": const LibraryInfo(\n      \"_collection_dev/collection_dev.dart\",\n      category: \"Internal\",\n      documented: false,\n      dart2jsPatchPath:\n          \"_internal/compiler/implementation/lib/collection_dev_patch.dart\"),\n\n  \"_js_helper\": const LibraryInfo(\n      \"_internal/compiler/implementation/lib/js_helper.dart\",\n      category: \"Internal\",\n      documented: false,\n      platforms: DART2JS_PLATFORM),\n\n  \"_interceptors\": const LibraryInfo(\n      \"_internal/compiler/implementation/lib/interceptors.dart\",\n      category: \"Internal\",\n      documented: false,\n      platforms: DART2JS_PLATFORM),\n\n  \"_foreign_helper\": const LibraryInfo(\n      \"_internal/compiler/implementation/lib/foreign_helper.dart\",\n      category: \"Internal\",\n      documented: false,\n      platforms: DART2JS_PLATFORM),\n\n  \"_isolate_helper\": const LibraryInfo(\n      \"_internal/compiler/implementation/lib/isolate_helper.dart\",\n      category: \"Internal\",\n      documented: false,\n      platforms: DART2JS_PLATFORM),\n};\n\n/**\n * Information about a \"dart:\" library.\n */\nclass LibraryInfo {\n\n  /**\n   * Path to the library's *.dart file relative to this file.\n   */\n  final String path;\n\n  /**\n   * The category in which the library should appear in the editor\n   * (e.g. \"Shared\", \"Client\", \"Server\", ...).\n   * If a category is not specified it defaults to \"Shared\".\n   */\n  final String category;\n\n  /**\n   * Path to the dart2js library's *.dart file relative to this file\n   * or null if dart2js uses the common library path defined above.\n   * Access using the [#getDart2JsPath()] method.\n   */\n  final String dart2jsPath;\n\n  /**\n   * Path to the dart2js library's patch file relative to this file\n   * or null if no dart2js patch file associated with this library.\n   * Access using the [#getDart2JsPatchPath()] method.\n   */\n  final String dart2jsPatchPath;\n\n  /**\n   * True if this library is documented and should be shown to the user.\n   */\n  final bool documented;\n\n  /**\n   * Bit flags indicating which platforms consume this library.\n   * See [DART2JS_LIBRARY] and [VM_LIBRARY].\n   */\n  final int platforms;\n\n  /**\n   * True if the library contains implementation details for another library.\n   * The implication is that these libraries are less commonly used\n   * and that tools like Dart Editor should not show these libraries\n   * in a list of all libraries unless the user specifically asks the tool to\n   * do so.\n   */\n  final bool implementation;\n\n  const LibraryInfo(this.path, {\n                    this.category: \"Shared\",\n                    this.dart2jsPath,\n                    this.dart2jsPatchPath,\n                    this.implementation: false,\n                    this.documented: true,\n                    this.platforms: DART2JS_PLATFORM | VM_PLATFORM});\n\n  bool get isDart2jsLibrary => (platforms & DART2JS_PLATFORM) != 0;\n  bool get isVmLibrary => (platforms & VM_PLATFORM) != 0;\n}\n","sdk/lib/async/async.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart.async;\n\npart 'async_error.dart';\npart 'deferred_load.dart';\npart 'event_loop.dart';\npart 'future.dart';\npart 'future_impl.dart';\npart 'stream.dart';\npart 'stream_controller.dart';\npart 'stream_impl.dart';\npart 'stream_pipe.dart';\npart 'timer.dart';\n","sdk/lib/async/async_error.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\nfinal Expando _stackTraceExpando = new Expando(\"asynchronous error\");\n\nvoid _attachStackTrace(o, st) {\n  if (o == null || o is bool || o is num || o is String) return;\n  _stackTraceExpando[o] = st;\n}\n\n/**\n * *This is an experimental API.*\n *\n * Get the [StackTrace] attached to [o].\n *\n * If object [o] was thrown and caught in a dart:async method, a [StackTrace]\n * object was attached to it. Use [getAttachedStackTrace] to get that object.\n *\n * Returns [null] if no [StackTrace] was attached.\n */\ngetAttachedStackTrace(o) {\n  if (o == null || o is bool || o is num || o is String) return null;\n  return _stackTraceExpando[o];\n}\n","sdk/lib/async/deferred_load.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n/**\n * Indicates that loading of [libraryName] is deferred.\n *\n * Applies to library imports, when used as metadata.\n *\n * Example usage:\n *\n *     @lazy\n *     import 'foo.dart' as foo;\n *\n *     const lazy = const DeferredLibrary('com.example.foo');\n *\n *     void main() {\n *       foo.method(); // Throws a NoSuchMethodError, foo is not loaded yet.\n *       lazy.load().then(onFooLoaded);\n *     }\n *\n *     void onFooLoaded(_) {\n *       foo.method();\n *     }\n */\nclass DeferredLibrary {\n  final String libraryName;\n  final String uri;\n\n  const DeferredLibrary(this.libraryName, {this.uri});\n\n  /**\n   * Ensure that [libraryName] has been loaded.\n   *\n   * The value of the returned future is true if this invocation of\n   * [load] caused the library to be loaded.\n   */\n  external Future<bool> load();\n}\n","sdk/lib/async/event_loop.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\ntypedef void _AsyncCallback();\n\nbool _callbacksAreEnqueued = false;\nList<_AsyncCallback> _asyncCallbacks = <_AsyncCallback>[];\n\nvoid _asyncRunCallback() {\n  // As long as we are iterating over the registered callbacks we don't\n  // unset the [_callbacksAreEnqueued] boolean.\n  while (!_asyncCallbacks.isEmpty) {\n    List callbacks = _asyncCallbacks;\n    // The callbacks we execute can register new callbacks. This means that\n    // the for-loop below could grow the list if we don't replace it here.\n    _asyncCallbacks = <_AsyncCallback>[];\n    for (int i = 0; i < callbacks.length; i++) {\n      Function callback = callbacks[i];\n      callbacks[i] = null;\n      try {\n        callback();\n      } catch (e) {\n        i++;  // Skip current callback.\n        List remainingCallbacks = callbacks.sublist(i);\n        List newCallbacks = _asyncCallbacks;\n        _asyncCallbacks = <_AsyncCallback>[];\n        _asyncCallbacks.addAll(remainingCallbacks);\n        _asyncCallbacks.addAll(newCallbacks);\n        _AsyncRun._enqueueImmediate(_asyncRunCallback);\n        throw;\n      }\n    }\n  }\n  // Any new callback must register a callback function now.\n  _callbacksAreEnqueued = false;\n}\n\n/**\n * Runs the given [callback] asynchronously.\n *\n * Callbacks registered through this function are always executed in order and\n * are guaranteed to run before other asynchronous events (like [Timer] events,\n * or DOM events).\n *\n * Warning: it is possible to starve the DOM by registering asynchronous\n * callbacks through this method. For example the following program will\n * run the callbacks without ever giving the Timer callback a chance to execute:\n *\n *     Timer.run(() { print(\"executed\"); });  // Will never be executed;\n *     foo() {\n *       asyncRun(foo);  // Schedules [foo] in front of other events.\n *     }\n *     main() {\n *       foo();\n *     }\n */\nvoid runAsync(void callback()) {\n  // Optimizing a group of Timer.run callbacks to be executed in the\n  // same Timer callback.\n  _asyncCallbacks.add(callback);\n  if (!_callbacksAreEnqueued) {\n    _AsyncRun._enqueueImmediate(_asyncRunCallback);\n    _callbacksAreEnqueued = true;\n  }\n}\n\nclass _AsyncRun {\n  /** Enqueues the given callback before any other event in the event-loop. */\n  external static void _enqueueImmediate(void callback());\n}\n","sdk/lib/async/future.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n/**\n * A [Future] represents a delayed computation. It is used to obtain a not-yet\n * available value, or error, sometime in the future.  Receivers of a\n * [Future] can register callbacks that handle the value or error once it is\n * available. For example:\n *\n *     Future<int> future = getFuture();\n *     future.then((value) => handleValue(value))\n *           .catchError((error) => handleError(error));\n *\n * A [Future] can be completed in two ways: with a value (\"the future succeeds\")\n * or with an error (\"the future fails\"). Users can install callbacks for each\n * case. The result of registering a pair of callbacks is a new Future (the\n * \"successor\") which in turn is completed with the result of invoking the\n * corresponding callback. The successor is completed with an error if the\n * invoked callback throws. For example:\n *\n *     Future<int> successor = future.then((int value) {\n *         // Invoked when the future is completed with a value.\n *         return 42;  // The successor is completed with the value 42.\n *       },\n *       onError: (e) {\n *         // Invoked when the future is completed with an error.\n *         if (canHandle(e)) {\n *           return 499;  // The successor is completed with the value 499.\n *         } else {\n *           throw e;  // The successor is completed with the error e.\n *         }\n *       });\n *\n * If a future does not have a successor but is completed with an error, it\n * forwards the error message to the global error-handler. This special casing\n * makes sure that no error is silently dropped. However, it also means that\n * error handlers should be installed early, so that they are present as soon\n * as a future is completed with an error. The following example demonstrates\n * this potential bug:\n *\n *     var future = getFuture();\n *     new Timer(new Duration(milliseconds: 5), () {\n *       // The error-handler is only attached 5ms after the future has been\n *       // received. If the future fails in the mean-time it will forward the\n *       // error to the global error-handler, even though there is code (just\n *       // below) to handle the error.\n *       future.then((value) { useValue(value); },\n *                   onError: (e) { handleError(e); });\n *     });\n *\n * In general we discourage registering the two callbacks at the same time, but\n * prefer to use [then] with one argument (the value handler), and to use\n * [catchError] for handling errors. The missing callbacks (the error-handler\n * for [then], and the value-handler for [catchError]), are automatically\n * configured to \"forward\" the value/error. Separating value and error-handling\n * into separate registration calls usually leads to code that is easier to\n * reason about. In fact it makes asynchronous code very similar to synchronous\n * code:\n *\n *     // Synchronous code.\n *     try {\n *       int value = foo();\n *       return bar(value);\n *     } catch (e) {\n *       return 499;\n *     }\n *\n *  Equivalent asynchronous code, based on futures:\n *\n *     Future<int> future = foo();  // foo now returns a future.\n *     future.then((int value) => bar(value))\n *           .catchError((e) => 499);\n *\n * Similar to the synchronous code, the error handler (registered with\n * [catchError]) is handling the errors for exceptions coming from calls to\n * 'foo', as well as 'bar'. This would not be the case if the error-handler was\n * registered at the same time as the value-handler.\n *\n * Futures can have more than one callback-pairs registered. Each successor is\n * treated independently and is handled as if it was the only successor.\n */\n// TODO(floitsch): document chaining.\nabstract class Future<T> {\n\n  /**\n   * Creates a future containing the result of calling [computation]\n   * asynchronously with [runAsync].\n   *\n   * if the result of executing [computation] throws, the returned future is\n   * completed with the error. If a thrown value is an [AsyncError], it is used\n   * directly, instead of wrapping this error again in another [AsyncError].\n   *\n   * If the returned value is itself a [Future], completion of\n   * the created future will wait until the returned future completes,\n   * and will then complete with the same result.\n   *\n   * If a value is returned, it becomes the result of the created future.\n   */\n  factory Future(computation()) {\n    _ThenFuture<dynamic, T> future =\n        new _ThenFuture<dynamic, T>((_) => computation());\n    runAsync(() => future._sendValue(null));\n    return future;\n  }\n\n  /**\n   * Creates a future containing the result of immediately calling\n   * [computation].\n   *\n   * if the result of executing [computation] throws, the returned future is\n   * completed with the error. If a thrown value is an [AsyncError], it is used\n   * directly, instead of wrapping this error again in another [AsyncError].\n   *\n   * If the returned value is itself a [Future], completion of\n   * the created future will wait until the returned future completes,\n   * and will then complete with the same result.\n   */\n  factory Future.sync(computation()) {\n    try {\n      var result = computation();\n      return new _FutureImpl<T>().._setOrChainValue(result);\n    } catch (error, stackTrace) {\n      return new _FutureImpl<T>.immediateError(error, stackTrace);\n    }\n  }\n\n  /**\n   * A future whose value is available in the next event-loop iteration.\n   *\n   * If [value] is not a [Future], using this constructor is equivalent\n   * to [:new Future.sync(() => value):].\n   *\n   * See [Completer] to create a Future and complete it later.\n   */\n  factory Future.value([T value]) => new _FutureImpl<T>.immediate(value);\n\n  /**\n   * A future that completes with an error in the next event-loop iteration.\n   *\n   * See [Completer] to create a Future and complete it later.\n   */\n  factory Future.error(var error, [Object stackTrace]) {\n    return new _FutureImpl<T>.immediateError(error, stackTrace);\n  }\n\n  /**\n   * Creates a future that completes after a delay.\n   *\n   * The future will be completed after the given [duration] has passed with\n   * the result of calling [computation]. If the duration is 0 or less, it\n   * completes no sooner than in the next event-loop iteration.\n   *\n   * If [computation] is not given or [:null:] then it will behave as if\n   * [computation] was set to [:() => null:]. That is, it will complete with\n   * [:null:].\n   *\n   * If calling [computation] throws, the created future will complete with the\n   * error.\n   *\n   * See [Completer]s, for futures with values that are computed asynchronously.\n   */\n  factory Future.delayed(Duration duration, [T computation()]) {\n    // TODO(floitsch): no need to allocate a ThenFuture when the computation is\n    // null.\n    if (computation == null) computation = (() => null);\n    _ThenFuture<dynamic, T> future =\n        new _ThenFuture<dynamic, T>((_) => computation());\n    new Timer(duration, () => future._sendValue(null));\n    return future;\n  }\n\n  /**\n   * Wait for all the given futures to complete and collect their values.\n   *\n   * Returns a future which will complete once all the futures in a list are\n   * complete. If any of the futures in the list completes with an error,\n   * the resulting future also completes with an error. Otherwise the value\n   * of the returned future will be a list of all the values that were produced.\n   */\n  static Future<List> wait(Iterable<Future> futures) {\n    return new _FutureImpl<List>.wait(futures);\n  }\n\n  /**\n   * Perform an async operation for each element of the iterable, in turn.\n   *\n   * Runs [f] for each element in [input] in order, moving to the next element\n   * only when the [Future] returned by [f] completes. Returns a [Future] that\n   * completes when all elements have been processed.\n   *\n   * The return values of all [Future]s are discarded. Any errors will cause the\n   * iteration to stop and will be piped through the returned [Future].\n   */\n  static Future forEach(Iterable input, Future f(element)) {\n    _FutureImpl doneSignal = new _FutureImpl();\n    Iterator iterator = input.iterator;\n    void nextElement(_) {\n      if (iterator.moveNext()) {\n        new Future.sync(() => f(iterator.current))\n            .then(nextElement, onError: doneSignal._setError);\n      } else {\n        doneSignal._setValue(null);\n      }\n    }\n    nextElement(null);\n    return doneSignal;\n  }\n\n  /**\n   * When this future completes with a value, then [onValue] is called with this\n   * value. If [this] future is already completed then the invocation of\n   * [onValue] is delayed until the next event-loop iteration.\n   *\n   * Returns a new [Future] `f` which is completed with the result of\n   * invoking [onValue] (if [this] completes with a value) or [onError] (if\n   * [this] completes with an error).\n   *\n   * If the invoked callback throws an exception, the returned future `f` is\n   * completed with the error.\n   *\n   * If the invoked callback returns a [Future] `f2` then `f` and `f2` are\n   * chained. That is, `f` is completed with the completion value of `f2`.\n   *\n   * If [onError] is not given, it is equivalent to `(e) { throw e; }`. That\n   * is, it forwards the error to `f`.\n   *\n   * In most cases, it is more readable to use [catchError] separately, possibly\n   * with a `test` parameter, instead of handling both value and error in a\n   * single [then] call.\n   */\n  Future then(onValue(T value), { onError(Object error) });\n\n  /**\n   * Handles errors emitted by this [Future].\n   *\n   * Returns a new [Future] `f`.\n   *\n   * When [this] completes with a value, the value is forwarded to `f`\n   * unmodified. That is, `f` completes with the same value.\n   *\n   * When [this] completes with an error, [test] is called with the\n   * error's value. If the invocation returns [true], [onError] is called with\n   * the error. The result of [onError] is handled exactly the same as for\n   * [then]'s [onError].\n   *\n   * If [test] returns false, the exception is not handled by [onError], but is\n   * thrown unmodified, thus forwarding it to `f`.\n   *\n   * If [test] is omitted, it defaults to a function that always returns true.\n   *\n   * Example:\n   *\n   *     foo\n   *       .catchError(..., test: (e) => e is ArgumentError)\n   *       .catchError(..., test: (e) => e is NoSuchMethodError)\n   *       .then((v) { ... });\n   *\n   * This method is equivalent to:\n   *\n   *     Future catchError(onError(error),\n   *                       {bool test(error)}) {\n   *       this.then((v) => v,  // Forward the value.\n   *                 // But handle errors, if the [test] succeeds.\n   *                 onError: (e) {\n   *                   if (test == null || test(e)) {\n   *                     return onError(e);\n   *                   }\n   *                   throw e;\n   *                 });\n   *     }\n   *\n   */\n  Future catchError(onError(Object error),\n                    {bool test(Object error)});\n\n  /**\n   * Register a function to be called when this future completes.\n   *\n   * The [action] function is called when this future completes, whether it\n   * does so with a value or with an error.\n   *\n   * This is the asynchronous equivalent of a \"finally\" block.\n   *\n   * The future returned by this call, `f`, will complete the same way\n   * as this future unless an error occurs in the [action] call, or in\n   * a [Future] returned by the [action] call. If the call to [action]\n   * does not return a future, its return value is ignored.\n   *\n   * If the call to [action] throws, then `f` is completed with the\n   * thrown error.\n   *\n   * If the call to [action] returns a [Future], `f2`, then completion of\n   * `f` is delayed until `f2` completes. If `f2` completes with\n   * an error, that will be the result of `f` too. The value of `f2` is always\n   * ignored.\n   *\n   * This method is equivalent to:\n   *\n   *     Future<T> whenComplete(action()) {\n   *       this.then((v) {\n   *                   var f2 = action();\n   *                   if (f2 is Future) return f2.then((_) => v);\n   *                   return v\n   *                 },\n   *                 onError: (e) {\n   *                   var f2 = action();\n   *                   if (f2 is Future) return f2.then((_) { throw e; });\n   *                   throw e;\n   *                 });\n   *     }\n   */\n  Future<T> whenComplete(action());\n\n  /**\n   * Creates a [Stream] that sends [this]' completion value, data or error, to\n   * its subscribers. The stream closes after the completion value.\n   */\n  Stream<T> asStream();\n}\n\n/**\n * A [Completer] is used to produce [Future]s and supply their value when it\n * becomes available.\n *\n * A service that provides values to callers, and wants to return [Future]s can\n * use a [Completer] as follows:\n *\n *     Completer completer = new Completer();\n *     // send future object back to client...\n *     return completer.future;\n *     ...\n *\n *     // later when value is available, call:\n *     completer.complete(value);\n *\n *     // alternatively, if the service cannot produce the value, it\n *     // can provide an error:\n *     completer.completeError(error);\n *\n */\nabstract class Completer<T> {\n\n  factory Completer() => new _CompleterImpl<T>();\n\n  /** The future that will contain the result provided to this completer. */\n  Future get future;\n\n  /**\n   * Completes [future] with the supplied values.\n   *\n   * All listeners on the future will be immediately informed about the value.\n   */\n  void complete([T value]);\n\n  /**\n   * Complete [future] with an error.\n   *\n   * Completing a future with an error indicates that an exception was thrown\n   * while trying to produce a value.\n   *\n   * The argument [exception] should not be `null`.\n   */\n  void completeError(Object exception, [Object stackTrace]);\n\n  /**\n   * Whether the future has been completed.\n   */\n  bool get isCompleted;\n}\n","sdk/lib/async/future_impl.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\ndeprecatedFutureValue(_FutureImpl future) =>\n  future._isComplete ? future._resultOrListeners : null;\n\nclass _CompleterImpl<T> implements Completer<T> {\n  final Future<T> future;\n  bool _isComplete = false;\n\n  _CompleterImpl() : future = new _FutureImpl<T>();\n\n  void complete([T value]) {\n    if (_isComplete) throw new StateError(\"Future already completed\");\n    _isComplete = true;\n    _FutureImpl future = this.future;\n    future._setValue(value);\n  }\n\n  void completeError(Object error, [Object stackTrace = null]) {\n    if (_isComplete) throw new StateError(\"Future already completed\");\n    _isComplete = true;\n    if (stackTrace != null) {\n      // Force the stack trace onto the error, even if it already had one.\n      _attachStackTrace(error, stackTrace);\n    }\n    _FutureImpl future = this.future;\n    future._setError(error);\n  }\n\n  bool get isCompleted => _isComplete;\n}\n\n/**\n * A listener on a future.\n *\n * When the future completes, the [_sendValue] or [_sendError] method\n * is invoked with the result.\n *\n * Listeners are kept in a linked list.\n */\nabstract class _FutureListener<T> {\n  _FutureListener _nextListener;\n  factory _FutureListener.wrap(_FutureImpl future) {\n    return new _FutureListenerWrapper(future);\n  }\n  void _sendValue(T value);\n  void _sendError(error);\n}\n\n/** Adapter for a [_FutureImpl] to be a future result listener. */\nclass _FutureListenerWrapper<T> implements _FutureListener<T> {\n  _FutureImpl future;\n  _FutureListener _nextListener;\n  _FutureListenerWrapper(this.future);\n  _sendValue(T value) { future._setValue(value); }\n  _sendError(error) { future._setError(error); }\n}\n\nclass _FutureImpl<T> implements Future<T> {\n  static const int _INCOMPLETE = 0;\n  static const int _VALUE = 1;\n  static const int _ERROR = 2;\n  static const int _UNHANDLED_ERROR = 4;\n\n  /** Whether the future is complete, and as what. */\n  int _state = _INCOMPLETE;\n\n  bool get _isComplete => _state != _INCOMPLETE;\n  bool get _hasValue => _state == _VALUE;\n  bool get _hasError => (_state & _ERROR) != 0;\n  bool get _hasUnhandledError => (_state & _UNHANDLED_ERROR) != 0;\n\n  void _clearUnhandledError() {\n    // Works because _UNHANDLED_ERROR is highest bit in use.\n    _state &= ~_UNHANDLED_ERROR;\n  }\n\n  /**\n   * Either the result, or a list of listeners until the future completes.\n   *\n   * The result of the future is either a value or an error.\n   * A result is only stored when the future has completed.\n   *\n   * The listeners is an internally linked list of [_FutureListener]s.\n   * Listeners are only remembered while the future is not yet complete.\n   *\n   * Since the result and the listeners cannot occur at the same time,\n   * we can use the same field for both.\n   */\n  var _resultOrListeners;\n\n  _FutureImpl();\n\n  _FutureImpl.immediate(T value) {\n    _state = _VALUE;\n    _resultOrListeners = value;\n  }\n\n  _FutureImpl.immediateError(var error, [Object stackTrace]) {\n    if (stackTrace != null) {\n      // Force stack trace onto error, even if it had already one.\n      _attachStackTrace(error, stackTrace);\n    }\n    _setError(error);\n  }\n\n  factory _FutureImpl.wait(Iterable<Future> futures) {\n    Completer completer;\n    // List collecting values from the futures.\n    // Set to null if an error occurs.\n    List values;\n    void handleError(error) {\n      if (values != null) {\n        values = null;\n        completer.completeError(error);\n      }\n    }\n    // As each future completes, put its value into the corresponding\n    // position in the list of values.\n    int remaining = 0;\n    for (Future future in futures) {\n      int pos = remaining++;\n      future.catchError(handleError).then((Object value) {\n        if (values == null) return null;\n        values[pos] = value;\n        remaining--;\n        if (remaining == 0) {\n          completer.complete(values);\n        }\n      });\n    }\n    if (remaining == 0) {\n      return new Future.value(const []);\n    }\n    values = new List(remaining);\n    completer = new Completer<List>();\n    return completer.future;\n  }\n\n  Future then(f(T value), { onError(error) }) {\n    if (!_isComplete) {\n      if (onError == null) {\n        return new _ThenFuture(f).._subscribeTo(this);\n      }\n      return new _SubscribeFuture(f, onError).._subscribeTo(this);\n    }\n    if (_hasError) {\n      if (onError != null) {\n        return _handleError(onError, null);\n      }\n      // The \"f\" funtion will never be called, so just return\n      // a future that delegates to this. We don't want to return\n      // this itself to give a signal that the future is complete.\n      return new _FutureWrapper(this);\n    } else {\n      assert(_hasValue);\n      return _handleValue(f);\n    }\n  }\n\n  Future catchError(f(error), { bool test(error) }) {\n    if (_hasValue) {\n      return new _FutureWrapper(this);\n    }\n    if (!_isComplete) {\n      return new _CatchErrorFuture(f, test).._subscribeTo(this);\n    } else {\n      return _handleError(f, test);\n    }\n  }\n\n  Future<T> whenComplete(action()) {\n    _WhenFuture<T> whenFuture = new _WhenFuture<T>(action);\n    if (!_isComplete) {\n      _addListener(whenFuture);\n    } else if (_hasValue) {\n      T value = _resultOrListeners;\n      Timer.run(() {\n        whenFuture._sendValue(value);\n      });\n    } else {\n      assert(_hasError);\n      _clearUnhandledError();\n      var error = _resultOrListeners;\n      Timer.run(() {\n        whenFuture._sendError(error);\n      });\n    }\n    return whenFuture;\n  }\n\n  /** Handle a late listener on a completed future with a value. */\n  Future _handleValue(onValue(var value)) {\n    assert(_hasValue);\n    _ThenFuture thenFuture = new _ThenFuture(onValue);\n    T value = _resultOrListeners;\n    Timer.run(() { thenFuture._sendValue(value); });\n    return thenFuture;\n  }\n\n  /** Handle a late listener on a completed future with an error. */\n  Future _handleError(onError(error), bool test(error)) {\n    assert(_hasError);\n    _clearUnhandledError();\n    var error = _resultOrListeners;\n    _CatchErrorFuture errorFuture = new _CatchErrorFuture(onError, test);\n    Timer.run(() { errorFuture._sendError(error); });\n    return errorFuture;\n  }\n\n  Stream<T> asStream() => new Stream.fromFuture(this);\n\n  void _setValue(T value) {\n    if (_isComplete) throw new StateError(\"Future already completed\");\n    _FutureListener listeners = _removeListeners();\n    _state = _VALUE;\n    _resultOrListeners = value;\n    while (listeners != null) {\n      _FutureListener listener = listeners;\n      listeners = listener._nextListener;\n      listener._nextListener = null;\n      listener._sendValue(value);\n    }\n  }\n\n  void _setError(error) {\n    if (_isComplete) throw new StateError(\"Future already completed\");\n    _FutureListener listeners = _removeListeners();\n    _state = _ERROR;\n    _resultOrListeners = error;\n    if (listeners == null) {\n      _scheduleUnhandledError();\n      return;\n    }\n    do {\n      _FutureListener listener = listeners;\n      listeners = listener._nextListener;\n      listener._nextListener = null;\n      listener._sendError(error);\n    } while (listeners != null);\n  }\n\n  void _scheduleUnhandledError() {\n    _state |= _UNHANDLED_ERROR;\n    // Wait for the rest of the current event's duration to see\n    // if a subscriber is added to handle the error.\n    Timer.run(() {\n      if (_hasUnhandledError) {\n        // No error handler has been added since the error was set.\n        _clearUnhandledError();\n        var error = _resultOrListeners;\n        print(\"Uncaught Error: ${error}\");\n        var trace = getAttachedStackTrace(error);\n        if (trace != null) {\n          print(\"Stack Trace:\\n$trace\\n\");\n        }\n        throw error;\n      }\n    });\n  }\n\n  void _addListener(_FutureListener listener) {\n    assert(!_isComplete);\n    assert(listener._nextListener == null);\n    listener._nextListener = _resultOrListeners;\n    _resultOrListeners = listener;\n  }\n\n  _FutureListener _removeListeners() {\n    // Reverse listeners before returning them, so the resulting list is in\n    // subscription order.\n    assert(!_isComplete);\n    _FutureListener current = _resultOrListeners;\n    _resultOrListeners = null;\n    _FutureListener prev = null;\n    while (current != null) {\n      _FutureListener next = current._nextListener;\n      current._nextListener = prev;\n      prev = current;\n      current = next;\n    }\n    return prev;\n  }\n\n  /**\n   * Make another [_FutureImpl] receive the result of this one.\n   *\n   * If this future is already complete, the [future] is notified\n   * immediately. This function is only called during event resolution\n   * where it's acceptable to send an event.\n   */\n  void _chain(_FutureImpl future) {\n    if (!_isComplete) {\n      _addListener(future._asListener());\n    } else if (_hasValue) {\n      future._setValue(_resultOrListeners);\n    } else {\n      assert(_hasError);\n      _clearUnhandledError();\n      future._setError(_resultOrListeners);\n    }\n  }\n\n  /**\n   * Helper function to handle the result of transforming an incoming event.\n   *\n   * If the result is itself a [Future], this future is linked to that\n   * future's output. If not, this future is completed with the result.\n   */\n  void _setOrChainValue(var result) {\n    if (result is Future) {\n      // Result should be a Future<T>.\n      if (result is _FutureImpl) {\n        _FutureImpl chainFuture = result;\n        chainFuture._chain(this);\n        return;\n      } else {\n        Future future = result;\n        future.then(_setValue,\n                    onError: _setError);\n        return;\n      }\n    } else {\n      // Result must be of type T.\n      _setValue(result);\n    }\n  }\n\n  _FutureListener _asListener() => new _FutureListener.wrap(this);\n}\n\n/**\n * Transforming future base class.\n *\n * A transforming future is itself a future and a future listener.\n * Subclasses override [_sendValue]/[_sendError] to intercept\n * the results of a previous future.\n */\nabstract class _TransformFuture<S, T> extends _FutureImpl<T>\n                                      implements _FutureListener<S> {\n  // _FutureListener implementation.\n  _FutureListener _nextListener;\n\n  void _sendValue(S value);\n\n  void _sendError(error);\n\n  void _subscribeTo(_FutureImpl future) {\n    future._addListener(this);\n  }\n}\n\n/** The onValue and onError handlers return either a value or a future */\ntypedef dynamic _FutureOnValue<T>(T value);\ntypedef dynamic _FutureOnError(error);\n/** Test used by [Future.catchError] to handle skip some errors. */\ntypedef bool _FutureErrorTest(var error);\n/** Used by [WhenFuture]. */\ntypedef _FutureAction();\n\n/** Future returned by [Future.then] with no [:onError:] parameter. */\nclass _ThenFuture<S, T> extends _TransformFuture<S, T> {\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode.\n  final /* _FutureOnValue<S> */ _onValue;\n\n  _ThenFuture(this._onValue);\n\n  _sendValue(S value) {\n    assert(_onValue != null);\n    var result;\n    try {\n      result = _onValue(value);\n    } catch (e, s) {\n      _setError(_asyncError(e, s));\n      return;\n    }\n    _setOrChainValue(result);\n  }\n\n  void _sendError(error) {\n    _setError(error);\n  }\n}\n\n/** Future returned by [Future.catchError]. */\nclass _CatchErrorFuture<T> extends _TransformFuture<T,T> {\n  final _FutureErrorTest _test;\n  final _FutureOnError _onError;\n\n  _CatchErrorFuture(this._onError, this._test);\n\n  _sendValue(T value) {\n    _setValue(value);\n  }\n\n  _sendError(error) {\n    assert(_onError != null);\n    // if _test is supplied, check if it returns true, otherwise just\n    // forward the error unmodified.\n    if (_test != null) {\n      bool matchesTest;\n      try {\n        matchesTest = _test(error);\n      } catch (e, s) {\n        _setError(_asyncError(e, s));\n        return;\n      }\n      if (!matchesTest) {\n        _setError(error);\n        return;\n      }\n    }\n    // Act on the error, and use the result as this future's result.\n    var result;\n    try {\n      result = _onError(error);\n    } catch (e, s) {\n      _setError(_asyncError(e, s));\n      return;\n    }\n    _setOrChainValue(result);\n  }\n}\n\n/** Future returned by [Future.then] with an [:onError:] parameter. */\nclass _SubscribeFuture<S, T> extends _ThenFuture<S, T> {\n  final _FutureOnError _onError;\n\n  _SubscribeFuture(onValue(S value), this._onError) : super(onValue);\n\n  // The _sendValue method is inherited from ThenFuture.\n\n  void _sendError(error) {\n    assert(_onError != null);\n    var result;\n    try {\n      result = _onError(error);\n    } catch (e, s) {\n      _setError(_asyncError(e, s));\n      return;\n    }\n    _setOrChainValue(result);\n  }\n}\n\n/** Future returned by [Future.whenComplete]. */\nclass _WhenFuture<T> extends _TransformFuture<T, T> {\n  final _FutureAction _action;\n\n  _WhenFuture(this._action);\n\n  void _sendValue(T value) {\n    try {\n      var result = _action();\n      if (result is Future) {\n        Future resultFuture = result;\n        resultFuture.then((_) {\n          _setValue(value);\n        }, onError: _setError);\n        return;\n      }\n    } catch (e, s) {\n      _setError(_asyncError(e, s));\n      return;\n    }\n    _setValue(value);\n  }\n\n  void _sendError(error) {\n    try {\n      var result = _action();\n      if (result is Future) {\n        Future resultFuture = result;\n        // TODO(lrn): Find a way to combine [error] into [e].\n        resultFuture.then((_) {\n          _setError(error);\n        }, onError: _setError);\n        return;\n      }\n    } catch (e, s) {\n      error = _asyncError(e, s);\n    }\n    _setError(error);\n  }\n}\n\n/**\n * Thin wrapper around a [Future].\n *\n * This is used to return a \"new\" [Future] that effectively work just\n * as an existing [Future], without making this discoverable by comparing\n * identities.\n */\nclass _FutureWrapper<T> implements Future<T> {\n  final Future<T> _future;\n\n  _FutureWrapper(this._future);\n\n  Future then(function(T value), { onError(error) }) {\n    return _future.then(function, onError: onError);\n  }\n\n  Future catchError(function(error), {bool test(var error)}) {\n    return _future.catchError(function, test: test);\n  }\n\n  Future<T> whenComplete(action()) {\n    return _future.whenComplete(action);\n  }\n\n  Stream<T> asStream() => new Stream.fromFuture(_future);\n}\n","sdk/lib/async/stream.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n// -------------------------------------------------------------------\n// Core Stream types\n// -------------------------------------------------------------------\n\n/**\n * A source of asynchronous data events.\n *\n * A Stream provides a sequence of events. Each event is either a data event or\n * an error event, representing the result of a single computation. When the\n * Stream is exhausted, it may send a single \"done\" event.\n *\n * You can [listen] on a stream to receive the events it sends. When you listen,\n * you receive a [StreamSubscription] object that can be used to stop listening,\n * or to temporarily pause events from the stream.\n *\n * When an event is fired, the listeners at that time are informed.\n * If a listener is added while an event is being fired, the change\n * will only take effect after the event is completely fired. If a listener\n * is canceled, it immediately stops receiving events.\n *\n * When the \"done\" event is fired, subscribers are unsubscribed before\n * receiving the event. After the event has been sent, the stream has no\n * subscribers. Adding new subscribers after this point is allowed, but\n * they will just receive a new \"done\" event as soon as possible.\n *\n * Streams always respect \"pause\" requests. If necessary they need to buffer\n * their input, but often, and preferably, they can simply request their input\n * to pause too.\n *\n * There are two kinds of streams: The normal \"single-subscription\" streams and\n * \"broadcast\" streams.\n *\n * A single-subscription stream allows only a single listener at a time.\n * It holds back events until it gets a listener, and it may exhaust\n * itself when the listener is unsubscribed, even if the stream wasn't done.\n *\n * Single-subscription streams are generally used for streaming parts of\n * contiguous data like file I/O.\n *\n * A broadcast stream allows any number of listeners, and it fires\n * its events when they are ready, whether there are listeners or not.\n *\n * Broadcast streams are used for independent events/observers.\n *\n * The default implementation of [isBroadcast] returns false.\n * A broadcast stream inheriting from [Stream] must override [isBroadcast]\n * to return [:true:].\n */\nabstract class Stream<T> {\n  Stream();\n\n  /**\n   * Creates a new single-subscription stream from the future.\n   *\n   * When the future completes, the stream will fire one event, either\n   * data or error, and then close with a done-event.\n   */\n  factory Stream.fromFuture(Future<T> future) {\n    _StreamImpl<T> stream = new _SingleStreamImpl<T>();\n    future.then((value) {\n        stream._add(value);\n        stream._close();\n      },\n      onError: (error) {\n        stream._addError(error);\n        stream._close();\n      });\n    return stream;\n  }\n\n  /**\n   * Creates a single-subscription stream that gets its data from [data].\n   */\n  factory Stream.fromIterable(Iterable<T> data) {\n    _PendingEvents iterableEvents = new _IterablePendingEvents<T>(data);\n    return new _GeneratedSingleStreamImpl<T>(iterableEvents);\n  }\n\n  /**\n   * Creates a stream that repeatedly emits events at [period] intervals.\n   *\n   * The event values are computed by invoking [computation]. The argument to\n   * this callback is an integer that starts with 0 and is incremented for\n   * every event.\n   *\n   * If [computation] is omitted the event values will all be `null`.\n   */\n  factory Stream.periodic(Duration period,\n                          [T computation(int computationCount)]) {\n    if (computation == null) computation = ((i) => null);\n\n    Timer timer;\n    int computationCount = 0;\n    StreamController<T> controller;\n    // Counts the time that the Stream was running (and not paused).\n    Stopwatch watch = new Stopwatch();\n\n    void sendEvent() {\n      watch.reset();\n      T data = computation(computationCount++);\n      controller.add(data);\n    }\n\n    void startPeriodicTimer() {\n      assert(timer == null);\n      timer = new Timer.periodic(period, (Timer timer) {\n        sendEvent();\n      });\n    }\n\n    controller = new StreamController<T>(\n        onListen: () {\n          watch.start();\n          startPeriodicTimer();\n        },\n        onPause: () {\n          timer.cancel();\n          timer = null;\n          watch.stop();\n        },\n        onResume: () {\n          assert(timer == null);\n          Duration elapsed = watch.elapsed;\n          watch.start();\n          timer = new Timer(period - elapsed, () {\n            timer = null;\n            startPeriodicTimer();\n            sendEvent();\n          });\n        },\n        onCancel: () {\n          if (timer != null) timer.cancel();\n          timer = null;\n        });\n    return controller.stream;\n  }\n\n  /**\n   * Reports whether this stream is a broadcast stream.\n   */\n  bool get isBroadcast => false;\n\n  /**\n   * Returns a multi-subscription stream that produces the same events as this.\n   *\n   * If this stream is single-subscription, return a new stream that allows\n   * multiple subscribers. It will subscribe to this stream when its first\n   * subscriber is added, and unsubscribe again when the last subscription is\n   * cancelled.\n   *\n   * If this stream is already a broadcast stream, it is returned unmodified.\n   */\n  Stream<T> asBroadcastStream() {\n    if (isBroadcast) return this;\n    return new _SingleStreamMultiplexer<T>(this);\n  }\n\n  /**\n   * Adds a subscription to this stream.\n   *\n   * On each data event from this stream, the subscriber's [onData] handler\n   * is called. If [onData] is null, nothing happens.\n   *\n   * On errors from this stream, the [onError] handler is given a\n   * object describing the error.\n   *\n   * If this stream closes, the [onDone] handler is called.\n   *\n   * If [cancelOnError] is true, the subscription is ended when\n   * the first error is reported. The default is false.\n   */\n  StreamSubscription<T> listen(void onData(T event),\n                               { void onError(error),\n                                 void onDone(),\n                                 bool cancelOnError});\n\n  /**\n   * Creates a new stream from this stream that discards some data events.\n   *\n   * The new stream sends the same error and done events as this stream,\n   * but it only sends the data events that satisfy the [test].\n   */\n  Stream<T> where(bool test(T event)) {\n    return new _WhereStream<T>(this, test);\n  }\n\n  /**\n   * Creates a new stream that converts each element of this stream\n   * to a new value using the [convert] function.\n   */\n  Stream map(convert(T event)) {\n    return new _MapStream<T, dynamic>(this, convert);\n  }\n\n  /**\n   * Creates a wrapper Stream that intercepts some errors from this stream.\n   *\n   * If this stream sends an error that matches [test], then it is intercepted\n   * by the [handle] function.\n   *\n   * An [AsyncError] [:e:] is matched by a test function if [:test(e):] returns\n   * true. If [test] is omitted, every error is considered matching.\n   *\n   * If the error is intercepted, the [handle] function can decide what to do\n   * with it. It can throw if it wants to raise a new (or the same) error,\n   * or simply return to make the stream forget the error.\n   *\n   * If you need to transform an error into a data event, use the more generic\n   * [Stream.transformEvent] to handle the event by writing a data event to\n   * the output sink\n   */\n  Stream<T> handleError(void handle( error), { bool test(error) }) {\n    return new _HandleErrorStream<T>(this, handle, test);\n  }\n\n  /**\n   * Creates a new stream from this stream that converts each element\n   * into zero or more events.\n   *\n   * Each incoming event is converted to an [Iterable] of new events,\n   * and each of these new events are then sent by the returned stream\n   * in order.\n   */\n  Stream expand(Iterable convert(T value)) {\n    return new _ExpandStream<T, dynamic>(this, convert);\n  }\n\n  /**\n   * Binds this stream as the input of the provided [StreamConsumer].\n   */\n  Future pipe(StreamConsumer<T> streamConsumer) {\n    return streamConsumer.addStream(this).then((_) => streamConsumer.close());\n  }\n\n  /**\n   * Chains this stream as the input of the provided [StreamTransformer].\n   *\n   * Returns the result of [:streamTransformer.bind:] itself.\n   */\n  Stream transform(StreamTransformer<T, dynamic> streamTransformer) {\n    return streamTransformer.bind(this);\n  }\n\n  /**\n   * Reduces a sequence of values by repeatedly applying [combine].\n   */\n  Future<T> reduce(T combine(T previous, T element)) {\n    _FutureImpl<T> result = new _FutureImpl<T>();\n    bool seenFirst = false;\n    T value;\n    StreamSubscription subscription;\n    subscription = this.listen(\n      // TODO(ahe): Restore type when feature is implemented in dart2js\n      // checked mode. http://dartbug.com/7733\n      (/* T */ element) {\n        if (seenFirst) {\n          _runUserCode(() => combine(value, element),\n                       (T newValue) { value = newValue; },\n                       _cancelAndError(subscription, result));\n        } else {\n          value = element;\n          seenFirst = true;\n        }\n      },\n      onError: result._setError,\n      onDone: () {\n        if (!seenFirst) {\n          result._setError(new StateError(\"No elements\"));\n        } else {\n          result._setValue(value);\n        }\n      },\n      cancelOnError: true\n    );\n    return result;\n  }\n\n  /** Reduces a sequence of values by repeatedly applying [combine]. */\n  Future fold(var initialValue, combine(var previous, T element)) {\n    _FutureImpl result = new _FutureImpl();\n    var value = initialValue;\n    StreamSubscription subscription;\n    subscription = this.listen(\n      // TODO(ahe): Restore type when feature is implemented in dart2js\n      // checked mode. http://dartbug.com/7733\n      (/*T*/ element) {\n        _runUserCode(\n          () => combine(value, element),\n          (newValue) { value = newValue; },\n          _cancelAndError(subscription, result)\n        );\n      },\n      onError: (e) {\n        result._setError(e);\n      },\n      onDone: () {\n        result._setValue(value);\n      },\n      cancelOnError: true);\n    return result;\n  }\n\n  /**\n   * Checks whether [match] occurs in the elements provided by this stream.\n   *\n   * Completes the [Future] when the answer is known.\n   * If this stream reports an error, the [Future] will report that error.\n   */\n  Future<bool> contains(T match) {\n    _FutureImpl<bool> future = new _FutureImpl<bool>();\n    StreamSubscription subscription;\n    subscription = this.listen(\n        // TODO(ahe): Restore type when feature is implemented in dart2js\n        // checked mode. http://dartbug.com/7733\n        (/*T*/ element) {\n          _runUserCode(\n            () => (element == match),\n            (bool isMatch) {\n              if (isMatch) {\n                subscription.cancel();\n                future._setValue(true);\n              }\n            },\n            _cancelAndError(subscription, future)\n          );\n        },\n        onError: future._setError,\n        onDone: () {\n          future._setValue(false);\n        },\n        cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Executes [action] on each data event of the stream.\n   *\n   * Completes the returned [Future] when all events of the stream\n   * have been processed. Completes the future with an error if the\n   * stream has an error event, or if [action] throws.\n   */\n  Future forEach(void action(T element)) {\n    _FutureImpl future = new _FutureImpl();\n    StreamSubscription subscription;\n    subscription = this.listen(\n        // TODO(ahe): Restore type when feature is implemented in dart2js\n        // checked mode. http://dartbug.com/7733\n        (/*T*/ element) {\n          _runUserCode(\n            () => action(element),\n            (_) {},\n            _cancelAndError(subscription, future)\n          );\n        },\n        onError: future._setError,\n        onDone: () {\n          future._setValue(null);\n        },\n        cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Checks whether [test] accepts all elements provided by this stream.\n   *\n   * Completes the [Future] when the answer is known.\n   * If this stream reports an error, the [Future] will report that error.\n   */\n  Future<bool> every(bool test(T element)) {\n    _FutureImpl<bool> future = new _FutureImpl<bool>();\n    StreamSubscription subscription;\n    subscription = this.listen(\n        // TODO(ahe): Restore type when feature is implemented in dart2js\n        // checked mode. http://dartbug.com/7733\n        (/*T*/ element) {\n          _runUserCode(\n            () => test(element),\n            (bool isMatch) {\n              if (!isMatch) {\n                subscription.cancel();\n                future._setValue(false);\n              }\n            },\n            _cancelAndError(subscription, future)\n          );\n        },\n        onError: future._setError,\n        onDone: () {\n          future._setValue(true);\n        },\n        cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Checks whether [test] accepts any element provided by this stream.\n   *\n   * Completes the [Future] when the answer is known.\n   * If this stream reports an error, the [Future] will report that error.\n   */\n  Future<bool> any(bool test(T element)) {\n    _FutureImpl<bool> future = new _FutureImpl<bool>();\n    StreamSubscription subscription;\n    subscription = this.listen(\n        // TODO(ahe): Restore type when feature is implemented in dart2js\n        // checked mode. http://dartbug.com/7733\n        (/*T*/ element) {\n          _runUserCode(\n            () => test(element),\n            (bool isMatch) {\n              if (isMatch) {\n                subscription.cancel();\n                future._setValue(true);\n              }\n            },\n            _cancelAndError(subscription, future)\n          );\n        },\n        onError: future._setError,\n        onDone: () {\n          future._setValue(false);\n        },\n        cancelOnError: true);\n    return future;\n  }\n\n\n  /** Counts the elements in the stream. */\n  Future<int> get length {\n    _FutureImpl<int> future = new _FutureImpl<int>();\n    int count = 0;\n    this.listen(\n      (_) { count++; },\n      onError: future._setError,\n      onDone: () {\n        future._setValue(count);\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /** Reports whether this stream contains any elements. */\n  Future<bool> get isEmpty {\n    _FutureImpl<bool> future = new _FutureImpl<bool>();\n    StreamSubscription subscription;\n    subscription = this.listen(\n      (_) {\n        subscription.cancel();\n        future._setValue(false);\n      },\n      onError: future._setError,\n      onDone: () {\n        future._setValue(true);\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /** Collects the data of this stream in a [List]. */\n  Future<List<T>> toList() {\n    List<T> result = <T>[];\n    _FutureImpl<List<T>> future = new _FutureImpl<List<T>>();\n    this.listen(\n      // TODO(ahe): Restore type when feature is implemented in dart2js\n      // checked mode. http://dartbug.com/7733\n      (/*T*/ data) {\n        result.add(data);\n      },\n      onError: future._setError,\n      onDone: () {\n        future._setValue(result);\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /** Collects the data of this stream in a [Set]. */\n  Future<Set<T>> toSet() {\n    Set<T> result = new Set<T>();\n    _FutureImpl<Set<T>> future = new _FutureImpl<Set<T>>();\n    this.listen(\n      // TODO(ahe): Restore type when feature is implemented in dart2js\n      // checked mode. http://dartbug.com/7733\n      (/*T*/ data) {\n        result.add(data);\n      },\n      onError: future._setError,\n      onDone: () {\n        future._setValue(result);\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Provides at most the first [n] values of this stream.\n   *\n   * Forwards the first [n] data events of this stream, and all error\n   * events, to the returned stream, and ends with a done event.\n   *\n   * If this stream produces fewer than [count] values before it's done,\n   * so will the returned stream.\n   */\n  Stream<T> take(int count) {\n    return new _TakeStream(this, count);\n  }\n\n  /**\n   * Forwards data events while [test] is successful.\n   *\n   * The returned stream provides the same events as this stream as long\n   * as [test] returns [:true:] for the event data. The stream is done\n   * when either this stream is done, or when this stream first provides\n   * a value that [test] doesn't accept.\n   */\n  Stream<T> takeWhile(bool test(T value)) {\n    return new _TakeWhileStream(this, test);\n  }\n\n  /**\n   * Skips the first [count] data events from this stream.\n   */\n  Stream<T> skip(int count) {\n    return new _SkipStream(this, count);\n  }\n\n  /**\n   * Skip data events from this stream while they are matched by [test].\n   *\n   * Error and done events are provided by the returned stream unmodified.\n   *\n   * Starting with the first data event where [test] returns true for the\n   * event data, the returned stream will have the same events as this stream.\n   */\n  Stream<T> skipWhile(bool test(T value)) {\n    return new _SkipWhileStream(this, test);\n  }\n\n  /**\n   * Skips data events if they are equal to the previous data event.\n   *\n   * The returned stream provides the same events as this stream, except\n   * that it never provides two consequtive data events that are equal.\n   *\n   * Equality is determined by the provided [equals] method. If that is\n   * omitted, the '==' operator on the last provided data element is used.\n   */\n  Stream<T> distinct([bool equals(T previous, T next)]) {\n    return new _DistinctStream(this, equals);\n  }\n\n  /**\n   * Returns the first element.\n   *\n   * If [this] is empty throws a [StateError]. Otherwise this method is\n   * equivalent to [:this.elementAt(0):]\n   */\n  Future<T> get first {\n    _FutureImpl<T> future = new _FutureImpl<T>();\n    StreamSubscription subscription;\n    subscription = this.listen(\n      // TODO(ahe): Restore type when feature is implemented in dart2js\n      // checked mode. http://dartbug.com/7733\n      (/*T*/ value) {\n        subscription.cancel();\n        future._setValue(value);\n        return;\n      },\n      onError: future._setError,\n      onDone: () {\n        future._setError(new StateError(\"No elements\"));\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Returns the last element.\n   *\n   * If [this] is empty throws a [StateError].\n   */\n  Future<T> get last {\n    _FutureImpl<T> future = new _FutureImpl<T>();\n    T result = null;\n    bool foundResult = false;\n    StreamSubscription subscription;\n    subscription = this.listen(\n      // TODO(ahe): Restore type when feature is implemented in dart2js\n      // checked mode. http://dartbug.com/7733\n      (/*T*/ value) {\n        foundResult = true;\n        result = value;\n      },\n      onError: future._setError,\n      onDone: () {\n        if (foundResult) {\n          future._setValue(result);\n          return;\n        }\n        future._setError(new StateError(\"No elements\"));\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Returns the single element.\n   *\n   * If [this] is empty or has more than one element throws a [StateError].\n   */\n  Future<T> get single {\n    _FutureImpl<T> future = new _FutureImpl<T>();\n    T result = null;\n    bool foundResult = false;\n    StreamSubscription subscription;\n    subscription = this.listen(\n      // TODO(ahe): Restore type when feature is implemented in dart2js\n      // checked mode. http://dartbug.com/7733\n      (/*T*/ value) {\n        if (foundResult) {\n          subscription.cancel();\n          // This is the second element we get.\n          Error error = new StateError(\"More than one element\");\n          future._setError(error);\n          return;\n        }\n        foundResult = true;\n        result = value;\n      },\n      onError: future._setError,\n      onDone: () {\n        if (foundResult) {\n          future._setValue(result);\n          return;\n        }\n        future._setError(new StateError(\"No elements\"));\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Finds the first element of this stream matching [test].\n   *\n   * Returns a future that is filled with the first element of this stream\n   * that [test] returns true for.\n   *\n   * If no such element is found before this stream is done, and a\n   * [defaultValue] function is provided, the result of calling [defaultValue]\n   * becomes the value of the future.\n   *\n   * If an error occurs, or if this stream ends without finding a match and\n   * with no [defaultValue] function provided, the future will receive an\n   * error.\n   */\n  Future<T> firstWhere(bool test(T value), {T defaultValue()}) {\n    _FutureImpl<T> future = new _FutureImpl<T>();\n    StreamSubscription subscription;\n    subscription = this.listen(\n      // TODO(ahe): Restore type when feature is implemented in dart2js\n      // checked mode. http://dartbug.com/7733\n      (/*T*/ value) {\n        _runUserCode(\n          () => test(value),\n          (bool isMatch) {\n            if (isMatch) {\n              subscription.cancel();\n              future._setValue(value);\n            }\n          },\n          _cancelAndError(subscription, future)\n        );\n      },\n      onError: future._setError,\n      onDone: () {\n        if (defaultValue != null) {\n          _runUserCode(defaultValue, future._setValue, future._setError);\n          return;\n        }\n        future._setError(new StateError(\"firstMatch ended without match\"));\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Finds the last element in this stream matching [test].\n   *\n   * As [firstWhere], except that the last matching element is found.\n   * That means that the result cannot be provided before this stream\n   * is done.\n   */\n  Future<T> lastWhere(bool test(T value), {T defaultValue()}) {\n    _FutureImpl<T> future = new _FutureImpl<T>();\n    T result = null;\n    bool foundResult = false;\n    StreamSubscription subscription;\n    subscription = this.listen(\n      // TODO(ahe): Restore type when feature is implemented in dart2js\n      // checked mode. http://dartbug.com/7733\n      (/*T*/ value) {\n        _runUserCode(\n          () => true == test(value),\n          (bool isMatch) {\n            if (isMatch) {\n              foundResult = true;\n              result = value;\n            }\n          },\n          _cancelAndError(subscription, future)\n        );\n      },\n      onError: future._setError,\n      onDone: () {\n        if (foundResult) {\n          future._setValue(result);\n          return;\n        }\n        if (defaultValue != null) {\n          _runUserCode(defaultValue, future._setValue, future._setError);\n          return;\n        }\n        future._setError(new StateError(\"lastMatch ended without match\"));\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Finds the single element in this stream matching [test].\n   *\n   * Like [lastMatch], except that it is an error if more than one\n   * matching element occurs in the stream.\n   */\n  Future<T> singleWhere(bool test(T value)) {\n    _FutureImpl<T> future = new _FutureImpl<T>();\n    T result = null;\n    bool foundResult = false;\n    StreamSubscription subscription;\n    subscription = this.listen(\n      // TODO(ahe): Restore type when feature is implemented in dart2js\n      // checked mode. http://dartbug.com/7733\n      (/*T*/ value) {\n        _runUserCode(\n          () => true == test(value),\n          (bool isMatch) {\n            if (isMatch) {\n              if (foundResult) {\n                subscription.cancel();\n                future._setError(\n                    new StateError('Multiple matches for \"single\"'));\n                return;\n              }\n              foundResult = true;\n              result = value;\n            }\n          },\n          _cancelAndError(subscription, future)\n        );\n      },\n      onError: future._setError,\n      onDone: () {\n        if (foundResult) {\n          future._setValue(result);\n          return;\n        }\n        future._setError(new StateError(\"single ended without match\"));\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Returns the value of the [index]th data event of this stream.\n   *\n   * If an error event occurs, the future will end with this error.\n   *\n   * If this stream provides fewer than [index] elements before closing,\n   * an error is reported.\n   */\n  Future<T> elementAt(int index) {\n    if (index is! int || index < 0) throw new ArgumentError(index);\n    _FutureImpl<T> future = new _FutureImpl<T>();\n    StreamSubscription subscription;\n    subscription = this.listen(\n      // TODO(ahe): Restore type when feature is implemented in dart2js\n      // checked mode. http://dartbug.com/7733\n      (/*T*/ value) {\n        if (index == 0) {\n          subscription.cancel();\n          future._setValue(value);\n          return;\n        }\n        index -= 1;\n      },\n      onError: future._setError,\n      onDone: () {\n        future._setError(new StateError(\"Not enough elements for elementAt\"));\n      },\n      cancelOnError: true);\n    return future;\n  }\n}\n\n/**\n * A control object for the subscription on a [Stream].\n *\n * When you subscribe on a [Stream] using [Stream.listen],\n * a [StreamSubscription] object is returned. This object\n * is used to later unsubscribe again, or to temporarily pause\n * the stream's events.\n */\nabstract class StreamSubscription<T> {\n  /**\n   * Cancels this subscription. It will no longer receive events.\n   *\n   * If an event is currently firing, this unsubscription will only\n   * take effect after all subscribers have received the current event.\n   */\n  void cancel();\n\n  /** Set or override the data event handler of this subscription. */\n  void onData(void handleData(T data));\n\n  /** Set or override the error event handler of this subscription. */\n  void onError(void handleError(error));\n\n  /** Set or override the done event handler of this subscription. */\n  void onDone(void handleDone());\n\n  /**\n   * Request that the stream pauses events until further notice.\n   *\n   * If [resumeSignal] is provided, the stream will undo the pause\n   * when the future completes. If the future completes with an error,\n   * it will not be handled!\n   *\n   * A call to [resume] will also undo a pause.\n   *\n   * If the subscription is paused more than once, an equal number\n   * of resumes must be performed to resume the stream.\n   */\n  void pause([Future resumeSignal]);\n\n  /**\n   * Resume after a pause.\n   */\n  void resume();\n\n  /**\n   * Returns a future that handles the [onDone] and [onError] callbacks.\n   *\n   * This method *overwrites* the existing [onDone] and [onError] callbacks\n   * with new ones that complete the returned future.\n   *\n   * In case of an error the subscription will automatically cancel (even\n   * when it was listening with `cancelOnError` set to `false`).\n   *\n   * In case of a `done` event the future completes with the given\n   * [futureValue].\n   */\n  Future asFuture([var futureValue]);\n}\n\n\n/**\n * An interface that abstracts creation or handling of [Stream] events.\n */\nabstract class EventSink<T> {\n  /** Create a data event */\n  void add(T event);\n  /** Create an async error. */\n  void addError(errorEvent);\n  /** Request a stream to close. */\n  void close();\n}\n\n\n/** [Stream] wrapper that only exposes the [Stream] interface. */\nclass StreamView<T> extends Stream<T> {\n  Stream<T> _stream;\n\n  StreamView(this._stream);\n\n  bool get isBroadcast => _stream.isBroadcast;\n\n  Stream<T> asBroadcastStream() => _stream.asBroadcastStream();\n\n  StreamSubscription<T> listen(void onData(T value),\n                               { void onError(error),\n                                 void onDone(),\n                                 bool cancelOnError }) {\n    return _stream.listen(onData, onError: onError, onDone: onDone,\n                          cancelOnError: cancelOnError);\n  }\n}\n\n/**\n * [EventSink] wrapper that only exposes the [EventSink] interface.\n */\nclass _EventSinkView<T> extends EventSink<T> {\n  final EventSink<T> _sink;\n\n  _EventSinkView(this._sink);\n\n  void add(T value) { _sink.add(value); }\n  void addError(error) { _sink.addError(error); }\n  void close() { _sink.close(); }\n}\n\n\n/**\n * The target of a [Stream.pipe] call.\n *\n * The [Stream.pipe] call will pass itself to this object, and then return\n * the resulting [Future]. The pipe should complete the future when it's\n * done.\n */\nabstract class StreamConsumer<S> {\n  Future addStream(Stream<S> stream);\n  Future close();\n}\n\n\n/**\n * A [StreamSink] unifies the asynchronous methods from [StreamConsumer] and\n * the synchronous methods from [EventSink].\n *\n * The [EventSink] methods can't be used while the [addStream] is called.\n * As soon as the [addStream]'s [Future] completes with a value, the\n * [EventSink] methods can be used again.\n *\n * If [addStream] is called after any of the [EventSink] methods, it'll\n * be delayed until the underlying system has consumed the data added by the\n * [EventSink] methods.\n *\n * When [EventSink] methods are used, the [done] [Future] can be used to\n * catch any errors.\n *\n * When [close] is called, it will return the [done] [Future].\n */\nabstract class StreamSink<S> implements StreamConsumer<S>, EventSink<S> {\n  /**\n   * Close the [StreamSink]. It'll return the [done] Future.\n   */\n  Future close();\n\n  /**\n   * The [done] Future completes with the same values as [close], except\n   * for the following case:\n   *\n   * * The synchronous methods of [EventSink] were called, resulting in an\n   *   error. If there is no active future (like from an addStream call), the\n   *   [done] future will complete with that error\n   */\n  Future get done;\n}\n\n\n/**\n * The target of a [Stream.transform] call.\n *\n * The [Stream.transform] call will pass itself to this object and then return\n * the resulting stream.\n */\nabstract class StreamTransformer<S, T> {\n  /**\n   * Create a [StreamTransformer] that delegates events to the given functions.\n   *\n   * This is actually a [StreamEventTransformer] where the event handling is\n   * performed by the function arguments.\n   * If an argument is omitted, it acts as the corresponding default method from\n   * [StreamEventTransformer].\n   *\n   * Example use:\n   *\n   *     stringStream.transform(new StreamTransformer<String, String>(\n   *         handleData: (Strung value, EventSink<String> sink) {\n   *           sink.add(value);\n   *           sink.add(value);  // Duplicate the incoming events.\n   *         }));\n   *\n   */\n  factory StreamTransformer({\n      void handleData(S data, EventSink<T> sink),\n      void handleError(error, EventSink<T> sink),\n      void handleDone(EventSink<T> sink)}) {\n    return new _StreamTransformerImpl<S, T>(handleData,\n                                            handleError,\n                                            handleDone);\n  }\n\n  Stream<T> bind(Stream<S> stream);\n}\n\n\n/**\n * Base class for transformers that modifies stream events.\n *\n * A [StreamEventTransformer] transforms incoming Stream\n * events of one kind into outgoing events of (possibly) another kind.\n *\n * Subscribing on the stream returned by [bind] is the same as subscribing on\n * the source stream, except that events are passed through the [transformer]\n * before being emitted. The transformer may generate any number and\n * types of events for each incoming event. Pauses on the returned\n * subscription are forwarded to this stream.\n *\n * An example that duplicates all data events:\n *\n *     class DoubleTransformer<T> extends StreamEventTransformerBase<T, T> {\n *       void handleData(T data, EventSink<T> sink) {\n *         sink.add(value);\n *         sink.add(value);\n *       }\n *     }\n *     someTypeStream.transform(new DoubleTransformer<Type>());\n *\n * The default implementations of the \"handle\" methods forward\n * the events unmodified. If using the default [handleData] the generic type [T]\n * needs to be assignable to [S].\n */\nabstract class StreamEventTransformer<S, T> implements StreamTransformer<S, T> {\n  const StreamEventTransformer();\n\n  Stream<T> bind(Stream<S> source) {\n    // Hackish way of buffering data that goes out of the event-transformer.\n    // TODO(floitsch): replace this with a correct solution.\n    Stream transformingStream = new EventTransformStream<S, T>(source, this);\n    StreamController controller;\n    StreamSubscription subscription;\n    controller = new StreamController<T>(\n        onListen: () {\n          subscription = transformingStream.listen(\n              controller.add,\n              onError: controller.addError,\n              onDone: controller.close);\n        },\n        onPause: () => subscription.pause(),\n        onResume: () => subscription.resume(),\n        onCancel: () => subscription.cancel());\n    return controller.stream;\n  }\n\n  /**\n   * Act on incoming data event.\n   *\n   * The method may generate any number of events on the sink, but should\n   * not throw.\n   */\n  void handleData(S event, EventSink<T> sink) {\n    var data = event;\n    sink.add(data);\n  }\n\n  /**\n   * Act on incoming error event.\n   *\n   * The method may generate any number of events on the sink, but should\n   * not throw.\n   */\n  void handleError(error, EventSink<T> sink) {\n    sink.addError(error);\n  }\n\n  /**\n   * Act on incoming done event.\n   *\n   * The method may generate any number of events on the sink, but should\n   * not throw.\n   */\n  void handleDone(EventSink<T> sink){\n    sink.close();\n  }\n}\n\n\n/**\n * Stream that transforms another stream by intercepting and replacing events.\n *\n * This [Stream] is a transformation of a source stream. Listening on this\n * stream is the same as listening on the source stream, except that events\n * are intercepted and modified by a [StreamEventTransformer] before becoming\n * events on this stream.\n */\nclass EventTransformStream<S, T> extends Stream<T> {\n  final Stream<S> _source;\n  final StreamEventTransformer _transformer;\n  EventTransformStream(Stream<S> source,\n                       StreamEventTransformer<S, T> transformer)\n      : _source = source, _transformer = transformer;\n\n  StreamSubscription<T> listen(void onData(T data),\n                               { void onError(error),\n                                 void onDone(),\n                                 bool cancelOnError }) {\n    cancelOnError = identical(true, cancelOnError);\n    return new _EventTransformStreamSubscription(_source, _transformer,\n                                                 onData, onError, onDone,\n                                                 cancelOnError);\n  }\n}\n\nclass _EventTransformStreamSubscription<S, T>\n    extends _BaseStreamSubscription<T>\n    implements _EventOutputSink<T> {\n  /** The transformer used to transform events. */\n  final StreamEventTransformer<S, T> _transformer;\n  /** Whether to unsubscribe when emitting an error. */\n  final bool _cancelOnError;\n  /** Whether this stream has sent a done event. */\n  bool _isClosed = false;\n  /** Source of incoming events. */\n  StreamSubscription<S> _subscription;\n  /** Cached EventSink wrapper for this class. */\n  EventSink<T> _sink;\n\n  _EventTransformStreamSubscription(Stream<S> source,\n                                    this._transformer,\n                                    void onData(T data),\n                                    void onError(error),\n                                    void onDone(),\n                                    this._cancelOnError)\n      : super(onData, onError, onDone) {\n    _sink = new _EventOutputSinkWrapper<T>(this);\n    _subscription = source.listen(_handleData,\n                                  onError: _handleError,\n                                  onDone: _handleDone);\n  }\n\n  /** Whether this subscription is still subscribed to its source. */\n  bool get _isSubscribed => _subscription != null;\n\n  void pause([Future pauseSignal]) {\n    if (_isSubscribed) _subscription.pause(pauseSignal);\n  }\n\n  void resume() {\n    if (_isSubscribed) _subscription.resume();\n  }\n\n  void cancel() {\n    if (_isSubscribed) {\n      StreamSubscription subscription = _subscription;\n      _subscription = null;\n      subscription.cancel();\n    }\n    _isClosed = true;\n  }\n\n  void _handleData(S data) {\n    try {\n      _transformer.handleData(data, _sink);\n    } catch (e, s) {\n      _sendError(_asyncError(e, s));\n    }\n  }\n\n  void _handleError(error) {\n    try {\n      _transformer.handleError(error, _sink);\n    } catch (e, s) {\n      _sendError(_asyncError(e, s));\n    }\n  }\n\n  void _handleDone() {\n    try {\n      _subscription = null;\n      _transformer.handleDone(_sink);\n    } catch (e, s) {\n      _sendError(_asyncError(e, s));\n    }\n  }\n\n  // EventOutputSink interface.\n  void _sendData(T data) {\n    if (_isClosed) return;\n    _onData(data);\n  }\n\n  void _sendError(error) {\n    if (_isClosed) return;\n    _onError(error);\n    if (_cancelOnError) {\n      cancel();\n    }\n  }\n\n  void _sendDone() {\n    if (_isClosed) throw new StateError(\"Already closed.\");\n    _isClosed = true;\n    if (_isSubscribed) {\n      _subscription.cancel();\n      _subscription = null;\n    }\n    _onDone();\n  }\n}\n\nclass _EventOutputSinkWrapper<T> extends EventSink<T> {\n  _EventOutputSink _sink;\n  _EventOutputSinkWrapper(this._sink);\n\n  void add(T data) { _sink._sendData(data); }\n  void addError(error) { _sink._sendError(error); }\n  void close() { _sink._sendDone(); }\n}\n","sdk/lib/async/stream_controller.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n// -------------------------------------------------------------------\n// Controller for creating and adding events to a stream.\n// -------------------------------------------------------------------\n\n/**\n * A controller with the stream it controls.\n *\n * This controller allows sending data, error and done events on\n * its [stream].\n * This class can be used to create a simple stream that others\n * can listen on, and to push events to that stream.\n *\n * It's possible to check whether the stream is paused or not, and whether\n * it has subscribers or not, as well as getting a callback when either of\n * these change.\n *\n * If the stream starts or stops having listeners (first listener subscribing,\n * last listener unsubscribing), the `onSubscriptionStateChange` callback\n * is notified as soon as possible. If the subscription stat changes during\n * an event firing or a callback being executed, the change will not be reported\n * until the current event or callback has finished.\n * If the pause state has also changed during an event or callback, only the\n * subscription state callback is notified.\n *\n * If the subscriber state has not changed, but the pause state has, the\n * `onPauseStateChange` callback is notified as soon as possible, after firing\n * a current event or completing another callback. This happens if the stream\n * is not paused, and a listener pauses it, or if the stream has been resumed\n * from pause and has no pending events. If the listeners resume a paused stream\n * while it still has queued events, the controller will still consider the\n * stream paused until all queued events have been dispatched.\n *\n * Whether to invoke a callback depends only on the state before and after\n * a stream action, for example firing an event. If the state changes multiple\n * times during the action, and then ends up in the same state as before, no\n * callback is performed.\n *\n * If listeners are added after the stream has completed (sent a \"done\" event),\n * the listeners will be sent a \"done\" event eventually, but they won't affect\n * the stream at all, and won't trigger callbacks. From the controller's point\n * of view, the stream is completely inert when has completed.\n */\nclass StreamController<T> extends EventSink<T> {\n  final _StreamImpl<T> stream;\n\n  /**\n   *\n   * If the stream is canceled before the controller needs new data the\n   * [onResume] call might not be executed.\n      : stream = new _MultiControllerStream<T>(\n            onListen, onPause, onResume, onCancel);\n   * A controller with a [stream] that supports only one single subscriber.\n   *\n   * The controller will buffer all incoming events until the subscriber is\n   * registered.\n   *\n   * The [onPause] function is called when the stream becomes\n   * paused. [onResume] is called when the stream resumed.\n   *\n   * The [onListen] callback is called when the stream\n   * receives its listener. [onCancel] when the listener cancels\n   * its subscription.\n   *\n   * If the stream is canceled before the controller needs new data the\n   * [onResume] call might not be executed.\n   */\n  StreamController({void onListen(),\n                    void onPause(),\n                    void onResume(),\n                    void onCancel()})\n      : stream = new _SingleControllerStream<T>(\n            onListen, onPause, onResume, onCancel);\n\n  /**\n   * Returns a view of this object that only exposes the [EventSink] interface.\n   */\n  EventSink<T> get sink => new _EventSinkView<T>(this);\n\n  /**\n   * Whether the stream is closed for adding more events.\n   *\n   * If true, the \"done\" event might not have fired yet, but it has been\n   * scheduled, and it is too late to add more events.\n   */\n  bool get isClosed => stream._isClosed;\n\n  /** Whether one or more active subscribers have requested a pause. */\n  bool get isPaused => stream._isInputPaused;\n\n  /** Whether there are currently any subscribers on this [Stream]. */\n  bool get hasListener => stream._hasListener;\n\n  /**\n   * Send or queue a data event.\n   */\n  void add(T value) => stream._add(value);\n\n  /**\n   * Send or enqueue an error event.\n   *\n   * If a subscription has requested to be unsubscribed on errors,\n   * it will be unsubscribed after receiving this event.\n   */\n  void addError(Object error, [Object stackTrace]) {\n    if (stackTrace != null) {\n      // Force stack trace overwrite. Even if the error already contained\n      // a stack trace.\n      _attachStackTrace(error, stackTrace);\n    }\n    stream._addError(error);\n  }\n\n  /**\n   * Send or enqueue a \"done\" message.\n   *\n   * The \"done\" message should be sent at most once by a stream, and it\n   * should be the last message sent.\n   */\n  void close() { stream._close(); }\n}\n\ntypedef void _NotificationHandler();\n\nclass _SingleControllerStream<T> extends _SingleStreamImpl<T> {\n  _NotificationHandler _onListen;\n  _NotificationHandler _onPause;\n  _NotificationHandler _onResume;\n  _NotificationHandler _onCancel;\n\n  // TODO(floitsch): share this code with _MultiControllerStream.\n  _runGuarded(_NotificationHandler notificationHandler) {\n    if (notificationHandler == null) return;\n    try {\n      notificationHandler();\n    } catch (e, s) {\n      _throwDelayed(e, s);\n    }\n  }\n\n  _SingleControllerStream(this._onListen,\n                          this._onPause,\n                          this._onResume,\n                          this._onCancel);\n\n  void _onSubscriptionStateChange() {\n    _runGuarded(_hasListener ? _onListen : _onCancel);\n  }\n\n  void _onPauseStateChange() {\n    _runGuarded(_isPaused ? _onPause : _onResume);\n  }\n}\n","sdk/lib/async/stream_impl.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n// States shared by single/multi stream implementations.\n\n// Completion state of the stream.\n/// Initial and default state where the stream can receive and send events.\nconst int _STREAM_OPEN = 0;\n/// The stream has received a request to complete, but hasn't done so yet.\n/// No further events can be added to the stream.\nconst int _STREAM_CLOSED = 1;\n/// The stream has completed and will no longer receive or send events.\n/// Also counts as closed. The stream must not be paused when it's completed.\n/// Always used in conjunction with [_STREAM_CLOSED].\nconst int _STREAM_COMPLETE = 2;\n\n/// Bit that alternates between events, and listeners are updated to the\n/// current value when they are notified of the event.\nconst int _STREAM_EVENT_ID = 4;\nconst int _STREAM_EVENT_ID_SHIFT = 2;\n\n// The activity state of the stream: What is it currently doing.\n/// Bit set while firing and clear while not.\nconst int _STREAM_FIRING = 8;\n/// Bit set while calling a pause-state or subscription-state change callback.\nconst int _STREAM_CALLBACK = 16;\n\n// The pause state of the stream.\n/// Bit set when resuming with pending events. Cleared after all pending events\n/// have been transmitted. Means that the controller still considers the\n/// stream paused, even if the listener doesn't.\nconst int _STREAM_PENDING_RESUME = 32;\n/// The count of times a stream has paused is stored in the\n/// state, shifted by this amount.\nconst int _STREAM_PAUSE_COUNT_SHIFT = 6;\n\n// States for listeners.\n\n/// The listener is currently not subscribed to its source stream.\nconst int _LISTENER_UNSUBSCRIBED = 0;\n/// The listener is actively subscribed to its source stream.\nconst int _LISTENER_SUBSCRIBED = 1;\n/// The listener is subscribed until it has been notified of the current event.\n/// This flag bit is always used in conjuction with [_LISTENER_SUBSCRIBED].\nconst int _LISTENER_PENDING_UNSUBSCRIBE = 2;\n\n/// Bit that contains the last sent event's \"id bit\".\nconst int _LISTENER_EVENT_ID = 4;\nconst int _LISTENER_EVENT_ID_SHIFT = 2;\n\n/// The count of times a listener has paused is stored in the\n/// state, shifted by this amount.\nconst int _LISTENER_PAUSE_COUNT_SHIFT = 3;\n\n/** Throws the given error in the next cycle. */\n_throwDelayed(var error, [Object stackTrace]) {\n  // We are going to reach the top-level here, but there might be a global\n  // exception handler. This means that we shouldn't print the stack trace.\n  // TODO(floitsch): Find better solution that doesn't print the stack trace\n  // if there is a global exception handler.\n  runAsync(() {\n    if (stackTrace != null) print(stackTrace);\n    var trace = getAttachedStackTrace(error);\n    if (trace != null && trace != stackTrace) print(trace);\n    throw error;\n  });\n}\n\n\n// -------------------------------------------------------------------\n// Common base class for single and multi-subscription streams.\n// -------------------------------------------------------------------\nabstract class _StreamImpl<T> extends Stream<T> {\n  /** Current state of the stream. */\n  int _state = _STREAM_OPEN;\n\n  /**\n   * List of pending events.\n   *\n   * If events are added to the stream (using [_add], [_addError] or [_done])\n   * while the stream is paused, or while another event is firing, events will\n   * stored here.\n   * Also supports scheduling the events for later execution.\n   */\n  _PendingEvents _pendingEvents;\n\n  // ------------------------------------------------------------------\n  // Stream interface.\n\n  StreamSubscription<T> listen(void onData(T data),\n                               { void onError(error),\n                                 void onDone(),\n                                 bool cancelOnError }) {\n    if (_isComplete) {\n      return new _DoneSubscription(onDone);\n    }\n    if (onData == null) onData = _nullDataHandler;\n    if (onError == null) onError = _nullErrorHandler;\n    if (onDone == null) onDone = _nullDoneHandler;\n    cancelOnError = identical(true, cancelOnError);\n    _StreamSubscriptionImpl subscription =\n        _createSubscription(onData, onError, onDone, cancelOnError);\n    _addListener(subscription);\n    return subscription;\n  }\n\n  // ------------------------------------------------------------------\n  // EventSink interface-like methods for sending events into the stream.\n  // It's the responsibility of the caller to ensure that the stream is not\n  // paused when adding events. If the stream is paused, the events will be\n  // queued, but it's better to not send events at all.\n\n  /**\n   * Send or queue a data event.\n   */\n  void _add(T value) {\n    if (_isClosed) throw new StateError(\"Sending on closed stream\");\n    if (!_mayFireState) {\n      // Not the time to send events.\n      _addPendingEvent(new _DelayedData<T>(value));\n      return;\n    }\n    if (_hasPendingEvent) {\n      _addPendingEvent(new _DelayedData<T>(value));\n    } else {\n      _sendData(value);\n    }\n    _handlePendingEvents();\n  }\n\n  /**\n   * Send or enqueue an error event.\n   *\n   * If a subscription has requested to be unsubscribed on errors,\n   * it will be unsubscribed after receiving this event.\n   */\n  void _addError(error) {\n    if (_isClosed) throw new StateError(\"Sending on closed stream\");\n    if (!_mayFireState) {\n      // Not the time to send events.\n      _addPendingEvent(new _DelayedError(error));\n      return;\n    }\n    if (_hasPendingEvent) {\n      _addPendingEvent(new _DelayedError(error));\n    } else {\n      _sendError(error);\n    }\n    _handlePendingEvents();\n  }\n\n  /**\n   * Send or enqueue a \"done\" message.\n   *\n   * The \"done\" message should be sent at most once by a stream, and it\n   * should be the last message sent.\n   */\n  void _close() {\n    if (_isClosed) return;\n    _state |= _STREAM_CLOSED;\n    if (!_mayFireState) {\n      // Not the time to send events.\n      _addPendingEvent(const _DelayedDone());\n      return;\n    }\n    if (_hasPendingEvent) {\n      _addPendingEvent(new _DelayedDone());\n      _handlePendingEvents();\n    } else {\n      _sendDone();\n      assert(_isComplete);\n      assert(!_hasPendingEvent);\n    }\n  }\n\n  // -------------------------------------------------------------------\n  // Internal implementation.\n\n  // State predicates.\n\n  // Lifecycle state.\n  /** Whether the stream is in the default, open, state for events. */\n  bool get _isOpen => (_state & (_STREAM_CLOSED | _STREAM_COMPLETE)) == 0;\n\n  /** Whether the stream has been closed (a done event requested). */\n  bool get _isClosed => (_state & _STREAM_CLOSED) != 0;\n\n  /** Whether the stream is completed. */\n  bool get _isComplete => (_state & _STREAM_COMPLETE) != 0;\n\n  // Pause state.\n\n  /** Whether one or more active subscribers have requested a pause. */\n  bool get _isPaused => _state >= (1 << _STREAM_PAUSE_COUNT_SHIFT);\n\n  /** How many times the stream has been paused. */\n  int get _pauseCount => _state >> _STREAM_PAUSE_COUNT_SHIFT;\n\n  /**\n   * Whether a controller thinks the stream is paused.\n   *\n   * When this changes, a pause-state change callback is performed.\n   *\n   * It may differ from [_isPaused] if there are pending events\n   * in the queue when the listeners resume. The controller won't\n   * be informed until all queued events have been fired.\n   */\n  bool get _isInputPaused => _state >= (_STREAM_PENDING_RESUME);\n\n  /** Whether we have a pending resume scheduled. */\n  bool get _hasPendingResume => (_state & _STREAM_PENDING_RESUME) != 0;\n\n\n  // Action state. If the stream makes a call-out to external code,\n  // this state tracks it and avoids reentrancy problems.\n\n  /** Whether the stream is not currently firing or calling a callback. */\n  bool get _isInactive => (_state & (_STREAM_CALLBACK | _STREAM_FIRING)) == 0;\n\n  /** Whether we are currently executing a state-chance callback. */\n  bool get _isInCallback => (_state & _STREAM_CALLBACK) != 0;\n\n  /** Whether we are currently firing an event. */\n  bool get _isFiring => (_state & _STREAM_FIRING) != 0;\n\n  /** Check whether the pending event queue is non-empty */\n  bool get _hasPendingEvent =>\n      _pendingEvents != null && !_pendingEvents.isEmpty;\n\n  /**\n   * The bit representing the current or last event fired.\n   *\n   * This bit matches a bit on listeners that have received the corresponding\n   * event. It is toggled for each new event being fired.\n   */\n  int get _currentEventIdBit =>\n      (_state & _STREAM_EVENT_ID ) >> _STREAM_EVENT_ID_SHIFT;\n\n  /** Whether there is currently a subscriber on this [Stream]. */\n  bool get _hasListener;\n\n\n  /** Whether the state bits allow firing. */\n  bool get _mayFireState {\n    // The state allows firing unless:\n    // - it's currently firing\n    // - it's currently in a callback\n    // - it's paused\n    const int mask =\n        _STREAM_FIRING |\n        _STREAM_CALLBACK |\n        ~((1 << _STREAM_PAUSE_COUNT_SHIFT) - 1);\n    return (_state & mask) == 0;\n  }\n\n  // State modification.\n\n  /** Record an increases in the number of times the listener has paused. */\n  void _incrementPauseCount(_StreamListener<T> listener) {\n    listener._incrementPauseCount();\n    _state &= ~_STREAM_PENDING_RESUME;\n    _updatePauseCount(1);\n  }\n\n  /** Record a decrease in the number of times the listener has paused. */\n  void _decrementPauseCount(_StreamListener<T> listener) {\n    assert(_isPaused);\n    listener._decrementPauseCount();\n    _updatePauseCount(-1);\n  }\n\n  /** Update the stream's own pause count only. */\n  void _updatePauseCount(int by) {\n    int oldState = _state;\n    // We can't just _state += by << _STREAM_PAUSE_COUNT_SHIFT, since dart2js\n    // converts the result of the left-shift to a positive number.\n    if (by >= 0) {\n      _state = oldState + (by << _STREAM_PAUSE_COUNT_SHIFT);\n    } else {\n      _state = oldState - ((-by) << _STREAM_PAUSE_COUNT_SHIFT);\n    }\n    assert(_state >= 0);\n    assert((_state >> _STREAM_PAUSE_COUNT_SHIFT) ==\n        (oldState >> _STREAM_PAUSE_COUNT_SHIFT) + by);\n  }\n\n  void _setClosed() {\n    assert(!_isClosed);\n    _state |= _STREAM_CLOSED;\n  }\n\n  void _setComplete() {\n    assert(_isClosed);\n    _state = _state |_STREAM_COMPLETE;\n  }\n\n  void _startFiring() {\n    assert(!_isFiring);\n    assert(!_isInCallback);\n    assert(_hasListener);\n    assert(!_isPaused);\n    // This sets the _STREAM_FIRING bit and toggles the _STREAM_EVENT_ID\n    // bit. All current subscribers will now have a _LISTENER_EVENT_ID\n    // that doesn't match _STREAM_EVENT_ID, and they will receive the\n    // event being fired.\n    _state ^= _STREAM_FIRING | _STREAM_EVENT_ID;\n  }\n\n  void _endFiring(bool wasInputPaused) {\n    assert(_isFiring);\n    _state ^= _STREAM_FIRING;\n    // Had listeners, or we wouldn't have fired.\n    _checkCallbacks(true, wasInputPaused);\n  }\n\n  /**\n   * Record that a listener wants a pause from events.\n   *\n   * This methods is called from [_StreamListener.pause()].\n   * Subclasses can override this method, along with [isPaused] and\n   * [createSubscription], if they want to do a different handling of paused\n   * subscriptions, e.g., a filtering stream pausing its own source if all its\n   * subscribers are paused.\n   */\n  void _pause(_StreamListener<T> listener, Future resumeSignal) {\n    assert(identical(listener._source, this));\n    if (!listener._isSubscribed) {\n      throw new StateError(\"Subscription has been canceled.\");\n    }\n    assert(!_isComplete);  // There can be no subscribers when complete.\n    bool wasInputPaused = _isInputPaused;\n    bool wasPaused = _isPaused;\n    _incrementPauseCount(listener);\n    if (resumeSignal != null) {\n      resumeSignal.whenComplete(() { this._resume(listener, true); });\n    }\n    if (!wasPaused && _hasPendingEvent && _pendingEvents.isScheduled) {\n      _pendingEvents.cancelSchedule();\n    }\n    if (_isInactive && !wasInputPaused) {\n      _checkCallbacks(true, false);\n      if (!_isPaused && _hasPendingEvent) {\n        _schedulePendingEvents();\n      }\n    }\n  }\n\n  /** Stops pausing due to one request from the given listener. */\n  void _resume(_StreamListener<T> listener, bool fromEvent) {\n    if (!listener.isPaused) return;\n    assert(listener._isSubscribed);\n    assert(_isPaused);\n    _decrementPauseCount(listener);\n    if (!_isPaused) {\n      if (_hasPendingEvent) {\n        _state |= _STREAM_PENDING_RESUME;\n        // Controller's pause state hasn't changed.\n        // If we can fire events now, fire any pending events right away.\n        if (_isInactive) {\n          if (fromEvent) {\n            _handlePendingEvents();\n          } else {\n            _schedulePendingEvents();\n          }\n        }\n      } else if (_isInactive) {\n        _checkCallbacks(true, true);\n        if (!_isPaused && _hasPendingEvent) {\n          if (fromEvent) {\n            _handlePendingEvents();\n          } else {\n            _schedulePendingEvents();\n          }\n        }\n      }\n    }\n  }\n\n  /** Schedule pending events to be executed. */\n  void _schedulePendingEvents() {\n    assert(_hasPendingEvent);\n    _pendingEvents.schedule(this);\n  }\n\n  /** Create a subscription object. Called by [subcribe]. */\n  _StreamSubscriptionImpl<T> _createSubscription(\n      void onData(T data),\n      void onError(error),\n      void onDone(),\n      bool cancelOnError);\n\n  /**\n   * Adds a listener to this stream.\n   */\n  void _addListener(_StreamSubscriptionImpl subscription);\n\n  /**\n   * Handle a cancel requested from a [_StreamSubscriptionImpl].\n   *\n   * This method is called from [_StreamSubscriptionImpl.cancel].\n   *\n   * If an event is currently firing, the cancel is delayed\n   * until after the subscribers have received the event.\n   */\n  void _cancel(_StreamSubscriptionImpl subscriber);\n\n  /**\n   * Iterate over all current subscribers and perform an action on each.\n   *\n   * Subscribers added during the iteration will not be visited.\n   * Subscribers unsubscribed during the iteration will only be removed\n   * after they have been acted on.\n   *\n   * Any change in the pause state is only reported after all subscribers have\n   * received the event.\n   *\n   * The [action] must not throw, or the controller will be left in an\n   * invalid state.\n   *\n   * This method must not be called while [isFiring] is true.\n   */\n  void _forEachSubscriber(void action(_StreamSubscriptionImpl<T> subscription));\n\n  /**\n   * Checks whether the subscription/pause state has changed.\n   *\n   * Calls the appropriate callback if the state has changed from the\n   * provided one. Repeats calling callbacks as long as the call changes\n   * the state.\n   */\n  void _checkCallbacks(bool hadListener, bool wasPaused) {\n    assert(!_isFiring);\n    // Will be handled after the current callback.\n    if (_isInCallback) return;\n    if (_hasPendingResume && !_hasPendingEvent) {\n      _state ^= _STREAM_PENDING_RESUME;\n    }\n    _state |= _STREAM_CALLBACK;\n    while (true) {\n      bool hasListener = _hasListener;\n      bool isPaused = _isInputPaused;\n      if (hadListener != hasListener) {\n        _onSubscriptionStateChange();\n      } else if (isPaused != wasPaused) {\n        _onPauseStateChange();\n      } else {\n        _state ^= _STREAM_CALLBACK;\n        return;\n      }\n      wasPaused = isPaused;\n      hadListener = hasListener;\n    }\n  }\n\n  /**\n   * Called when the first subscriber requests a pause or the last a resume.\n   *\n   * Read [isPaused] to see the new state.\n   */\n  void _onPauseStateChange() {}\n\n  /**\n   * Called when the first listener subscribes or the last unsubscribes.\n   *\n   * Read [hasListener] to see what the new state is.\n   */\n  void _onSubscriptionStateChange() {}\n\n  /**\n   * Add a pending event at the end of the pending event queue.\n   *\n   * Schedules events if currently not paused and inside a callback.\n   */\n  void _addPendingEvent(_DelayedEvent event) {\n    if (_pendingEvents == null) _pendingEvents = new _StreamImplEvents();\n    _StreamImplEvents events = _pendingEvents;\n    events.add(event);\n    if (_isPaused || _isFiring) return;\n    if (_isInCallback) {\n      _schedulePendingEvents();\n      return;\n    }\n  }\n\n  /** Fire any pending events until the pending event queue is empty. */\n  void _handlePendingEvents() {\n    assert(_isInactive);\n    if (!_hasPendingEvent) return;\n    _PendingEvents events = _pendingEvents;\n    do {\n      if (_isPaused) return;\n      if (events.isScheduled) events.cancelSchedule();\n      events.handleNext(this);\n    } while (!events.isEmpty);\n  }\n\n  /**\n   * Send a data event directly to each subscriber.\n   */\n  _sendData(T value) {\n    assert(!_isPaused);\n    assert(!_isComplete);\n    if (!_hasListener) return;\n    _forEachSubscriber((subscriber) {\n      try {\n        subscriber._sendData(value);\n      } catch (e, s) {\n        _throwDelayed(e, s);\n      }\n    });\n  }\n\n  /**\n   * Sends an error event directly to each subscriber.\n   */\n  void _sendError(error) {\n    assert(!_isPaused);\n    assert(!_isComplete);\n    if (!_hasListener) return;\n    _forEachSubscriber((subscriber) {\n      try {\n        subscriber._sendError(error);\n      } catch (e, s) {\n        _throwDelayed(e, s);\n      }\n    });\n  }\n\n  /**\n   * Sends the \"done\" message directly to each subscriber.\n   * This automatically stops further subscription and\n   * unsubscribes all subscribers.\n   */\n  void _sendDone() {\n    assert(!_isPaused);\n    assert(_isClosed);\n    _setComplete();\n    if (!_hasListener) return;\n    _forEachSubscriber((subscriber) {\n      _cancel(subscriber);\n      try {\n        subscriber._sendDone();\n      } catch (e, s) {\n        _throwDelayed(e, s);\n      }\n    });\n    assert(!_hasListener);\n  }\n}\n\n// -------------------------------------------------------------------\n// Default implementation of a stream with a single subscriber.\n// -------------------------------------------------------------------\n/**\n * Default implementation of stream capable of sending events to one subscriber.\n *\n * Any class needing to implement [Stream] can either directly extend this\n * class, or extend [Stream] and delegate the subscribe method to an instance\n * of this class.\n *\n * The only public methods are those of [Stream], so instances of\n * [_SingleStreamImpl] can be returned directly as a [Stream] without exposing\n * internal functionality.\n *\n * The [StreamController] is a public facing version of this class, with\n * some methods made public.\n *\n * The user interface of [_SingleStreamImpl] are the following methods:\n * * [_add]: Add a data event to the stream.\n * * [_addError]: Add an error event to the stream.\n * * [_close]: Request to close the stream.\n * * [_onSubscriberStateChange]: Called when receiving the first subscriber or\n *                               when losing the last subscriber.\n * * [_onPauseStateChange]: Called when entering or leaving paused mode.\n * * [_hasListener]: Test whether there are currently any subscribers.\n * * [_isInputPaused]: Test whether the stream is currently paused.\n * The user should not add new events while the stream is paused, but if it\n * happens anyway, the stream will enqueue the events just as when new events\n * arrive while still firing an old event.\n */\nclass _SingleStreamImpl<T> extends _StreamImpl<T> {\n  _StreamListener _subscriber = null;\n\n  /** Whether there is currently a subscriber on this [Stream]. */\n  bool get _hasListener => _subscriber != null;\n\n  // -------------------------------------------------------------------\n  // Internal implementation.\n\n  _SingleStreamImpl() {\n    // Start out paused.\n    _updatePauseCount(1);\n  }\n\n  /**\n   * Create the new subscription object.\n   */\n  _StreamSubscriptionImpl<T> _createSubscription(\n      void onData(T data),\n      void onError(error),\n      void onDone(),\n      bool cancelOnError) {\n    return new _StreamSubscriptionImpl<T>(\n        this, onData, onError, onDone, cancelOnError);\n  }\n\n  void _addListener(_StreamListener subscription) {\n    assert(!_isComplete);\n    if (_hasListener) {\n      throw new StateError(\"Stream already has subscriber.\");\n    }\n    assert(_pauseCount == 1);\n    _updatePauseCount(-1);\n    _subscriber = subscription;\n    subscription._setSubscribed(0);\n    if (_isInactive) {\n      _checkCallbacks(false, true);\n      if (!_isPaused && _hasPendingEvent) {\n        _schedulePendingEvents();\n      }\n    }\n  }\n\n  /**\n   * Handle a cancel requested from a [_StreamSubscriptionImpl].\n   *\n   * This method is called from [_StreamSubscriptionImpl.cancel].\n   */\n  void _cancel(_StreamListener subscriber) {\n    assert(identical(subscriber._source, this));\n    // We allow unsubscribing the currently firing subscription during\n    // the event firing, because it is indistinguishable from delaying it since\n    // that event has already received the event.\n    if (!identical(_subscriber, subscriber)) {\n      // You may unsubscribe more than once, only the first one counts.\n      return;\n    }\n    _subscriber = null;\n    // Unsubscribing a paused subscription also cancels its pauses.\n    int resumeCount = subscriber._setUnsubscribed();\n    // Keep being paused while there is no subscriber and the stream is not\n    // complete.\n    _updatePauseCount(_isComplete ? -resumeCount : -resumeCount + 1);\n    if (_isInactive) {\n      _checkCallbacks(true, resumeCount > 0);\n      if (!_isPaused && _hasPendingEvent) {\n        _schedulePendingEvents();\n      }\n    }\n  }\n\n  void _forEachSubscriber(\n      void action(_StreamListener<T> subscription)) {\n    assert(!_isPaused);\n    bool wasInputPaused = _isInputPaused;\n    _StreamListener subscription = _subscriber;\n    assert(subscription != null);\n    _startFiring();\n    action(subscription);\n    _endFiring(wasInputPaused);\n  }\n}\n\n// -------------------------------------------------------------------\n// Default implementation of a stream with subscribers.\n// -------------------------------------------------------------------\n\n/**\n * Default implementation of stream capable of sending events to subscribers.\n *\n * Any class needing to implement [Stream] can either directly extend this\n * class, or extend [Stream] and delegate the subscribe method to an instance\n * of this class.\n *\n * The only public methods are those of [Stream], so instances of\n * [_MultiStreamImpl] can be returned directly as a [Stream] without exposing\n * internal functionality.\n *\n * The [StreamController] is a public facing version of this class, with\n * some methods made public.\n *\n * The user interface of [_MultiStreamImpl] are the following methods:\n * * [_add]: Add a data event to the stream.\n * * [_addError]: Add an error event to the stream.\n * * [_close]: Request to close the stream.\n * * [_onSubscriptionStateChange]: Called when receiving the first subscriber or\n *                                 when losing the last subscriber.\n * * [_onPauseStateChange]: Called when entering or leaving paused mode.\n * * [_hasListener]: Test whether there are currently any subscribers.\n * * [_isPaused]: Test whether the stream is currently paused.\n * The user should not add new events while the stream is paused, but if it\n * happens anyway, the stream will enqueue the events just as when new events\n * arrive while still firing an old event.\n */\nclass _MultiStreamImpl<T> extends _StreamImpl<T>\n                          implements _InternalLinkList {\n  // Link list implementation (mixin when possible).\n  _InternalLink _nextLink;\n  _InternalLink _previousLink;\n\n  _MultiStreamImpl() {\n    _nextLink = _previousLink = this;\n  }\n\n  bool get isBroadcast => true;\n\n  Stream<T> asBroadcastStream() => this;\n\n  // ------------------------------------------------------------------\n  // Helper functions that can be overridden in subclasses.\n\n  /** Whether there are currently any subscribers on this [Stream]. */\n  bool get _hasListener => !_InternalLinkList.isEmpty(this);\n\n  /**\n   * Create the new subscription object.\n   */\n  _StreamListener<T> _createSubscription(\n      void onData(T data),\n      void onError(error),\n      void onDone(),\n      bool cancelOnError) {\n    return new _StreamSubscriptionImpl<T>(\n        this, onData, onError, onDone, cancelOnError);\n  }\n\n  // -------------------------------------------------------------------\n  // Internal implementation.\n\n  /**\n   * Iterate over all current subscribers and perform an action on each.\n   *\n   * The set of subscribers cannot be modified during this iteration.\n   * All attempts to add or unsubscribe subscribers will be delayed until\n   * after the iteration is complete.\n   *\n   * The [action] must not throw, or the controller will be left in an\n   * invalid state.\n   *\n   * This method must not be called while [isFiring] is true.\n   */\n  void _forEachSubscriber(\n      void action(_StreamListener<T> subscription)) {\n    assert(!_isFiring);\n    if (!_hasListener) return;\n    bool wasInputPaused = _isInputPaused;\n    _startFiring();\n    _InternalLink cursor = this._nextLink;\n    while (!identical(cursor, this)) {\n      _StreamListener<T> current = cursor;\n      if (current._needsEvent(_currentEventIdBit)) {\n        action(current);\n        // Marks as having received the event.\n        current._toggleEventReceived();\n      }\n      cursor = current._nextLink;\n      if (current._isPendingUnsubscribe) {\n        _removeListener(current);\n      }\n    }\n    _endFiring(wasInputPaused);\n  }\n\n  void _addListener(_StreamListener listener) {\n    listener._setSubscribed(_currentEventIdBit);\n    bool hadListener = _hasListener;\n    _InternalLinkList.add(this, listener);\n    if (!hadListener && _isInactive) {\n      _checkCallbacks(false, false);\n      if (!_isPaused && _hasPendingEvent) {\n        _schedulePendingEvents();\n      }\n    }\n  }\n\n  /**\n   * Handle a cancel requested from a [_StreamListener].\n   *\n   * This method is called from [_StreamListener.cancel].\n   *\n   * If an event is currently firing, the cancel is delayed\n   * until after the subscribers have received the event.\n   */\n  void _cancel(_StreamListener listener) {\n    assert(identical(listener._source, this));\n    if (_InternalLink.isUnlinked(listener)) {\n      // You may unsubscribe more than once, only the first one counts.\n      return;\n    }\n    if (_isFiring) {\n      if (listener._needsEvent(_currentEventIdBit)) {\n        assert(listener._isSubscribed);\n        listener._setPendingUnsubscribe(_currentEventIdBit);\n      } else {\n        // The listener has been notified of the event (or don't need to,\n        // if it's still pending subscription) so it's safe to remove it.\n        _removeListener(listener);\n      }\n      // Pause and subscription state changes are reported when we end\n      // firing.\n    } else {\n      bool wasInputPaused = _isInputPaused;\n      _removeListener(listener);\n      if (_isInactive) {\n        _checkCallbacks(true, wasInputPaused);\n        if (!_isPaused && _hasPendingEvent) {\n          _schedulePendingEvents();\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes a listener from this stream and cancels its pauses.\n   *\n   * This is a low-level action that doesn't call [_onSubscriptionStateChange].\n   * or [_callOnPauseStateChange].\n   */\n  void _removeListener(_StreamListener listener) {\n    int pauseCount = listener._setUnsubscribed();\n    _InternalLinkList.remove(listener);\n    if (pauseCount > 0) {\n      _updatePauseCount(-pauseCount);\n      if (!_isPaused && _hasPendingEvent) {\n        _state |= _STREAM_PENDING_RESUME;\n      }\n    }\n  }\n}\n\n\n/** Stream that generates its own events. */\nclass _GeneratedSingleStreamImpl<T> extends _SingleStreamImpl<T> {\n  /**\n   * Initializes the stream to have only the events provided by [events].\n   *\n   * A [_PendingEvents] implementation provides events that are handled\n   * by calling [_PendingEvents.handleNext] with the [_StreamImpl].\n   */\n  _GeneratedSingleStreamImpl(_PendingEvents events) {\n    _pendingEvents = events;\n    _setClosed();  // Closed for input since all events are already pending.\n  }\n\n  void _add(T value) {\n    throw new UnsupportedError(\"Cannot inject events into generated stream\");\n  }\n\n  void _addError(value) {\n    throw new UnsupportedError(\"Cannot inject events into generated stream\");\n  }\n\n  void _close() {\n    throw new UnsupportedError(\"Cannot inject events into generated stream\");\n  }\n}\n\n\n/** Pending events object that gets its events from an [Iterable]. */\nclass _IterablePendingEvents<T> extends _PendingEvents {\n  final Iterator<T> _iterator;\n  /**\n   * Whether there are no more events to be sent.\n   *\n   * This starts out as [:false:] since there is always at least\n   * a 'done' event to be sent.\n   */\n  bool _isDone = false;\n\n  _IterablePendingEvents(Iterable<T> data) : _iterator = data.iterator;\n\n  bool get isEmpty => _isDone;\n\n  void handleNext(_StreamImpl<T> stream) {\n    if (_isDone) throw new StateError(\"No events pending.\");\n    try {\n      _isDone = !_iterator.moveNext();\n      if (!_isDone) {\n        stream._sendData(_iterator.current);\n      } else {\n        stream._sendDone();\n      }\n    } catch (e, s) {\n      stream._sendError(_asyncError(e, s));\n      stream._sendDone();\n      _isDone = true;\n    }\n  }\n}\n\n\n/**\n * The subscription class that the [StreamController] uses.\n *\n * The [_StreamImpl.createSubscription] method should\n * create an object of this type, or another subclass of [_StreamListener].\n * A subclass of [_StreamImpl] can specify which subclass\n * of [_StreamSubscriptionImpl] it uses by overriding\n * [_StreamImpl.createSubscription].\n *\n * The subscription is in one of three states:\n * * Subscribed.\n * * Paused-and-subscribed.\n * * Unsubscribed.\n * Unsubscribing also resumes any pauses started by the subscription.\n */\nclass _StreamSubscriptionImpl<T> extends _StreamListener<T>\n                                 implements StreamSubscription<T> {\n  final bool _cancelOnError;\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  var /* _DataHandler<T> */ _onData;\n  _ErrorHandler _onError;\n  _DoneHandler _onDone;\n  _StreamSubscriptionImpl(_StreamImpl source,\n                          this._onData,\n                          this._onError,\n                          this._onDone,\n                          this._cancelOnError) : super(source);\n\n  void onData(void handleData(T event)) {\n    if (handleData == null) handleData = _nullDataHandler;\n    _onData = handleData;\n  }\n\n  void onError(void handleError(error)) {\n    if (handleError == null) handleError = _nullErrorHandler;\n    _onError = handleError;\n  }\n\n  void onDone(void handleDone()) {\n    if (handleDone == null) handleDone = _nullDoneHandler;\n    _onDone = handleDone;\n  }\n\n  void _sendData(T data) {\n    _onData(data);\n  }\n\n  void _sendError(error) {\n    _onError(error);\n    if (_cancelOnError) _source._cancel(this);\n  }\n\n  void _sendDone() {\n    _onDone();\n  }\n\n  void cancel() {\n    if (!_isSubscribed) return;\n    _source._cancel(this);\n  }\n\n  void pause([Future resumeSignal]) {\n    if (!_isSubscribed) return;\n    _source._pause(this, resumeSignal);\n  }\n\n  void resume() {\n    if (!_isSubscribed || !isPaused) return;\n    _source._resume(this, false);\n  }\n\n  Future asFuture([var futureValue]) {\n    _FutureImpl<T> result = new _FutureImpl<T>();\n\n    // Overwrite the onDone and onError handlers.\n    onDone(() { result._setValue(futureValue); });\n    onError((error) {\n      cancel();\n      result._setError(error);\n    });\n\n    return result;\n  }\n}\n\n// Internal helpers.\n\n// Types of the different handlers on a stream. Types used to type fields.\ntypedef void _DataHandler<T>(T value);\ntypedef void _ErrorHandler(error);\ntypedef void _DoneHandler();\n\n\n/** Default data handler, does nothing. */\nvoid _nullDataHandler(var value) {}\n\n/** Default error handler, reports the error to the global handler. */\nvoid _nullErrorHandler(error) {\n  _throwDelayed(error);\n}\n\n/** Default done handler, does nothing. */\nvoid _nullDoneHandler() {}\n\n\n/** A delayed event on a stream implementation. */\nabstract class _DelayedEvent {\n  /** Added as a linked list on the [StreamController]. */\n  _DelayedEvent next;\n  /** Execute the delayed event on the [StreamController]. */\n  void perform(_StreamImpl stream);\n}\n\n/** A delayed data event. */\nclass _DelayedData<T> extends _DelayedEvent{\n  final T value;\n  _DelayedData(this.value);\n  void perform(_StreamImpl<T> stream) {\n    stream._sendData(value);\n  }\n}\n\n/** A delayed error event. */\nclass _DelayedError extends _DelayedEvent {\n  final error;\n  _DelayedError(this.error);\n  void perform(_StreamImpl stream) {\n    stream._sendError(error);\n  }\n}\n\n/** A delayed done event. */\nclass _DelayedDone implements _DelayedEvent {\n  const _DelayedDone();\n  void perform(_StreamImpl stream) {\n    stream._sendDone();\n  }\n\n  _DelayedEvent get next => null;\n\n  void set next(_DelayedEvent _) {\n    throw new StateError(\"No events after a done.\");\n  }\n}\n\n/**\n * Simple internal doubly-linked list implementation.\n *\n * In an internal linked list, the links are in the data objects themselves,\n * instead of in a separate object. That means each element can be in at most\n * one list at a time.\n *\n * All links are always members of an element cycle. At creation it's a\n * singleton cycle.\n */\nabstract class _InternalLink {\n  _InternalLink _nextLink;\n  _InternalLink _previousLink;\n\n  _InternalLink() {\n    this._previousLink = this._nextLink = this;\n  }\n\n  /* Removes a link from any list it may be part of, and links it to itself. */\n  static void unlink(_InternalLink element) {\n    _InternalLink next = element._nextLink;\n    _InternalLink previous = element._previousLink;\n    next._previousLink = previous;\n    previous._nextLink = next;\n    element._nextLink = element._previousLink = element;\n  }\n\n  /** Check whether an element is unattached to other elements. */\n  static bool isUnlinked(_InternalLink element) {\n    return identical(element, element._nextLink);\n  }\n}\n\n/**\n * Marker interface for \"list\" links.\n *\n * An \"InternalLinkList\" is an abstraction on top of a link cycle, where the\n * \"list\" object itself is not considered an element (it's just a header link\n * created to avoid edge cases).\n * An element is considered part of a list if it is in the list's cycle.\n * There should never be more than one \"list\" object in a cycle.\n */\nabstract class _InternalLinkList extends _InternalLink {\n  /**\n   * Adds an element to a list, just before the header link.\n   *\n   * This effectively adds it at the end of the list.\n   */\n  static void add(_InternalLinkList list, _InternalLink element) {\n    if (!_InternalLink.isUnlinked(element)) _InternalLink.unlink(element);\n    _InternalLink listEnd = list._previousLink;\n    listEnd._nextLink = element;\n    list._previousLink = element;\n    element._previousLink = listEnd;\n    element._nextLink = list;\n  }\n\n  /** Removes an element from its list. */\n  static void remove(_InternalLink element) {\n    _InternalLink.unlink(element);\n  }\n\n  /** Check whether a list contains no elements, only the header link. */\n  static bool isEmpty(_InternalLinkList list) => _InternalLink.isUnlinked(list);\n\n  /** Moves all elements from the list [other] to [list]. */\n  static void addAll(_InternalLinkList list, _InternalLinkList other) {\n    if (isEmpty(other)) return;\n    _InternalLink listLast = list._previousLink;\n    _InternalLink otherNext = other._nextLink;\n    listLast._nextLink = otherNext;\n    otherNext._previousLink = listLast;\n    _InternalLink otherLast = other._previousLink;\n    list._previousLink = otherLast;\n    otherLast._nextLink = list;\n    // Clean up [other].\n    other._nextLink = other._previousLink = other;\n  }\n}\n\n/** Abstract type for an internal interface for sending events. */\nabstract class _EventOutputSink<T> {\n  _sendData(T data);\n  _sendError(error);\n  _sendDone();\n}\n\nabstract class _StreamListener<T> extends _InternalLink\n                                  implements _EventOutputSink<T> {\n  final _StreamImpl _source;\n  int _state = _LISTENER_UNSUBSCRIBED;\n\n  _StreamListener(this._source);\n\n  bool get isPaused => _state >= (1 << _LISTENER_PAUSE_COUNT_SHIFT);\n\n  bool get _isPendingUnsubscribe =>\n      (_state & _LISTENER_PENDING_UNSUBSCRIBE) != 0;\n\n  bool get _isSubscribed => (_state & _LISTENER_SUBSCRIBED) != 0;\n\n  /**\n   * Whether the listener still needs to receive the currently firing event.\n   *\n   * The currently firing event is identified by a single bit, which alternates\n   * between events. The [_state] contains the previously sent event's bit in\n   * the [_LISTENER_EVENT_ID] bit. If the two don't match, this listener\n   * still need the current event.\n   */\n  bool _needsEvent(int currentEventIdBit) {\n    int lastEventIdBit =\n        (_state & _LISTENER_EVENT_ID) >> _LISTENER_EVENT_ID_SHIFT;\n    return lastEventIdBit != currentEventIdBit;\n  }\n\n  /// If a subscriber's \"firing bit\" doesn't match the stream's firing bit,\n  /// we are currently firing an event and the subscriber still need to receive\n  /// the event.\n  void _toggleEventReceived() {\n    _state ^= _LISTENER_EVENT_ID;\n  }\n\n  void _setSubscribed(int eventIdBit) {\n    assert(eventIdBit == 0 || eventIdBit == 1);\n    _state = _LISTENER_SUBSCRIBED | (eventIdBit << _LISTENER_EVENT_ID_SHIFT);\n  }\n\n  void _setPendingUnsubscribe(int currentEventIdBit) {\n    assert(_isSubscribed);\n    // Sets the pending unsubscribe, and ensures that the listener\n    // won't get the current event.\n    _state |= _LISTENER_PENDING_UNSUBSCRIBE | _LISTENER_EVENT_ID;\n    _state ^= (1 ^ currentEventIdBit) << _LISTENER_EVENT_ID_SHIFT;\n    assert(!_needsEvent(currentEventIdBit));\n  }\n\n  /**\n   * Marks the listener as unsubscibed.\n   *\n   * Returns the number of unresumed pauses for the listener.\n   */\n  int _setUnsubscribed() {\n    assert(_isSubscribed);\n    int timesPaused = _state >> _LISTENER_PAUSE_COUNT_SHIFT;\n    _state = _LISTENER_UNSUBSCRIBED;\n    return timesPaused;\n  }\n\n  void _incrementPauseCount() {\n    _state += 1 << _LISTENER_PAUSE_COUNT_SHIFT;\n  }\n\n  void _decrementPauseCount() {\n    assert(isPaused);\n    _state -= 1 << _LISTENER_PAUSE_COUNT_SHIFT;\n  }\n\n  _sendData(T data);\n  _sendError(error);\n  _sendDone();\n}\n\n/** Superclass for provider of pending events. */\nabstract class _PendingEvents {\n  /**\n   * Timer set when pending events are scheduled for execution.\n   *\n   * When scheduling pending events for execution in a later cycle, the timer\n   * is stored here. If pending events are executed earlier than that, e.g.,\n   * due to a second event in the current cycle, the timer is canceled again.\n   */\n  Timer scheduleTimer = null;\n\n  bool get isEmpty;\n\n  bool get isScheduled => scheduleTimer != null;\n\n  void schedule(_StreamImpl stream) {\n    if (isScheduled) return;\n    scheduleTimer = new Timer(Duration.ZERO, () {\n      scheduleTimer = null;\n      stream._handlePendingEvents();\n    });\n  }\n\n  void cancelSchedule() {\n    assert(isScheduled);\n    scheduleTimer.cancel();\n    scheduleTimer = null;\n  }\n\n  void handleNext(_StreamImpl stream);\n}\n\n\n/** Class holding pending events for a [_StreamImpl]. */\nclass _StreamImplEvents extends _PendingEvents {\n  /// Single linked list of [_DelayedEvent] objects.\n  _DelayedEvent firstPendingEvent = null;\n  /// Last element in the list of pending events. New events are added after it.\n  _DelayedEvent lastPendingEvent = null;\n\n  bool get isEmpty => lastPendingEvent == null;\n\n  bool get isScheduled => scheduleTimer != null;\n\n  void add(_DelayedEvent event) {\n    if (lastPendingEvent == null) {\n      firstPendingEvent = lastPendingEvent = event;\n    } else {\n      lastPendingEvent = lastPendingEvent.next = event;\n    }\n  }\n\n  void handleNext(_StreamImpl stream) {\n    assert(!isScheduled);\n    _DelayedEvent event = firstPendingEvent;\n    firstPendingEvent = event.next;\n    if (firstPendingEvent == null) {\n      lastPendingEvent = null;\n    }\n    event.perform(stream);\n  }\n}\n\n\nclass _DoneSubscription<T> implements StreamSubscription<T> {\n  _DoneHandler _handler;\n  Timer _timer;\n  int _pauseCount = 0;\n\n  _DoneSubscription(this._handler) {\n    _delayDone();\n  }\n\n  void _delayDone() {\n    assert(_timer == null && _pauseCount == 0);\n    _timer = new Timer(Duration.ZERO, () {\n      if (_handler != null) _handler();\n    });\n  }\n\n  bool get _isComplete => _timer == null && _pauseCount == 0;\n\n  void onData(void handleAction(T value)) {}\n\n  void onError(void handleError(error)) {}\n\n  void onDone(void handleDone()) {\n    _handler = handleDone;\n  }\n\n  void pause([Future signal]) {\n    if (_isComplete) return;\n    if (_timer != null) {\n      _timer.cancel();\n      _timer = null;\n    }\n    _pauseCount++;\n    if (signal != null) signal.whenComplete(resume);\n  }\n\n  void resume() {\n    if (_isComplete) return;\n    if (_pauseCount == 0) return;\n    _pauseCount--;\n    if (_pauseCount == 0) {\n      _delayDone();\n    }\n  }\n\n  bool get isPaused => _pauseCount > 0;\n\n  void cancel() {\n    if (_isComplete) return;\n    if (_timer != null) {\n      _timer.cancel();\n      _timer = null;\n    }\n    _pauseCount = 0;\n  }\n\n  Future asFuture([var futureValue]) {\n    // TODO(floitsch): share more code.\n    _FutureImpl<T> result = new _FutureImpl<T>();\n\n    // Overwrite the onDone and onError handlers.\n    onDone(() { result._setValue(futureValue); });\n    onError((error) {\n      cancel();\n      result._setError(error);\n    });\n\n    return result;\n  }\n}\n\nclass _SingleStreamMultiplexer<T> extends _MultiStreamImpl<T> {\n  final Stream<T> _source;\n  StreamSubscription<T> _subscription;\n\n  _SingleStreamMultiplexer(this._source);\n\n  void _callOnPauseStateChange() {\n    if (_isPaused) {\n      if (_subscription != null) {\n        _subscription.pause();\n      }\n    } else {\n      if (_subscription != null) {\n        _subscription.resume();\n      }\n    }\n  }\n\n  /**\n    * Subscribe or unsubscribe on [_source] depending on whether\n    * [_stream] has subscribers.\n    */\n  void _onSubscriptionStateChange() {\n    if (_hasListener) {\n      assert(_subscription == null);\n      _subscription = _source.listen(this._add,\n                                     onError: this._addError,\n                                     onDone: this._close);\n    } else {\n      // TODO(lrn): Check why this can happen.\n      if (_subscription == null) return;\n      _subscription.cancel();\n      _subscription = null;\n    }\n  }\n}\n","sdk/lib/async/stream_pipe.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n/**\n * Utility function to attach a stack trace to an [error]  if it doesn't have\n * one already.\n */\n_asyncError(Object error, Object stackTrace) {\n  if (stackTrace == null) return error;\n  if (getAttachedStackTrace(error) != null) return error;\n  _attachStackTrace(error, stackTrace);\n  return error;\n}\n\n/** Runs user code and takes actions depending on success or failure. */\n_runUserCode(userCode(), onSuccess(value), onError(error)) {\n  try {\n    onSuccess(userCode());\n  } catch (e, s) {\n    onError(_asyncError(e, s));\n  }\n}\n\n/** Helper function to make an onError argument to [_runUserCode]. */\n_cancelAndError(StreamSubscription subscription, _FutureImpl future) =>\n  (error) {\n    subscription.cancel();\n    future._setError(error);\n  };\n\n\n/**\n * A [Stream] that forwards subscriptions to another stream.\n *\n * This stream implements [Stream], but forwards all subscriptions\n * to an underlying stream, and wraps the returned subscription to\n * modify the events on the way.\n *\n * This class is intended for internal use only.\n */\nabstract class _ForwardingStream<S, T> extends Stream<T> {\n  final Stream<S> _source;\n\n  _ForwardingStream(this._source);\n\n  bool get isBroadcast => _source.isBroadcast;\n\n  StreamSubscription<T> listen(void onData(T value),\n                              { void onError(error),\n                                void onDone(),\n                                bool cancelOnError }) {\n    if (onData == null) onData = _nullDataHandler;\n    if (onError == null) onError = _nullErrorHandler;\n    if (onDone == null) onDone = _nullDoneHandler;\n    cancelOnError = identical(true, cancelOnError);\n    return _createSubscription(onData, onError, onDone, cancelOnError);\n  }\n\n  StreamSubscription<T> _createSubscription(void onData(T value),\n                                            void onError(error),\n                                            void onDone(),\n                                            bool cancelOnError) {\n    return new _ForwardingStreamSubscription<S, T>(\n        this, onData, onError, onDone, cancelOnError);\n  }\n\n  // Override the following methods in subclasses to change the behavior.\n\n  void _handleData(S data, _EventOutputSink<T> sink) {\n    var outputData = data;\n    sink._sendData(outputData);\n  }\n\n  void _handleError(error, _EventOutputSink<T> sink) {\n    sink._sendError(error);\n  }\n\n  void _handleDone(_EventOutputSink<T> sink) {\n    sink._sendDone();\n  }\n}\n\n/**\n * Common behavior of [StreamSubscription] classes.\n *\n * Stores and allows updating of the event handlers of a [StreamSubscription].\n */\nabstract class _BaseStreamSubscription<T> implements StreamSubscription<T> {\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  var /* _DataHandler<T> */ _onData;\n  _ErrorHandler _onError;\n  _DoneHandler _onDone;\n\n  _BaseStreamSubscription(this._onData,\n                          this._onError,\n                          this._onDone) {\n    if (_onData == null) _onData = _nullDataHandler;\n    if (_onError == null) _onError = _nullErrorHandler;\n    if (_onDone == null) _onDone = _nullDoneHandler;\n  }\n\n  // StreamSubscription interface.\n  void onData(void handleData(T event)) {\n    if (handleData == null) handleData = _nullDataHandler;\n    _onData = handleData;\n  }\n\n  void onError(void handleError(error)) {\n    if (handleError == null) handleError = _nullErrorHandler;\n    _onError = handleError;\n  }\n\n  void onDone(void handleDone()) {\n    if (handleDone == null) handleDone = _nullDoneHandler;\n    _onDone = handleDone;\n  }\n\n  void pause([Future resumeSignal]);\n\n  void resume();\n\n  void cancel();\n\n  Future asFuture([var futureValue]) {\n    _FutureImpl<T> result = new _FutureImpl<T>();\n\n    // Overwrite the onDone and onError handlers.\n    onDone(() { result._setValue(futureValue); });\n    onError((error) {\n      cancel();\n      result._setError(error);\n    });\n\n    return result;\n  }\n}\n\n\n/**\n * Abstract superclass for subscriptions that forward to other subscriptions.\n */\nclass _ForwardingStreamSubscription<S, T>\n    extends _BaseStreamSubscription<T> implements _EventOutputSink<T> {\n  final _ForwardingStream<S, T> _stream;\n  final bool _cancelOnError;\n\n  StreamSubscription<S> _subscription;\n\n  _ForwardingStreamSubscription(this._stream,\n                                void onData(T data),\n                                void onError(error),\n                                void onDone(),\n                                this._cancelOnError)\n      : super(onData, onError, onDone) {\n    // Don't unsubscribe on incoming error, only if we send an error forwards.\n    _subscription =\n        _stream._source.listen(_handleData,\n                               onError: _handleError,\n                               onDone: _handleDone);\n  }\n\n  // StreamSubscription interface.\n\n  void pause([Future resumeSignal]) {\n    if (_subscription == null) return;\n    _subscription.pause(resumeSignal);\n  }\n\n  void resume() {\n    if (_subscription == null) return;\n    _subscription.resume();\n  }\n\n  void cancel() {\n    if (_subscription != null) {\n      _subscription.cancel();\n      _subscription = null;\n    }\n  }\n\n  // _EventOutputSink interface. Sends data to this subscription.\n\n  void _sendData(T data) {\n    _onData(data);\n  }\n\n  void _sendError(error) {\n    _onError(error);\n    if (_cancelOnError) {\n      _subscription.cancel();\n      _subscription = null;\n    }\n  }\n\n  void _sendDone() {\n    // If the transformation sends a done signal, we stop the subscription.\n    if (_subscription != null) {\n      _subscription.cancel();\n      _subscription = null;\n    }\n    _onDone();\n  }\n\n  // Methods used as listener on source subscription.\n\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  void _handleData(/*S*/ data) {\n    _stream._handleData(data, this);\n  }\n\n  void _handleError(error) {\n    _stream._handleError(error, this);\n  }\n\n  void _handleDone() {\n    // On a done-event, we have already been unsubscribed.\n    _subscription = null;\n    _stream._handleDone(this);\n  }\n}\n\n// -------------------------------------------------------------------\n// Stream transformers used by the default Stream implementation.\n// -------------------------------------------------------------------\n\ntypedef bool _Predicate<T>(T value);\n\nclass _WhereStream<T> extends _ForwardingStream<T, T> {\n  final _Predicate<T> _test;\n\n  _WhereStream(Stream<T> source, bool test(T value))\n      : _test = test, super(source);\n\n  void _handleData(T inputEvent, _EventOutputSink<T> sink) {\n    bool satisfies;\n    try {\n      satisfies = _test(inputEvent);\n    } catch (e, s) {\n      sink._sendError(_asyncError(e, s));\n      return;\n    }\n    if (satisfies) {\n      sink._sendData(inputEvent);\n    }\n  }\n}\n\n\ntypedef T _Transformation<S, T>(S value);\n\n/**\n * A stream pipe that converts data events before passing them on.\n */\nclass _MapStream<S, T> extends _ForwardingStream<S, T> {\n  final _Transformation _transform;\n\n  _MapStream(Stream<S> source, T transform(S event))\n      : this._transform = transform, super(source);\n\n  void _handleData(S inputEvent, _EventOutputSink<T> sink) {\n    T outputEvent;\n    try {\n      outputEvent = _transform(inputEvent);\n    } catch (e, s) {\n      sink._sendError(_asyncError(e, s));\n      return;\n    }\n    sink._sendData(outputEvent);\n  }\n}\n\n/**\n * A stream pipe that converts data events before passing them on.\n */\nclass _ExpandStream<S, T> extends _ForwardingStream<S, T> {\n  final _Transformation<S, Iterable<T>> _expand;\n\n  _ExpandStream(Stream<S> source, Iterable<T> expand(S event))\n      : this._expand = expand, super(source);\n\n  void _handleData(S inputEvent, _EventOutputSink<T> sink) {\n    try {\n      for (T value in _expand(inputEvent)) {\n        sink._sendData(value);\n      }\n    } catch (e, s) {\n      // If either _expand or iterating the generated iterator throws,\n      // we abort the iteration.\n      sink._sendError(_asyncError(e, s));\n    }\n  }\n}\n\n\ntypedef void _ErrorTransformation(error);\ntypedef bool _ErrorTest(error);\n\n/**\n * A stream pipe that converts or disposes error events\n * before passing them on.\n */\nclass _HandleErrorStream<T> extends _ForwardingStream<T, T> {\n  final _ErrorTransformation _transform;\n  final _ErrorTest _test;\n\n  _HandleErrorStream(Stream<T> source,\n                    void transform(event),\n                    bool test(error))\n      : this._transform = transform, this._test = test, super(source);\n\n  void _handleError(Object error, _EventOutputSink<T> sink) {\n    bool matches = true;\n    if (_test != null) {\n      try {\n        matches = _test(error);\n      } catch (e, s) {\n        sink._sendError(_asyncError(e, s));\n        return;\n      }\n    }\n    if (matches) {\n      try {\n        _transform(error);\n      } catch (e, s) {\n        sink._sendError(_asyncError(e, s));\n        return;\n      }\n    } else {\n      sink._sendError(error);\n    }\n  }\n}\n\n\nclass _TakeStream<T> extends _ForwardingStream<T, T> {\n  int _remaining;\n\n  _TakeStream(Stream<T> source, int count)\n      : this._remaining = count, super(source) {\n    // This test is done early to avoid handling an async error\n    // in the _handleData method.\n    if (count is! int) throw new ArgumentError(count);\n  }\n\n  void _handleData(T inputEvent, _EventOutputSink<T> sink) {\n    if (_remaining > 0) {\n      sink._sendData(inputEvent);\n      _remaining -= 1;\n      if (_remaining == 0) {\n        // Closing also unsubscribes all subscribers, which unsubscribes\n        // this from source.\n        sink._sendDone();\n      }\n    }\n  }\n}\n\n\nclass _TakeWhileStream<T> extends _ForwardingStream<T, T> {\n  final _Predicate<T> _test;\n\n  _TakeWhileStream(Stream<T> source, bool test(T value))\n      : this._test = test, super(source);\n\n  void _handleData(T inputEvent, _EventOutputSink<T> sink) {\n    bool satisfies;\n    try {\n      satisfies = _test(inputEvent);\n    } catch (e, s) {\n      sink._sendError(_asyncError(e, s));\n      // The test didn't say true. Didn't say false either, but we stop anyway.\n      sink._sendDone();\n      return;\n    }\n    if (satisfies) {\n      sink._sendData(inputEvent);\n    } else {\n      sink._sendDone();\n    }\n  }\n}\n\nclass _SkipStream<T> extends _ForwardingStream<T, T> {\n  int _remaining;\n\n  _SkipStream(Stream<T> source, int count)\n      : this._remaining = count, super(source) {\n    // This test is done early to avoid handling an async error\n    // in the _handleData method.\n    if (count is! int || count < 0) throw new ArgumentError(count);\n  }\n\n  void _handleData(T inputEvent, _EventOutputSink<T> sink) {\n    if (_remaining > 0) {\n      _remaining--;\n      return;\n    }\n    return sink._sendData(inputEvent);\n  }\n}\n\nclass _SkipWhileStream<T> extends _ForwardingStream<T, T> {\n  final _Predicate<T> _test;\n  bool _hasFailed = false;\n\n  _SkipWhileStream(Stream<T> source, bool test(T value))\n      : this._test = test, super(source);\n\n  void _handleData(T inputEvent, _EventOutputSink<T> sink) {\n    if (_hasFailed) {\n      sink._sendData(inputEvent);\n      return;\n    }\n    bool satisfies;\n    try {\n      satisfies = _test(inputEvent);\n    } catch (e, s) {\n      sink._sendError(_asyncError(e, s));\n      // A failure to return a boolean is considered \"not matching\".\n      _hasFailed = true;\n      return;\n    }\n    if (!satisfies) {\n      _hasFailed = true;\n      sink._sendData(inputEvent);\n    }\n  }\n}\n\ntypedef bool _Equality<T>(T a, T b);\n\nclass _DistinctStream<T> extends _ForwardingStream<T, T> {\n  static var _SENTINEL = new Object();\n\n  _Equality<T> _equals;\n  var _previous = _SENTINEL;\n\n  _DistinctStream(Stream<T> source, bool equals(T a, T b))\n      : _equals = equals, super(source);\n\n  void _handleData(T inputEvent, _EventOutputSink<T> sink) {\n    if (identical(_previous, _SENTINEL)) {\n      _previous = inputEvent;\n      return sink._sendData(inputEvent);\n    } else {\n      bool isEqual;\n      try {\n        if (_equals == null) {\n          isEqual = (_previous == inputEvent);\n        } else {\n          isEqual = _equals(_previous, inputEvent);\n        }\n      } catch (e, s) {\n        sink._sendError(_asyncError(e, s));\n        return null;\n      }\n      if (!isEqual) {\n        sink._sendData(inputEvent);\n        _previous = inputEvent;\n      }\n    }\n  }\n}\n\n// Stream transformations and event transformations.\n\ntypedef void _TransformDataHandler<S, T>(S data, EventSink<T> sink);\ntypedef void _TransformErrorHandler<T>(data, EventSink<T> sink);\ntypedef void _TransformDoneHandler<T>(EventSink<T> sink);\n\n/** Default data handler forwards all data. */\nvoid _defaultHandleData(var data, EventSink sink) {\n  sink.add(data);\n}\n\n/** Default error handler forwards all errors. */\nvoid _defaultHandleError(error, EventSink sink) {\n  sink.addError(error);\n}\n\n/** Default done handler forwards done. */\nvoid _defaultHandleDone(EventSink sink) {\n  sink.close();\n}\n\n\n/**\n * A [StreamTransformer] that modifies stream events.\n *\n * This class is used by [StreamTransformer]'s factory constructor.\n * It is actually an [StreamEventTransformer] where the functions used to\n * modify the events are passed as constructor arguments.\n *\n * If an argument is omitted, it acts as the default method from\n * [StreamEventTransformer].\n */\nclass _StreamTransformerImpl<S, T> extends StreamEventTransformer<S, T> {\n  // TODO(ahe): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  final Function /*_TransformDataHandler<S, T>*/ _handleData;\n  final _TransformErrorHandler<T> _handleError;\n  final _TransformDoneHandler<T> _handleDone;\n\n  _StreamTransformerImpl(void handleData(S data, EventSink<T> sink),\n                         void handleError(data, EventSink<T> sink),\n                         void handleDone(EventSink<T> sink))\n      : this._handleData  = (handleData == null  ? _defaultHandleData\n                                                 : handleData),\n        this._handleError = (handleError == null ? _defaultHandleError\n                                                 : handleError),\n        this._handleDone  = (handleDone == null  ? _defaultHandleDone\n                                                 : handleDone);\n\n  void handleData(S data, EventSink<T> sink) {\n    _handleData(data, sink);\n  }\n\n  void handleError(error, EventSink<T> sink) {\n    _handleError(error, sink);\n  }\n\n  void handleDone(EventSink<T> sink) {\n    _handleDone(sink);\n  }\n}\n\n","sdk/lib/async/timer.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\nabstract class Timer {\n  // Internal list used to group Timer.run callbacks.\n  static List _runCallbacks = [];\n\n  /**\n   * Creates a new timer.\n   *\n   * The [callback] callback is invoked after the given [duration].\n   * A negative duration is treated similar to a duration of 0.\n   *\n   * If the [duration] is statically known to be 0, consider using [run].\n   *\n   * Frequently the [duration] is either a constant or computed as in the\n   * following example (taking advantage of the multiplication operator of\n   * the Duration class):\n   *\n   *     const TIMEOUT = const Duration(seconds: 3);\n   *     const ms = const Duration(milliseconds: 1);\n   *\n   *     startTimeout([int milliseconds]) {\n   *       var duration = milliseconds == null ? TIMEOUT : ms * milliseconds;\n   *       return new Timer(duration, handleTimeout);\n   *     }\n   *\n   * Note: If Dart code using Timer is compiled to JavaScript, the finest\n   * granularity available in the browser is 4 milliseconds.\n   */\n  external factory Timer(Duration duration, void callback());\n\n  /**\n   * Creates a new repeating timer.\n   *\n   * The [callback] is invoked repeatedly with [duration] intervals until\n   * canceled. A negative duration is treated similar to a duration of 0.\n   */\n  external factory Timer.periodic(Duration duration,\n                                  void callback(Timer timer));\n\n  /**\n   * Runs the given [callback] asynchronously as soon as possible.\n   */\n  static void run(void callback()) {\n    // Optimizing a group of Timer.run callbacks to be executed in the\n    // same Timer callback.\n    _runCallbacks.add(callback);\n    if (_runCallbacks.length == 1) {\n      new Timer(const Duration(milliseconds: 0), () {\n        List runCallbacks = _runCallbacks;\n        // Create new list to make sure we don't call newly added callbacks in\n        // this event.\n        _runCallbacks = [];\n        for (int i = 0; i < runCallbacks.length; i++) {\n          Function callback = runCallbacks[i];\n          try {\n            callback();\n          } catch (e) {\n            List newCallbacks = _runCallbacks;\n            _runCallbacks = [];\n            i++;  // Skip the current;\n            _runCallbacks.addAll(\n                runCallbacks.sublist(i));\n            _runCallbacks.addAll(newCallbacks);\n            throw;\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Cancels the timer.\n   */\n  void cancel();\n}\n","sdk/lib/chrome/dart2js/chrome_dart2js.dart":"/// Native wrappers for the Chrome Packaged App APIs.\n///\n/// These functions allow direct access to the Packaged App APIs, allowing\n/// Chrome Packaged Apps to be written using Dart.\n///\n/// For more information on these APIs, see the\n/// [Chrome APIs Documentation](http://developer.chrome.com/extensions/api_index.html)\nlibrary chrome;\n\nimport 'dart:_foreign_helper' show JS;\nimport 'dart:_js_helper';\nimport 'dart:html_common';\nimport 'dart:html';\n\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// DO NOT EDIT - unless you are editing documentation as per:\n// https://code.google.com/p/dart/wiki/ContributingHTMLDocumentation\n// Auto-generated dart:chrome library.\n\n\n/* TODO(sashab): Add \"show convertDartClosureToJS\" once 'show' works. */\n\n\n// Generated files below this line.\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/**\n * A set of utilities for use with the Chrome Extension APIs.\n *\n * Allows for easy access to required JS objects.\n */\n\n/**\n * A dart object, that is convertible to JS. Used for creating objects in dart,\n * then passing them to JS.\n *\n * Objects that are passable to JS need to implement this interface.\n */\nabstract class ChromeObject {\n  /*\n   * Default Constructor\n   *\n   * Called by child objects during their regular construction.\n   */\n  ChromeObject() : _jsObject = JS('var', '{}');\n\n  /*\n   * Internal proxy constructor\n   *\n   * Creates a new Dart object using this existing proxy.\n   */\n  ChromeObject._proxy(this._jsObject);\n\n  /*\n   * JS Object Representation\n   */\n  final Object _jsObject;\n}\n\n/**\n * Useful functions for converting arguments.\n */\n\n/**\n * Converts the given map-type argument to js-friendly format, recursively.\n * Returns the new Map object.\n */\nObject _convertMapArgument(Map argument) {\n  Map m = new Map();\n  for (Object key in argument.keys)\n    m[key] = convertArgument(argument[key]);\n  return convertDartToNative_Dictionary(m);\n}\n\n/**\n * Converts the given list-type argument to js-friendly format, recursively.\n * Returns the new List object.\n */\nList _convertListArgument(List argument) {\n  List l = new List();\n  for (var i = 0; i < argument.length; i ++)\n    l.add(convertArgument(argument[i]));\n  return l;\n}\n\n/**\n * Converts the given argument Object to js-friendly format, recursively.\n *\n * Flattens out all Chrome objects into their corresponding ._toMap()\n * definitions, then converts them to JS objects.\n *\n * Returns the new argument.\n *\n * Cannot be used for functions.\n */\nObject convertArgument(var argument) {\n  if (argument == null)\n    return argument;\n\n  if (argument is num || argument is String || argument is bool)\n    return argument;\n\n  if (argument is ChromeObject)\n    return argument._jsObject;\n\n  if (argument is List)\n    return _convertListArgument(argument);\n\n  if (argument is Map)\n    return _convertMapArgument(argument);\n\n  if (argument is Function)\n    throw new Exception(\"Cannot serialize Function argument ${argument}.\");\n\n  // TODO(sashab): Try and detect whether the argument is already serialized.\n  return argument;\n}\n\n/// Description of a declarative rule for handling events.\nclass Rule extends ChromeObject {\n  /*\n   * Public (Dart) constructor\n   */\n  Rule({String id, List conditions, List actions, int priority}) {\n    this.id = id;\n    this.conditions = conditions;\n    this.actions = actions;\n    this.priority = priority;\n  }\n\n  /*\n   * Private (JS) constructor\n   */\n  Rule._proxy(_jsObject) : super._proxy(_jsObject);\n\n  /*\n   * Public accessors\n   */\n  String get id => JS('String', '#.id', this._jsObject);\n\n  void set id(String id) {\n    JS('void', '#.id = #', this._jsObject, id);\n  }\n\n  // TODO(sashab): Wrap these generic Lists somehow.\n  List get conditions => JS('List', '#.conditions', this._jsObject);\n\n  void set conditions(List conditions) {\n    JS('void', '#.conditions = #', this._jsObject, convertArgument(conditions));\n  }\n\n  // TODO(sashab): Wrap these generic Lists somehow.\n  List get actions => JS('List', '#.actions', this._jsObject);\n\n  void set actions(List actions) {\n    JS('void', '#.actions = #', this._jsObject, convertArgument(actions));\n  }\n\n  int get priority => JS('int', '#.priority', this._jsObject);\n\n  void set priority(int priority) {\n    JS('void', '#.priority = #', this._jsObject, priority);\n  }\n\n}\n\n/**\n * The Event class.\n *\n * Chrome Event classes extend this interface.\n *\n * e.g.\n *\n *  // chrome.app.runtime.onLaunched\n *  class Event_ChromeAppRuntimeOnLaunched extends Event {\n *    // constructor, passing the arity of the callback\n *    Event_ChromeAppRuntimeOnLaunched(jsObject) :\n *     super._(jsObject, 1);\n *\n *    // methods, strengthening the Function parameter specificity\n *    void addListener(void callback(LaunchData launchData))\n *        => super.addListener(callback);\n *    void removeListener(void callback(LaunchData launchData))\n *        => super.removeListener(callback);\n *    bool hasListener(void callback(LaunchData launchData))\n *        => super.hasListener(callback);\n *  }\n *\n */\nclass Event {\n  /*\n   * JS Object Representation\n   */\n  final Object _jsObject;\n\n  /*\n   * Number of arguments the callback takes.\n   */\n  final int _callbackArity;\n\n  /*\n   * Private constructor\n   */\n  Event._(this._jsObject, this._callbackArity);\n\n  /*\n   * Methods\n   */\n\n  /// Registers an event listener <em>callback</em> to an event.\n  void addListener(Function callback) =>\n      JS('void',\n         '#.addListener(#)',\n         this._jsObject,\n         convertDartClosureToJS(callback, this._callbackArity)\n      );\n\n  /// Deregisters an event listener <em>callback</em> from an event.\n  void removeListener(Function callback) =>\n      JS('void',\n         '#.removeListener(#)',\n         this._jsObject,\n         convertDartClosureToJS(callback, this._callbackArity)\n      );\n\n  /// Returns True if <em>callback</em> is registered to the event.\n  bool hasListener(Function callback) =>\n      JS('bool',\n         '#.hasListener(#)',\n         this._jsObject,\n         convertDartClosureToJS(callback, this._callbackArity)\n      );\n\n  /// Returns true if any event listeners are registered to the event.\n  bool hasListeners() =>\n      JS('bool',\n         '#.hasListeners()',\n         this._jsObject\n      );\n\n  /// Registers rules to handle events.\n  ///\n  /// [eventName] is the name of the event this function affects and [rules] are\n  /// the rules to be registered. These do not replace previously registered\n  /// rules. [callback] is called with registered rules.\n  ///\n  void addRules(String eventName, List<Rule> rules,\n                [void callback(List<Rule> rules)]) {\n    // proxy the callback\n    void __proxy_callback(List rules) {\n      if (?callback) {\n        List<Rule> __proxy_rules = new List<Rule>();\n\n        for (Object o in rules)\n          __proxy_rules.add(new Rule._proxy(o));\n\n        callback(__proxy_rules);\n      }\n    }\n\n    JS('void',\n       '#.addRules(#, #, #)',\n       this._jsObject,\n       convertArgument(eventName),\n       convertArgument(rules),\n       convertDartClosureToJS(__proxy_callback, 1)\n    );\n  }\n\n  /// Returns currently registered rules.\n  ///\n  /// [eventName] is the name of the event this function affects and, if an array\n  /// is passed as [ruleIdentifiers], only rules with identifiers contained in\n  /// this array are returned. [callback] is called with registered rules.\n  ///\n  void getRules(String eventName, [List<String> ruleIdentifiers,\n                                   void callback(List<Rule> rules)]) {\n    // proxy the callback\n    void __proxy_callback(List rules) {\n      if (?callback) {\n        List<Rule> __proxy_rules = new List<Rule>();\n\n        for (Object o in rules)\n          __proxy_rules.add(new Rule._proxy(o));\n\n        callback(__proxy_rules);\n      }\n    }\n\n    JS('void',\n       '#.getRules(#, #, #)',\n       this._jsObject,\n       convertArgument(eventName),\n       convertArgument(ruleIdentifiers),\n       convertDartClosureToJS(__proxy_callback, 1)\n    );\n  }\n\n  /// Unregisters currently registered rules.\n  ///\n  /// [eventName] is the name of the event this function affects and, if an array\n  /// is passed as [ruleIdentifiers], only rules with identifiers contained in\n  /// this array are unregistered. [callback] is called when the rules are\n  /// unregistered.\n  ///\n  void removeRules(String eventName, [List<String> ruleIdentifiers,\n                                      void callback()]) =>\n      JS('void',\n         '#.removeRules(#, #, #)',\n         this._jsObject,\n         convertArgument(eventName),\n         convertArgument(ruleIdentifiers),\n         convertDartClosureToJS(callback, 0)\n      );\n}\n\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n// chrome.app\nclass API_ChromeApp {\n  /*\n   * JS Variable\n   */\n  final Object _jsObject;\n\n  /*\n   * Members\n   */\n  API_app_window window;\n  API_app_runtime runtime;\n\n  /*\n   * Constructor\n   */\n  API_ChromeApp(this._jsObject) {\n    var window_object = JS('', '#.window', this._jsObject);\n    if (window_object == null)\n      throw new UnsupportedError('Not supported by current browser.');\n    window = new API_app_window(window_object);\n\n    var runtime_object = JS('', '#.runtime', this._jsObject);\n    if (runtime_object == null)\n      throw new UnsupportedError('Not supported by current browser.');\n    runtime = new API_app_runtime(runtime_object);\n  }\n}\n\n// chrome\nclass API_Chrome {\n  /*\n   * JS Variable\n   */\n  Object _jsObject;\n\n  /*\n   * Members\n   */\n  API_ChromeApp app;\n\n  /*\n   * Constructor\n   */\n  API_Chrome() {\n    this._jsObject = JS(\"Object\", \"chrome\");\n    if (this._jsObject == null)\n      throw new UnsupportedError('Not supported by current browser.');\n\n    var app_object = JS('', '#.app', this._jsObject);\n    if (app_object == null)\n      throw new UnsupportedError('Not supported by current browser.');\n    app = new API_ChromeApp(app_object);\n  }\n}\n\n// The final chrome objects\nfinal API_Chrome chrome = new API_Chrome();\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Generated from namespace: app.window\n\n\n/**\n * Types\n */\n\nclass AppWindowCreateWindowOptions extends ChromeObject {\n  /*\n   * Public constructor\n   */\n  AppWindowCreateWindowOptions({String id, int defaultWidth, int defaultHeight, int defaultLeft, int defaultTop, int width, int height, int left, int top, int minWidth, int minHeight, int maxWidth, int maxHeight, String type, String frame, AppWindowBounds bounds, bool transparentBackground, bool hidden, bool singleton}) {\n    if (?id)\n      this.id = id;\n    if (?defaultWidth)\n      this.defaultWidth = defaultWidth;\n    if (?defaultHeight)\n      this.defaultHeight = defaultHeight;\n    if (?defaultLeft)\n      this.defaultLeft = defaultLeft;\n    if (?defaultTop)\n      this.defaultTop = defaultTop;\n    if (?width)\n      this.width = width;\n    if (?height)\n      this.height = height;\n    if (?left)\n      this.left = left;\n    if (?top)\n      this.top = top;\n    if (?minWidth)\n      this.minWidth = minWidth;\n    if (?minHeight)\n      this.minHeight = minHeight;\n    if (?maxWidth)\n      this.maxWidth = maxWidth;\n    if (?maxHeight)\n      this.maxHeight = maxHeight;\n    if (?type)\n      this.type = type;\n    if (?frame)\n      this.frame = frame;\n    if (?bounds)\n      this.bounds = bounds;\n    if (?transparentBackground)\n      this.transparentBackground = transparentBackground;\n    if (?hidden)\n      this.hidden = hidden;\n    if (?singleton)\n      this.singleton = singleton;\n  }\n\n  /*\n   * Private constructor\n   */\n  AppWindowCreateWindowOptions._proxy(_jsObject) : super._proxy(_jsObject);\n\n  /*\n   * Public accessors\n   */\n  /// Id to identify the window. This will be used to remember the size and\n  /// position of the window and restore that geometry when a window with the\n  /// same id (and no explicit size or position) is later opened.\n  String get id => JS('String', '#.id', this._jsObject);\n\n  void set id(String id) {\n    JS('void', '#.id = #', this._jsObject, id);\n  }\n\n  /// Default width of the window. (Deprecated; regular bounds act like this\n  /// now.)\n  int get defaultWidth => JS('int', '#.defaultWidth', this._jsObject);\n\n  void set defaultWidth(int defaultWidth) {\n    JS('void', '#.defaultWidth = #', this._jsObject, defaultWidth);\n  }\n\n  /// Default height of the window. (Deprecated; regular bounds act like this\n  /// now.)\n  int get defaultHeight => JS('int', '#.defaultHeight', this._jsObject);\n\n  void set defaultHeight(int defaultHeight) {\n    JS('void', '#.defaultHeight = #', this._jsObject, defaultHeight);\n  }\n\n  /// Default X coordinate of the window. (Deprecated; regular bounds act like\n  /// this now.)\n  int get defaultLeft => JS('int', '#.defaultLeft', this._jsObject);\n\n  void set defaultLeft(int defaultLeft) {\n    JS('void', '#.defaultLeft = #', this._jsObject, defaultLeft);\n  }\n\n  /// Default Y coordinate of the window. (Deprecated; regular bounds act like\n  /// this now.)\n  int get defaultTop => JS('int', '#.defaultTop', this._jsObject);\n\n  void set defaultTop(int defaultTop) {\n    JS('void', '#.defaultTop = #', this._jsObject, defaultTop);\n  }\n\n  /// Width of the window. (Deprecated; use 'bounds'.)\n  int get width => JS('int', '#.width', this._jsObject);\n\n  void set width(int width) {\n    JS('void', '#.width = #', this._jsObject, width);\n  }\n\n  /// Height of the window. (Deprecated; use 'bounds'.)\n  int get height => JS('int', '#.height', this._jsObject);\n\n  void set height(int height) {\n    JS('void', '#.height = #', this._jsObject, height);\n  }\n\n  /// X coordinate of the window. (Deprecated; use 'bounds'.)\n  int get left => JS('int', '#.left', this._jsObject);\n\n  void set left(int left) {\n    JS('void', '#.left = #', this._jsObject, left);\n  }\n\n  /// Y coordinate of the window. (Deprecated; use 'bounds'.)\n  int get top => JS('int', '#.top', this._jsObject);\n\n  void set top(int top) {\n    JS('void', '#.top = #', this._jsObject, top);\n  }\n\n  /// Minimum width of the window.\n  int get minWidth => JS('int', '#.minWidth', this._jsObject);\n\n  void set minWidth(int minWidth) {\n    JS('void', '#.minWidth = #', this._jsObject, minWidth);\n  }\n\n  /// Minimum height of the window.\n  int get minHeight => JS('int', '#.minHeight', this._jsObject);\n\n  void set minHeight(int minHeight) {\n    JS('void', '#.minHeight = #', this._jsObject, minHeight);\n  }\n\n  /// Maximum width of the window.\n  int get maxWidth => JS('int', '#.maxWidth', this._jsObject);\n\n  void set maxWidth(int maxWidth) {\n    JS('void', '#.maxWidth = #', this._jsObject, maxWidth);\n  }\n\n  /// Maximum height of the window.\n  int get maxHeight => JS('int', '#.maxHeight', this._jsObject);\n\n  void set maxHeight(int maxHeight) {\n    JS('void', '#.maxHeight = #', this._jsObject, maxHeight);\n  }\n\n  /// Window type:  'shell' - the default window type  'panel' - a panel, managed\n  /// by the OS (Currently experimental, Ash only)\n  String get type => JS('String', '#.type', this._jsObject);\n\n  void set type(String type) {\n    JS('void', '#.type = #', this._jsObject, type);\n  }\n\n  /// Frame type: 'none' or 'chrome' (defaults to 'chrome').\n  String get frame => JS('String', '#.frame', this._jsObject);\n\n  void set frame(String frame) {\n    JS('void', '#.frame = #', this._jsObject, frame);\n  }\n\n  /// Size of the content in the window (excluding the titlebar). If specified in\n  /// addition to any of the left/top/width/height parameters, this field takes\n  /// precedence. If a frameBounds is specified, the frameBounds take precedence.\n  AppWindowBounds get bounds => new AppWindowBounds._proxy(JS('', '#.bounds', this._jsObject));\n\n  void set bounds(AppWindowBounds bounds) {\n    JS('void', '#.bounds = #', this._jsObject, convertArgument(bounds));\n  }\n\n  /// Enable window background transparency. Only supported in ash. Requires\n  /// experimental API permission.\n  bool get transparentBackground => JS('bool', '#.transparentBackground', this._jsObject);\n\n  void set transparentBackground(bool transparentBackground) {\n    JS('void', '#.transparentBackground = #', this._jsObject, transparentBackground);\n  }\n\n  /// If true, the window will be created in a hidden state. Call show() on the\n  /// window to show it once it has been created. Defaults to false.\n  bool get hidden => JS('bool', '#.hidden', this._jsObject);\n\n  void set hidden(bool hidden) {\n    JS('void', '#.hidden = #', this._jsObject, hidden);\n  }\n\n  /// By default if you specify an id for the window, the window will only be\n  /// created if another window with the same id doesn't already exist. If a\n  /// window with the same id already exists that window is activated instead. If\n  /// you do want to create multiple windows with the same id, you can set this\n  /// property to false.\n  bool get singleton => JS('bool', '#.singleton', this._jsObject);\n\n  void set singleton(bool singleton) {\n    JS('void', '#.singleton = #', this._jsObject, singleton);\n  }\n\n}\n\nclass AppWindowBounds extends ChromeObject {\n  /*\n   * Public constructor\n   */\n  AppWindowBounds({int left, int top, int width, int height}) {\n    if (?left)\n      this.left = left;\n    if (?top)\n      this.top = top;\n    if (?width)\n      this.width = width;\n    if (?height)\n      this.height = height;\n  }\n\n  /*\n   * Private constructor\n   */\n  AppWindowBounds._proxy(_jsObject) : super._proxy(_jsObject);\n\n  /*\n   * Public accessors\n   */\n  int get left => JS('int', '#.left', this._jsObject);\n\n  void set left(int left) {\n    JS('void', '#.left = #', this._jsObject, left);\n  }\n\n  int get top => JS('int', '#.top', this._jsObject);\n\n  void set top(int top) {\n    JS('void', '#.top = #', this._jsObject, top);\n  }\n\n  int get width => JS('int', '#.width', this._jsObject);\n\n  void set width(int width) {\n    JS('void', '#.width = #', this._jsObject, width);\n  }\n\n  int get height => JS('int', '#.height', this._jsObject);\n\n  void set height(int height) {\n    JS('void', '#.height = #', this._jsObject, height);\n  }\n\n}\n\nclass AppWindowAppWindow extends ChromeObject {\n  /*\n   * Private constructor\n   */\n  AppWindowAppWindow._proxy(_jsObject) : super._proxy(_jsObject);\n\n  /*\n   * Public accessors\n   */\n  /// The JavaScript 'window' object for the created child.\n  // Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n  // for details. All rights reserved. Use of this source code is governed by a\n  // BSD-style license that can be found in the LICENSE file.\n\n  // TODO(sashab, sra): Detect whether this is the current window, or an\n  // external one, and return an appropriately-typed object\n  WindowBase get contentWindow =>\n    JS(\"Window\", \"#.contentWindow\", this._jsObject);\n\n  /*\n   * Methods\n   */\n  /// Focus the window.\n  void focus() => JS('void', '#.focus()', this._jsObject);\n\n  /// Minimize the window.\n  void minimize() => JS('void', '#.minimize()', this._jsObject);\n\n  /// Is the window minimized?\n  void isMinimized() => JS('void', '#.isMinimized()', this._jsObject);\n\n  /// Maximize the window.\n  void maximize() => JS('void', '#.maximize()', this._jsObject);\n\n  /// Is the window maximized?\n  void isMaximized() => JS('void', '#.isMaximized()', this._jsObject);\n\n  /// Restore the window.\n  void restore() => JS('void', '#.restore()', this._jsObject);\n\n  /// Move the window to the position (|left|, |top|).\n  void moveTo(int left, int top) => JS('void', '#.moveTo(#, #)', this._jsObject, left, top);\n\n  /// Resize the window to |width|x|height| pixels in size.\n  void resizeTo(int width, int height) => JS('void', '#.resizeTo(#, #)', this._jsObject, width, height);\n\n  /// Draw attention to the window.\n  void drawAttention() => JS('void', '#.drawAttention()', this._jsObject);\n\n  /// Clear attention to the window.\n  void clearAttention() => JS('void', '#.clearAttention()', this._jsObject);\n\n  /// Close the window.\n  void close() => JS('void', '#.close()', this._jsObject);\n\n  /// Show the window. Does nothing if the window is already visible.\n  void show() => JS('void', '#.show()', this._jsObject);\n\n  /// Hide the window. Does nothing if the window is already hidden.\n  void hide() => JS('void', '#.hide()', this._jsObject);\n\n  /// Get the window's bounds as a $ref:Bounds object.\n  // Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n  // for details. All rights reserved. Use of this source code is governed by a\n  // BSD-style license that can be found in the LICENSE file.\n\n  // TODO(sashab, kalman): Fix IDL parser to read function return values\n  // correctly. Currently, it just reads void for all functions.\n  AppWindowBounds getBounds() =>\n      new AppWindowBounds._proxy(JS('void', '#.getBounds()', this._jsObject));\n\n  /// Set the window's bounds.\n  void setBounds(AppWindowBounds bounds) => JS('void', '#.setBounds(#)', this._jsObject, convertArgument(bounds));\n\n  /// Set the app icon for the window (experimental). Currently this is only\n  /// being implemented on Ash. TODO(stevenjb): Investigate implementing this on\n  /// Windows and OSX.\n  void setIcon(String icon_url) => JS('void', '#.setIcon(#)', this._jsObject, icon_url);\n\n}\n\n/**\n * Events\n */\n\n/// Fired when the window is resized.\nclass Event_app_window_onBoundsChanged extends Event {\n  void addListener(void callback()) => super.addListener(callback);\n\n  void removeListener(void callback()) => super.removeListener(callback);\n\n  bool hasListener(void callback()) => super.hasListener(callback);\n\n  Event_app_window_onBoundsChanged(jsObject) : super._(jsObject, 0);\n}\n\n/// Fired when the window is closed.\nclass Event_app_window_onClosed extends Event {\n  void addListener(void callback()) => super.addListener(callback);\n\n  void removeListener(void callback()) => super.removeListener(callback);\n\n  bool hasListener(void callback()) => super.hasListener(callback);\n\n  Event_app_window_onClosed(jsObject) : super._(jsObject, 0);\n}\n\n/// Fired when the window is maximized.\nclass Event_app_window_onMaximized extends Event {\n  void addListener(void callback()) => super.addListener(callback);\n\n  void removeListener(void callback()) => super.removeListener(callback);\n\n  bool hasListener(void callback()) => super.hasListener(callback);\n\n  Event_app_window_onMaximized(jsObject) : super._(jsObject, 0);\n}\n\n/// Fired when the window is minimized.\nclass Event_app_window_onMinimized extends Event {\n  void addListener(void callback()) => super.addListener(callback);\n\n  void removeListener(void callback()) => super.removeListener(callback);\n\n  bool hasListener(void callback()) => super.hasListener(callback);\n\n  Event_app_window_onMinimized(jsObject) : super._(jsObject, 0);\n}\n\n/// Fired when the window is restored from being minimized or maximized.\nclass Event_app_window_onRestored extends Event {\n  void addListener(void callback()) => super.addListener(callback);\n\n  void removeListener(void callback()) => super.removeListener(callback);\n\n  bool hasListener(void callback()) => super.hasListener(callback);\n\n  Event_app_window_onRestored(jsObject) : super._(jsObject, 0);\n}\n\n/**\n * Functions\n */\n\nclass API_app_window {\n  /*\n   * API connection\n   */\n  Object _jsObject;\n\n  /*\n   * Events\n   */\n  Event_app_window_onBoundsChanged onBoundsChanged;\n  Event_app_window_onClosed onClosed;\n  Event_app_window_onMaximized onMaximized;\n  Event_app_window_onMinimized onMinimized;\n  Event_app_window_onRestored onRestored;\n\n  /*\n   * Functions\n   */\n  /// The size and position of a window can be specified in a number of different\n  /// ways. The most simple option is not specifying anything at all, in which\n  /// case a default size and platform dependent position will be used.<br/><br/>\n  /// Another option is to use the top/left and width/height properties, which\n  /// will always put the window at the specified coordinates with the specified\n  /// size.<br/><br/> Yet another option is to give the window a (unique) id.\n  /// This id is then used to remember the size and position of the window\n  /// whenever it is moved or resized. This size and position is then used\n  /// instead of the specified bounds on subsequent opening of a window with the\n  /// same id. If you need to open a window with an id at a location other than\n  /// the remembered default, you can create it hidden, move it to the desired\n  /// location, then show it.<br/><br/> You can also combine these various\n  /// options, explicitly specifying for example the size while having the\n  /// position be remembered or other combinations like that. Size and position\n  /// are dealt with seperately, but individual coordinates are not. So if you\n  /// specify a top (or left) coordinate, you should also specify a left (or top)\n  /// coordinate, and similar for size.<br/><br/> If you specify both a regular\n  /// and a default value for the same option the regular value is the only one\n  /// that takes effect.\n  // Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n  // for details. All rights reserved. Use of this source code is governed by a\n  // BSD-style license that can be found in the LICENSE file.\n\n  // TODO(sashab): This override is no longer needed once prefixes are removed.\n  void create(String url,\n              [AppWindowCreateWindowOptions options,\n              void callback(AppWindowAppWindow created_window)]) {\n    void __proxy_callback(created_window) {\n      if (?callback)\n        callback(new AppWindowAppWindow._proxy(created_window));\n    }\n    JS('void', '#.create(#, #, #)', this._jsObject, url, convertArgument(options),\n       convertDartClosureToJS(__proxy_callback, 1));\n  }\n\n  /// Returns an $ref:AppWindow object for the current script context (ie\n  /// JavaScript 'window' object). This can also be called on a handle to a\n  /// script context for another page, for example:\n  /// otherWindow.chrome.app.window.current().\n  // Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n  // for details. All rights reserved. Use of this source code is governed by a\n  // BSD-style license that can be found in the LICENSE file.\n\n  // TODO(sashab, kalman): Fix IDL parser to read function return values\n  // correctly. Currently, it just reads void for all functions.\n  AppWindowAppWindow current() =>\n      new AppWindowAppWindow._proxy(JS('void', '#.current()', this._jsObject));\n\n  void initializeAppWindow(Object state) => JS('void', '#.initializeAppWindow(#)', this._jsObject, convertArgument(state));\n\n  API_app_window(this._jsObject) {\n    onBoundsChanged = new Event_app_window_onBoundsChanged(JS('', '#.onBoundsChanged', this._jsObject));\n    onClosed = new Event_app_window_onClosed(JS('', '#.onClosed', this._jsObject));\n    onMaximized = new Event_app_window_onMaximized(JS('', '#.onMaximized', this._jsObject));\n    onMinimized = new Event_app_window_onMinimized(JS('', '#.onMinimized', this._jsObject));\n    onRestored = new Event_app_window_onRestored(JS('', '#.onRestored', this._jsObject));\n  }\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Generated from namespace: app.runtime\n\n\n/**\n * Types\n */\n\nclass AppRuntimeIntent extends ChromeObject {\n  /*\n   * Private constructor\n   */\n  AppRuntimeIntent._proxy(_jsObject) : super._proxy(_jsObject);\n\n  /*\n   * Public accessors\n   */\n  /// The WebIntent being invoked.\n  String get action => JS('String', '#.action', this._jsObject);\n\n  void set action(String action) {\n    JS('void', '#.action = #', this._jsObject, action);\n  }\n\n  /// The MIME type of the data.\n  String get type => JS('String', '#.type', this._jsObject);\n\n  void set type(String type) {\n    JS('void', '#.type = #', this._jsObject, type);\n  }\n\n  /// Data associated with the intent.\n  Object get data => JS('Object', '#.data', this._jsObject);\n\n  void set data(Object data) {\n    JS('void', '#.data = #', this._jsObject, convertArgument(data));\n  }\n\n\n  /*\n   * Methods\n   */\n  /// Callback to be compatible with WebIntents.\n  void postResult() => JS('void', '#.postResult()', this._jsObject);\n\n  /// Callback to be compatible with WebIntents.\n  void postFailure() => JS('void', '#.postFailure()', this._jsObject);\n\n}\n\nclass AppRuntimeLaunchItem extends ChromeObject {\n  /*\n   * Public constructor\n   */\n  AppRuntimeLaunchItem({FileEntry entry, String type}) {\n    if (?entry)\n      this.entry = entry;\n    if (?type)\n      this.type = type;\n  }\n\n  /*\n   * Private constructor\n   */\n  AppRuntimeLaunchItem._proxy(_jsObject) : super._proxy(_jsObject);\n\n  /*\n   * Public accessors\n   */\n  /// FileEntry for the file.\n  FileEntry get entry => JS('FileEntry', '#.entry', this._jsObject);\n\n  void set entry(FileEntry entry) {\n    JS('void', '#.entry = #', this._jsObject, convertArgument(entry));\n  }\n\n  /// The MIME type of the file.\n  String get type => JS('String', '#.type', this._jsObject);\n\n  void set type(String type) {\n    JS('void', '#.type = #', this._jsObject, type);\n  }\n\n}\n\nclass AppRuntimeLaunchData extends ChromeObject {\n  /*\n   * Public constructor\n   */\n  AppRuntimeLaunchData({AppRuntimeIntent intent, String id, List<AppRuntimeLaunchItem> items}) {\n    if (?intent)\n      this.intent = intent;\n    if (?id)\n      this.id = id;\n    if (?items)\n      this.items = items;\n  }\n\n  /*\n   * Private constructor\n   */\n  AppRuntimeLaunchData._proxy(_jsObject) : super._proxy(_jsObject);\n\n  /*\n   * Public accessors\n   */\n  AppRuntimeIntent get intent => new AppRuntimeIntent._proxy(JS('', '#.intent', this._jsObject));\n\n  void set intent(AppRuntimeIntent intent) {\n    JS('void', '#.intent = #', this._jsObject, convertArgument(intent));\n  }\n\n  /// The id of the file handler that the app is being invoked with.\n  String get id => JS('String', '#.id', this._jsObject);\n\n  void set id(String id) {\n    JS('void', '#.id = #', this._jsObject, id);\n  }\n\n  List<AppRuntimeLaunchItem> get items {\n    List<AppRuntimeLaunchItem> __proxy_items = new List<AppRuntimeLaunchItem>();\n    for (var o in JS('List', '#.items', this._jsObject)) {\n      __proxy_items.add(new AppRuntimeLaunchItem._proxy(o));\n    }\n    return __proxy_items;\n  }\n\n  void set items(List<AppRuntimeLaunchItem> items) {\n    JS('void', '#.items = #', this._jsObject, convertArgument(items));\n  }\n\n}\n\nclass AppRuntimeIntentResponse extends ChromeObject {\n  /*\n   * Public constructor\n   */\n  AppRuntimeIntentResponse({int intentId, bool success, Object data}) {\n    if (?intentId)\n      this.intentId = intentId;\n    if (?success)\n      this.success = success;\n    if (?data)\n      this.data = data;\n  }\n\n  /*\n   * Private constructor\n   */\n  AppRuntimeIntentResponse._proxy(_jsObject) : super._proxy(_jsObject);\n\n  /*\n   * Public accessors\n   */\n  /// Identifies the intent.\n  int get intentId => JS('int', '#.intentId', this._jsObject);\n\n  void set intentId(int intentId) {\n    JS('void', '#.intentId = #', this._jsObject, intentId);\n  }\n\n  /// Was this intent successful? (i.e., postSuccess vs postFailure).\n  bool get success => JS('bool', '#.success', this._jsObject);\n\n  void set success(bool success) {\n    JS('void', '#.success = #', this._jsObject, success);\n  }\n\n  /// Data associated with the intent response.\n  Object get data => JS('Object', '#.data', this._jsObject);\n\n  void set data(Object data) {\n    JS('void', '#.data = #', this._jsObject, convertArgument(data));\n  }\n\n}\n\n/**\n * Events\n */\n\n/// Fired when an app is launched from the launcher or in response to a web\n/// intent.\nclass Event_app_runtime_onLaunched extends Event {\n  void addListener(void callback(AppRuntimeLaunchData launchData)) {\n    void __proxy_callback(launchData) {\n      if (?callback) {\n        callback(new AppRuntimeLaunchData._proxy(launchData));\n      }\n    }\n    super.addListener(callback);\n  }\n\n  void removeListener(void callback(AppRuntimeLaunchData launchData)) {\n    void __proxy_callback(launchData) {\n      if (?callback) {\n        callback(new AppRuntimeLaunchData._proxy(launchData));\n      }\n    }\n    super.removeListener(callback);\n  }\n\n  bool hasListener(void callback(AppRuntimeLaunchData launchData)) {\n    void __proxy_callback(launchData) {\n      if (?callback) {\n        callback(new AppRuntimeLaunchData._proxy(launchData));\n      }\n    }\n    super.hasListener(callback);\n  }\n\n  Event_app_runtime_onLaunched(jsObject) : super._(jsObject, 1);\n}\n\n/// Fired at Chrome startup to apps that were running when Chrome last shut\n/// down.\nclass Event_app_runtime_onRestarted extends Event {\n  void addListener(void callback()) => super.addListener(callback);\n\n  void removeListener(void callback()) => super.removeListener(callback);\n\n  bool hasListener(void callback()) => super.hasListener(callback);\n\n  Event_app_runtime_onRestarted(jsObject) : super._(jsObject, 0);\n}\n\n/**\n * Functions\n */\n\nclass API_app_runtime {\n  /*\n   * API connection\n   */\n  Object _jsObject;\n\n  /*\n   * Events\n   */\n  Event_app_runtime_onLaunched onLaunched;\n  Event_app_runtime_onRestarted onRestarted;\n\n  /*\n   * Functions\n   */\n  /// postIntentResponse is an internal method to responds to an intent\n  /// previously sent to a packaged app. This is identified by intentId, and\n  /// should only be invoked at most once per intentId.\n  void postIntentResponse(AppRuntimeIntentResponse intentResponse) => JS('void', '#.postIntentResponse(#)', this._jsObject, convertArgument(intentResponse));\n\n  API_app_runtime(this._jsObject) {\n    onLaunched = new Event_app_runtime_onLaunched(JS('', '#.onLaunched', this._jsObject));\n    onRestarted = new Event_app_runtime_onRestarted(JS('', '#.onRestarted', this._jsObject));\n  }\n}\n","sdk/lib/collection/collection.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart.collection;\n\nimport 'dart:_collection-dev';\n\npart 'collections.dart';\npart 'iterable.dart';\npart 'iterator.dart';\npart 'maps.dart';\npart 'queue.dart';\npart 'splay_tree.dart';\npart 'hash_set.dart';\npart 'hash_map.dart';\npart 'list.dart';\npart 'linked_hash_set.dart';\npart 'linked_hash_map.dart';\n","sdk/lib/collection/collections.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/**\n * An unmodifiable [List] view of another List.\n *\n * The source of the elements may be a [List] or any [Iterable] with\n * efficient [Iterable.length] and [Iterable.elementAt].\n */\nclass UnmodifiableListView<E> extends UnmodifiableListBase<E> {\n  final Iterable<E> _source;\n  /** Create an unmodifiable list backed by [source]. */\n  UnmodifiableListView(Iterable<E> source) : _source = source;\n  int get length => _source.length;\n  E operator[](int index) => _source.elementAt(index);\n}\n","sdk/lib/collection/hash_map.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\nclass HashMap<K, V> implements Map<K, V> {\n  external HashMap();\n\n  factory HashMap.from(Map<K, V> other) {\n    return new HashMap<K, V>()..addAll(other);\n  }\n\n  external int get length;\n  external bool get isEmpty;\n\n  external Iterable<K> get keys;\n  external Iterable<V> get values;\n\n  external bool containsKey(K key);\n  external bool containsValue(V value);\n\n  external void addAll(Map<K, V> other);\n\n  external V operator [](K key);\n  external void operator []=(K key, V value);\n\n  external V putIfAbsent(K key, V ifAbsent());\n\n  external V remove(K key);\n  external void clear();\n\n  external void forEach(void action(K key, V value));\n\n  String toString() => Maps.mapToString(this);\n}\n","sdk/lib/collection/hash_set.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/** Common parts of [HashSet] and [LinkedHashSet] implementations. */\nabstract class _HashSetBase<E> extends IterableBase<E> implements Set<E> {\n  // Set.\n  bool containsAll(Iterable<E> other) {\n    for (E object in other) {\n      if (!this.contains(object)) return false;\n    }\n    return true;\n  }\n\n  /** Create a new Set of the same type as this. */\n  Set _newSet();\n\n  Set<E> intersection(Set<E> other) {\n    Set<E> result = _newSet();\n    if (other.length < this.length) {\n      for (E element in other) {\n        if (this.contains(element)) result.add(element);\n      }\n    } else {\n      for (E element in this) {\n        if (other.contains(element)) result.add(element);\n      }\n    }\n    return result;\n  }\n\n  Set<E> union(Set<E> other) {\n    return _newSet()..addAll(this)..addAll(other);\n  }\n\n  Set<E> difference(Set<E> other) {\n    HashSet<E> result = _newSet();\n    for (E element in this) {\n      if (!other.contains(element)) result.add(element);\n    }\n    return result;\n  }\n\n  void retainAll(Iterable objectsToRetain) {\n    Set retainSet;\n    if (objectsToRetain is Set) {\n      retainSet = objectsToRetain;\n    } else {\n      retainSet = objectsToRetain.toSet();\n    }\n    retainWhere(retainSet.contains);\n  }\n\n  String toString() => ToString.iterableToString(this);\n}\n\nclass HashSet<E> extends _HashSetBase<E> {\n  external HashSet();\n\n  factory HashSet.from(Iterable<E> iterable) {\n    return new HashSet<E>()..addAll(iterable);\n  }\n\n  // Iterable.\n  external Iterator<E> get iterator;\n\n  external int get length;\n\n  external bool get isEmpty;\n\n  external bool contains(Object object);\n\n  // Collection.\n  external void add(E element);\n\n  external void addAll(Iterable<E> objects);\n\n  external bool remove(Object object);\n\n  external void removeAll(Iterable objectsToRemove);\n\n  external void removeWhere(bool test(E element));\n\n  external void retainWhere(bool test(E element));\n\n  external void clear();\n\n  // Set.\n  Set<E> _newSet() => new HashSet<E>();\n}\n","sdk/lib/collection/iterable.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/**\n * This [Iterable] mixin implements all [Iterable] members except `iterator`.\n *\n * All other methods are implemented in terms of `iterator`.\n */\nabstract class IterableMixin<E> implements Iterable<E> {\n  Iterable map(f(E element)) => new MappedIterable<E, dynamic>(this, f);\n\n  Iterable<E> where(bool f(E element)) => new WhereIterable<E>(this, f);\n\n  Iterable expand(Iterable f(E element)) =>\n      new ExpandIterable<E, dynamic>(this, f);\n\n  bool contains(E element) {\n    for (E e in this) {\n      if (e == element) return true;\n    }\n    return false;\n  }\n\n  void forEach(void f(E element)) {\n    for (E element in this) f(element);\n  }\n\n  E reduce(E combine(E value, E element)) {\n    Iterator<E> iterator = this.iterator;\n    if (!iterator.moveNext()) {\n      throw new StateError(\"No elements\");\n    }\n    E value = iterator.current;\n    while (iterator.moveNext()) {\n      value = combine(value, iterator.current);\n    }\n    return value;\n  }\n\n  dynamic fold(var initialValue,\n               dynamic combine(var previousValue, E element)) {\n    var value = initialValue;\n    for (E element in this) value = combine(value, element);\n    return value;\n  }\n\n  bool every(bool f(E element)) {\n    for (E element in this) {\n      if (!f(element)) return false;\n    }\n    return true;\n  }\n\n  String join([String separator]) {\n    Iterator<E> iterator = this.iterator;\n    if (!iterator.moveNext()) return \"\";\n    StringBuffer buffer = new StringBuffer();\n    if (separator == null || separator == \"\") {\n      do {\n        buffer.write(\"${iterator.current}\");\n      } while (iterator.moveNext());\n    } else {\n      buffer.write(\"${iterator.current}\");\n      while (iterator.moveNext()) {\n        buffer.write(separator);\n        buffer.write(\"${iterator.current}\");\n      }\n    }\n    return buffer.toString();\n  }\n\n  bool any(bool f(E element)) {\n    for (E element in this) {\n      if (f(element)) return true;\n    }\n    return false;\n  }\n\n  List<E> toList({ bool growable: true }) =>\n      new List<E>.from(this, growable: growable);\n\n  Set<E> toSet() => new Set<E>.from(this);\n\n  int get length {\n    int count = 0;\n    Iterator it = iterator;\n    while (it.moveNext()) {\n      count++;\n    }\n    return count;\n  }\n\n  bool get isEmpty => !iterator.moveNext();\n\n  Iterable<E> take(int n) {\n    return new TakeIterable<E>(this, n);\n  }\n\n  Iterable<E> takeWhile(bool test(E value)) {\n    return new TakeWhileIterable<E>(this, test);\n  }\n\n  Iterable<E> skip(int n) {\n    return new SkipIterable<E>(this, n);\n  }\n\n  Iterable<E> skipWhile(bool test(E value)) {\n    return new SkipWhileIterable<E>(this, test);\n  }\n\n  E get first {\n    Iterator it = iterator;\n    if (!it.moveNext()) {\n      throw new StateError(\"No elements\");\n    }\n    return it.current;\n  }\n\n  E get last {\n    Iterator it = iterator;\n    if (!it.moveNext()) {\n      throw new StateError(\"No elements\");\n    }\n    E result;\n    do {\n      result = it.current;\n    } while(it.moveNext());\n    return result;\n  }\n\n  E get single {\n    Iterator it = iterator;\n    if (!it.moveNext()) throw new StateError(\"No elements\");\n    E result = it.current;\n    if (it.moveNext()) throw new StateError(\"More than one element\");\n    return result;\n  }\n\n  E firstWhere(bool test(E value), { E orElse() }) {\n    // TODO(floitsch): check that arguments are of correct type?\n    for (E element in this) {\n      if (test(element)) return element;\n    }\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  E lastWhere(bool test(E value), {E orElse()}) {\n    // TODO(floitsch): check that arguments are of correct type?\n    E result = null;\n    bool foundMatching = false;\n    for (E element in this) {\n      if (test(element)) {\n        result = element;\n        foundMatching = true;\n      }\n    }\n    if (foundMatching) return result;\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  E singleWhere(bool test(E value)) {\n    // TODO(floitsch): check that argument is of correct type?\n    E result = null;\n    bool foundMatching = false;\n    for (E element in this) {\n      if (test(element)) {\n        if (foundMatching) {\n          throw new StateError(\"More than one matching element\");\n        }\n        result = element;\n        foundMatching = true;\n      }\n    }\n    if (foundMatching) return result;\n    throw new StateError(\"No matching element\");\n  }\n\n  E elementAt(int index) {\n    if (index is! int || index < 0) throw new RangeError.value(index);\n    int remaining = index;\n    for (E element in this) {\n      if (remaining == 0) return element;\n      remaining--;\n    }\n    throw new RangeError.value(index);\n  }\n}\n\n/**\n * Base class for implementing [Iterable].\n *\n * This class implements all methods of [Iterable] except [Iterable.iterator]\n * in terms of `iterator`.\n */\nabstract class IterableBase<E> implements Iterable<E> {\n  // TODO(lrn): Base this on IterableMixin if there ever becomes a way\n  // to combine const constructors and mixins.\n  const IterableBase();\n\n  Iterable map(f(E element)) => new MappedIterable<E, dynamic>(this, f);\n\n  Iterable<E> where(bool f(E element)) => new WhereIterable<E>(this, f);\n\n  Iterable expand(Iterable f(E element)) =>\n      new ExpandIterable<E, dynamic>(this, f);\n\n  bool contains(E element) {\n    for (E e in this) {\n      if (e == element) return true;\n    }\n    return false;\n  }\n\n  void forEach(void f(E element)) {\n    for (E element in this) f(element);\n  }\n\n  E reduce(E combine(E value, E element)) {\n    Iterator<E> iterator = this.iterator;\n    if (!iterator.moveNext()) {\n      throw new StateError(\"No elements\");\n    }\n    E value = iterator.current;\n    while (iterator.moveNext()) {\n      value = combine(value, iterator.current);\n    }\n    return value;\n  }\n\n  dynamic fold(var initialValue,\n               dynamic combine(var previousValue, E element)) {\n    var value = initialValue;\n    for (E element in this) value = combine(value, element);\n    return value;\n  }\n\n  bool every(bool f(E element)) {\n    for (E element in this) {\n      if (!f(element)) return false;\n    }\n    return true;\n  }\n\n  String join([String separator]) {\n    Iterator<E> iterator = this.iterator;\n    if (!iterator.moveNext()) return \"\";\n    StringBuffer buffer = new StringBuffer();\n    if (separator == null || separator == \"\") {\n      do {\n        buffer.write(\"${iterator.current}\");\n      } while (iterator.moveNext());\n    } else {\n      buffer.write(\"${iterator.current}\");\n      while (iterator.moveNext()) {\n        buffer.write(separator);\n        buffer.write(\"${iterator.current}\");\n      }\n    }\n    return buffer.toString();\n  }\n\n  bool any(bool f(E element)) {\n    for (E element in this) {\n      if (f(element)) return true;\n    }\n    return false;\n  }\n\n  List<E> toList({ bool growable: true }) =>\n      new List<E>.from(this, growable: growable);\n\n  Set<E> toSet() => new Set<E>.from(this);\n\n  int get length {\n    int count = 0;\n    Iterator it = iterator;\n    while (it.moveNext()) {\n      count++;\n    }\n    return count;\n  }\n\n  bool get isEmpty => !iterator.moveNext();\n\n  Iterable<E> take(int n) {\n    return new TakeIterable<E>(this, n);\n  }\n\n  Iterable<E> takeWhile(bool test(E value)) {\n    return new TakeWhileIterable<E>(this, test);\n  }\n\n  Iterable<E> skip(int n) {\n    return new SkipIterable<E>(this, n);\n  }\n\n  Iterable<E> skipWhile(bool test(E value)) {\n    return new SkipWhileIterable<E>(this, test);\n  }\n\n  E get first {\n    Iterator it = iterator;\n    if (!it.moveNext()) {\n      throw new StateError(\"No elements\");\n    }\n    return it.current;\n  }\n\n  E get last {\n    Iterator it = iterator;\n    if (!it.moveNext()) {\n      throw new StateError(\"No elements\");\n    }\n    E result;\n    do {\n      result = it.current;\n    } while(it.moveNext());\n    return result;\n  }\n\n  E get single {\n    Iterator it = iterator;\n    if (!it.moveNext()) throw new StateError(\"No elements\");\n    E result = it.current;\n    if (it.moveNext()) throw new StateError(\"More than one element\");\n    return result;\n  }\n\n  E firstWhere(bool test(E value), { E orElse() }) {\n    // TODO(floitsch): check that arguments are of correct type?\n    for (E element in this) {\n      if (test(element)) return element;\n    }\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  E lastWhere(bool test(E value), {E orElse()}) {\n    // TODO(floitsch): check that arguments are of correct type?\n    E result = null;\n    bool foundMatching = false;\n    for (E element in this) {\n      if (test(element)) {\n        result = element;\n        foundMatching = true;\n      }\n    }\n    if (foundMatching) return result;\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  E singleWhere(bool test(E value)) {\n    // TODO(floitsch): check that argument is of correct type?\n    E result = null;\n    bool foundMatching = false;\n    for (E element in this) {\n      if (test(element)) {\n        if (foundMatching) {\n          throw new StateError(\"More than one matching element\");\n        }\n        result = element;\n        foundMatching = true;\n      }\n    }\n    if (foundMatching) return result;\n    throw new StateError(\"No matching element\");\n  }\n\n  E elementAt(int index) {\n    if (index is! int || index < 0) throw new RangeError.value(index);\n    int remaining = index;\n    for (E element in this) {\n      if (remaining == 0) return element;\n      remaining--;\n    }\n    throw new RangeError.value(index);\n  }\n}\n","sdk/lib/collection/iterator.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/**\n * The [HasNextIterator] class wraps an [Iterator] and provides methods to\n * iterate over an object using `hasNext` and `next`.\n *\n * An [HasNextIterator] does not implement the [Iterator] interface.\n */\nclass HasNextIterator<E> {\n  static const int _HAS_NEXT_AND_NEXT_IN_CURRENT = 0;\n  static const int _NO_NEXT = 1;\n  static const int _NOT_MOVED_YET = 2;\n\n  Iterator _iterator;\n  int _state = _NOT_MOVED_YET;\n\n  HasNextIterator(this._iterator);\n\n  bool get hasNext {\n    if (_state == _NOT_MOVED_YET) _move();\n    return _state == _HAS_NEXT_AND_NEXT_IN_CURRENT;\n  }\n\n  E next() {\n    // Call to hasNext is necessary to make sure we are positioned at the first\n    // element when we start iterating.\n    if (!hasNext) throw new StateError(\"No more elements\");\n    assert(_state == _HAS_NEXT_AND_NEXT_IN_CURRENT);\n    E result = _iterator.current;\n    _move();\n    return result;\n  }\n\n  void _move() {\n    if (_iterator.moveNext()) {\n      _state = _HAS_NEXT_AND_NEXT_IN_CURRENT;\n    } else {\n      _state = _NO_NEXT;\n    }\n  }\n}\n","sdk/lib/collection/linked_hash_map.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/**\n * A hash-based map that iterates keys and values in key insertion order.\n */\nclass LinkedHashMap<K, V> implements Map<K, V> {\n  external LinkedHashMap();\n\n  factory LinkedHashMap.from(Map<K, V> other) {\n    return new LinkedHashMap<K, V>()..addAll(other);\n  }\n\n  external bool containsKey(K key);\n\n  external bool containsValue(V value);\n\n  external void addAll(Map<K, V> other);\n\n  external V operator [](K key);\n\n  external void operator []=(K key, V value);\n\n  external V putIfAbsent(K key, V ifAbsent());\n\n  external V remove(K key);\n\n  external void clear();\n\n  external void forEach(void action (K key, V value));\n\n  external Iterable<K> get keys;\n  external Iterable<V> get values;\n\n  external int get length;\n\n  external bool get isEmpty;\n\n  String toString() => Maps.mapToString(this);\n}\n","sdk/lib/collection/linked_hash_set.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\nclass LinkedHashSet<E> extends _HashSetBase<E> {\n\n  external LinkedHashSet();\n\n  factory LinkedHashSet.from(Iterable<E> iterable) {\n    return new LinkedHashSet<E>()..addAll(iterable);\n  }\n\n  // Iterable.\n  external Iterator<E> get iterator;\n\n  external int get length;\n\n  external bool get isEmpty;\n\n  external bool contains(Object object);\n\n  external void forEach(void action(E element));\n\n  external E get first;\n\n  external E get last;\n\n  E get single {\n    if (length == 1) return first;\n    var message = (length == 0) ? \"No Elements\" : \"Too many elements\";\n    throw new StateError(message);\n  }\n\n  // Collection.\n  external void add(E element);\n\n  external void addAll(Iterable<E> objects);\n\n  external bool remove(Object object);\n\n  external void removeAll(Iterable objectsToRemove);\n\n  external void removeWhere(bool test(E element));\n\n  external void retainWhere(bool test(E element));\n\n  external void clear();\n\n  // Set.\n  Set<E> _newSet() => new LinkedHashSet<E>();\n}\n","sdk/lib/collection/list.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/**\n * Abstract implementation of a list.\n *\n * All operations are defined in terms of `length`, `operator[]`,\n * `operator[]=` and `length=`, which need to be implemented.\n */\ntypedef ListBase<E> = Object with ListMixin<E>;\n\n/**\n * Base implementation of a [List] class.\n *\n * This class can be used as a mixin.\n *\n * This implements all read operations using only the `length` and\n * `operator[]` members. It implements write operations using those and\n * `length=` and `operator[]=`\n *\n * A fixed-length list should mix this class in, and the [FixedLengthListMixin]\n * as well, in that order, to overwrite the methods that modify the length.\n *\n * An unmodifiable list should mix [UnmodifiableListMixin] on top of this\n * mixin to prevent all modifications.\n */\nabstract class ListMixin<E> implements List<E> {\n  // Iterable interface.\n  Iterator<E> get iterator => new ListIterator<E>(this);\n\n  E elementAt(int index) => this[index];\n\n  void forEach(void action(E element)) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      action(this[i]);\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n  }\n\n  bool get isEmpty => length == 0;\n\n  E get first {\n    if (length == 0) throw new StateError(\"No elements\");\n    return this[0];\n  }\n\n  E get last {\n    if (length == 0) throw new StateError(\"No elements\");\n    return this[length - 1];\n  }\n\n  E get single {\n    if (length == 0) throw new StateError(\"No elements\");\n    if (length > 1) throw new StateError(\"Too many elements\");\n    return this[0];\n  }\n\n  bool contains(E element) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      if (this[i] == element) return true;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return false;\n  }\n\n  bool every(bool test(E element)) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      if (!test(this[i])) return false;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return true;\n  }\n\n  bool any(bool test(E element)) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      if (test(this[i])) return true;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return false;\n  }\n\n  E firstWhere(bool test(E element), { E orElse() }) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      E element = this[i];\n      if (test(element)) return element;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  E lastWhere(bool test(E element), { E orElse() }) {\n    int length = this.length;\n    for (int i = length - 1; i >= 0; i--) {\n      E element = this[i];\n      if (test(element)) return element;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  E singleWhere(bool test(E element)) {\n    int length = this.length;\n    E match = null;\n    bool matchFound = false;\n    for (int i = 0; i < length; i++) {\n      E element = this[i];\n      if (test(element)) {\n        if (matchFound) {\n          throw new StateError(\"More than one matching element\");\n        }\n        matchFound = true;\n        match = element;\n      }\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    if (matchFound) return match;\n    throw new StateError(\"No matching element\");\n  }\n\n  String join([String separator = \"\"]) {\n    int length = this.length;\n    if (!separator.isEmpty) {\n      if (length == 0) return \"\";\n      String first = \"${this[0]}\";\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n      StringBuffer buffer = new StringBuffer(first);\n      for (int i = 1; i < length; i++) {\n        buffer.write(separator);\n        buffer.write(this[i]);\n        if (length != this.length) {\n          throw new ConcurrentModificationError(this);\n        }\n      }\n      return buffer.toString();\n    } else {\n      StringBuffer buffer = new StringBuffer();\n      for (int i = 0; i < length; i++) {\n        buffer.write(this[i]);\n        if (length != this.length) {\n          throw new ConcurrentModificationError(this);\n        }\n      }\n      return buffer.toString();\n    }\n  }\n\n  Iterable<E> where(bool test(E element)) => new WhereIterable<E>(this, test);\n\n  Iterable map(f(E element)) => new MappedListIterable(this, f);\n\n  Iterable expand(Iterable f(E element)) =>\n      new ExpandIterable<E, dynamic>(this, f);\n\n  E reduce(E combine(E previousValue, E element)) {\n    if (length == 0) throw new StateError(\"No elements\");\n    E value = this[0];\n    for (int i = 1; i < length; i++) {\n      value = combine(value, this[i]);\n    }\n    return value;\n  }\n\n  fold(var initialValue, combine(var previousValue, E element)) {\n    var value = initialValue;\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      value = combine(value, this[i]);\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return value;\n  }\n\n  Iterable<E> skip(int count) => new SubListIterable(this, count, null);\n\n  Iterable<E> skipWhile(bool test(E element)) {\n    return new SkipWhileIterable<E>(this, test);\n  }\n\n  Iterable<E> take(int count) => new SubListIterable(this, 0, count);\n\n  Iterable<E> takeWhile(bool test(E element)) {\n    return new TakeWhileIterable<E>(this, test);\n  }\n\n  List<E> toList({ bool growable: true }) {\n    List<E> result;\n    if (growable) {\n      result = new List<E>()..length = length;\n    } else {\n      result = new List<E>(length);\n    }\n    for (int i = 0; i < length; i++) {\n      result[i] = this[i];\n    }\n    return result;\n  }\n\n  Set<E> toSet() {\n    Set<E> result = new Set<E>();\n    for (int i = 0; i < length; i++) {\n      result.add(this[i]);\n    }\n    return result;\n  }\n\n  // Collection interface.\n  void add(E element) {\n    this[this.length++] = element;\n  }\n\n  void addAll(Iterable<E> iterable) {\n    for (E element in iterable) {\n      this[this.length++] = element;\n    }\n  }\n\n  bool remove(Object element) {\n    for (int i = 0; i < this.length; i++) {\n      if (this[i] == element) {\n        this.setRange(i, this.length - 1, this, i + 1);\n        this.length -= 1;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  void removeWhere(bool test(E element)) {\n    _filter(this, test, false);\n  }\n\n  void retainWhere(bool test(E element)) {\n    _filter(this, test, true);\n  }\n\n  static void _filter(List source,\n                      bool test(var element),\n                      bool retainMatching) {\n    List retained = [];\n    int length = source.length;\n    for (int i = 0; i < length; i++) {\n      var element = source[i];\n      if (test(element) == retainMatching) {\n        retained.add(element);\n      }\n      if (length != source.length) {\n        throw new ConcurrentModificationError(source);\n      }\n    }\n    if (retained.length != source.length) {\n      source.setRange(0, retained.length, retained);\n      source.length = retained.length;\n    }\n  }\n\n  void clear() { this.length = 0; }\n\n  // List interface.\n\n  E removeLast() {\n    if (length == 0) {\n      throw new StateError(\"No elements\");\n    }\n    E result = this[length - 1];\n    length--;\n    return result;\n  }\n\n  void sort([int compare(E a, E b)]) {\n    if (compare == null) {\n      var defaultCompare = Comparable.compare;\n      compare = defaultCompare;\n    }\n    Sort.sort(this, compare);\n  }\n\n  Map<int, E> asMap() {\n    return new ListMapView(this);\n  }\n\n  void _rangeCheck(int start, int end) {\n    if (start < 0 || start > this.length) {\n      throw new RangeError.range(start, 0, this.length);\n    }\n    if (end < start || end > this.length) {\n      throw new RangeError.range(end, start, this.length);\n    }\n  }\n\n  List<E> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    _rangeCheck(start, end);\n    int length = end - start;\n    List<E> result = new List<E>()..length = length;\n    for (int i = 0; i < length; i++) {\n      result[i] = this[start + i];\n    }\n    return result;\n  }\n\n  Iterable<E> getRange(int start, int end) {\n    _rangeCheck(start, end);\n    return new SubListIterable(this, start, end);\n  }\n\n  void removeRange(int start, int end) {\n    _rangeCheck(start, end);\n    int length = end - start;\n    setRange(start, this.length - length, this, end);\n    this.length -= length;\n  }\n\n  void fillRange(int start, int end, [E fill]) {\n    _rangeCheck(start, end);\n    for (int i = start; i < end; i++) {\n      this[i] = fill;\n    }\n  }\n\n  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) {\n    _rangeCheck(start, end);\n    int length = end - start;\n    if (length == 0) return;\n\n    if (skipCount < 0) throw new ArgumentError(skipCount);\n\n    List otherList;\n    int otherStart;\n    // TODO(floitsch): Make this accept more.\n    if (iterable is List) {\n      otherList = iterable;\n      otherStart = skipCount;\n    } else {\n      otherList = iterable.skip(skipCount).toList(growable: false);\n      otherStart = 0;\n    }\n    if (otherStart + length > otherList.length) {\n      throw new StateError(\"Not enough elements\");\n    }\n    if (otherStart < start) {\n      // Copy backwards to ensure correct copy if [from] is this.\n      for (int i = length - 1; i >= 0; i--) {\n        this[start + i] = otherList[otherStart + i];\n      }\n    } else {\n      for (int i = 0; i < length; i++) {\n        this[start + i] = otherList[otherStart + i];\n      }\n    }\n  }\n\n  void replaceRange(int start, int end, Iterable<E> newContents) {\n    // TODO(floitsch): Optimize this.\n    removeRange(start, end);\n    insertAll(start, newContents);\n  }\n\n  int indexOf(E element, [int startIndex = 0]) {\n    if (startIndex >= this.length) {\n      return -1;\n    }\n    if (startIndex < 0) {\n      startIndex = 0;\n    }\n    for (int i = startIndex; i < this.length; i++) {\n      if (this[i] == element) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the last index in the list [a] of the given [element], starting\n   * the search at index [startIndex] to 0.\n   * Returns -1 if [element] is not found.\n   */\n  int lastIndexOf(E element, [int startIndex]) {\n    if (startIndex == null) {\n      startIndex = this.length - 1;\n    } else {\n      if (startIndex < 0) {\n        return -1;\n      }\n      if (startIndex >= this.length) {\n        startIndex = this.length - 1;\n      }\n    }\n    for (int i = startIndex; i >= 0; i--) {\n      if (this[i] == element) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  void insert(int index, E element) {\n    if (index < 0 || index > length) {\n      throw new RangeError.range(index, 0, length);\n    }\n    if (index == this.length) {\n      add(element);\n      return;\n    }\n    // We are modifying the length just below the is-check. Without the check\n    // Array.copy could throw an exception, leaving the list in a bad state\n    // (with a length that has been increased, but without a new element).\n    if (index is! int) throw new ArgumentError(index);\n    this.length++;\n    setRange(index + 1, this.length, this, index);\n    this[index] = element;\n  }\n\n  E removeAt(int index) {\n    E result = this[index];\n    setRange(index, this.length - 1, this, index + 1);\n    length--;\n    return result;\n  }\n\n  void insertAll(int index, Iterable<E> iterable) {\n    if (index < 0 || index > length) {\n      throw new RangeError.range(index, 0, length);\n    }\n    // TODO(floitsch): we can probably detect more cases.\n    if (iterable is! List && iterable is! Set && iterable is! SubListIterable) {\n      iterable = iterable.toList();\n    }\n    int insertionLength = iterable.length;\n    // There might be errors after the length change, in which case the list\n    // will end up being modified but the operation not complete. Unless we\n    // always go through a \"toList\" we can't really avoid that.\n    this.length += insertionLength;\n    setRange(index + insertionLength, this.length, this, index);\n    setAll(index, iterable);\n  }\n\n  void setAll(int index, Iterable<E> iterable) {\n    if (iterable is List) {\n      setRange(index, index + iterable.length, iterable);\n    } else {\n      for (E element in iterable) {\n        this[index++] = element;\n      }\n    }\n  }\n\n  Iterable<E> get reversed => new ReversedListIterable(this);\n\n  String toString() => ToString.iterableToString(this);\n}\n","sdk/lib/collection/maps.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/*\n * Helper class which implements complex [Map] operations\n * in term of basic ones ([Map.keys], [Map.operator []],\n * [Map.operator []=] and [Map.remove].)  Not all methods are\n * necessary to implement each particular operation.\n */\nclass Maps {\n  static bool containsValue(Map map, value) {\n    for (final v in map.values) {\n      if (value == v) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static bool containsKey(Map map, key) {\n    for (final k in map.keys) {\n      if (key == k) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static putIfAbsent(Map map, key, ifAbsent()) {\n    if (map.containsKey(key)) {\n      return map[key];\n    }\n    final v = ifAbsent();\n    map[key] = v;\n    return v;\n  }\n\n  static clear(Map map) {\n    for (final k in map.keys.toList()) {\n      map.remove(k);\n    }\n  }\n\n  static forEach(Map map, void f(key, value)) {\n    for (final k in map.keys) {\n      f(k, map[k]);\n    }\n  }\n\n  static Iterable getValues(Map map) {\n    return map.keys.map((key) => map[key]);\n  }\n\n  static int length(Map map) => map.keys.length;\n\n  static bool isEmpty(Map map) => map.keys.isEmpty;\n\n  /**\n   * Returns a string representing the specified map. The returned string\n   * looks like this: [:'{key0: value0, key1: value1, ... keyN: valueN}':].\n   * The value returned by its [toString] method is used to represent each\n   * key or value.\n   *\n   * If the map collection contains a reference to itself, either\n   * directly as a key or value, or indirectly through other collections\n   * or maps, the contained reference is rendered as [:'{...}':]. This\n   * prevents the infinite regress that would otherwise occur. So, for example,\n   * calling this method on a map whose sole entry maps the string key 'me'\n   * to a reference to the map would return [:'{me: {...}}':].\n   *\n   * A typical implementation of a map's [toString] method will\n   * simply return the results of this method applied to the collection.\n   */\n  static String mapToString(Map m) => ToString.mapToString(m);\n}\n","sdk/lib/collection/queue.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/**\n * A [Queue] is a collection that can be manipulated at both ends. One\n * can iterate over the elements of a queue through [forEach] or with\n * an [Iterator].\n */\nabstract class Queue<E> implements Iterable<E> {\n\n  /**\n   * Creates a queue.\n   */\n  factory Queue() => new ListQueue<E>();\n\n  /**\n   * Creates a queue with the elements of [other]. The order in\n   * the queue will be the order provided by the iterator of [other].\n   */\n  factory Queue.from(Iterable<E> other) => new ListQueue<E>.from(other);\n\n  /**\n   * Removes and returns the first element of this queue. Throws an\n   * [StateError] exception if this queue is empty.\n   */\n  E removeFirst();\n\n  /**\n   * Removes and returns the last element of the queue. Throws an\n   * [StateError] exception if this queue is empty.\n   */\n  E removeLast();\n\n  /**\n   * Adds [value] at the beginning of the queue.\n   */\n  void addFirst(E value);\n\n  /**\n   * Adds [value] at the end of the queue.\n   */\n  void addLast(E value);\n\n  /**\n   * Adds [value] at the end of the queue.\n   */\n  void add(E value);\n\n  /**\n   * Remove a single instance of [value] from the queue.\n   *\n   * Returns `true` if a value was removed, or `false` if the queue\n   * contained no element equal to [value].\n   */\n  bool remove(Object object);\n\n\n  /**\n   * Adds all elements of [iterable] at the end of the queue. The\n   * length of the queue is extended by the length of [iterable].\n   */\n  void addAll(Iterable<E> iterable);\n\n  /**\n   * Removes all elements in the queue. The size of the queue becomes zero.\n   */\n  void clear();\n}\n\n\n/**\n * An entry in a doubly linked list. It contains a pointer to the next\n * entry, the previous entry, and the boxed element.\n *\n * WARNING: This class is temporary located in dart:core. It'll be removed\n * at some point in the near future.\n */\nclass DoubleLinkedQueueEntry<E> {\n  DoubleLinkedQueueEntry<E> _previous;\n  DoubleLinkedQueueEntry<E> _next;\n  E _element;\n\n  DoubleLinkedQueueEntry(E e) {\n    _element = e;\n  }\n\n  void _link(DoubleLinkedQueueEntry<E> p,\n             DoubleLinkedQueueEntry<E> n) {\n    _next = n;\n    _previous = p;\n    p._next = this;\n    n._previous = this;\n  }\n\n  void append(E e) {\n    new DoubleLinkedQueueEntry<E>(e)._link(this, _next);\n  }\n\n  void prepend(E e) {\n    new DoubleLinkedQueueEntry<E>(e)._link(_previous, this);\n  }\n\n  E remove() {\n    _previous._next = _next;\n    _next._previous = _previous;\n    _next = null;\n    _previous = null;\n    return _element;\n  }\n\n  DoubleLinkedQueueEntry<E> _asNonSentinelEntry() {\n    return this;\n  }\n\n  DoubleLinkedQueueEntry<E> previousEntry() {\n    return _previous._asNonSentinelEntry();\n  }\n\n  DoubleLinkedQueueEntry<E> nextEntry() {\n    return _next._asNonSentinelEntry();\n  }\n\n  E get element {\n    return _element;\n  }\n\n  void set element(E e) {\n    _element = e;\n  }\n}\n\n/**\n * A sentinel in a double linked list is used to manipulate the list\n * at both ends. A double linked list has exactly one sentinel, which\n * is the only entry when the list is constructed. Initially, a\n * sentinel has its next and previous entry point to itself. A\n * sentinel does not box any user element.\n */\nclass _DoubleLinkedQueueEntrySentinel<E> extends DoubleLinkedQueueEntry<E> {\n  _DoubleLinkedQueueEntrySentinel() : super(null) {\n    _link(this, this);\n  }\n\n  E remove() {\n    throw new StateError(\"Empty queue\");\n  }\n\n  DoubleLinkedQueueEntry<E> _asNonSentinelEntry() {\n    return null;\n  }\n\n  void set element(E e) {\n    // This setter is unreachable.\n    assert(false);\n  }\n\n  E get element {\n    throw new StateError(\"Empty queue\");\n  }\n}\n\n/**\n * A [Queue] implementation based on a double-linked list.\n *\n * Allows constant time add, remove-at-ends and peek operations.\n *\n * Can do [removeAll] and [retainAll] in linear time.\n */\nclass DoubleLinkedQueue<E> extends IterableBase<E> implements Queue<E> {\n  _DoubleLinkedQueueEntrySentinel<E> _sentinel;\n  int _elementCount = 0;\n\n  DoubleLinkedQueue() {\n    _sentinel = new _DoubleLinkedQueueEntrySentinel<E>();\n  }\n\n  factory DoubleLinkedQueue.from(Iterable<E> other) {\n    Queue<E> list = new DoubleLinkedQueue();\n    for (final e in other) {\n      list.addLast(e);\n    }\n    return list;\n  }\n\n  int get length => _elementCount;\n\n  void addLast(E value) {\n    _sentinel.prepend(value);\n    _elementCount++;\n  }\n\n  void addFirst(E value) {\n    _sentinel.append(value);\n    _elementCount++;\n  }\n\n  void add(E value) {\n    _sentinel.prepend(value);\n    _elementCount++;\n  }\n\n  void addAll(Iterable<E> iterable) {\n    for (final E value in iterable) {\n      _sentinel.prepend(value);\n      _elementCount++;\n    }\n  }\n\n  E removeLast() {\n    E result = _sentinel._previous.remove();\n    _elementCount--;\n    return result;\n  }\n\n  E removeFirst() {\n    E result = _sentinel._next.remove();\n    _elementCount--;\n    return result;\n  }\n\n  bool remove(Object o) {\n    DoubleLinkedQueueEntry<E> entry = firstEntry();\n    while (!identical(entry, _sentinel)) {\n      if (entry.element == o) {\n        entry.remove();\n        _elementCount--;\n        return true;\n      }\n      entry = entry._next;\n    }\n    return false;\n  }\n\n  void _filter(bool test(E element), bool removeMatching) {\n    DoubleLinkedQueueEntry<E> entry = firstEntry();\n    while (!identical(entry, _sentinel)) {\n      DoubleLinkedQueueEntry<E> next = entry._next;\n      if (identical(removeMatching, test(entry.element))) {\n        entry.remove();\n        _elementCount--;\n      }\n      entry = next;\n    }\n  }\n\n  void removeWhere(bool test(E element)) {\n    _filter(test, true);\n  }\n\n  void retainWhere(bool test(E element)) {\n    _filter(test, false);\n  }\n\n  E get first {\n    return _sentinel._next.element;\n  }\n\n  E get last {\n    return _sentinel._previous.element;\n  }\n\n  E get single {\n    // Note that this also covers the case where the queue is empty.\n    if (identical(_sentinel._next, _sentinel._previous)) {\n      return _sentinel._next.element;\n    }\n    throw new StateError(\"More than one element\");\n  }\n\n  DoubleLinkedQueueEntry<E> lastEntry() {\n    return _sentinel.previousEntry();\n  }\n\n  DoubleLinkedQueueEntry<E> firstEntry() {\n    return _sentinel.nextEntry();\n  }\n\n  bool get isEmpty {\n    return (identical(_sentinel._next, _sentinel));\n  }\n\n  void clear() {\n    _sentinel._next = _sentinel;\n    _sentinel._previous = _sentinel;\n    _elementCount = 0;\n  }\n\n  void forEachEntry(void f(DoubleLinkedQueueEntry<E> element)) {\n    DoubleLinkedQueueEntry<E> entry = _sentinel._next;\n    while (!identical(entry, _sentinel)) {\n      DoubleLinkedQueueEntry<E> nextEntry = entry._next;\n      f(entry);\n      entry = nextEntry;\n    }\n  }\n\n  _DoubleLinkedQueueIterator<E> get iterator {\n    return new _DoubleLinkedQueueIterator<E>(_sentinel);\n  }\n\n  String toString() {\n    return ToString.iterableToString(this);\n  }\n}\n\nclass _DoubleLinkedQueueIterator<E> implements Iterator<E> {\n  _DoubleLinkedQueueEntrySentinel<E> _sentinel;\n  DoubleLinkedQueueEntry<E> _currentEntry = null;\n  E _current;\n\n  _DoubleLinkedQueueIterator(_DoubleLinkedQueueEntrySentinel<E> sentinel)\n      : _sentinel = sentinel, _currentEntry = sentinel;\n\n  bool moveNext() {\n    // When [_currentEntry] it is set to [:null:] then it is at the end.\n    if (_currentEntry == null) {\n      assert(_current == null);\n      return false;\n    }\n    _currentEntry = _currentEntry._next;\n    if (identical(_currentEntry, _sentinel)) {\n      _currentEntry = null;\n      _current = null;\n      _sentinel = null;\n      return false;\n    }\n    _current = _currentEntry.element;\n    return true;\n  }\n\n  E get current => _current;\n}\n\n/**\n * List based [Queue].\n *\n * Keeps a cyclic buffer of elements, and grows to a larger buffer when\n * it fills up. This guarantees constant time peek and remove operations, and\n * amortized constant time add operations.\n *\n * The structure is efficient for any queue or stack usage.\n *\n * Operations like [removeAll] and [removeWhere] are very\n * inefficient. If those are needed, use a [DoubleLinkedQueue] instead.\n */\nclass ListQueue<E> extends IterableBase<E> implements Queue<E> {\n  static const int _INITIAL_CAPACITY = 8;\n  List<E> _table;\n  int _head;\n  int _tail;\n  int _modificationCount = 0;\n\n  /**\n   * Create an empty queue.\n   *\n   * If [initialCapacity] is given, prepare the queue for at least that many\n   * elements.\n   */\n  ListQueue([int initialCapacity]) : _head = 0, _tail = 0 {\n    if (initialCapacity == null || initialCapacity < _INITIAL_CAPACITY) {\n      initialCapacity = _INITIAL_CAPACITY;\n    } else if (!_isPowerOf2(initialCapacity)) {\n      initialCapacity = _nextPowerOf2(initialCapacity);\n    }\n    assert(_isPowerOf2(initialCapacity));\n    _table = new List<E>(initialCapacity);\n  }\n\n  /**\n   * Create a queue initially containing the elements of [source].\n   */\n  factory ListQueue.from(Iterable<E> source) {\n    if (source is List) {\n      int length = source.length;\n      ListQueue<E> queue = new ListQueue(length + 1);\n      assert(queue._table.length > length);\n      List sourceList = source;\n      queue._table.setRange(0, length, sourceList, 0);\n      queue._tail = length;\n      return queue;\n    } else {\n      return new ListQueue<E>()..addAll(source);\n    }\n  }\n\n  // Iterable interface.\n\n  Iterator<E> get iterator => new _ListQueueIterator(this);\n\n  void forEach(void action (E element)) {\n    int modificationCount = _modificationCount;\n    for (int i = _head; i != _tail; i = (i + 1) & (_table.length - 1)) {\n      action(_table[i]);\n      _checkModification(modificationCount);\n    }\n  }\n\n  bool get isEmpty => _head == _tail;\n\n  int get length => (_tail - _head) & (_table.length - 1);\n\n  E get first {\n    if (_head == _tail) throw new StateError(\"No elements\");\n    return _table[_head];\n  }\n\n  E get last {\n    if (_head == _tail) throw new StateError(\"No elements\");\n    return _table[(_tail - 1) & (_table.length - 1)];\n  }\n\n  E get single {\n    if (_head == _tail) throw new StateError(\"No elements\");\n    if (length > 1) throw new StateError(\"Too many elements\");\n    return _table[_head];\n  }\n\n  E elementAt(int index) {\n    if (index < 0 || index > length) {\n      throw new RangeError.range(index, 0, length);\n    }\n    return _table[(_head + index) & (_table.length - 1)];\n  }\n\n  List<E> toList({ bool growable: true }) {\n    List<E> list;\n    if (growable) {\n      list = new List<E>()..length = length;\n    } else {\n      list = new List<E>(length);\n    }\n    _writeToList(list);\n    return list;\n  }\n\n  // Collection interface.\n\n  void add(E element) {\n    _add(element);\n  }\n\n  void addAll(Iterable<E> elements) {\n    if (elements is List) {\n      List list = elements;\n      int addCount = list.length;\n      int length = this.length;\n      if (length + addCount >= _table.length) {\n        _preGrow(length + addCount);\n        // After preGrow, all elements are at the start of the list.\n        _table.setRange(length, length + addCount, list, 0);\n        _tail += addCount;\n      } else {\n        // Adding addCount elements won't reach _head.\n        int endSpace = _table.length - _tail;\n        if (addCount < endSpace) {\n          _table.setRange(_tail, _tail + addCount, list, 0);\n          _tail += addCount;\n        } else {\n          int preSpace = addCount - endSpace;\n          _table.setRange(_tail, _tail + endSpace, list, 0);\n          _table.setRange(0, preSpace, list, endSpace);\n          _tail = preSpace;\n        }\n      }\n      _modificationCount++;\n    } else {\n      for (E element in elements) _add(element);\n    }\n  }\n\n  bool remove(Object object) {\n    for (int i = _head; i != _tail; i = (i + 1) & (_table.length - 1)) {\n      E element = _table[i];\n      if (element == object) {\n        _remove(i);\n        _modificationCount++;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  void _filterWhere(bool test(E element), bool removeMatching) {\n    int index = _head;\n    int modificationCount = _modificationCount;\n    int i = _head;\n    while (i != _tail) {\n      E element = _table[i];\n      bool remove = identical(removeMatching, test(element));\n      _checkModification(modificationCount);\n      if (remove) {\n        i = _remove(i);\n        modificationCount = ++_modificationCount;\n      } else {\n        i = (i + 1) & (_table.length - 1);\n      }\n    }\n  }\n\n  /**\n   * Remove all elements matched by [test].\n   *\n   * This method is inefficient since it works by repeatedly removing single\n   * elements, each of which can take linear time.\n   */\n  void removeWhere(bool test(E element)) {\n    _filterWhere(test, true);\n  }\n\n  /**\n   * Remove all elements not matched by [test].\n   *\n   * This method is inefficient since it works by repeatedly removing single\n   * elements, each of which can take linear time.\n   */\n  void retainWhere(bool test(E element)) {\n    _filterWhere(test, false);\n  }\n\n  void clear() {\n    if (_head != _tail) {\n      for (int i = _head; i != _tail; i = (i + 1) & (_table.length - 1)) {\n        _table[i] = null;\n      }\n      _head = _tail = 0;\n      _modificationCount++;\n    }\n  }\n\n  String toString() {\n    return ToString.iterableToString(this);\n  }\n\n  // Queue interface.\n\n  void addLast(E element) { _add(element); }\n\n  void addFirst(E element) {\n    _head = (_head - 1) & (_table.length - 1);\n    _table[_head] = element;\n    if (_head == _tail) _grow();\n    _modificationCount++;\n  }\n\n  E removeFirst() {\n    if (_head == _tail) throw new StateError(\"No elements\");\n    _modificationCount++;\n    E result = _table[_head];\n    _head = (_head + 1) & (_table.length - 1);\n    return result;\n  }\n\n  E removeLast() {\n    if (_head == _tail) throw new StateError(\"No elements\");\n    _modificationCount++;\n    _tail = (_tail - 1) & (_table.length - 1);\n    return _table[_tail];\n  }\n\n  // Internal helper functions.\n\n  /**\n   * Whether [number] is a power of two.\n   *\n   * Only works for positive numbers.\n   */\n  static bool _isPowerOf2(int number) => (number & (number - 1)) == 0;\n\n  /**\n   * Rounds [number] up to the nearest power of 2.\n   *\n   * If [number] is a power of 2 already, it is returned.\n   *\n   * Only works for positive numbers.\n   */\n  static int _nextPowerOf2(int number) {\n    assert(number > 0);\n    number = (number << 2) - 1;\n    for(;;) {\n      int nextNumber = number & (number - 1);\n      if (nextNumber == 0) return number;\n      number = nextNumber;\n    }\n  }\n\n  /** Check if the queue has been modified during iteration. */\n  void _checkModification(int expectedModificationCount) {\n    if (expectedModificationCount != _modificationCount) {\n      throw new ConcurrentModificationError(this);\n    }\n  }\n\n  /** Adds element at end of queue. Used by both [add] and [addAll]. */\n  void _add(E element) {\n    _table[_tail] = element;\n    _tail = (_tail + 1) & (_table.length - 1);\n    if (_head == _tail) _grow();\n    _modificationCount++;\n  }\n\n  /**\n   * Removes the element at [offset] into [_table].\n   *\n   * Removal is performed by linerarly moving elements either before or after\n   * [offset] by one position.\n   *\n   * Returns the new offset of the following element. This may be the same\n   * offset or the following offset depending on how elements are moved\n   * to fill the hole.\n   */\n  int _remove(int offset) {\n    int mask = _table.length - 1;\n    int startDistance = (offset - _head) & mask;\n    int endDistance = (_tail - offset) & mask;\n    if (startDistance < endDistance) {\n      // Closest to start.\n      int i = offset;\n      while (i != _head) {\n        int prevOffset = (i - 1) & mask;\n        _table[i] = _table[prevOffset];\n        i = prevOffset;\n      }\n      _table[_head] = null;\n      _head = (_head + 1) & mask;\n      return (offset + 1) & mask;\n    } else {\n      _tail = (_tail - 1) & mask;\n      int i = offset;\n      while (i != _tail) {\n        int nextOffset = (i + 1) & mask;\n        _table[i] = _table[nextOffset];\n        i = nextOffset;\n      }\n      _table[_tail] = null;\n      return offset;\n    }\n  }\n\n  /**\n   * Grow the table when full.\n   */\n  void _grow() {\n    List<E> newTable = new List<E>(_table.length * 2);\n    int split = _table.length - _head;\n    newTable.setRange(0, split, _table, _head);\n    newTable.setRange(split, split + _head, _table, 0);\n    _head = 0;\n    _tail = _table.length;\n    _table = newTable;\n  }\n\n  int _writeToList(List<E> target) {\n    assert(target.length >= length);\n    if (_head <= _tail) {\n      int length = _tail - _head;\n      target.setRange(0, length, _table, _head);\n      return length;\n    } else {\n      int firstPartSize = _table.length - _head;\n      target.setRange(0, firstPartSize, _table, _head);\n      target.setRange(firstPartSize, firstPartSize + _tail, _table, 0);\n      return _tail + firstPartSize;\n    }\n  }\n\n  /** Grows the table even if it is not full. */\n  void _preGrow(int newElementCount) {\n    assert(newElementCount >= length);\n    int newCapacity = _nextPowerOf2(newElementCount);\n    List<E> newTable = new List<E>(newCapacity);\n    _tail = _writeToList(newTable);\n    _table = newTable;\n    _head = 0;\n  }\n}\n\n/**\n * Iterator for a [ListQueue].\n *\n * Considers any add or remove operation a concurrent modification.\n */\nclass _ListQueueIterator<E> implements Iterator<E> {\n  final ListQueue _queue;\n  final int _end;\n  final int _modificationCount;\n  int _position;\n  E _current;\n\n  _ListQueueIterator(ListQueue queue)\n      : _queue = queue,\n        _end = queue._tail,\n        _modificationCount = queue._modificationCount,\n        _position = queue._head;\n\n  E get current => _current;\n\n  bool moveNext() {\n    _queue._checkModification(_modificationCount);\n    if (_position == _end) {\n      _current = null;\n      return false;\n    }\n    _current = _queue._table[_position];\n    _position = (_position + 1) & (_queue._table.length - 1);\n    return true;\n  }\n}\n","sdk/lib/collection/splay_tree.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/**\n * A node in a splay tree. It holds the sorting key and the left\n * and right children in the tree.\n */\nclass _SplayTreeNode<K> {\n  final K key;\n  _SplayTreeNode<K> left;\n  _SplayTreeNode<K> right;\n\n  _SplayTreeNode(K this.key);\n}\n\n/**\n * A node in a splay tree based map.\n *\n * A [_SplayTreeNode] that also contains a value\n */\nclass _SplayTreeMapNode<K, V> extends _SplayTreeNode<K> {\n  V value;\n  _SplayTreeMapNode(K key, V this.value) : super(key);\n}\n\n/**\n * A splay tree is a self-balancing binary search tree.\n *\n * It has the additional property that recently accessed elements\n * are quick to access again.\n * It performs basic operations such as insertion, look-up and\n * removal, in O(log(n)) amortized time.\n */\nabstract class _SplayTree<K> {\n  // The root node of the splay tree. It will contain either the last\n  // element inserted or the last element looked up.\n  _SplayTreeNode<K> _root;\n\n  // The dummy node used when performing a splay on the tree. Reusing it\n  // avoids allocating a node each time a splay is performed.\n  _SplayTreeNode<K> _dummy = new _SplayTreeNode<K>(null);\n\n  // Number of elements in the splay tree.\n  int _count = 0;\n\n  /**\n   * Counter incremented whenever the keys in the map changes.\n   *\n   * Used to detect concurrent modifications.\n   */\n  int _modificationCount = 0;\n\n  /**\n   * Counter incremented whenever the tree structure changes.\n   *\n   * Used to detect that an in-place traversal cannot use\n   * cached information that relies on the tree structure.\n   */\n  int _splayCount = 0;\n\n  /** Comparison used to compare keys. */\n  int _compare(K key1, K key2);\n\n  /**\n   * Perform the splay operation for the given key. Moves the node with\n   * the given key to the top of the tree.  If no node has the given\n   * key, the last node on the search path is moved to the top of the\n   * tree. This is the simplified top-down splaying algorithm from:\n   * \"Self-adjusting Binary Search Trees\" by Sleator and Tarjan.\n   *\n   * Returns the result of comparing the new root of the tree to [key].\n   * Returns -1 if the table is empty.\n   */\n  int _splay(K key) {\n    if (_root == null) return -1;\n\n    // The right child of the dummy node will hold\n    // the L tree of the algorithm.  The left child of the dummy node\n    // will hold the R tree of the algorithm.  Using a dummy node, left\n    // and right will always be nodes and we avoid special cases.\n    _SplayTreeNode<K> left = _dummy;\n    _SplayTreeNode<K> right = _dummy;\n    _SplayTreeNode<K> current = _root;\n    int comp;\n    while (true) {\n      comp = _compare(current.key, key);\n      if (comp > 0) {\n        if (current.left == null) break;\n        comp = _compare(current.left.key, key);\n        if (comp > 0) {\n          // Rotate right.\n          _SplayTreeNode<K> tmp = current.left;\n          current.left = tmp.right;\n          tmp.right = current;\n          current = tmp;\n          if (current.left == null) break;\n        }\n        // Link right.\n        right.left = current;\n        right = current;\n        current = current.left;\n      } else if (comp < 0) {\n        if (current.right == null) break;\n        comp = _compare(current.right.key, key);\n        if (comp < 0) {\n          // Rotate left.\n          _SplayTreeNode<K> tmp = current.right;\n          current.right = tmp.left;\n          tmp.left = current;\n          current = tmp;\n          if (current.right == null) break;\n        }\n        // Link left.\n        left.right = current;\n        left = current;\n        current = current.right;\n      } else {\n        break;\n      }\n    }\n    // Assemble.\n    left.right = current.left;\n    right.left = current.right;\n    current.left = _dummy.right;\n    current.right = _dummy.left;\n    _root = current;\n\n    _dummy.right = null;\n    _dummy.left = null;\n    _splayCount++;\n    return comp;\n  }\n\n  // Emulates splaying with a key that is smaller than any in the tree.\n  // After this, the smallest element in the tree is the root.\n  void _splayMin() {\n    assert(_root != null);\n    _SplayTreeNode current = _root;\n    while (current.left != null) {\n      _SplayTreeNode left = current.left;\n      current.left = left.right;\n      left.right = current;\n      current = left;\n    }\n    _root = current;\n  }\n\n  // Emulates splaying with a key that is greater than any in the tree.\n  // After this, the largest element in the tree is the root.\n  void _splayMax() {\n    assert(_root != null);\n    _SplayTreeNode current = _root;\n    while (current.right != null) {\n      _SplayTreeNode right = current.right;\n      current.right = right.left;\n      right.left = current;\n      current = right;\n    }\n    _root = current;\n  }\n\n  _SplayTreeNode _remove(K key) {\n    if (_root == null) return null;\n    int comp = _splay(key);\n    if (comp != 0) return null;\n    _SplayTreeNode result = _root;\n    _count--;\n    // assert(_count >= 0);\n    if (_root.left == null) {\n      _root = _root.right;\n    } else {\n      _SplayTreeNode<K> right = _root.right;\n      _root = _root.left;\n      // Splay to make sure that the new root has an empty right child.\n      _splay(key);\n      // Insert the original right child as the right child of the new\n      // root.\n      _root.right = right;\n    }\n    _modificationCount++;\n    return result;\n  }\n\n  /**\n   * Adds a new root node with the given [key] or [value].\n   *\n   * The [comp] value is the result of comparing the existing root's key\n   * with key.\n   */\n  void _addNewRoot(_SplayTreeNode<K> node, int comp) {\n    _count++;\n    _modificationCount++;\n    if (_root == null) {\n      _root = node;\n      return;\n    }\n    // assert(_count >= 0);\n    if (comp < 0) {\n      node.left = _root;\n      node.right = _root.right;\n      _root.right = null;\n    } else {\n      node.right = _root;\n      node.left = _root.left;\n      _root.left = null;\n    }\n    _root = node;\n  }\n\n  _SplayTreeNode get _first {\n    if (_root == null) return null;\n    _splayMin();\n    return _root;\n  }\n\n  _SplayTreeNode get _last {\n    if (_root == null) return null;\n    _splayMax();\n    return _root;\n  }\n\n  void _clear() {\n    _root = null;\n    _count = 0;\n    _modificationCount++;\n  }\n}\n\n/*\n * A [Map] of objects that can be ordered relative to each other.\n *\n * The map is based on a self-balancing binary tree. It allows most operations\n * in amortized logarithmic time.\n *\n * Keys of the map are compared using the `compare` function passed in\n * the constructor. If that is omitted, the objects are assumed to be\n * [Comparable], and are compared using their [Comparable.compareTo]\n * method. This also means that `null` is *not* allowed as a key.\n */\nclass SplayTreeMap<K, V> extends _SplayTree<K> implements Map<K, V> {\n  // TODO(ngeoffray): Restore type when feature is implemented in dart2js\n  // checked mode. http://dartbug.com/7733\n  Function /* Comparator<K> */_comparator;\n\n  SplayTreeMap([int compare(K key1, K key2)])\n      : _comparator = (compare == null) ? Comparable.compare : compare;\n\n  int _compare(K key1, K key2) => _comparator(key1, key2);\n\n  SplayTreeMap._internal();\n\n  V operator [](K key) {\n    if (key == null) throw new ArgumentError(key);\n    if (_root != null) {\n      int comp = _splay(key);\n      if (comp == 0) {\n        _SplayTreeMapNode mapRoot = _root;\n        return mapRoot.value;\n      }\n    }\n    return null;\n  }\n\n  V remove(Object key) {\n    if (key is! K) return null;\n    _SplayTreeMapNode mapRoot = _remove(key);\n    if (mapRoot != null) return mapRoot.value;\n    return null;\n  }\n\n  void operator []=(K key, V value) {\n    if (key == null) throw new ArgumentError(key);\n    // Splay on the key to move the last node on the search path for\n    // the key to the root of the tree.\n    int comp = _splay(key);\n    if (comp == 0) {\n      _SplayTreeMapNode mapRoot = _root;\n      mapRoot.value = value;\n      return;\n    }\n    _addNewRoot(new _SplayTreeMapNode(key, value), comp);\n  }\n\n\n  V putIfAbsent(K key, V ifAbsent()) {\n    if (key == null) throw new ArgumentError(key);\n    int comp = _splay(key);\n    if (comp == 0) {\n      _SplayTreeMapNode mapRoot = _root;\n      return mapRoot.value;\n    }\n    int modificationCount = _modificationCount;\n    int splayCount = _splayCount;\n    V value = ifAbsent();\n    if (modificationCount != _modificationCount) {\n      throw new ConcurrentModificationError(this);\n    }\n    if (splayCount != _splayCount) {\n      comp = _splay(key);\n      // Key is still not there, otherwise _modificationCount would be changed.\n      assert(comp != 0);\n    }\n    _addNewRoot(new _SplayTreeMapNode(key, value), comp);\n    return value;\n  }\n\n  bool get isEmpty {\n    // assert(!((_root == null) && (_count != 0)));\n    // assert(!((_count == 0) && (_root != null)));\n    return (_root == null);\n  }\n\n  void forEach(void f(K key, V value)) {\n    Iterator<_SplayTreeNode<K>> nodes =\n        new _SplayTreeNodeIterator<K>(this);\n    while (nodes.moveNext()) {\n      _SplayTreeMapNode<K, V> node = nodes.current;\n      f(node.key, node.value);\n    }\n  }\n\n  int get length {\n    return _count;\n  }\n\n  void clear() {\n    _clear();\n  }\n\n  bool containsKey(K key) {\n    return _splay(key) == 0;\n  }\n\n  bool containsValue(V value) {\n    bool found = false;\n    int initialSplayCount = _splayCount;\n    bool visit(_SplayTreeMapNode node) {\n      while (node != null) {\n        if (node.value == value) return true;\n        if (initialSplayCount != _splayCount) {\n          throw new ConcurrentModificationError(this);\n        }\n        if (node.right != null && visit(node.right)) return true;\n        node = node.left;\n      }\n      return false;\n    }\n    return visit(_root);\n  }\n\n  Iterable<K> get keys => new _SplayTreeKeyIterable<K>(this);\n\n  Iterable<V> get values => new _SplayTreeValueIterable<K, V>(this);\n\n  String toString() {\n    return Maps.mapToString(this);\n  }\n\n  /**\n   * Get the first key in the map. Returns [null] if the map is empty.\n   */\n  K firstKey() {\n    if (_root == null) return null;\n    return _first.key;\n  }\n\n  /**\n   * Get the last key in the map. Returns [null] if the map is empty.\n   */\n  K lastKey() {\n    if (_root == null) return null;\n    return _last.key;\n  }\n\n  /**\n   * Get the last key in the map that is strictly smaller than [key]. Returns\n   * [null] if no key was not found.\n   */\n  K lastKeyBefore(K key) {\n    if (key == null) throw new ArgumentError(key);\n    if (_root == null) return null;\n    int comp = _splay(key);\n    if (comp < 0) return _root.key;\n    _SplayTreeNode<K> node = _root.left;\n    if (node == null) return null;\n    while (node.right != null) {\n      node = node.right;\n    }\n    return node.key;\n  }\n\n  /**\n   * Get the first key in the map that is strictly larger than [key]. Returns\n   * [null] if no key was not found.\n   */\n  K firstKeyAfter(K key) {\n    if (key == null) throw new ArgumentError(key);\n    if (_root == null) return null;\n    int comp = _splay(key);\n    if (comp > 0) return _root.key;\n    _SplayTreeNode<K> node = _root.right;\n    if (node == null) return null;\n    while (node.left != null) {\n      node = node.left;\n    }\n    return node.key;\n  }\n}\n\nabstract class _SplayTreeIterator<T> implements Iterator<T> {\n  final _SplayTree _tree;\n  /**\n   * Worklist of nodes to visit.\n   *\n   * These nodes have been passed over on the way down in a\n   * depth-first left-to-right traversal. Visiting each node,\n   * and their right subtrees will visit the remainder of\n   * the nodes of a full traversal.\n   *\n   * Only valid as long as the original tree isn't reordered.\n   */\n  final List<_SplayTreeNode> _workList = <_SplayTreeNode>[];\n\n  /**\n   * Original modification counter of [_tree].\n   *\n   * Incremented on [_tree] when a key is added or removed.\n   * If it changes, iteration is aborted.\n   */\n  final int _modificationCount;\n\n  /**\n   * Count of splay operations on [_tree] when [_workList] was built.\n   *\n   * If the splay count on [_tree] increases, [_workList] becomes invalid.\n   */\n  int _splayCount;\n\n  /** Current node. */\n  _SplayTreeNode _currentNode;\n\n  _SplayTreeIterator(_SplayTree tree)\n      : _tree = tree,\n        _modificationCount = tree._modificationCount,\n        _splayCount = tree._splayCount {\n    _findLeftMostDescendent(tree._root);\n  }\n\n  T get current {\n    if (_currentNode == null) return null;\n    return _getValue(_currentNode);\n  }\n\n  void _findLeftMostDescendent(_SplayTreeNode node) {\n    while (node != null) {\n      _workList.add(node);\n      node = node.left;\n    }\n  }\n\n  /**\n   * Called when the tree structure of the tree has changed.\n   *\n   * This can be caused by a splay operation.\n   * If the key-set changes, iteration is aborted before getting\n   * here, so we know that the keys are the same as before, it's\n   * only the tree that has been reordered.\n   */\n  void _rebuildWorkList(_SplayTreeNode currentNode) {\n    assert(!_workList.isEmpty);\n    _workList.clear();\n    if (currentNode == null) {\n      _findLeftMostDescendent(_tree._root);\n    } else {\n      _tree._splay(currentNode.key);\n      _findLeftMostDescendent(_tree._root.right);\n      assert(!_workList.isEmpty);\n    }\n  }\n\n  bool moveNext() {\n    if (_modificationCount != _tree._modificationCount) {\n      throw new ConcurrentModificationError(_tree);\n    }\n    // Picks the next element in the worklist as current.\n    // Updates the worklist with the left-most path of the current node's\n    // right-hand child.\n    // If the worklist is no longer valid (after a splay), it is rebuild\n    // from scratch.\n    if (_workList.isEmpty) {\n      _currentNode = null;\n      return false;\n    }\n    if (_tree._splayCount != _splayCount) {\n      _rebuildWorkList(_currentNode);\n    }\n    _currentNode = _workList.removeLast();\n    _findLeftMostDescendent(_currentNode.right);\n    return true;\n  }\n\n  T _getValue(_SplayTreeNode node);\n}\n\nclass _SplayTreeKeyIterable<K> extends IterableBase<K> {\n  _SplayTree<K> _tree;\n  _SplayTreeKeyIterable(this._tree);\n  int get length => _tree._count;\n  bool get isEmpty => _tree._count == 0;\n  Iterator<K> get iterator => new _SplayTreeKeyIterator<K>(_tree);\n}\n\nclass _SplayTreeValueIterable<K, V> extends IterableBase<V> {\n  SplayTreeMap<K, V> _map;\n  _SplayTreeValueIterable(this._map);\n  int get length => _map._count;\n  bool get isEmpty => _map._count == 0;\n  Iterator<V> get iterator => new _SplayTreeValueIterator<K, V>(_map);\n}\n\nclass _SplayTreeKeyIterator<K> extends _SplayTreeIterator<K> {\n  _SplayTreeKeyIterator(_SplayTree<K> map): super(map);\n  K _getValue(_SplayTreeNode node) => node.key;\n}\n\nclass _SplayTreeValueIterator<K, V> extends _SplayTreeIterator<V> {\n  _SplayTreeValueIterator(SplayTreeMap<K, V> map): super(map);\n  V _getValue(_SplayTreeMapNode node) => node.value;\n}\n\nclass _SplayTreeNodeIterator<K>\n    extends _SplayTreeIterator<_SplayTreeNode<K>> {\n  _SplayTreeNodeIterator(_SplayTree<K> map): super(map);\n  _SplayTreeNode<K> _getValue(_SplayTreeNode node) => node;\n}\n","sdk/lib/core/bool.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\nclass bool {\n  factory bool._uninstantiable() {\n    throw new UnsupportedError(\n        \"class bool cannot be instantiated\");\n  }\n}\n","sdk/lib/core/comparable.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * The signature of a generic comparison function.\n *\n * A comparison function represents an ordering on a type of objects.\n * A total ordering on a type means that for two values, either they\n * are equal or one is greater than the other (and the latter must then be\n * smaller than the former).\n *\n * A [Comparator] function represents such a total ordering by returning\n *\n * * a negative integer if [a] is smaller than [b],\n * * zero if [a] is equal to [b], and\n * * a positive integer if [a] is greater than [b].\n */\ntypedef int Comparator<T>(T a, T b);\n\n/**\n * Interface used by types that have an intrinsic ordering.\n */\nabstract class Comparable<T> {\n  /**\n   * Compares this object to another [Comparable]\n   *\n   * Returns a value like a [Comparator] when comparing [:this:] to [other].\n   *\n   * May throw an [ArgumentError] if [other] is of a type that\n   * is not comparable to [:this:].\n   */\n  int compareTo(T other);\n\n  /**\n   * Compare one comparable to another.\n   *\n   * This utility function is used as the default comparator\n   * for the [List] sort function.\n   */\n  static int compare(Comparable a, Comparable b) => a.compareTo(b);\n}\n","sdk/lib/core/core.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart.core;\n\nimport \"dart:collection\";\nimport \"dart:_collection-dev\" hide Symbol;\nimport \"dart:_collection-dev\" as _collection_dev;\n\npart \"bool.dart\";\npart \"comparable.dart\";\npart \"date_time.dart\";\npart \"double.dart\";\npart \"duration.dart\";\npart \"errors.dart\";\npart \"exceptions.dart\";\npart \"expando.dart\";\npart \"function.dart\";\npart \"identical.dart\";\npart \"int.dart\";\npart \"invocation.dart\";\npart \"iterable.dart\";\npart \"iterator.dart\";\npart \"list.dart\";\npart \"map.dart\";\npart \"num.dart\";\npart \"object.dart\";\npart \"pattern.dart\";\npart \"print.dart\";\npart \"regexp.dart\";\npart \"set.dart\";\npart \"stacktrace.dart\";\npart \"stopwatch.dart\";\npart \"string.dart\";\npart \"string_buffer.dart\";\npart \"string_sink.dart\";\npart \"symbol.dart\";\npart \"type.dart\";\n","sdk/lib/core/date_time.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * A DateTime object represents a point in time.\n *\n * It can represent time values that are at a distance of at most\n * 8,640,000,000,000,000ms (100,000,000 days) from epoch (1970-01-01 UTC). In\n * other words: [:millisecondsSinceEpoch.abs() <= 8640000000000000:].\n *\n * Also see [Stopwatch] for means to measure time-spans.\n */\nclass DateTime {\n  // Weekday constants that are returned by [weekday] method:\n  static const int MONDAY = 1;\n  static const int TUESDAY = 2;\n  static const int WEDNESDAY = 3;\n  static const int THURSDAY = 4;\n  static const int FRIDAY = 5;\n  static const int SATURDAY = 6;\n  static const int SUNDAY = 7;\n  static const int DAYS_PER_WEEK = 7;\n\n  // Month constants that are returned by the [month] getter.\n  static const int JANUARY = 1;\n  static const int FEBRUARY = 2;\n  static const int MARCH = 3;\n  static const int APRIL = 4;\n  static const int MAY = 5;\n  static const int JUNE = 6;\n  static const int JULY = 7;\n  static const int AUGUST = 8;\n  static const int SEPTEMBER = 9;\n  static const int OCTOBER = 10;\n  static const int NOVEMBER = 11;\n  static const int DECEMBER = 12;\n  static const int MONTHS_PER_YEAR = 12;\n\n  /**\n   * The milliseconds since 1970-01-01T00:00:00Z (UTC). This value is\n   * independent of the time zone.\n   *\n   * See [Stopwatch] for means to measure time-spans.\n   */\n  final int millisecondsSinceEpoch;\n\n  /**\n   * True if this [DateTime] is set to UTC time.\n   */\n  final bool isUtc;\n\n  /**\n   * Constructs a [DateTime] instance based on the individual parts. The date is\n   * in the local time zone.\n   *\n   * [month] and [day] are one-based. For example\n   * [:new DateTime(1938, 1, 10):] represents the 10th of January 1938.\n   */\n  // TODO(8042): This should be a redirecting constructor and not a factory.\n  factory DateTime(int year,\n           [int month = 1,\n            int day = 1,\n            int hour = 0,\n            int minute = 0,\n            int second = 0,\n            int millisecond = 0]) {\n    return new DateTime._internal(\n          year, month, day, hour, minute, second, millisecond, false);\n  }\n\n  /**\n   * Constructs a [DateTime] instance based on the individual parts. The date is\n   * in the UTC time zone.\n   *\n   * [month] and [day] are one-based. For example\n   * [:new DateTime.utc(1938, 1, 10):] represents the 10th of January 1938 in\n   * Coordinated Universal Time.\n   */\n  // TODO(8042): This should be a redirecting constructor and not a factory.\n  factory DateTime.utc(int year,\n                       [int month = 1,\n                        int day = 1,\n                        int hour = 0,\n                        int minute = 0,\n                        int second = 0,\n                        int millisecond = 0]) {\n    return new DateTime._internal(\n          year, month, day, hour, minute, second, millisecond, true);\n  }\n\n  /**\n   * Constructs a new [DateTime] instance with current date time value in the\n   * local time zone.\n   */\n  // TODO(8042): This should be a redirecting constructor and not a factory.\n  factory DateTime.now() { return new DateTime._now(); }\n\n  /**\n   * Constructs a new [DateTime] instance based on [formattedString].\n   *\n   * The function parses a subset of ISO 8601. Examples of accepted strings:\n   *\n   * * `\"2012-02-27 13:27:00\"`\n   * * `\"2012-02-27 13:27:00.123456z\"`\n   * * `\"20120227 13:27:00\"`\n   * * `\"20120227T132700\"`\n   * * `\"20120227\"`\n   * * `\"+20120227\"`\n   * * `\"2012-02-27T14Z\"`\n   * * `\"-123450101 00:00:00 Z\"`: in the year -12345.\n   */\n  // TODO(floitsch): specify grammar.\n  static DateTime parse(String formattedString) {\n    final RegExp re = new RegExp(\n        r'^([+-]?\\d?\\d\\d\\d\\d)-?(\\d\\d)-?(\\d\\d)'  // The day part.\n        r'(?:[ T](\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(.\\d{1,6})?)?)? ?([zZ])?)?$');\n    Match match = re.firstMatch(formattedString);\n    if (match != null) {\n      int parseIntOrZero(String matched) {\n        if (matched == null) return 0;\n        return int.parse(matched);\n      }\n\n      double parseDoubleOrZero(String matched) {\n        if (matched == null) return 0.0;\n        return double.parse(matched);\n      }\n\n      int years = int.parse(match[1]);\n      int month = int.parse(match[2]);\n      int day = int.parse(match[3]);\n      int hour = parseIntOrZero(match[4]);\n      int minute = parseIntOrZero(match[5]);\n      int second = parseIntOrZero(match[6]);\n      bool addOneMillisecond = false;\n      int millisecond = (parseDoubleOrZero(match[7]) * 1000).round();\n      if (millisecond == 1000) {\n        addOneMillisecond = true;\n        millisecond = 999;\n      }\n      // TODO(floitsch): we should not need to test against the empty string.\n      bool isUtc = (match[8] != null) && (match[8] != \"\");\n      int millisecondsSinceEpoch = _brokenDownDateToMillisecondsSinceEpoch(\n          years, month, day, hour, minute, second, millisecond, isUtc);\n      if (millisecondsSinceEpoch == null) {\n        throw new ArgumentError(formattedString);\n      }\n      if (addOneMillisecond) millisecondsSinceEpoch++;\n      return new DateTime.fromMillisecondsSinceEpoch(millisecondsSinceEpoch,\n                                                     isUtc: isUtc);\n    } else {\n      throw new ArgumentError(formattedString);\n    }\n  }\n\n  static const int _MAX_MILLISECONDS_SINCE_EPOCH = 8640000000000000;\n\n  /**\n   * Constructs a new [DateTime] instance with the given [millisecondsSinceEpoch].\n   * If [isUtc] is false then the date is in the local time zone.\n   *\n   * The constructed [DateTime] represents\n   * 1970-01-01T00:00:00Z + [millisecondsSinceEpoch]ms in the given\n   * time zone (local or UTC).\n   */\n  // TODO(lrn): Have two constructors instead of taking an optional bool.\n  DateTime.fromMillisecondsSinceEpoch(int millisecondsSinceEpoch,\n                                      {bool isUtc: false})\n      : this.millisecondsSinceEpoch = millisecondsSinceEpoch,\n        this.isUtc = isUtc {\n    if (millisecondsSinceEpoch.abs() > _MAX_MILLISECONDS_SINCE_EPOCH) {\n      throw new ArgumentError(millisecondsSinceEpoch);\n    }\n    if (isUtc == null) throw new ArgumentError(isUtc);\n  }\n\n  /**\n   * Returns true if [other] is a [DateTime] at the same moment and in the\n   * same timezone (UTC or local).\n   *\n   * See [isAtSameMomentAs] for a comparison that ignores the timezone.\n   */\n  bool operator ==(other) {\n    if (!(other is DateTime)) return false;\n    return (millisecondsSinceEpoch == other.millisecondsSinceEpoch &&\n            isUtc == other.isUtc);\n  }\n\n  /**\n   * Returns true if [this] occurs before [other]. The comparison is independent\n   * of whether the time is in UTC or in the local time zone.\n   */\n  bool isBefore(DateTime other) {\n    return millisecondsSinceEpoch < other.millisecondsSinceEpoch;\n  }\n\n  /**\n   * Returns true if [this] occurs after [other]. The comparison is independent\n   * of whether the time is in UTC or in the local time zone.\n   */\n  bool isAfter(DateTime other) {\n    return millisecondsSinceEpoch > other.millisecondsSinceEpoch;\n  }\n\n  /**\n   * Returns true if [this] occurs at the same moment as [other]. The\n   * comparison is independent of whether the time is in UTC or in the local\n   * time zone.\n   */\n  bool isAtSameMomentAs(DateTime other) {\n    return millisecondsSinceEpoch == other.millisecondsSinceEpoch;\n  }\n\n  int compareTo(DateTime other)\n      => millisecondsSinceEpoch.compareTo(other.millisecondsSinceEpoch);\n\n  int get hashCode => millisecondsSinceEpoch;\n\n  /**\n   * Returns [this] in the local time zone. Returns itself if it is already in\n   * the local time zone. Otherwise, this method is equivalent to\n   *\n   *     new DateTime.fromMillisecondsSinceEpoch(millisecondsSinceEpoch,\n   *                                             isUtc: false)\n   */\n  DateTime toLocal() {\n    if (isUtc) {\n      return new DateTime.fromMillisecondsSinceEpoch(millisecondsSinceEpoch,\n                                                     isUtc: false);\n    }\n    return this;\n  }\n\n  /**\n   * Returns [this] in UTC. Returns itself if it is already in UTC. Otherwise,\n   * this method is equivalent to\n   *\n   *     new DateTime.fromMillisecondsSinceEpoch(millisecondsSinceEpoch,\n   *                                             isUtc: true)\n   */\n  DateTime toUtc() {\n    if (isUtc) return this;\n    return new DateTime.fromMillisecondsSinceEpoch(millisecondsSinceEpoch,\n                                                   isUtc: true);\n  }\n\n  /**\n   * Returns a human readable string for this instance.\n   * The returned string is constructed for the time zone of this instance.\n   */\n  String toString() {\n    String fourDigits(int n) {\n      int absN = n.abs();\n      String sign = n < 0 ? \"-\" : \"\";\n      if (absN >= 1000) return \"$n\";\n      if (absN >= 100) return \"${sign}0$absN\";\n      if (absN >= 10) return \"${sign}00$absN\";\n      return \"${sign}000$absN\";\n    }\n\n    String threeDigits(int n) {\n      if (n >= 100) return \"${n}\";\n      if (n >= 10) return \"0${n}\";\n      return \"00${n}\";\n    }\n\n    String twoDigits(int n) {\n      if (n >= 10) return \"${n}\";\n      return \"0${n}\";\n    }\n\n    String y = fourDigits(year);\n    String m = twoDigits(month);\n    String d = twoDigits(day);\n    String h = twoDigits(hour);\n    String min = twoDigits(minute);\n    String sec = twoDigits(second);\n    String ms = threeDigits(millisecond);\n    if (isUtc) {\n      return \"$y-$m-$d $h:$min:$sec.${ms}Z\";\n    } else {\n      return \"$y-$m-$d $h:$min:$sec.$ms\";\n    }\n  }\n\n  /** Returns a new [DateTime] with the [duration] added to [this]. */\n  DateTime add(Duration duration) {\n    int ms = millisecondsSinceEpoch;\n    return new DateTime.fromMillisecondsSinceEpoch(\n        ms + duration.inMilliseconds, isUtc: isUtc);\n  }\n\n  /** Returns a new [DateTime] with the [duration] subtracted from [this]. */\n  DateTime subtract(Duration duration) {\n    int ms = millisecondsSinceEpoch;\n    return new DateTime.fromMillisecondsSinceEpoch(\n        ms - duration.inMilliseconds, isUtc: isUtc);\n  }\n\n  /** Returns a [Duration] with the difference of [this] and [other]. */\n  Duration difference(DateTime other) {\n    int ms = millisecondsSinceEpoch;\n    int otherMs = other.millisecondsSinceEpoch;\n    return new Duration(milliseconds: ms - otherMs);\n  }\n\n  external DateTime._internal(int year,\n                              int month,\n                              int day,\n                              int hour,\n                              int minute,\n                              int second,\n                              int millisecond,\n                              bool isUtc);\n  external DateTime._now();\n  external static int _brokenDownDateToMillisecondsSinceEpoch(\n      int year, int month, int day, int hour, int minute, int second,\n      int millisecond, bool isUtc);\n\n  /**\n   * Returns the abbreviated time-zone name.\n   *\n   * Examples: [:\"CET\":] or [:\"CEST\":].\n   */\n  external String get timeZoneName;\n\n  /**\n   * The time-zone offset is the difference between local time and UTC. That is,\n   * the offset is positive for time zones west of UTC.\n   *\n   * Note, that JavaScript, Python and C return the difference between UTC and\n   * local time. Java, C# and Ruby return the difference between local time and\n   * UTC.\n   */\n  external Duration get timeZoneOffset;\n\n  /**\n   * Returns the year.\n   */\n  external int get year;\n\n  /**\n   * Returns the month into the year [1..12].\n   */\n  external int get month;\n\n  /**\n   * Returns the day into the month [1..31].\n   */\n  external int get day;\n\n  /**\n   * Returns the hour into the day [0..23].\n   */\n  external int get hour;\n\n  /**\n   * Returns the minute into the hour [0...59].\n   */\n  external int get minute;\n\n  /**\n   * Returns the second into the minute [0...59].\n   */\n  external int get second;\n\n  /**\n   * Returns the millisecond into the second [0...999].\n   */\n  external int get millisecond;\n\n  /**\n   * Returns the week day [MON..SUN]. In accordance with ISO 8601\n   * a week starts with Monday which has the value 1.\n   */\n  external int get weekday;\n}\n","sdk/lib/core/double.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n// TODO: Convert this abstract class into a concrete class double\n// that uses the patch class functionality to account for the\n// different platform implementations.\n\n/**\n * Representation of Dart doubles containing double specific constants\n * and operations and specializations of operations inherited from\n * [num].\n *\n * The [double] type is contagious. Operations on [double]s return\n * [double] results.\n */\nabstract class double extends num {\n  static const double NAN = 0.0 / 0.0;\n  static const double INFINITY = 1.0 / 0.0;\n  static const double NEGATIVE_INFINITY = -INFINITY;\n  static const double MIN_POSITIVE = 5e-324;\n  static const double MAX_FINITE = 1.7976931348623157e+308;\n\n  double remainder(num other);\n\n  /** Addition operator. */\n  double operator +(num other);\n\n  /** Subtraction operator. */\n  double operator -(num other);\n\n  /** Multiplication operator. */\n  double operator *(num other);\n\n  double operator %(num other);\n\n  /** Division operator. */\n  double operator /(num other);\n\n  /**\n   * Truncating division operator.\n   *\n   * The result of the truncating division [:a ~/ b:] is equivalent to\n   * [:(a / b).truncate():].\n   */\n  int operator ~/(num other);\n\n  /** Negate operator. */\n  double operator -();\n\n  /** Returns the absolute value of this [double]. */\n  double abs();\n\n  /**\n   * Returns the integer closest to `this`.\n   *\n   * Rounds away from zero when there is no closest integer:\n   *  [:(3.5).round() == 4:] and [:(-3.5).round() == -4:].\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int round();\n\n  /**\n   * Returns the greatest integer no greater than `this`.\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int floor();\n\n  /**\n   * Returns the least integer no smaller than `this`.\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int ceil();\n\n  /**\n   * Returns the integer obtained by discarding any fractional\n   * digits from `this`.\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int truncate();\n\n  /**\n   * Returns the integer value, as a double, closest to `this`.\n   *\n   * Rounds away from zero when there is no closest integer:\n   *  [:(3.5).round() == 4:] and [:(-3.5).round() == -4:].\n   */\n  double roundToDouble();\n\n  /**\n   * Returns the greatest integer value no greater than `this`.\n   *\n   * The result is a double.\n   */\n  double floorToDouble();\n\n  /**\n   * Returns the least integer value no smaller than `this`.\n   *\n   * The result is a double.\n   */\n  double ceilToDouble();\n\n  /**\n   * Returns the integer obtained by discarding any fractional\n   * digits from `this`.\n   *\n   * The result is a double.\n   */\n  double truncateToDouble();\n\n  /**\n   * Provide a representation of this [double] value.\n   *\n   * The representation is a number literal such that the closest double value\n   * to the representation's mathematical value is this [double].\n   *\n   * Returns \"NaN\" for the Not-a-Number value.\n   * Returns \"Infinity\" and \"-Infinity\" for positive and negative Infinity.\n   * Returns \"-0.0\" for negative zero.\n   *\n   * It should always be the case that if [:d:] is a [double], then\n   * [:d == double.parse(d.toString()):].\n   */\n  String toString();\n\n  /**\n   * Parse [source] as an double literal and return its value.\n   *\n   * Accepts the same format as double literals:\n   *   [: ['+'|'-'] [digit* '.'] digit+ [('e'|'E') ['+'|'-'] digit+] :]\n   *\n   * Also recognizes \"NaN\", \"Infinity\" and \"-Infinity\" as inputs and\n   * returns the corresponding double value.\n   *\n   * If the [soure] is not a valid double literal, the [handleError]\n   * is called with the [source] as argument, and its return value is\n   * used instead. If no handleError is provided, a [FormatException]\n   * is thrown.\n   */\n  external static double parse(String source,\n                               [double handleError(String source)]);\n}\n","sdk/lib/core/duration.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * A [Duration] represents a time span. A duration can be negative.\n */\nclass Duration implements Comparable<Duration> {\n  static const int MICROSECONDS_PER_MILLISECOND = 1000;\n  static const int MILLISECONDS_PER_SECOND = 1000;\n  static const int SECONDS_PER_MINUTE = 60;\n  static const int MINUTES_PER_HOUR = 60;\n  static const int HOURS_PER_DAY = 24;\n\n  static const int MICROSECONDS_PER_SECOND =\n      MICROSECONDS_PER_MILLISECOND * MILLISECONDS_PER_SECOND;\n  static const int MICROSECONDS_PER_MINUTE =\n      MICROSECONDS_PER_SECOND * SECONDS_PER_MINUTE;\n  static const int MICROSECONDS_PER_HOUR =\n      MICROSECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n  static const int MICROSECONDS_PER_DAY =\n      MICROSECONDS_PER_HOUR * HOURS_PER_DAY;\n\n\n  static const int MILLISECONDS_PER_MINUTE =\n      MILLISECONDS_PER_SECOND * SECONDS_PER_MINUTE;\n  static const int MILLISECONDS_PER_HOUR =\n      MILLISECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n  static const int MILLISECONDS_PER_DAY =\n      MILLISECONDS_PER_HOUR * HOURS_PER_DAY;\n\n  static const int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n  static const int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;\n\n  static const int MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY;\n\n  static const Duration ZERO = const Duration(seconds: 0);\n\n  /**\n   * This [Duration] in microseconds.\n   */\n  final int _duration;\n\n  /**\n   * The duration is the sum of all individual parts. This means that individual\n   * parts don't need to be less than the next-bigger unit. For example [hours]\n   * is allowed to have a value greater than 23.\n   *\n   * All individual parts are allowed to be negative.\n   * All arguments are by default 0.\n   */\n  const Duration({int days: 0,\n                  int hours: 0,\n                  int minutes: 0,\n                  int seconds: 0,\n                  int milliseconds: 0,\n                  int microseconds: 0})\n      : _duration = days * MICROSECONDS_PER_DAY +\n                    hours * MICROSECONDS_PER_HOUR +\n                    minutes * MICROSECONDS_PER_MINUTE +\n                    seconds * MICROSECONDS_PER_SECOND +\n                    milliseconds * MICROSECONDS_PER_MILLISECOND +\n                    microseconds;\n\n  /**\n   * Returns the sum of this [Duration] and [other]  as a new [Duration].\n   */\n  Duration operator +(Duration other) {\n    return new Duration(microseconds: _duration + other._duration);\n  }\n\n  /**\n   * Returns the difference of this [Duration] and [other] as a new\n   * [Duration].\n   */\n  Duration operator -(Duration other) {\n    return new Duration(microseconds: _duration - other._duration);\n  }\n\n  /**\n   * Multiplies this [Duration] by the given [factor] and returns the result\n   * as a new [Duration].\n   */\n  Duration operator *(int factor) {\n    return new Duration(microseconds: _duration * factor);\n  }\n\n  /**\n   * Divides this [Duration] by the given [quotient] and returns the truncated\n   * result as a new [Duration].\n   *\n   * Throws an [IntegerDivisionByZeroException] if [quotient] is `0`.\n   */\n  Duration operator ~/(int quotient) {\n    // By doing the check here instead of relying on \"~/\" below we get the\n    // exception even with dart2js.\n    if (quotient == 0) throw new IntegerDivisionByZeroException();\n    return new Duration(microseconds: _duration ~/ quotient);\n  }\n\n  bool operator <(Duration other) => this._duration < other._duration;\n\n  bool operator >(Duration other) => this._duration > other._duration;\n\n  bool operator <=(Duration other) => this._duration <= other._duration;\n\n  bool operator >=(Duration other) => this._duration >= other._duration;\n\n  /**\n   * This [Duration] in days. Incomplete days are discarded\n   */\n  int get inDays => _duration ~/ Duration.MICROSECONDS_PER_DAY;\n\n  /**\n   * This [Duration] in hours. Incomplete hours are discarded.\n   *\n   * The returned value can be greater than 23.\n   */\n  int get inHours => _duration ~/ Duration.MICROSECONDS_PER_HOUR;\n\n  /**\n   * This [Duration] in minutes. Incomplete minutes are discarded.\n   *\n   * The returned value can be greater than 59.\n   */\n  int get inMinutes => _duration ~/ Duration.MICROSECONDS_PER_MINUTE;\n\n  /**\n   * This [Duration] in seconds. Incomplete seconds are discarded.\n   *\n   * The returned value can be greater than 59.\n   */\n  int get inSeconds => _duration ~/ Duration.MICROSECONDS_PER_SECOND;\n\n  /**\n   * This [Duration] in milliseconds. Incomplete milliseconds are discarded.\n   *\n   * The returned value can be greater than 999.\n   */\n  int get inMilliseconds => _duration ~/ Duration.MICROSECONDS_PER_MILLISECOND;\n\n  /**\n   * This [Duration] in microseconds.\n   */\n  int get inMicroseconds => _duration;\n\n  bool operator ==(other) {\n    if (other is !Duration) return false;\n    return _duration == other._duration;\n  }\n\n  int get hashCode => _duration.hashCode;\n\n  int compareTo(Duration other) => _duration.compareTo(other._duration);\n\n  String toString() {\n    String sixDigits(int n) {\n      if (n >= 100000) return \"$n\";\n      if (n >= 10000) return \"0$n\";\n      if (n >= 1000) return \"00$n\";\n      if (n >= 100) return \"000$n\";\n      if (n > 10) return \"0000$n\";\n      return \"00000$n\";\n    }\n    String twoDigits(int n) {\n      if (n >= 10) return \"$n\";\n      return \"0$n\";\n    }\n\n    if (inMicroseconds < 0) {\n      Duration duration =\n          new Duration(microseconds: -inMicroseconds);\n      return \"-$duration\";\n    }\n    String twoDigitMinutes = twoDigits(inMinutes.remainder(MINUTES_PER_HOUR));\n    String twoDigitSeconds = twoDigits(inSeconds.remainder(SECONDS_PER_MINUTE));\n    String sixDigitUs =\n        sixDigits(inMicroseconds.remainder(MICROSECONDS_PER_SECOND));\n    return \"$inHours:$twoDigitMinutes:$twoDigitSeconds.$sixDigitUs\";\n  }\n}\n","sdk/lib/core/errors.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\nclass Error {\n  const Error();\n\n  /**\n   * Safely convert a value to a [String] description.\n   *\n   * The conversion is guaranteed to not throw, so it won't use the object's\n   * toString method.\n   */\n  static String safeToString(Object object) {\n    if (object is int || object is double || object is bool || null == object) {\n      return object.toString();\n    }\n    if (object is String) {\n      // TODO(ahe): Remove backslash when http://dartbug.com/4995 is fixed.\n      String string = object;\n      const backslash = '\\\\';\n      String escaped = string\n        .replaceAll('$backslash', '$backslash$backslash')\n        .replaceAll('\\n', '${backslash}n')\n        .replaceAll('\\r', '${backslash}r')\n        .replaceAll('\"',  '$backslash\"');\n      return '\"$escaped\"';\n    }\n    return _objectToString(object);\n  }\n\n  external static String _objectToString(Object object);\n}\n\n/**\n * Error thrown by the runtime system when an assert statement fails.\n */\nclass AssertionError implements Error {\n}\n\n/**\n * Error thrown by the runtime system when a type assertion fails.\n */\nclass TypeError implements AssertionError {\n}\n\n/**\n * Error thrown by the runtime system when a cast operation fails.\n */\nclass CastError implements Error {\n}\n\n/**\n * Error thrown when attempting to throw [:null:].\n */\nclass NullThrownError implements Error {\n  const NullThrownError();\n  String toString() => \"Throw of null.\";\n}\n\n/**\n * Error thrown when a function is passed an unacceptable argument.\n */\nclass ArgumentError implements Error {\n  final message;\n\n  /** The [message] describes the erroneous argument. */\n  ArgumentError([this.message]);\n\n  String toString() {\n    if (message != null) {\n      return \"Illegal argument(s): $message\";\n    }\n    return \"Illegal argument(s)\";\n  }\n}\n\n/**\n * Error thrown because of an index outside of the valid range.\n *\n */\nclass RangeError extends ArgumentError {\n  // TODO(lrn): This constructor should be called only with string values.\n  // It currently isn't in all cases.\n  /**\n   * Create a new [RangeError] with the given [message].\n   *\n   * Temporarily made const for backwards compatibilty.\n   */\n  RangeError(var message) : super(message);\n\n  /** Create a new [RangeError] with a message for the given [value]. */\n  RangeError.value(num value) : super(\"value $value\");\n\n  /** Create a new [RangeError] with a message for a value and a range. */\n  RangeError.range(num value, num start, num end)\n      : super(\"value $value not in range $start..$end\");\n\n  String toString() => \"RangeError: $message\";\n}\n\n\n/**\n * Error thrown when control reaches the end of a switch case.\n *\n * The Dart specification requires this error to be thrown when\n * control reaches the end of a switch case (except the last case\n * of a switch) without meeting a break or similar end of the control\n * flow.\n */\nclass FallThroughError implements Error {\n  const FallThroughError();\n}\n\n\nclass AbstractClassInstantiationError implements Error {\n  final String _className;\n  const AbstractClassInstantiationError(String this._className);\n  String toString() => \"Cannot instantiate abstract class: '$_className'\";\n}\n\n/**\n * Error thrown by the default implementation of [:noSuchMethod:] on [Object].\n */\nclass NoSuchMethodError implements Error {\n  final Object _receiver;\n  final String _memberName;\n  final List _arguments;\n  final Map<String,dynamic> _namedArguments;\n  final List _existingArgumentNames;\n\n  /**\n   * Create a [NoSuchMethodError] corresponding to a failed method call.\n   *\n   * The first parameter to this constructor is the receiver of the method call.\n   * That is, the object on which the method was attempted called.\n   * The second parameter is the name of the called method or accessor.\n   * The third parameter is a list of the positional arguments that the method\n   * was called with.\n   * The fourth parameter is a map from [String] names to the values of named\n   * arguments that the method was called with.\n   * The optional [exisitingArgumentNames] is the expected parameters of a\n   * method with the same name on the receiver, if available. This is\n   * the method that would have been called if the parameters had matched.\n   */\n  const NoSuchMethodError(Object this._receiver,\n                          String this._memberName,\n                          List this._arguments,\n                          Map<String,dynamic> this._namedArguments,\n                          [List existingArgumentNames = null])\n      : this._existingArgumentNames = existingArgumentNames;\n\n  external String toString();\n}\n\n\n/**\n * The operation was not allowed by the object.\n *\n * This [Error] is thrown when an instance cannot implement one of the methods\n * in its signature.\n */\nclass UnsupportedError implements Error {\n  final String message;\n  UnsupportedError(this.message);\n  String toString() => \"Unsupported operation: $message\";\n}\n\n\n/**\n * Thrown by operations that have not been implemented yet.\n *\n * This [Error] is thrown by unfinished code that hasn't yet implemented\n * all the features it needs.\n *\n * If a class is not intending to implement the feature, it should throw\n * an [UnsupportedError] instead. This error is only intended for\n * use during development.\n */\nclass UnimplementedError implements UnsupportedError {\n  final String message;\n  UnimplementedError([String this.message]);\n  String toString() => (this.message != null\n                        ? \"UnimplementedError: $message\"\n                        : \"UnimplementedError\");\n}\n\n\n/**\n * The operation was not allowed by the current state of the object.\n *\n * This is a generic error used for a variety of different erroneous\n * actions. The message should be descriptive.\n */\nclass StateError implements Error {\n  final String message;\n  StateError(this.message);\n  String toString() => \"Bad state: $message\";\n}\n\n\n/**\n * Error occurring when a collection is modified during iteration.\n *\n * Some modifications may be allowed for some collections, so each collection\n * ([Iterable] or similar collection of values) should declare which operations\n * are allowed during an iteration.\n */\nclass ConcurrentModificationError implements Error {\n  /** The object that was modified in an incompatible way. */\n  final Object modifiedObject;\n\n  const ConcurrentModificationError([this.modifiedObject]);\n\n  String toString() {\n    if (modifiedObject == null) {\n      return \"Concurrent modification during iteration.\";\n    }\n    return \"Concurrent modification during iteration: \"\n           \"${Error.safeToString(modifiedObject)}.\";\n  }\n}\n\n\nclass OutOfMemoryError implements Error {\n  const OutOfMemoryError();\n  String toString() => \"Out of Memory\";\n}\n\nclass StackOverflowError implements Error {\n  const StackOverflowError();\n  String toString() => \"Stack Overflow\";\n}\n\n/**\n * Error thrown when a runtime error occurs.\n */\nclass RuntimeError implements Error {\n  final message;\n  RuntimeError(this.message);\n  String toString() => \"RuntimeError: $message\";\n}\n","sdk/lib/core/exceptions.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n// Exceptions are thrown either by the VM or from Dart code.\n\n/**\n * A marker interface implemented by all core library exceptions.\n *\n * An [Exception] is intended to convey information to the user about a failure,\n * so that the error can be addressed programmatically. It is intended to be\n * caught, and it should contain useful data fields.\n *\n * Creating instances of [Exception] directly with [:new Exception(\"message\"):]\n * is discouraged, and only included as a temporary measure during development,\n * until the actual exceptions used by a library are done.\n */\nabstract class Exception {\n  factory Exception([var message]) => new _ExceptionImplementation(message);\n}\n\n\n/** Default implementation of [Exception] which carries a message. */\nclass _ExceptionImplementation implements Exception {\n  final message;\n\n  _ExceptionImplementation([this.message]);\n\n  String toString() {\n    if (message == null) return \"Exception\";\n    return \"Exception: $message\";\n  }\n}\n\n\n/**\n * Exception thrown when a string or some other data does not have an expected\n * format and cannot be parsed or processed.\n */\nclass FormatException implements Exception {\n  /**\n   * A message describing the format error.\n   */\n  final String message;\n\n  /**\n   * Creates a new FormatException with an optional error [message].\n   */\n  const FormatException([this.message = \"\"]);\n\n  String toString() => \"FormatException: $message\";\n}\n\nclass IntegerDivisionByZeroException implements Exception {\n  const IntegerDivisionByZeroException();\n  String toString() => \"IntegerDivisionByZeroException\";\n}\n","sdk/lib/core/expando.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * An [Expando] allows adding new properties to objects.\n */\nclass Expando<T> {\n\n  /**\n   * The name of the this [Expando] as passed to the constructor. If\n   * no name was passed to the constructor, the name is [null].\n   */\n  final String name;\n\n  /**\n   * Creates a new [Expando]. The optional name is only used for\n   * debugging purposes and creating two different [Expando]s with the\n   * same name yields two [Expando]s that work on different properties\n   * of the objects they are used on.\n   */\n  external Expando([String name]);\n\n  /**\n   * Expando toString method override.\n   */\n  String toString() => \"Expando:$name\";\n\n  /**\n   * Gets the value of this [Expando]'s property on the given\n   * object. If the object hasn't been expanded, the method returns\n   * [null].\n   */\n  external T operator [](Object object);\n\n  /**\n   * Sets the value of this [Expando]'s property on the given\n   * object. Properties can effectively be removed again by setting\n   * their value to null.\n   */\n  external void operator []=(Object object, T value);\n\n}\n","sdk/lib/core/function.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * Super-type of all function types.\n *\n * A function value, or an instance of a class with a \"call\" method, is a\n * subtype of a function type, and as such, a subtype of [Function].\n */\nabstract class Function {\n  /**\n   * Dynamically call [function] with the specified arguments.\n   *\n   * Acts the same as calling function with positional arguments\n   * corresponding to the elements of [positionalArguments] and\n   * named arguments corresponding to the elements of [namedArguments].\n   *\n   * This includes giving the same errors if [function] isn't callable or\n   * if it expects different parameters.\n   *\n   * Example: [:\n   * Map<Symbol, dynamic> namedArguments = new Map<Symbol, dynamic>();\n   * namedArguments[const Symbol(\"f\")] = 4;\n   * namedArguments[const Symbol(\"g\")] = 5;\n   * Function.apply(foo, [1,2,3], namedArguments); :]\n   * gives exactly the same result as [: foo(1, 2, 3, f: 4, g: 5) :].\n   *\n   * If [positionalArguments] is null, it's considered an empty list.\n   * If [namedArguments] is omitted or null, it is considered an empty map.\n   */\n  external static apply(Function function,\n                        List positionalArguments,\n                        [Map<Symbol, dynamic> namedArguments]);\n}\n","sdk/lib/core/identical.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * Check whether two references are to the same object.\n */\nexternal bool identical(Object a, Object b);\n","sdk/lib/core/int.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * Representation of Dart integers containing integer specific\n * operations and specialization of operations inherited from [num].\n *\n * Integers can be arbitrarily large in Dart.\n *\n * *Note however, that when compiling to JavaScript, integers are\n * implemented as JavaScript numbers. When compiling to JavaScript,\n * integers are therefore restricted to 53 significant bits because\n * all JavaScript numbers are double-precision floating point\n * values. The behavior of the operators and methods in the [int]\n * class therefore sometimes differs between the Dart VM and Dart code\n * compiled to JavaScript.*\n */\nabstract class int extends num {\n  /** The bit-wise and operator. */\n  int operator &(int other);\n\n  /** The bit-wise or operator. */\n  int operator |(int other);\n\n  /** The bit-wise xor operator. */\n  int operator ^(int other);\n\n  /** The bit-wise negate operator. */\n  int operator ~();\n\n  /** The left shift operator. */\n  int operator <<(int shiftAmount);\n\n  /** The right shift operator. */\n  int operator >>(int shiftAmount);\n\n  /** Returns true if and only if this integer is even. */\n  bool get isEven;\n\n  /** Returns true if and only if this integer is odd. */\n  bool get isOdd;\n\n  /** Negate operator. Negating an integer produces an integer. */\n  int operator -();\n\n  /** Returns the absolute value of this integer. */\n  int abs();\n\n  /** Returns `this`. */\n  int round();\n\n  /** Returns `this`. */\n  int floor();\n\n  /** Returns [this]. */\n  int ceil();\n\n  /** Returns [this]. */\n  int truncate();\n\n  /** Returns `this.toDouble()`. */\n  double roundToDouble();\n\n  /** Returns `this.toDouble()`. */\n  double floorToDouble();\n\n  /** Returns `this.toDouble()`. */\n  double ceilToDouble();\n\n  /** Returns `this.toDouble()`. */\n  double truncateToDouble();\n\n  /**\n   * Returns a representation of this [int] value.\n   *\n   * It should always be the case that if [:i:] is an [int] value,\n   * then [:i == int.parse(i.toString()):].\n   */\n  String toString();\n\n  /**\n   * Converts [this] to a string representation in the given [radix].\n   *\n   * In the string representation, lower-case letters are used for digits above\n   * '9'.\n   *\n   * The [radix] argument must be an integer in the range 2 to 36.\n   */\n  String toRadixString(int radix);\n\n  /**\n   * Parse [source] as an integer literal and return its value.\n   *\n   * The [radix] must be in the range 2..36. The digits used are\n   * first the decimal digits 0..9, and then the letters 'a'..'z'.\n   * Accepts capital letters as well.\n   *\n   * If no [radix] is given then it defaults to 16 if the string starts\n   * with \"0x\", \"-0x\" or \"+0x\" and 10 otherwise.\n   *\n   * The [source] must be a non-empty sequence of base-[radix] digits,\n   * optionally prefixed with a minus or plus sign ('-' or '+').\n   *\n   * It must always be the case for an int [:n:] and radix [:r:] that\n   * [:n == parseRadix(n.toRadixString(r), r):].\n   *\n   * If the [source] is not a valid integer literal, optionally prefixed by a\n   * sign, the [onError] is called with the [source] as argument, and its return\n   * value is used instead. If no [onError] is provided, a [FormatException]\n   * is thrown.\n   */\n  external static int parse(String source,\n                            { int radix,\n                              int onError(String source) });\n}\n","sdk/lib/core/invocation.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * Representation of the invocation of a member on an object.\n *\n * This is the type of objects passed to [Object.noSuchMethod] when\n * an object doesn't support the member invocation that was attempted\n * on it.\n */\nabstract class Invocation {\n  /** The name of the invoked member. */\n  Symbol get memberName;\n\n  /** An unmodifiable view of the positional arguments of the call. */\n  List get positionalArguments;\n\n  /** An unmodifiable view of the named arguments of the call. */\n  Map<Symbol, dynamic> get namedArguments;\n\n  /** Whether the invocation was a method call. */\n  bool get isMethod;\n\n  /**\n   * Whether the invocation was a getter call.\n   * If so, both types of arguments will be null.\n   */\n  bool get isGetter;\n\n  /**\n   * Whether the invocation was a setter call.\n   *\n   * If so, [arguments] will have exactly one positonal argument,\n   * and namedArguments will be null.\n   */\n  bool get isSetter;\n\n  /** Whether the invocation was a getter or a setter call. */\n  bool get isAccessor => isGetter || isSetter;\n}\n","sdk/lib/core/iterable.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * The [Iterable] interface allows to get an [Iterator] out of an\n * [Iterable] object.\n *\n * This interface is used by the for-in construct to iterate over an\n * [Iterable] object.\n * The for-in construct takes an [Iterable] object at the right-hand\n * side, and calls its [iterator] method to get an [Iterator] on it.\n *\n * A user-defined class that implements the [Iterable] interface can\n * be used as the right-hand side of a for-in construct.\n */\nabstract class Iterable<E> {\n  const Iterable();\n\n  /**\n   * Create an [Iterable] that generates its elements dynamically.\n   *\n   * The [Iterators] created by the [Iterable] will count from\n   * zero to [:count - 1:] while iterating, and call [generator]\n   * with that index to create the next value.\n   *\n   * As an [Iterable], [:new Iterable.generate(n, generator)):] is equivalent to\n   * [:const [0, ..., n - 1].map(generator):]\n   */\n  factory Iterable.generate(int count, E generator(int index)) {\n    return new _GeneratorIterable<E>(count, generator);\n  }\n\n  /**\n   * Returns an [Iterator] that iterates over this [Iterable] object.\n   */\n  Iterator<E> get iterator;\n\n  /**\n   * Returns a lazy [Iterable] where each element [:e:] of [this] is replaced\n   * by the result of [:f(e):].\n   *\n   * This method returns a view of the mapped elements. As long as the\n   * returned [Iterable] is not iterated over, the supplied function [f] will\n   * not be invoked. The transformed elements will not be cached. Iterating\n   * multiple times over the the returned [Iterable] will invoke the supplied\n   * function [f] multiple times on the same element.\n   */\n  Iterable map(f(E element));\n\n  /**\n   * Returns a lazy [Iterable] with all elements that satisfy the\n   * predicate [f].\n   *\n   * This method returns a view of the mapped elements. As long as the\n   * returned [Iterable] is not iterated over, the supplied function [f] will\n   * not be invoked. Iterating will not cache results, and thus iterating\n   * multiple times over the the returned [Iterable] will invoke the supplied\n   * function [f] multiple times on the same element.\n   */\n  Iterable<E> where(bool f(E element));\n\n  /**\n   * Expand each element of this [Iterable] into zero or more elements.\n   *\n   * The resulting Iterable will run through the elements returned\n   * by [f] for each element of this, in order.\n   *\n   * The returned [Iterable] is lazy, and will call [f] for each element\n   * of this every time it's iterated.\n   */\n  Iterable expand(Iterable f(E element));\n\n  /**\n   * Check whether the collection contains an element equal to [element].\n   */\n  bool contains(E element);\n\n  /**\n   * Applies the function [f] to each element of this collection.\n   */\n  void forEach(void f(E element));\n\n  /**\n   * Reduces a collection to a single value by iteratively combining elements\n   * of the collection using the provided function.\n   *\n   * Example of calculating the sum of an iterable:\n   *\n   *     iterable.reduce((value, element) => value + element);\n   *\n   */\n  E reduce(E combine(E value, E element));\n\n  /**\n   * Reduces a collection to a single value by iteratively combining each\n   * element of the collection with an existing value using the provided\n   * function.\n   *\n   * Use [initialValue] as the initial value, and the function [combine] to\n   * create a new value from the previous one and an element.\n   *\n   * Example of calculating the sum of an iterable:\n   *\n   *     iterable.fold(0, (prev, element) => prev + element);\n   *\n   */\n  dynamic fold(var initialValue,\n               dynamic combine(var previousValue, E element));\n\n  /**\n   * Returns true if every elements of this collection satisify the\n   * predicate [f]. Returns false otherwise.\n   */\n  bool every(bool f(E element));\n\n  /**\n   * Converts each element to a [String] and concatenates the strings.\n   *\n   * Converts each element to a [String] by calling [Object.toString] on it.\n   * Then concatenates the strings, optionally separated by the [separator]\n   * string.\n   */\n  String join([String separator = \"\"]) {\n    StringBuffer buffer = new StringBuffer();\n    buffer.writeAll(this, separator);\n    return buffer.toString();\n  }\n\n  /**\n   * Returns true if one element of this collection satisfies the\n   * predicate [f]. Returns false otherwise.\n   */\n  bool any(bool f(E element));\n\n  /**\n   * Creates a [List] containing the elements of this [Iterable].\n   *\n   * The elements will be in iteration order. The list is fixed-length\n   * if [growable] is false.\n   */\n  List<E> toList({ bool growable: true });\n\n  /**\n   * Creates a [Set] containing the elements of this [Iterable].\n   */\n  Set<E> toSet();\n\n  /**\n   * Returns the number of elements in [this].\n   *\n   * Counting all elements may be involve running through all elements and can\n   * therefore be slow.\n   */\n  int get length;\n\n  /**\n   * Returns true if there is no element in this collection.\n   */\n  bool get isEmpty;\n\n  /**\n   * Returns an [Iterable] with at most [n] elements.\n   *\n   * The returned [Iterable] may contain fewer than [n] elements, if [this]\n   * contains fewer than [n] elements.\n   */\n  Iterable<E> take(int n);\n\n  /**\n   * Returns an [Iterable] that stops once [test] is not satisfied anymore.\n   *\n   * The filtering happens lazily. Every new [Iterator] of the returned\n   * [Iterable] will start iterating over the elements of [this].\n   * When the iterator encounters an element [:e:] that does not satisfy [test],\n   * it discards [:e:] and moves into the finished state. That is, it will not\n   * ask or provide any more elements.\n   */\n  Iterable<E> takeWhile(bool test(E value));\n\n  /**\n   * Returns an [Iterable] that skips the first [n] elements.\n   *\n   * If [this] has fewer than [n] elements, then the resulting [Iterable] will\n   * be empty.\n   */\n  Iterable<E> skip(int n);\n\n  /**\n   * Returns an [Iterable] that skips elements while [test] is satisfied.\n   *\n   * The filtering happens lazily. Every new [Iterator] of the returned\n   * [Iterable] will iterate over all elements of [this].\n   * As long as the iterator's elements do not satisfy [test] they are\n   * discarded. Once an element satisfies the [test] the iterator stops testing\n   * and uses every element unconditionally.\n   */\n  Iterable<E> skipWhile(bool test(E value));\n\n  /**\n   * Returns the first element.\n   *\n   * If [this] is empty throws a [StateError]. Otherwise this method is\n   * equivalent to [:this.elementAt(0):]\n   */\n  E get first;\n\n  /**\n   * Returns the last element.\n   *\n   * If [this] is empty throws a [StateError].\n   */\n  E get last;\n\n  /**\n   * Returns the single element in [this].\n   *\n   * If [this] is empty or has more than one element throws a [StateError].\n   */\n  E get single;\n\n  /**\n   * Returns the first element that satisfies the given predicate [f].\n   *\n   * If none matches, the result of invoking the [orElse] function is\n   * returned. By default, when [orElse] is `null`, a [StateError] is\n   * thrown.\n   */\n  E firstWhere(bool test(E value), { E orElse() });\n\n  /**\n   * Returns the last element that satisfies the given predicate [f].\n   *\n   * If none matches, the result of invoking the [orElse] function is\n   * returned. By default, when [orElse] is [:null:], a [StateError] is\n   * thrown.\n   */\n  E lastWhere(bool test(E value), {E orElse()});\n\n  /**\n   * Returns the single element that satisfies [f]. If no or more than one\n   * element match then a [StateError] is thrown.\n   */\n  E singleWhere(bool test(E value));\n\n  /**\n   * Returns the [index]th element.\n   *\n   * If [this] [Iterable] has fewer than [index] elements throws a\n   * [RangeError].\n   *\n   * Note: if [this] does not have a deterministic iteration order then the\n   * function may simply return any element without any iteration if there are\n   * at least [index] elements in [this].\n   */\n  E elementAt(int index);\n}\n\n\ntypedef E _Generator<E>(int index);\n\nclass _GeneratorIterable<E> extends IterableBase<E> {\n  final int _count;\n  final _Generator<E> _generator;\n  _GeneratorIterable(this._count, this._generator);\n  Iterator<E> get iterator => new _GeneratorIterator(_count, _generator);\n}\n\nclass _GeneratorIterator<E> implements Iterator<E> {\n  final int _count;\n  final _Generator<E> _generator;\n  int _index = 0;\n  E _current;\n\n  _GeneratorIterator(this._count, this._generator);\n\n  bool moveNext() {\n    if (_index < _count) {\n      _current = _generator(_index);\n      _index++;\n      return true;\n    } else {\n      _current = null;\n      return false;\n    }\n  }\n\n  E get current => _current;\n}\n\n/**\n * An [Iterator] that allows moving backwards as well as forwards.\n */\nabstract class BidirectionalIterator<E> implements Iterator<E> {\n  /**\n   * Move back to the previous element.\n   *\n   * Returns true and updates [current] if successful. Returns false\n   * and sets [current] to null if there is no previous element.\n   */\n  bool movePrevious();\n}\n","sdk/lib/core/iterator.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * The [Iterator] class provides methods to iterate over an object. It\n * is transparently used by the for-in construct to test for the end\n * of the iteration, and to get the elements.\n *\n * If the object iterated over is changed during the iteration, the\n * behavior is unspecified.\n *\n * The [Iterator] is initially positioned before the first element. Before\n * accessing the first element the iterator must thus be advanced ([moveNext])\n * to point to the first element. If there is no element left, then [moveNext]\n * returns false.\n *\n * A typical usage of an [Iterator] looks as follows:\n *\n *     var it = obj.iterator;\n *     while (it.moveNext()) {\n *       use(it.current);\n *     }\n */\nabstract class Iterator<E> {\n  /**\n   * Moves to the next element. Returns true if [current] contains the next\n   * element. Returns false, if no element was left.\n   *\n   * It is safe to invoke [moveNext] even when the iterator is already\n   * positioned after the last element. In this case [moveNext] has no effect.\n   */\n  bool moveNext();\n\n  /**\n   * Returns the current element.\n   *\n   * Return [:null:] if the iterator has not yet been moved to the first\n   * element, or if the iterator has been moved after the last element of the\n   * [Iterable].\n   */\n  E get current;\n}\n","sdk/lib/core/list.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * A [List] is an indexable collection with a length.\n *\n * A `List` implementation can choose not to support all methods\n * of the `List` interface.\n *\n * The most common list types are:\n * * Fixed length list. It is an error to use operations that can change\n *   the list's length.\n * * Growable list. Full implementation of the interface.\n * * Unmodifiable list. It is an error to use operations that can change\n *   the list's length, or that can change the values of the list.\n *   If an unmodifable list is backed by another modifiable data structure,\n *   the values read from it may still change over time.\n *\n * Example:\n *\n *    var fixedLengthList = new List(5);\n *    fixedLengthList.length = 0;  // throws.\n *    fixedLengthList.add(499);  // throws\n *    fixedLengthList[0] = 87;\n *    var growableList = [1, 2];\n *    growableList.length = 0;\n *    growableList.add(499);\n *    growableList[0] = 87;\n *    var unmodifiableList = const [1, 2];\n *    unmodifiableList.length = 0;  // throws.\n *    unmodifiableList.add(499);  // throws\n *    unmodifiableList[0] = 87;  // throws.\n *\n * Lists are [Iterable].\n * List iteration iterates over values in index order.\n * Changing the values will not affect iteration,\n * but changing the valid indices -\n * that is, changing the list's length -\n * between iteration steps\n * will cause a [ConcurrentModificationError].\n * This means that only growable lists can throw [ConcurrentModificationError].\n * If the length changes temporarily\n * and is restored before continuing the iteration,\n * the iterator will not detect it.\n */\nabstract class List<E> implements Iterable<E> {\n  /**\n   * Creates a list of the given [length].\n   *\n   * The list is a fixed-length list if [length] is provided, and an empty\n   * growable list if [length] is omitted.\n   *\n   * It is an error if [length] is not a non-negative integer.\n   */\n  external factory List([int length]);\n\n  /**\n   * Creates a fixed-length list of the given [length] where each entry\n   * contains [fill].\n   */\n  external factory List.filled(int length, E fill);\n\n  /**\n   * Creates an list with the elements of [other].\n   *\n   * The order in the list will be\n   * the order provided by the iterator of [other].\n   *\n   * The returned list is growable if [growable] is true, otherwise it's\n   * a fixed length list.\n   */\n  factory List.from(Iterable other, { bool growable: true }) {\n    List<E> list = new List<E>();\n    for (E e in other) {\n      list.add(e);\n    }\n    if (growable) return list;\n    int length = list.length;\n    List<E> fixedList = new List<E>(length);\n    for (int i = 0; i < length; i++) {\n      fixedList[i] = list[i];\n    }\n    return fixedList;\n  }\n\n  /**\n   * Generate a `List` of values.\n   *\n   * Creates a list with [length] positions\n   * and fills them by values created by calling [generator]\n   * for each index in the range `0` .. `[length] - 1`\n   * in increasing order.\n   *\n   * The created length's length is fixed unless [growable] is true.\n   */\n  factory List.generate(int length, E generator(int index),\n                       { bool growable: true }) {\n    List<E> result;\n    if (growable) {\n      result = <E>[]..length = length;\n    } else {\n      result = new List<E>(length);\n    }\n    for (int i = 0; i < length; i++) {\n      result[i] = generator(i);\n    }\n    return result;\n  }\n\n  /**\n   * Returns the element at the given [index] in the list or throws\n   * an [RangeError] if [index] is out of bounds.\n   */\n  E operator [](int index);\n\n  /**\n   * Sets the entry at the given [index] in the list to [value].\n   * Throws an [RangeError] if [index] is out of bounds.\n   */\n  void operator []=(int index, E value);\n\n  /**\n   * Returns the number of elements in the list.\n   *\n   * The valid indices for a list are 0 through `length - 1`.\n   */\n  int get length;\n\n  /**\n   * Changes the length of the list. If [newLength] is greater than\n   * the current [length], entries are initialized to [:null:]. Throws\n   * an [UnsupportedError] if the list is not extendable.\n   */\n  void set length(int newLength);\n\n  /**\n   * Adds [value] at the end of the list, extending the length by\n   * one. Throws an [UnsupportedError] if the list is not\n   * extendable.\n   */\n  void add(E value);\n\n  /**\n   * Appends all elements of the [iterable] to the end of this list.\n   * Extends the length of the list by the number of elements in [iterable].\n   * Throws an [UnsupportedError] if this list is not extensible.\n   */\n  void addAll(Iterable<E> iterable);\n\n  /**\n   * Returns an [Iterable] of the elements of this [List] in reverse order.\n   */\n  Iterable<E> get reversed;\n\n  /**\n   * Sorts the list according to the order specified by the [compare] function.\n   *\n   * The [compare] function must act as a [Comparator].\n   * The default [List] implementations use [Comparable.compare] if\n   * [compare] is omitted.\n   */\n  void sort([int compare(E a, E b)]);\n\n  /**\n   * Returns the first index of [element] in the list.\n   *\n   * Searches the list from index [start] to the length of the list.\n   * The first time an element [:e:] is encountered so that [:e == element:],\n   * the index of [:e:] is returned.\n   * Returns -1 if [element] is not found.\n   */\n  int indexOf(E element, [int start = 0]);\n\n  /**\n   * Returns the last index of [element] in the list.\n   *\n   * Searches the list backwards from index [start] (inclusive) to 0.\n   * The first time an element [:e:] is encountered so that [:e == element:],\n   * the index of [:e:] is returned.\n   * If start is not provided, it defaults to [:this.length - 1:] .\n   * Returns -1 if [element] is not found.\n   */\n  int lastIndexOf(E element, [int start]);\n\n  /**\n   * Removes all elements in the list.\n   *\n   * The length of the list becomes zero.\n   * Throws an [UnsupportedError], and retains all elements, if the\n   * length of the list cannot be changed.\n   */\n  void clear();\n\n  /**\n   * Inserts the element at position [index] in the list.\n   *\n   * This increases the length of the list by one and shifts all elements\n   * at or after the index towards the end of the list.\n   *\n   * It is an error if the [index] does not point inside the list or at the\n   * position after the last element.\n   */\n  void insert(int index, E element);\n\n  /**\n   * Inserts all elements of [iterable] at position [index] in the list.\n   *\n   * This increases the length of the list by the length of [iterable] and\n   * shifts all later elements towards the end of the list.\n   *\n   * It is an error if the [index] does not point inside the list or at the\n   * position after the last element.\n   */\n  void insertAll(int index, Iterable<E> iterable);\n\n  /**\n   * Overwrites elements of `this` with the elemenst of [iterable] starting\n   * at position [index] in the list.\n   *\n   * This operation does not increase the length of the list.\n   *\n   * It is an error if the [index] does not point inside the list or at the\n   * position after the last element.\n   *\n   * It is an error if the [iterable] is longer than [length] - [index].\n   */\n  void setAll(int index, Iterable<E> iterable);\n\n  /**\n   * Removes [value] from the list. Returns true if [value] was\n   * in the list. Returns false otherwise. The method has no effect\n   * if [value] value was not in the list.\n   */\n  bool remove(Object value);\n\n  /**\n   * Removes the element at position [index] from the list.\n   *\n   * This reduces the length of the list by one and moves all later elements\n   * down by one position.\n   * Returns the removed element.\n   * Throws an [ArgumentError] if [index] is not an [int].\n   * Throws an [RangeError] if the [index] does not point inside\n   * the list.\n   * Throws an [UnsupportedError], and doesn't remove the element,\n   * if the length of the list cannot be changed.\n   */\n  E removeAt(int index);\n\n  /**\n   * Pops and returns the last element of the list.\n   * Throws a [UnsupportedError] if the length of the\n   * list cannot be changed.\n   */\n  E removeLast();\n\n  /**\n   * Removes all elements of this list that satisfy [test].\n   *\n   * An elements [:e:] satisfies [test] if [:test(e):] is true.\n   */\n  void removeWhere(bool test(E element));\n\n  /**\n   * Removes all elements of this list that fail to satisfy [test].\n   *\n   * An elements [:e:] satisfies [test] if [:test(e):] is true.\n   */\n  void retainWhere(bool test(E element));\n\n  /**\n   * Returns a new list containing the elements from [start] to [end].\n   *\n   * If [end] is omitted, the [length] of the list is used.\n   *\n   * It is an error if [start] or [end] are not list indices for this list,\n   * or if [end] is before [start].\n   */\n  List<E> sublist(int start, [int end]);\n\n  /**\n   * Returns an [Iterable] that iterators over the elements in the range\n   * [start] to [end] exclusive. The result of this function\n   * is backed by `this`.\n   *\n   * It is an error if [end] is before [start].\n   *\n   * It is an error if the [start] and [end] are not valid ranges at the time\n   * of the call to this method. The returned [Iterable] behaves similar to\n   * `skip(start).take(end - start)`. That is, it will not throw exceptions\n   * if `this` changes size.\n   *\n   * Example:\n   *\n   *     var list = [1, 2, 3, 4, 5];\n   *     var range = list.getRange(1, 4);\n   *     print(range.join(', '));  // => 2, 3, 4\n   *     list.length = 3;\n   *     print(range.join(', '));  // => 2, 3\n   */\n  Iterable<E> getRange(int start, int end);\n\n  /**\n   * Copies the elements of [iterable], skipping the [skipCount] first elements\n   * into the range [start] to [end] exclusive of `this`.\n   *\n   * If [start] equals [end] and represent a legal range, this method has\n   * no effect.\n   *\n   * It is an error if [start]..[end] is not a valid range pointing into the\n   * `this`.\n   *\n   * It is an error if the [iterable] does not have enough elements after\n   * skipping [skipCount] elements.\n   */\n  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]);\n\n  /**\n   * Removes the elements in the range [start] to [end] exclusive.\n   *\n   * It is an error if [start]..[end] is not a valid range pointing into the\n   * `this`.\n   */\n  void removeRange(int start, int end);\n\n  /**\n   * Sets the elements in the range [start] to [end] exclusive to the given\n   * [fillValue].\n   *\n   * It is an error if [start]..[end] is not a valid range pointing into the\n   * `this`.\n   */\n  void fillRange(int start, int end, [E fillValue]);\n\n  /**\n   * Removes the elements in the range [start] to [end] exclusive and replaces\n   * them with the contents of the [iterable].\n   *\n   * It is an error if [start]..[end] is not a valid range pointing into the\n   * `this`.\n   *\n   * Example:\n   *\n   *     var list = [1, 2, 3, 4, 5];\n   *     list.replaceRange(1, 3, [6, 7, 8, 9]);\n   *     print(list);  // [1, 6, 7, 8, 9, 4, 5]\n   */\n  void replaceRange(int start, int end, Iterable<E> iterable);\n\n  /**\n   * Returns an unmodifiable [Map] view of `this`.\n   *\n   * It has the indices of this list as keys, and the corresponding elements\n   * as values.\n   */\n  Map<int, E> asMap();\n}\n","sdk/lib/core/map.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * A [Map] is an associative container, mapping a key to a value.\n * Null values are supported, but null keys are not.\n */\nabstract class Map<K, V> {\n  /**\n   * Creates a map with the default implementation.\n   */\n  factory Map() => new HashMap<K, V>();\n\n  /**\n   * Creates a [Map] that contains all key value pairs of [other].\n   */\n  factory Map.from(Map<K, V> other) => new HashMap<K, V>.from(other);\n\n\n  /**\n   * Returns whether this map contains the given [value].\n   */\n  bool containsValue(V value);\n\n  /**\n   * Returns whether this map contains the given [key].\n   */\n  bool containsKey(K key);\n\n  /**\n   * Returns the value for the given [key] or null if [key] is not\n   * in the map. Because null values are supported, one should either\n   * use containsKey to distinguish between an absent key and a null\n   * value, or use the [putIfAbsent] method.\n   */\n  V operator [](K key);\n\n  /**\n   * Associates the [key] with the given [value].\n   */\n  void operator []=(K key, V value);\n\n  /**\n   * If [key] is not associated to a value, calls [ifAbsent] and\n   * updates the map by mapping [key] to the value returned by\n   * [ifAbsent]. Returns the value in the map.\n   *\n   * It is an error to add or remove keys from map during the call to\n   * [ifAbsent].\n   */\n  V putIfAbsent(K key, V ifAbsent());\n\n  /**\n   * Removes the association for the given [key]. Returns the value for\n   * [key] in the map or null if [key] is not in the map. Note that values\n   * can be null and a returned null value does not always imply that the\n   * key is absent.\n   */\n  V remove(K key);\n\n  /**\n   * Removes all pairs from the map.\n   */\n  void clear();\n\n  /**\n   * Applies [f] to each {key, value} pair of the map.\n   *\n   * It is an error to add or remove keys from the map during iteration.\n   */\n  void forEach(void f(K key, V value));\n\n  /**\n   * The keys of [this].\n   */\n  // TODO(floitsch): this should return a [Set].\n  Iterable<K> get keys;\n\n  /**\n   * The values of [this].\n   */\n  Iterable<V> get values;\n\n  /**\n   * The number of {key, value} pairs in the map.\n   */\n  int get length;\n\n  /**\n   * Returns true if there is no {key, value} pair in the map.\n   */\n  bool get isEmpty;\n}\n","sdk/lib/core/num.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * All numbers in dart are instances of [num].\n */\nabstract class num implements Comparable<num> {\n  /** Addition operator. */\n  num operator +(num other);\n\n  /** Subtraction operator. */\n  num operator -(num other);\n\n  /** Multiplication operator. */\n  num operator *(num other);\n\n  /**\n   * Euclidean modulo operator.\n   *\n   * Returns the remainder of the euclidean division. The euclidean division of\n   * two integers `a` and `b` yields two integers `q` and `r` such that\n   * `a = b*q + r` and `0 <= r < |a|`.\n   *\n   * The euclidean division is only defined for integers, but can be easily\n   * extended to work with doubles. In that case `r` may have a non-integer\n   * value, but it still verifies `0 <= r < |a|`.\n   *\n   * The sign of the returned value `r` is always positive.\n   *\n   * See [remainder] for the remainder of the truncating division.\n   */\n  num operator %(num other);\n\n  /** Division operator. */\n  double operator /(num other);\n\n  /**\n   * Truncating division operator.\n   *\n   * If either operand is a [double] then the result of the truncating division\n   * [:a ~/ b:] is equivalent to [:(a / b).truncate().toInt():].\n   *\n   * If both operands are [int]s then [:a ~/ b:] performs the truncating\n   * integer division.\n   */\n  int operator ~/(num other);\n\n  /** Negate operator. */\n  num operator -();\n\n  /**\n   * Return the remainder of the truncating division of `this` by [other].\n   *\n   * The result `r` of this operation satisfies: `this = this ~/ other + r`.\n   * As a consequence the remainder `r` has the same sign as the dividend\n   * `this`.\n   */\n  num remainder(num other);\n\n  /** Relational less than operator. */\n  bool operator <(num other);\n\n  /** Relational less than or equal operator. */\n  bool operator <=(num other);\n\n  /** Relational greater than operator. */\n  bool operator >(num other);\n\n  /** Relational greater than or equal operator. */\n  bool operator >=(num other);\n\n  bool get isNaN;\n\n  bool get isNegative;\n\n  bool get isInfinite;\n\n  /** Returns the absolute value of this [num]. */\n  num abs();\n\n  /**\n   * Returns the integer closest to `this`.\n   *\n   * Rounds away from zero when there is no closest integer:\n   *  [:(3.5).round() == 4:] and [:(-3.5).round() == -4:].\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int round();\n\n  /**\n   * Returns the greatest integer no greater than `this`.\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int floor();\n\n  /**\n   * Returns the least integer no smaller than `this`.\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int ceil();\n\n  /**\n   * Returns the integer obtained by discarding any fractional\n   * digits from `this`.\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int truncate();\n\n  /**\n   * Returns the integer value closest to `this`.\n   *\n   * Rounds away from zero when there is no closest integer:\n   *  [:(3.5).round() == 4:] and [:(-3.5).round() == -4:].\n   *\n   * The result is a double.\n   */\n  double roundToDouble();\n\n  /**\n   * Returns the greatest integer value no greater than `this`.\n   *\n   * The result is a double.\n   */\n  double floorToDouble();\n\n  /**\n   * Returns the least integer value no smaller than `this`.\n   *\n   * The result is a double.\n   */\n  double ceilToDouble();\n\n  /**\n   * Returns the integer obtained by discarding any fractional\n   * digits from `this`.\n   *\n   * The result is a double.\n   */\n  double truncateToDouble();\n\n  /**\n   * Clamps [this] to be in the range [lowerLimit]-[upperLimit]. The comparison\n   * is done using [compareTo] and therefore takes [:-0.0:] into account.\n   * It also implies that [double.NAN] is treated as the maximal double value.\n   */\n  num clamp(num lowerLimit, num upperLimit);\n\n  /** Truncates this [num] to an integer and returns the result as an [int]. */\n  int toInt();\n\n  /**\n   * Return this [num] as a [double].\n   *\n   * If the number is not representable as a [double], an\n   * approximation is returned. For numerically large integers, the\n   * approximation may be infinite.\n   */\n  double toDouble();\n\n  /**\n   * Converts [this] to a string representation with [fractionDigits] digits\n   * after the decimal point.\n   *\n   * The parameter [fractionDigits] must be an integer satisfying:\n   * [:0 <= fractionDigits <= 20:].\n   */\n  String toStringAsFixed(int fractionDigits);\n\n  /**\n   * Converts [this] to a string in decimal exponential notation with\n   * [fractionDigits] digits after the decimal point.\n   *\n   * If [fractionDigits] is given then it must be an integer satisfying:\n   * [:0 <= fractionDigits <= 20:]. Without the parameter the returned string\n   * uses the shortest number of digits that accurately represent [this].\n   */\n  String toStringAsExponential([int fractionDigits]);\n\n  /**\n   * Converts [this] to a string representation with [precision] significant\n   * digits.\n   *\n   * The parameter [precision] must be an integer satisfying:\n   * [:1 <= precision <= 21:].\n   */\n  String toStringAsPrecision(int precision);\n\n\n}\n","sdk/lib/core/object.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * Everything in Dart is an [Object].\n */\nclass Object {\n  /**\n   * Creates a new [Object] instance.\n   *\n   * [Object] instances have no meaningful state, and are only useful\n   * through their identity. An [Object] instance is equal to itself\n   * only.\n   */\n  const Object();\n\n  /**\n   * The equality operator.\n   *\n   * The default behavior for all [Object]s is to return true if and\n   * only if [:this:] and [other] are the same object.\n   *\n   * If a subclass overrides the equality operator it should override\n   * the [hashCode] method as well to maintain consistency.\n   */\n  bool operator ==(other) => identical(this, other);\n\n  /**\n   * Get a hash code for this object.\n   *\n   * All objects have hash codes. Hash codes are guaranteed to be the\n   * same for objects that are equal when compared using the equality\n   * operator [:==:]. Other than that there are no guarantees about\n   * the hash codes. They will not be consistent between runs and\n   * there are no distribution guarantees.\n   *\n   * If a subclass overrides [hashCode] it should override the\n   * equality operator as well to maintain consistency.\n   */\n  external int get hashCode;\n\n  /**\n   * Returns a string representation of this object.\n   */\n  external String toString();\n\n  /**\n   * [noSuchMethod] is invoked when users invoke a non-existant method\n   * on an object. The name of the method and the arguments of the\n   * invocation are passed to [noSuchMethod] in an [Invocation].\n   * If [noSuchMethod] returns a value, that value becomes the result of\n   * the original invocation.\n   *\n   * The default behavior of [noSuchMethod] is to throw a\n   * [noSuchMethodError].\n   */\n  external dynamic noSuchMethod(Invocation invocation);\n\n  /**\n   * A representation of the runtime type of the object.\n   */\n  external Type get runtimeType;\n}\n\n","sdk/lib/core/pattern.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\nabstract class Pattern {\n  Iterable<Match> allMatches(String str);\n}\n","sdk/lib/core/print.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\nexternal void print(Object object);\n","sdk/lib/core/regexp.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * [Match] contains methods to manipulate a regular expression match.\n *\n * Iterables of [Match] objects are returned from [RegExp] matching methods.\n *\n * The following example finds all matches of a [RegExp] in a [String]\n * and iterates through the returned iterable of [Match] objects.\n *\n *     RegExp exp = new RegExp(r\"(\\w+)\");\n *     String str = \"Parse my string\";\n *     Iterable<Match> matches = exp.allMatches(str);\n *     for (Match m in matches) {\n *       String match = m.group(0);\n *       print(match);\n *     };\n *\n * The output of the example is:\n *\n *     Parse\n *     my\n *     string\n */\nabstract class Match {\n  /**\n   * Returns the index in the string where the match starts.\n   */\n  int get start;\n\n  /**\n   * Returns the index in the string after the last character of the\n   * match.\n   */\n  int get end;\n\n  /**\n   * Returns the string matched by the given [group]. If [group] is 0,\n   * returns the match of the regular expression.\n   */\n  String group(int group);\n  String operator [](int group);\n\n  /**\n   * Returns the strings matched by [groups]. The order in the\n   * returned string follows the order in [groups].\n   */\n  List<String> groups(List<int> groups);\n\n  /**\n   * Returns the number of groups in the regular expression.\n   */\n  int get groupCount;\n\n  /**\n   * The string on which this matcher was computed.\n   */\n  String get str;\n\n  /**\n   * The pattern used to search in [str].\n   */\n  Pattern get pattern;\n}\n\n\n/**\n * [RegExp] represents regular expressions.\n *\n * Dart regular expressions have the same syntax and semantics as\n * JavaScript regular expressions. See\n * <http://ecma-international.org/ecma-262/5.1/#sec-15.10>\n * for the specification of JavaScript regular expressions.\n *\n * [firstMatch] is the main implementation method that applies a regular\n * expression to a string and returns the first [Match]. All\n * other methods in [RegExp] can build on it.\n *\n * Use [allMatches] to look for all matches of a regular expression in\n * a string.\n *\n * The following example finds all matches of a regular expression in\n * a string.\n *\n *     RegExp exp = new RegExp(r\"(\\w+)\");\n *     String str = \"Parse my string\";\n *     Iterable<Match> matches = exp.allMatches(str);\n */\nabstract class RegExp implements Pattern {\n  /**\n   * Constructs a regular expression. The default implementation of a\n   * [RegExp] sets [multiLine] to false and [caseSensitive] to true.\n   * Throws a [FormatException] if [pattern] is not a valid regular\n   * exression pattern.\n   */\n  external factory RegExp(String pattern, {bool multiLine: false,\n                                           bool caseSensitive: true});\n\n  /**\n   * Searches for the first match of the regular expression\n   * in the string [str]. Returns `null` if there is no match.\n   */\n  Match firstMatch(String str);\n\n  /**\n   * Returns an iterable on the  matches of the regular\n   * expression in [str].\n   */\n  Iterable<Match> allMatches(String str);\n\n  /**\n   * Returns whether the regular expression has a match in the string [str].\n   */\n  bool hasMatch(String str);\n\n  /**\n   * Searches for the first match of the regular expression\n   * in the string [str] and returns the matched string.\n   */\n  String stringMatch(String str);\n\n  /**\n   * The pattern of this regular expression.\n   */\n  String get pattern;\n\n  /**\n   * Whether this regular expression matches multiple lines.\n   */\n  bool get isMultiLine;\n\n  /**\n   * Whether this regular expression is case insensitive.\n   */\n  bool get isCaseSensitive;\n}\n","sdk/lib/core/set.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * This class is the public interface of a set. A set is a collection\n * without duplicates.\n */\nabstract class Set<E> extends IterableBase<E> {\n  factory Set() => new HashSet<E>();\n\n  /**\n   * Creates a [Set] that contains all elements of [other].\n   */\n  factory Set.from(Iterable<E> other) => new HashSet<E>.from(other);\n\n  /**\n   * Returns true if [value] is in the set.\n   */\n  bool contains(E value);\n\n  /**\n   * Adds [value] into the set. The method has no effect if\n   * [value] was already in the set.\n   */\n  void add(E value);\n\n  /**\n   * Adds all of [elements] to this Set.\n   *\n   * Equivalent to adding each element in [elements] using [add],\n   * but some collections may be able to optimize it.\n   */\n  void addAll(Iterable<E> elements);\n\n  /**\n   * Removes [value] from the set. Returns true if [value] was\n   * in the set. Returns false otherwise. The method has no effect\n   * if [value] value was not in the set.\n   */\n  bool remove(Object value);\n\n  /**\n   * Removes all of [elements] from this set.\n   */\n  void removeAll(Iterable elements);\n\n  /**\n   * Removes all elements of this set that are not\n   * in [elements].\n   */\n  void retainAll(Iterable elements);\n\n  /**\n   * Removes all elements of this set that satisfy [test].\n   */\n  void removeWhere(bool test(E element));\n\n  /**\n   * Removes all elements of this set that fail to satisfy [test].\n   */\n  void retainWhere(bool test(E element));\n\n  /**\n   * Returns true if this Set contains all the elements of [other].\n   */\n  bool containsAll(Iterable<E> other);\n\n  /**\n   * Returns a new set which is the intersection between this set and [other].\n   */\n  Set<E> intersection(Set<E> other);\n\n  /**\n   * Returns a new set which contains all the elements of this set and [other].\n   */\n  Set<E> union(Set<E> other);\n\n  /**\n   * Returns a new set with the the elements of this that are not in [other].\n   */\n  Set<E> difference(Set<E> other);\n\n  /**\n   * Removes all elements in the set.\n   */\n  void clear();\n}\n","sdk/lib/core/stacktrace.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * An interface implemented by all stack trace objects.\n *\n * A [StackTrace] is intended to convey information to the user about the call\n * sequence that triggered an exception.\n *\n * These objects are created by the runtime, it is not possible to create\n * them programmatically.\n */\nabstract class StackTrace {\n  /**\n   * Returns a [String] representation of the stack trace.\n   *\n   * The string represents the full stack trace starting from\n   * the point where a throw ocurred to the top of the current call sequence.\n   *\n   * The exact format of the string representation is not final.\n   */\n  String toString();\n}\n\n","sdk/lib/core/stopwatch.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * A simple [Stopwatch] interface to measure elapsed time.\n */\nclass Stopwatch {\n  // The _start and _stop fields capture the time when [start] and [stop]\n  // are called respectively.\n  // If _start is null, then the [Stopwatch] has not been started yet.\n  // If _stop is null, then the [Stopwatch] has not been stopped yet,\n  // or is running.\n  int _start;\n  int _stop;\n\n  /**\n   * Creates a [Stopwatch] in stopped state with a zero elapsed count.\n   *\n   * The following example shows how to start a [Stopwatch]\n   * immediately after allocation.\n   *\n   *     Stopwatch stopwatch = new Stopwatch()..start();\n   */\n  Stopwatch() : _start = null, _stop = null {}\n\n  /**\n   * Starts the [Stopwatch].\n   *\n   * The [elapsed] count is increasing monotonically. If the [Stopwatch] has\n   * been stopped, then calling start again restarts it without resetting the\n   * [elapsed] count.\n   *\n   * If the [Stopwatch] is currently running, then calling start does nothing.\n   */\n  void start() {\n    if (isRunning) return;\n    if (_start == null) {\n      // This stopwatch has never been started.\n      _start = _now();\n    } else {\n      // Restart this stopwatch. Prepend the elapsed time to the current\n      // start time.\n      _start = _now() - (_stop - _start);\n      _stop = null;\n    }\n  }\n\n  /**\n   * Stops the [Stopwatch].\n   *\n   * The [elapsedTicks] count stops increasing after this call. If the\n   * [Stopwatch] is currently not running, then calling this method has no\n   * effect.\n   */\n  void stop() {\n    if (!isRunning) return;\n    _stop = _now();\n  }\n\n  /**\n   * Resets the [elapsed] count to zero.\n   *\n   * This method does not stop or start the [Stopwatch].\n   */\n  void reset() {\n    if (_start == null) return;\n    // If [_start] is not null, then the stopwatch had already been started. It\n    // may running right now.\n    _start = _now();\n    if (_stop != null) {\n      // The watch is not running. So simply set the [_stop] to [_start] thus\n      // having an elapsed time of 0.\n      _stop = _start;\n    }\n  }\n\n  /**\n   * Returns the elapsed number of clock ticks since calling [start] while the\n   * [Stopwatch] is running.\n   *\n   * Returns the elapsed number of clock ticks between calling [start] and\n   * calling [stop].\n   *\n   * Returns 0 if the [Stopwatch] has never been started.\n   *\n   * The elapsed number of clock ticks increases by [frequency] every second.\n   */\n  int get elapsedTicks {\n    if (_start == null) {\n      return 0;\n    }\n    return (_stop == null) ? (_now() - _start) : (_stop - _start);\n  }\n\n  /**\n   * Returns the [elapsedTicks] counter converted to a [Duration].\n   */\n  Duration get elapsed {\n    return new Duration(microseconds: elapsedMicroseconds);\n  }\n\n  /**\n   * Returns the [elapsedTicks] counter converted to microseconds.\n   */\n  int get elapsedMicroseconds {\n    return (elapsedTicks * 1000000) ~/ frequency;\n  }\n\n  /**\n   * Returns the [elapsedTicks] counter converted to milliseconds.\n   */\n  int get elapsedMilliseconds {\n    return (elapsedTicks * 1000) ~/ frequency;\n  }\n\n  /**\n   * Returns the frequency of the elapsed counter in Hz.\n   */\n  int get frequency => _frequency();\n\n  /**\n   * Returns wether the [StopWatch] is currently running.\n   */\n  bool get isRunning => _start != null && _stop == null;\n\n  external static int _frequency();\n  external static int _now();\n}\n","sdk/lib/core/string.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * The String class represents sequences of characters. Strings are\n * immutable. A string is represented by a sequence of Unicode UTF-16\n * code units accessible through the [codeUnitAt] or the\n * [codeUnits] members. Their string representation is accessible through\n * the index-operator.\n *\n * The characters of a string are encoded in UTF-16. Decoding UTF-16, which\n * combines surrogate pairs, yields Unicode code points. Following a similar\n * terminology to Go we use the name \"rune\" for an integer representing a\n * Unicode code point. The runes of a string are accessible through the [runes]\n * getter.\n */\nabstract class String implements Comparable<String>, Pattern {\n  /**\n   * Allocates a new String for the specified [charCodes].\n   *\n   * The [charCodes] can be UTF-16 code units or runes. If a char-code value is\n   * 16-bit it is copied verbatim. If it is greater than 16 bits it is\n   * decomposed into a surrogate pair.\n   */\n  external factory String.fromCharCodes(Iterable<int> charCodes);\n\n  /**\n   * Allocates a new String for the specified [charCode].\n   *\n   * The new string contains a single code unit if the [charCode] can be\n   * represented by a single UTF-16 code unit. Otherwise the [length] is 2 and\n   * the code units form a surrogate pair.\n   *\n   * It is allowed (though generally discouraged) to create a String with only\n   * one half of a surrogate pair.\n   */\n  factory String.fromCharCode(int charCode) {\n    List<int> charCodes = new List<int>.filled(1, charCode);\n    return new String.fromCharCodes(charCodes);\n  }\n\n  /**\n   * Gets the character (as a single-code-unit [String]) at the given [index].\n   *\n   * The returned string represents exactly one UTF-16 code unit which may be\n   * half of a surrogate pair. For example the Unicode character for a\n   * musical G-clef (\"\") with rune value 0x1D11E consists of a UTF-16 surrogate\n   * pair: `0xD834` and `0xDD1E`. Using the index-operator on this string yields\n   * a String with half of a surrogate pair:\n   *\n   *     var clef = \"\\u{1D11E}\";\n   *     clef.length;  // => 2\n   *     clef.runes.first == 0x1D11E;  // => true\n   *     clef.runes.length;  // => 1\n   *     clef.codeUnitAt(0);  // => 0xD834\n   *     clef.codeUnitAt(1);  // => 0xDD1E\n   *     // The following strings are halves of a UTF-16 surrogate pair and\n   *     // thus invalid UTF-16 strings:\n   *     clef[0];  // => a string of length 1 with code-unit value 0xD834.\n   *     clef[1];  // => a string of length 1 with code-unit value 0xDD1E.\n   *\n   * This method is equivalent to\n   * `new String.fromCharCode(this.codeUnitAt(index))`.\n   */\n  String operator [](int index);\n\n  /**\n   * Returns the 16-bit UTF-16 code unit at the given [index].\n   */\n  int codeUnitAt(int index);\n\n  /**\n   * The length of the string.\n   *\n   * Returns the number of UTF-16 code units in this string. The number\n   * of [runes] might be less, if the string contains characters outside\n   * the basic multilingual plane (plane 0).\n   */\n  int get length;\n\n  /**\n   * Returns whether the two strings are equal.\n   *\n   * This method compares each individual code unit of the strings.\n   * Equivalently (for strings that are well-formed UTF-16) it compares each\n   * individual rune (code point).  It does not check for Unicode equivalence.\n   * For example the two following strings both represent the string \"Amlie\"\n   * but, due to their different encoding will not return equal.\n   *\n   *     \"Am\\xe9lie\"\n   *     \"Ame\\u{301}lie\"\n   *\n   * In the first string the \"\" is encoded as a single unicode code unit (also\n   * a single rune), whereas the second string encodes it as \"e\" with the\n   * combining accent character \"\".\n   */\n  bool operator ==(var other);\n\n  /**\n   * Returns whether this string ends with [other].\n   */\n  bool endsWith(String other);\n\n  /**\n   * Returns whether this string starts with [other].\n   */\n  bool startsWith(String other);\n\n  /**\n   * Returns the first location of [other] in this string starting at\n   * [start] (inclusive).\n   * Returns -1 if [other] could not be found.\n   */\n  int indexOf(String other, [int start]);\n\n  /**\n   * Returns the last location of [other] in this string, searching\n   * backward starting at [start] (inclusive).\n   * Returns -1 if [other] could not be found.\n   */\n  int lastIndexOf(String other, [int start]);\n\n  /**\n   * Returns whether this string is empty.\n   */\n  bool get isEmpty;\n\n  /**\n   * Creates a new string by concatenating this string with [other].\n   *\n   * A sequence of strings can be concatenated by using [Iterable.join]:\n   *\n   *     var strings = ['foo', 'bar', 'geez'];\n   *     var concatenated = strings.join();\n   */\n  String operator +(String other);\n\n  /**\n   * Returns a substring of this string in the given range.\n   * [startIndex] is inclusive and [endIndex] is exclusive.\n   */\n  String substring(int startIndex, [int endIndex]);\n\n  /**\n   * Removes leading and trailing whitespace from a string. If the string\n   * contains leading or trailing whitespace a new string with no leading and\n   * no trailing whitespace is returned. Otherwise, the string itself is\n   * returned.  Whitespace is defined as every Unicode character in the Zs, Zl\n   * and Zp categories (this includes no-break space), the spacing control\n   * characters from 9 to 13 (tab, lf, vtab, ff and cr), and 0xfeff the BOM\n   * character.\n   */\n  String trim();\n\n  /**\n   * Returns whether this string contains [other] starting\n   * at [startIndex] (inclusive).\n   */\n  bool contains(Pattern other, [int startIndex]);\n\n  /**\n   * Returns a new string where the first occurence of [from] in this string\n   * is replaced with [to].\n   */\n  String replaceFirst(Pattern from, String to);\n\n  /**\n   * Returns a new string where all occurences of [from] in this string\n   * are replaced with [replace].\n   */\n  String replaceAll(Pattern from, var replace);\n\n  /**\n   * Returns a new string where all occurences of [from] in this string\n   * are replaced with a [String] depending on [replace].\n   *\n   *\n   * The [replace] function is called with the [Match] generated\n   * by the pattern, and its result is used as replacement.\n   */\n  String replaceAllMapped(Pattern from, String replace(Match match));\n\n  /**\n   * Splits the string around matches of [pattern]. Returns\n   * a list of substrings.\n   *\n   * Splitting with an empty string pattern (`\"\"`) splits at UTF-16 code unit\n   * boundaries and not at rune boundaries. The following two expressions\n   * are hence equivalent:\n   *\n   *     string.split(\"\")\n   *     string.codeUnits.map((unit) => new String.fromCharCode(unit))\n   *\n   * Unless it guaranteed that the string is in the basic multilingual plane\n   * (meaning that each code unit represents a rune) it is often better to\n   * map the runes instead:\n   *\n   *     string.runes.map((rune) => new String.fromCharCode(rune))\n   */\n  List<String> split(Pattern pattern);\n\n  /**\n   * Splits the string on the [pattern], then converts each part and each match.\n   *\n   * The pattern is used to split the string into parts and separating matches.\n   *\n   * Each match is converted to a string by calling [onMatch]. If [onMatch]\n   * is omitted, the matched string is used.\n   *\n   * Each non-matched part is converted by a call to [onNonMatch]. If\n   * [onNonMatch] is omitted, the non-matching part is used.\n   *\n   * Then all the converted parts are combined into the resulting string.\n   */\n  String splitMapJoin(Pattern pattern,\n                      {String onMatch(Match match),\n                       String onNonMatch(String nonMatch)});\n\n  /**\n   * Returns an unmodifiable list of the UTF-16 code units of this string.\n   */\n  List<int> get codeUnits;\n\n  /**\n   * Returns an iterable of Unicode code-points of this string.\n   *\n   * If the string contains surrogate pairs, they will be combined and returned\n   * as one integer by this iterator. Unmatched surrogate halves are treated\n   * like valid 16-bit code-units.\n   */\n  Runes get runes;\n\n  /**\n   * If this string is not already all lower case, returns a new string\n   * where all characters are made lower case. Returns [:this:] otherwise.\n   */\n  // TODO(floitsch): document better. (See EcmaScript for description).\n  String toLowerCase();\n\n  /**\n   * If this string is not already all upper case, returns a new string\n   * where all characters are made upper case. Returns [:this:] otherwise.\n   */\n  // TODO(floitsch): document better. (See EcmaScript for description).\n  String toUpperCase();\n}\n\n/**\n * The runes (integer Unicode code points) of a [String].\n */\nclass Runes extends IterableBase<int> {\n  final String string;\n  Runes(this.string);\n\n  RuneIterator get iterator => new RuneIterator(string);\n\n  int get last {\n    if (string.length == 0) {\n      throw new StateError(\"No elements.\");\n    }\n    int length = string.length;\n    int code = string.codeUnitAt(length - 1);\n    if (_isTrailSurrogate(code) && string.length > 1) {\n      int previousCode = string.codeUnitAt(length - 2);\n      if (_isLeadSurrogate(previousCode)) {\n        return _combineSurrogatePair(previousCode, code);\n      }\n    }\n    return code;\n  }\n\n}\n\n// Is then code (a 16-bit unsigned integer) a UTF-16 lead surrogate.\nbool _isLeadSurrogate(int code) => (code & 0xFC00) == 0xD800;\n\n// Is then code (a 16-bit unsigned integer) a UTF-16 trail surrogate.\nbool _isTrailSurrogate(int code) => (code & 0xFC00) == 0xDC00;\n\n// Combine a lead and a trail surrogate value into a single code point.\nint _combineSurrogatePair(int start, int end) {\n  return 0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF);\n}\n\n/** [Iterator] for reading runes (integer Unicode code points) out of a Dart\n  * string.\n  */\nclass RuneIterator implements BidirectionalIterator<int> {\n  /** String being iterated. */\n  final String string;\n  /** Position before the current code point. */\n  int _position;\n  /** Position after the current code point. */\n  int _nextPosition;\n  /**\n   * Current code point.\n   *\n   * If the iterator has hit either end, the [_currentCodePoint] is null\n   * and [: _position == _nextPosition :].\n   */\n  int _currentCodePoint;\n\n  /** Create an iterator positioned at the beginning of the string. */\n  RuneIterator(String string)\n      : this.string = string, _position = 0, _nextPosition = 0;\n\n  /**\n   * Create an iterator positioned before the [index]th code unit of the string.\n   *\n   * When created, there is no [current] value.\n   * A [moveNext] will use the rune starting at [index] the current value,\n   * and a [movePrevious] will use the rune ending just before [index] as the\n   * the current value.\n   *\n   * It is an error if the [index] position is in the middle of a surrogate\n   * pair.\n   */\n  RuneIterator.at(String string, int index)\n      : string = string, _position = index, _nextPosition = index {\n    if (index < 0 || index > string.length) {\n      throw new RangeError.range(index, 0, string.length);\n    }\n    _checkSplitSurrogate(index);\n  }\n\n  /** Throw an error if the index is in the middle of a surrogate pair. */\n  void _checkSplitSurrogate(int index) {\n    if (index > 0 && index < string.length &&\n        _isLeadSurrogate(string.codeUnitAt(index - 1)) &&\n        _isTrailSurrogate(string.codeUnitAt(index))) {\n      throw new ArgumentError(\"Index inside surrogate pair: $index\");\n    }\n  }\n\n  /**\n   * Returns the starting position of the current rune in the string.\n   *\n   * Returns null if the [current] rune is null.\n   */\n  int get rawIndex => (_position != _nextPosition) ? _position : null;\n\n  /**\n   * Resets the iterator to the rune at the specified index of the string.\n   *\n   * Setting a negative [rawIndex], or one greater than or equal to\n   * [:string.length:],\n   * is an error. So is setting it in the middle of a surrogate pair.\n   *\n   * Setting the position to the end of then string will set [current] to null.\n   */\n  void set rawIndex(int rawIndex) {\n    if (rawIndex >= string.length) {\n      throw new RangeError.range(rawIndex, 0, string.length - 1);\n    }\n    reset(rawIndex);\n    moveNext();\n  }\n\n  /**\n   * Resets the iterator to the given index into the string.\n   *\n   * After this the [current] value is unset.\n   * You must call [moveNext] make the rune at the position current,\n   * or [movePrevious] for the last rune before the position.\n   *\n   * Setting a negative [rawIndex], or one greater than [:string.length:],\n   * is an error. So is setting it in the middle of a surrogate pair.\n   */\n  void reset([int rawIndex = 0]) {\n    if (rawIndex < 0 || rawIndex > string.length) {\n      throw new RangeError.range(rawIndex, 0, string.length);\n    }\n    _checkSplitSurrogate(rawIndex);\n    _position = _nextPosition = rawIndex;\n    _currentCodePoint = null;\n  }\n\n  /** The rune (integer Unicode code point) starting at the current position in\n   *  the string.\n   */\n  int get current => _currentCodePoint;\n\n  /**\n   * The number of code units comprising the current rune.\n   *\n   * Returns zero if there is no current rune ([current] is null).\n   */\n  int get currentSize => _nextPosition - _position;\n\n  /**\n   * A string containing the current rune.\n   *\n   * For runes outside the basic multilingual plane, this will be\n   * a String of length 2, containing two code units.\n   *\n   * Returns null if [current] is null.\n   */\n  String get currentAsString {\n    if (_position == _nextPosition) return null;\n    if (_position + 1 == _nextPosition) return string[_position];\n    return string.substring(_position, _nextPosition);\n  }\n\n  bool moveNext() {\n    _position = _nextPosition;\n    if (_position == string.length) {\n      _currentCodePoint = null;\n      return false;\n    }\n    int codeUnit = string.codeUnitAt(_position);\n    int nextPosition = _position + 1;\n    if (_isLeadSurrogate(codeUnit) && nextPosition < string.length) {\n      int nextCodeUnit = string.codeUnitAt(nextPosition);\n      if (_isTrailSurrogate(nextCodeUnit)) {\n        _nextPosition = nextPosition + 1;\n        _currentCodePoint = _combineSurrogatePair(codeUnit, nextCodeUnit);\n        return true;\n      }\n    }\n    _nextPosition = nextPosition;\n    _currentCodePoint = codeUnit;\n    return true;\n  }\n\n  bool movePrevious() {\n    _nextPosition = _position;\n    if (_position == 0) {\n      _currentCodePoint = null;\n      return false;\n    }\n    int position = _position - 1;\n    int codeUnit = string.codeUnitAt(position);\n    if (_isTrailSurrogate(codeUnit) && position > 0) {\n      int prevCodeUnit = string.codeUnitAt(position - 1);\n      if (_isLeadSurrogate(prevCodeUnit)) {\n        _position = position - 1;\n        _currentCodePoint = _combineSurrogatePair(prevCodeUnit, codeUnit);\n        return true;\n      }\n    }\n    _position = position;\n    _currentCodePoint = codeUnit;\n    return true;\n  }\n}\n","sdk/lib/core/string_buffer.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * The StringBuffer class is useful for concatenating strings\n * efficiently. Only on a call to [toString] are the strings\n * concatenated to a single String.\n */\nclass StringBuffer implements StringSink {\n\n  /** Creates the string buffer with an initial content. */\n  external StringBuffer([Object content = \"\"]);\n\n  /**\n   * Returns the length of the content that has been accumulated so far.\n   * This is a constant-time operation.\n   */\n  external int get length;\n\n  /** Returns whether the buffer is empty. This is a constant-time operation. */\n  bool get isEmpty => length == 0;\n\n  /// Adds the contents of [obj], converted to a string, to the buffer.\n  external void write(Object obj);\n\n  /// Adds the string representation of [charCode] to the buffer.\n  external void writeCharCode(int charCode);\n\n  void writeAll(Iterable objects, [String separator = \"\"]) {\n    Iterator iterator = objects.iterator;\n    if (!iterator.moveNext()) return;\n    if (separator.isEmpty) {\n      do {\n        write(iterator.current);\n      } while (iterator.moveNext());\n    } else {\n      write(iterator.current);\n      while (iterator.moveNext()) {\n        write(separator);\n        write(iterator.current);\n      }\n    }\n  }\n\n  void writeln([Object obj = \"\"]) {\n    write(obj);\n    write(\"\\n\");\n  }\n\n  /**\n   * Clears the string buffer.\n   */\n  external void clear();\n\n  /// Returns the contents of buffer as a concatenated string.\n  external String toString();\n}\n","sdk/lib/core/string_sink.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\nabstract class StringSink {\n\n  /**\n   * Converts [obj] to a String by invoking `toString` and adds the result to\n   * `this`.\n   */\n  void write(Object obj);\n\n  /**\n   * Iterates over the given [objects] and [write]s them in sequence.\n   */\n  void writeAll(Iterable objects, [String separator = \"\"]);\n\n  /**\n   * Converts [obj] to a String by invoking `toString` and adds the result to\n   * `this`. Then adds a new line.\n   */\n  void writeln([Object obj = \"\"]);\n\n  /**\n   * Writes the [charCode] to `this`.\n   *\n   * This method is equivalent to `write(new String.fromCharCode(charCode))`.\n   */\n  void writeCharCode(int charCode);\n}\n","sdk/lib/core/symbol.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/// Opaque name used by mirrors, invocations and [Function.apply].\nclass Symbol {\n  /**\n   * Constructs a new Symbol.\n   *\n   * An [ArgumentError] is thrown if [name] starts with an underscore,\n   * or if [name] is not a [String].  An [ArgumentError] is thrown if\n   * [name] is not an empty string and is not a valid qualified\n   * identifier optionally followed by [:'=':].\n   */\n  const factory Symbol(String name) = _collection_dev.Symbol;\n}\n","sdk/lib/core/type.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * Runtime representation of a type.\n */\nabstract class Type {}\n","sdk/lib/crypto/crypto.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart.crypto;\n\nimport 'dart:math';\n\npart 'crypto_utils.dart';\npart 'hash_utils.dart';\npart 'hmac.dart';\npart 'md5.dart';\npart 'sha1.dart';\npart 'sha256.dart';\n\n/**\n * Interface for cryptographic hash functions.\n *\n * The [add] method is used to add data to the hash. The [close] method\n * is used to extract the message digest.\n *\n * Once the [close] method has been called no more data can be added using the\n * [add] method. If [add] is called after the first call to [close] a\n * HashException is thrown.\n *\n * If multiple instances of a given Hash is needed the [newInstance]\n * method can provide a new instance.\n */\n// TODO(floitsch): make Hash implement Sink, EventSink or similar.\nabstract class Hash {\n  /**\n   * Add a list of bytes to the hash computation.\n   */\n  add(List<int> data);\n\n  /**\n   * Finish the hash computation and extract the message digest as\n   * a list of bytes.\n   */\n  List<int> close();\n\n  /**\n   * Returns a new instance of this hash function.\n   */\n  Hash newInstance();\n\n  /**\n   * Internal block size of the hash in bytes.\n   *\n   * This is exposed for use by the HMAC class which needs to know the\n   * block size for the [Hash] it is using.\n   */\n  int get blockSize;\n}\n\n/**\n * SHA1 hash function implementation.\n */\nabstract class SHA1 implements Hash {\n  factory SHA1() => new _SHA1();\n}\n\n/**\n * SHA256 hash function implementation.\n */\nabstract class SHA256 implements Hash {\n  factory SHA256() => new _SHA256();\n}\n\n/**\n * MD5 hash function implementation.\n *\n * WARNING: MD5 has known collisions and should only be used when\n * required for backwards compatibility.\n */\nabstract class MD5 implements Hash {\n  factory MD5() => new _MD5();\n}\n\n/**\n * Hash-based Message Authentication Code support.\n *\n * The [add] method is used to add data to the message. The [digest] and\n * [close] methods are used to extract the message authentication code.\n */\n// TODO(floitsch): make Hash implement Sink, EventSink or similar.\nabstract class HMAC {\n  /**\n   * Create an [HMAC] object from a [Hash] and a key.\n   */\n  factory HMAC(Hash hash, List<int> key) => new _HMAC(hash, key);\n\n  /**\n   * Add a list of bytes to the message.\n   */\n  add(List<int> data);\n\n  /**\n   * Perform the actual computation and extract the message digest\n   * as a list of bytes.\n   */\n  List<int> close();\n\n  /**\n   * Extract the message digest as a list of bytes without closing [this].\n   */\n  List<int> get digest;\n\n  /**\n   * Verify that the HMAC computed for the data so far matches the\n   * given message digest.\n   *\n   * This method should be used instead of memcmp-style comparisons\n   * to avoid leaking information via timing.\n   *\n   * Throws an exception if the given digest does not have the same\n   * size as the digest computed by this HMAC instance.\n   */\n  bool verify(List<int> digest);\n}\n\n/**\n * Utility methods for working with message digests.\n */\nabstract class CryptoUtils {\n  /**\n   * Convert a list of bytes (for example a message digest) into a hex\n   * string.\n   */\n  static String bytesToHex(List<int> bytes) {\n    return _CryptoUtils.bytesToHex(bytes);\n  }\n\n  /**\n   * Converts a list of bytes into a Base 64 encoded string.\n   *\n   * The list can be any list of integers in the range 0..255,\n   * for example a message digest.\n   *\n   * If [addLineSeparator] is true, the resulting string will  be\n   * broken into lines of 76 characters, separated by \"\\r\\n\".\n   *\n   * If [urlSafe] is true, the result is URL and filename safe.\n   *\n   * Based on [RFC 4648](http://tools.ietf.org/html/rfc4648)\n   *\n   */\n  static String bytesToBase64(List<int> bytes,\n                              {bool urlSafe : false,\n                               bool addLineSeparator : false}) {\n    return _CryptoUtils.bytesToBase64(bytes,\n                                      urlSafe,\n                                      addLineSeparator);\n  }\n\n\n  /**\n   * Converts a Base 64 encoded String into list of bytes.\n   *\n   * Decoder ignores \"\\r\\n\" sequences from input. By default it also ignores\n   * all illegal characters unless [ignoreInvalidCharacters] is false.\n   *\n   * Accepts both URL safe and unsafe Base 64 encoded strings.\n   *\n   * Based on [RFC 4648](http://tools.ietf.org/html/rfc4648)\n   */\n  static List<int> base64StringToBytes(String input,\n                                       {bool ignoreInvalidCharacters : true}) {\n    return _CryptoUtils.base64StringToBytes(input, ignoreInvalidCharacters);\n  }\n}\n\n/**\n * HashExceptions are thrown on invalid use of a Hash\n * object.\n */\nclass HashException {\n  HashException(String this.message);\n  toString() => \"HashException: $message\";\n  String message;\n}\n\n","sdk/lib/crypto/crypto_utils.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.crypto;\n\nabstract class _CryptoUtils {\n  static String bytesToHex(List<int> bytes) {\n    var result = new StringBuffer();\n    for (var part in bytes) {\n      result.write('${part < 16 ? '0' : ''}${part.toRadixString(16)}');\n    }\n    return result.toString();\n  }\n\n  static const int PAD = 61; // '='\n  static const int CR = 13;  // '\\r'\n  static const int LF = 10;  // '\\n'\n  static const int LINE_LENGTH = 76;\n\n  static const String _encodeTable =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  static const String _encodeTableUrlSafe =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\n  // Lookup table used for finding Base 64 alphabet index of a given byte.\n  // -2 : Outside Base 64 alphabet.\n  // -1 : '\\r' or '\\n'\n  //  0 : = (Padding character).\n  // >0 : Base 64 alphabet index of given byte.\n  static const List<int> _decodeTable =\n      const [ -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -2, -2, -1, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, 62, -2, 62, -2, 63,\n              52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2,  0, -2, -2,\n              -2,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,\n              15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, 63,\n              -2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n              41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2 ];\n\n  static String bytesToBase64(List<int> bytes,\n                              [bool urlSafe = false,\n                               bool addLineSeparator = false]) {\n    int len = bytes.length;\n    if (len == 0) {\n      return \"\";\n    }\n    final String lookup = urlSafe ? _encodeTableUrlSafe : _encodeTable;\n    // Size of 24 bit chunks.\n    final int remainderLength = len.remainder(3);\n    final int chunkLength = len - remainderLength;\n    // Size of base output.\n    int outputLen = ((len ~/ 3) * 4) + ((remainderLength > 0) ? 4 : 0);\n    // Add extra for line separators.\n    if (addLineSeparator) {\n      outputLen += ((outputLen - 1) ~/ LINE_LENGTH) << 1;\n    }\n    List<int> out = new List<int>(outputLen);\n\n    // Encode 24 bit chunks.\n    int j = 0, i = 0, c = 0;\n    while (i < chunkLength) {\n      int x = ((bytes[i++] << 16) & 0xFFFFFF) |\n              ((bytes[i++] << 8) & 0xFFFFFF) |\n                bytes[i++];\n      out[j++] = lookup.codeUnitAt(x >> 18);\n      out[j++] = lookup.codeUnitAt((x >> 12) & 0x3F);\n      out[j++] = lookup.codeUnitAt((x >> 6)  & 0x3F);\n      out[j++] = lookup.codeUnitAt(x & 0x3f);\n      // Add optional line separator for each 76 char output.\n      if (addLineSeparator && ++c == 19 && j < outputLen - 2) {\n          out[j++] = CR;\n          out[j++] = LF;\n          c = 0;\n      }\n    }\n\n    // If input length if not a multiple of 3, encode remaining bytes and\n    // add padding.\n    if (remainderLength == 1) {\n      int x = bytes[i];\n      out[j++] = lookup.codeUnitAt(x >> 2);\n      out[j++] = lookup.codeUnitAt((x << 4) & 0x3F);\n      out[j++] = PAD;\n      out[j++] = PAD;\n    } else if (remainderLength == 2) {\n      int x = bytes[i];\n      int y = bytes[i + 1];\n      out[j++] = lookup.codeUnitAt(x >> 2);\n      out[j++] = lookup.codeUnitAt(((x << 4) | (y >> 4)) & 0x3F);\n      out[j++] = lookup.codeUnitAt((y << 2) & 0x3F);\n      out[j++] = PAD;\n    }\n\n    return new String.fromCharCodes(out);\n  }\n\n  static List<int> base64StringToBytes(String input,\n                                       [bool ignoreInvalidCharacters = true]) {\n    int len = input.length;\n    if (len == 0) {\n      return new List<int>(0);\n    }\n\n    // Count '\\r', '\\n' and illegal characters, For illegal characters,\n    // if [ignoreInvalidCharacters] is false, throw an exception.\n    int extrasLen = 0;\n    for (int i = 0; i < len; i++) {\n      int c = _decodeTable[input.codeUnitAt(i)];\n      if (c < 0) {\n        extrasLen++;\n        if(c == -2 && !ignoreInvalidCharacters) {\n          throw new FormatException('Invalid character: ${input[i]}');\n        }\n      }\n    }\n\n    if ((len - extrasLen) % 4 != 0) {\n      throw new FormatException('''Size of Base 64 characters in Input\n          must be a multiple of 4. Input: $input''');\n    }\n\n    // Count pad characters, ignore illegal characters at the end.\n    int padLength = 0;\n    for (int i = len - 1; i >= 0; i--) {\n      int currentCodeUnit = input.codeUnitAt(i);\n      if (_decodeTable[currentCodeUnit] > 0) break;\n      if (currentCodeUnit == PAD) padLength++;\n    }\n    int outputLen = (((len - extrasLen) * 6) >> 3) - padLength;\n    List<int> out = new List<int>(outputLen);\n\n    for (int i = 0, o = 0; o < outputLen;) {\n      // Accumulate 4 valid 6 bit Base 64 characters into an int.\n      int x = 0;\n      for (int j = 4; j > 0;) {\n        int c = _decodeTable[input.codeUnitAt(i++)];\n        if (c >= 0) {\n          x = ((x << 6) & 0xFFFFFF) | c;\n          j--;\n        }\n      }\n      out[o++] = x >> 16;\n      if (o < outputLen) {\n        out[o++] = (x >> 8) & 0xFF;\n        if (o < outputLen) out[o++] = x & 0xFF;\n      }\n    }\n    return out;\n  }\n\n}\n","sdk/lib/crypto/hash_utils.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.crypto;\n\n// Constants.\nconst _MASK_8 = 0xff;\nconst _MASK_32 = 0xffffffff;\nconst _BITS_PER_BYTE = 8;\nconst _BYTES_PER_WORD = 4;\n\n// Helper functions used by more than one hasher.\n\n// Rotate left limiting to unsigned 32-bit values.\nint _rotl32(int val, int shift) {\n  var mod_shift = shift & 31;\n  return ((val << mod_shift) & _MASK_32) |\n      ((val & _MASK_32) >> (32 - mod_shift));\n}\n\n// Base class encapsulating common behavior for cryptographic hash\n// functions.\nabstract class _HashBase implements Hash {\n  _HashBase(int this._chunkSizeInWords,\n            int this._digestSizeInWords,\n            bool this._bigEndianWords)\n      : _pendingData = [] {\n    _currentChunk = new List(_chunkSizeInWords);\n    _h = new List(_digestSizeInWords);\n  }\n\n  // Update the hasher with more data.\n  add(List<int> data) {\n    if (_digestCalled) {\n      throw new HashException(\n          'Hash update method called after digest was retrieved');\n    }\n    _lengthInBytes += data.length;\n    _pendingData.addAll(data);\n    _iterate();\n  }\n\n  // Finish the hash computation and return the digest string.\n  List<int> close() {\n    if (_digestCalled) {\n      return _resultAsBytes();\n    }\n    _digestCalled = true;\n    _finalizeData();\n    _iterate();\n    assert(_pendingData.length == 0);\n    return _resultAsBytes();\n  }\n\n  // Returns the block size of the hash in bytes.\n  int get blockSize {\n    return _chunkSizeInWords * _BYTES_PER_WORD;\n  }\n\n  // Create a fresh instance of this Hash.\n  newInstance();\n\n  // One round of the hash computation.\n  _updateHash(List<int> m);\n\n  // Helper methods.\n  _add32(x, y) => (x + y) & _MASK_32;\n  _roundUp(val, n) => (val + n - 1) & -n;\n\n  // Compute the final result as a list of bytes from the hash words.\n  _resultAsBytes() {\n    var result = [];\n    for (var i = 0; i < _h.length; i++) {\n      result.addAll(_wordToBytes(_h[i]));\n    }\n    return result;\n  }\n\n  // Converts a list of bytes to a chunk of 32-bit words.\n  _bytesToChunk(List<int> data, int dataIndex) {\n    assert((data.length - dataIndex) >= (_chunkSizeInWords * _BYTES_PER_WORD));\n\n    for (var wordIndex = 0; wordIndex < _chunkSizeInWords; wordIndex++) {\n      var w3 = _bigEndianWords ? data[dataIndex] : data[dataIndex + 3];\n      var w2 = _bigEndianWords ? data[dataIndex + 1] : data[dataIndex + 2];\n      var w1 = _bigEndianWords ? data[dataIndex + 2] : data[dataIndex + 1];\n      var w0 = _bigEndianWords ? data[dataIndex + 3] : data[dataIndex];\n      dataIndex += 4;\n      var word = (w3 & 0xff) << 24;\n      word |= (w2 & _MASK_8) << 16;\n      word |= (w1 & _MASK_8) << 8;\n      word |= (w0 & _MASK_8);\n      _currentChunk[wordIndex] = word;\n    }\n  }\n\n  // Convert a 32-bit word to four bytes.\n  _wordToBytes(int word) {\n    List<int> bytes = new List(_BYTES_PER_WORD);\n    bytes[0] = (word >> (_bigEndianWords ? 24 : 0)) & _MASK_8;\n    bytes[1] = (word >> (_bigEndianWords ? 16 : 8)) & _MASK_8;\n    bytes[2] = (word >> (_bigEndianWords ? 8 : 16)) & _MASK_8;\n    bytes[3] = (word >> (_bigEndianWords ? 0 : 24)) & _MASK_8;\n    return bytes;\n  }\n\n  // Iterate through data updating the hash computation for each\n  // chunk.\n  _iterate() {\n    var len = _pendingData.length;\n    var chunkSizeInBytes = _chunkSizeInWords * _BYTES_PER_WORD;\n    if (len >= chunkSizeInBytes) {\n      var index = 0;\n      for (; (len - index) >= chunkSizeInBytes; index += chunkSizeInBytes) {\n        _bytesToChunk(_pendingData, index);\n        _updateHash(_currentChunk);\n      }\n      _pendingData = _pendingData.sublist(index, len);\n    }\n  }\n\n  // Finalize the data. Add a 1 bit to the end of the message. Expand with\n  // 0 bits and add the length of the message.\n  _finalizeData() {\n    _pendingData.add(0x80);\n    var contentsLength = _lengthInBytes + 9;\n    var chunkSizeInBytes = _chunkSizeInWords * _BYTES_PER_WORD;\n    var finalizedLength = _roundUp(contentsLength, chunkSizeInBytes);\n    var zeroPadding = finalizedLength - contentsLength;\n    for (var i = 0; i < zeroPadding; i++) {\n      _pendingData.add(0);\n    }\n    var lengthInBits = _lengthInBytes * _BITS_PER_BYTE;\n    assert(lengthInBits < pow(2, 32));\n    if (_bigEndianWords) {\n      _pendingData.addAll(_wordToBytes(0));\n      _pendingData.addAll(_wordToBytes(lengthInBits & _MASK_32));\n    } else {\n      _pendingData.addAll(_wordToBytes(lengthInBits & _MASK_32));\n      _pendingData.addAll(_wordToBytes(0));\n    }\n  }\n\n  // Hasher state.\n  final int _chunkSizeInWords;\n  final int _digestSizeInWords;\n  final bool _bigEndianWords;\n  int _lengthInBytes = 0;\n  List<int> _pendingData;\n  List<int> _currentChunk;\n  List<int> _h;\n  bool _digestCalled = false;\n}\n","sdk/lib/crypto/hmac.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.crypto;\n\nclass _HMAC implements HMAC {\n  bool _isClosed = false;\n\n  _HMAC(Hash this._hash, List<int> this._key) : _message = [];\n\n  add(List<int> data) {\n    if (_isClosed) throw new StateError(\"HMAC is closed\");\n    _message.addAll(data);\n  }\n\n  List<int> get digest {\n    var blockSize = _hash.blockSize;\n\n    // Hash the key if it is longer than the block size of the hash.\n    if (_key.length > blockSize) {\n      _hash = _hash.newInstance();\n      _hash.add(_key);\n      _key = _hash.close();\n    }\n\n    // Zero-pad the key until its size is equal to the block size of the hash.\n    if (_key.length < blockSize) {\n      var newKey = new List(blockSize);\n      newKey.setRange(0, _key.length, _key);\n      for (var i = _key.length; i < blockSize; i++) {\n        newKey[i] = 0;\n      }\n      _key = newKey;\n    }\n\n    // Compute inner padding.\n    var padding = new List(blockSize);\n    for (var i = 0; i < blockSize; i++) {\n      padding[i] = 0x36 ^ _key[i];\n    }\n\n    // Inner hash computation.\n    _hash = _hash.newInstance();\n    _hash.add(padding);\n    _hash.add(_message);\n    var innerHash = _hash.close();\n\n    // Compute outer padding.\n    for (var i = 0; i < blockSize; i++) {\n      padding[i] = 0x5c ^ _key[i];\n    }\n\n    // Outer hash computation which is the result.\n    _hash = _hash.newInstance();\n    _hash.add(padding);\n    _hash.add(innerHash);\n    return _hash.close();\n  }\n\n  List<int> close() {\n    _isClosed = true;\n    return digest;\n  }\n\n  bool verify(List<int> digest) {\n    var computedDigest = this.digest;\n    if (digest.length != computedDigest.length) {\n      throw new ArgumentError(\n          'Invalid digest size: ${digest.length} in HMAC.verify. '\n          'Expected: ${_hash.blockSize}.');\n    }\n    int result = 0;\n    for (var i = 0; i < digest.length; i++) {\n      result |= digest[i] ^ computedDigest[i];\n    }\n    return result == 0;\n  }\n\n  // HMAC internal state.\n  Hash _hash;\n  List<int> _key;\n  List<int> _message;\n}\n","sdk/lib/crypto/md5.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.crypto;\n\n// The MD5 hasher is used to compute an MD5 message digest.\nclass _MD5 extends _HashBase implements MD5 {\n  _MD5() : super(16, 4, false) {\n    _h[0] = 0x67452301;\n    _h[1] = 0xefcdab89;\n    _h[2] = 0x98badcfe;\n    _h[3] = 0x10325476;\n  }\n\n  // Returns a new instance of this Hash.\n  MD5 newInstance() {\n    return new MD5();\n  }\n\n  static const _k = const [\n    0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a,\n    0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,\n    0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340,\n    0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,\n    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8,\n    0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,\n    0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa,\n    0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,\n    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92,\n    0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,\n    0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 ];\n\n  static const _r = const [\n    7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5,  9, 14,\n    20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 4, 11, 16, 23, 4, 11,\n    16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6,\n    10, 15, 21, 6, 10, 15, 21 ];\n\n  // Compute one iteration of the MD5 algorithm with a chunk of\n  // 16 32-bit pieces.\n  void _updateHash(List<int> m) {\n    assert(m.length == 16);\n\n    var a = _h[0];\n    var b = _h[1];\n    var c = _h[2];\n    var d = _h[3];\n\n    var t0;\n    var t1;\n\n    for (var i = 0; i < 64; i++) {\n      if (i < 16) {\n        t0 = (b & c) | ((~b & _MASK_32) & d);\n        t1 = i;\n      } else if (i < 32) {\n        t0 = (d & b) | ((~d & _MASK_32) & c);\n        t1 = ((5 * i) + 1) % 16;\n      } else if (i < 48) {\n        t0 = b ^ c ^ d;\n        t1 = ((3 * i) + 5) % 16;\n      } else {\n        t0 = c ^ (b | (~d & _MASK_32));\n        t1 = (7 * i) % 16;\n      }\n\n      var temp = d;\n      d = c;\n      c = b;\n      b = _add32(b, _rotl32(_add32(_add32(a, t0),\n                                   _add32(_k[i], m[t1])),\n                            _r[i]));\n      a = temp;\n    }\n\n    _h[0] = _add32(a, _h[0]);\n    _h[1] = _add32(b, _h[1]);\n    _h[2] = _add32(c, _h[2]);\n    _h[3] = _add32(d, _h[3]);\n  }\n}\n","sdk/lib/crypto/sha1.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.crypto;\n\n// The SHA1 hasher is used to compute an SHA1 message digest.\nclass _SHA1 extends _HashBase implements SHA1 {\n  // Construct a SHA1 hasher object.\n  _SHA1() : _w = new List(80), super(16, 5, true) {\n    _h[0] = 0x67452301;\n    _h[1] = 0xEFCDAB89;\n    _h[2] = 0x98BADCFE;\n    _h[3] = 0x10325476;\n    _h[4] = 0xC3D2E1F0;\n  }\n\n  // Returns a new instance of this Hash.\n  SHA1 newInstance() {\n    return new SHA1();\n  }\n\n  // Compute one iteration of the SHA1 algorithm with a chunk of\n  // 16 32-bit pieces.\n  void _updateHash(List<int> m) {\n    assert(m.length == 16);\n\n    var a = _h[0];\n    var b = _h[1];\n    var c = _h[2];\n    var d = _h[3];\n    var e = _h[4];\n\n    for (var i = 0; i < 80; i++) {\n      if (i < 16) {\n        _w[i] = m[i];\n      } else {\n        var n = _w[i - 3] ^ _w[i - 8] ^ _w[i - 14] ^ _w[i - 16];\n        _w[i] = _rotl32(n, 1);\n      }\n      var t = _rotl32(a, 5) + e + _w[i];\n      if (i < 20) {\n        t = t + ((b & c) | (~b & d)) + 0x5A827999;\n      } else if (i < 40) {\n        t = t + (b ^ c ^ d) + 0x6ED9EBA1;\n      } else if (i < 60) {\n        t = t + ((b & c) | (b & d) | (c & d)) + 0x8F1BBCDC;\n      } else {\n        t = t + (b ^ c ^ d) + 0xCA62C1D6;\n      }\n\n      e = d;\n      d = c;\n      c = _rotl32(b, 30);\n      b = a;\n      a = t & _MASK_32;\n    }\n\n    _h[0] = _add32(a, _h[0]);\n    _h[1] = _add32(b, _h[1]);\n    _h[2] = _add32(c, _h[2]);\n    _h[3] = _add32(d, _h[3]);\n    _h[4] = _add32(e, _h[4]);\n  }\n\n  List<int> _w;\n}\n","sdk/lib/crypto/sha256.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.crypto;\n\n// The SHA256 hasher is used to compute an SHA256 message digest.\nclass _SHA256 extends _HashBase implements SHA256 {\n  // Construct a SHA256 hasher object.\n  _SHA256() : _w = new List(64), super(16, 8, true) {\n    // Initial value of the hash parts. First 32 bits of the fractional parts\n    // of the square roots of the first 8 prime numbers.\n    _h[0] = 0x6a09e667;\n    _h[1] = 0xbb67ae85;\n    _h[2] = 0x3c6ef372;\n    _h[3] = 0xa54ff53a;\n    _h[4] = 0x510e527f;\n    _h[5] = 0x9b05688c;\n    _h[6] = 0x1f83d9ab;\n    _h[7] = 0x5be0cd19;\n  }\n\n  // Returns a new instance of this Hash.\n  SHA256 newInstance() {\n    return new SHA256();\n  }\n\n  // Table of round constants. First 32 bits of the fractional\n  // parts of the cube roots of the first 64 prime numbers.\n  static const List<int> _K =\n      const [ 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,\n              0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,\n              0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,\n              0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n              0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,\n              0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n              0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n              0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n              0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n              0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,\n              0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,\n              0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n              0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2 ];\n\n  // Helper functions as defined in http://tools.ietf.org/html/rfc6234\n  _rotr32(n, x) => (x >> n) | ((x << (32 - n)) & _MASK_32);\n  _ch(x, y, z) => (x & y) ^ ((~x & _MASK_32) & z);\n  _maj(x, y, z) => (x & y) ^ (x & z) ^ (y & z);\n  _bsig0(x) => _rotr32(2, x) ^ _rotr32(13, x) ^ _rotr32(22, x);\n  _bsig1(x) => _rotr32(6, x) ^ _rotr32(11, x) ^ _rotr32(25, x);\n  _ssig0(x) => _rotr32(7, x) ^ _rotr32(18, x) ^ (x >> 3);\n  _ssig1(x) => _rotr32(17, x) ^ _rotr32(19, x) ^ (x >> 10);\n\n  // Compute one iteration of the SHA256 algorithm with a chunk of\n  // 16 32-bit pieces.\n  void _updateHash(List<int> M) {\n    assert(M.length == 16);\n\n    // Prepare message schedule.\n    var i = 0;\n    for (; i < 16; i++) {\n      _w[i] = M[i];\n    }\n    for (; i < 64; i++) {\n      _w[i] = _add32(_add32(_ssig1(_w[i - 2]), _w[i - 7]),\n                     _add32(_ssig0(_w[i - 15]), _w[i - 16]));\n    }\n\n    // Shuffle around the bits.\n    var a = _h[0];\n    var b = _h[1];\n    var c = _h[2];\n    var d = _h[3];\n    var e = _h[4];\n    var f = _h[5];\n    var g = _h[6];\n    var h = _h[7];\n\n    for (var t = 0; t < 64; t++) {\n      var t1 = _add32(_add32(h, _bsig1(e)),\n                      _add32(_ch(e, f, g), _add32(_K[t], _w[t])));\n      var t2 = _add32(_bsig0(a), _maj(a, b, c));\n      h = g;\n      g = f;\n      f = e;\n      e = _add32(d, t1);\n      d = c;\n      c = b;\n      b = a;\n      a = _add32(t1, t2);\n    }\n\n    // Update hash values after iteration.\n    _h[0] = _add32(a, _h[0]);\n    _h[1] = _add32(b, _h[1]);\n    _h[2] = _add32(c, _h[2]);\n    _h[3] = _add32(d, _h[3]);\n    _h[4] = _add32(e, _h[4]);\n    _h[5] = _add32(f, _h[5]);\n    _h[6] = _add32(g, _h[6]);\n    _h[7] = _add32(h, _h[7]);\n  }\n\n  List<int> _w;\n}\n","sdk/lib/html/dart2js/html_dart2js.dart":"/// The Dart HTML library.\nlibrary dart.dom.html;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:_collection-dev';\nimport 'dart:html_common';\nimport 'dart:indexed_db';\nimport 'dart:isolate';\nimport 'dart:json' as json;\nimport 'dart:math';\nimport 'dart:typed_data';\nimport 'dart:svg' as svg;\nimport 'dart:web_audio' as web_audio;\nimport 'dart:web_gl' as gl;\nimport 'dart:web_sql';\nimport 'dart:_js_helper' show convertDartClosureToJS, Creates, JavaScriptIndexingBehavior, JSName, Null, Returns;\nimport 'dart:_isolate_helper' show IsolateNatives;\nimport 'dart:_foreign_helper' show JS;\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// DO NOT EDIT - unless you are editing documentation as per:\n// https://code.google.com/p/dart/wiki/ContributingHTMLDocumentation\n// Auto-generated dart:html library.\n\n\n// Not actually used, but imported since dart:html can generate these objects.\n\n\n\n\n\n/**\n * The top-level Window object.\n */\nWindow get window => JS('Window', 'window');\n\n/**\n * The top-level Document object.\n */\nHtmlDocument get document => JS('HtmlDocument', 'document');\n\nElement query(String selector) => document.query(selector);\nList<Element> queryAll(String selector) => document.queryAll(selector);\n\n// Workaround for tags like <cite> that lack their own Element subclass --\n// Dart issue 1990.\nclass _HTMLElement extends Element native \"HTMLElement\" {\n}\n\n// Support for Send/ReceivePortSync.\nint _getNewIsolateId() {\n  if (JS('bool', r'!window.$dart$isolate$counter')) {\n    JS('void', r'window.$dart$isolate$counter = 1');\n  }\n  return JS('int', r'window.$dart$isolate$counter++');\n}\n\n// Fast path to invoke JS send port.\n_callPortSync(int id, message) {\n  return JS('var', r'ReceivePortSync.dispatchCall(#, #)', id, message);\n}\n\nspawnDomFunction(f) => IsolateNatives.spawnDomFunction(f);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('AbstractWorker')\nclass AbstractWorker extends EventTarget native \"AbstractWorker\" {\n\n  @DomName('AbstractWorker.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @JSName('addEventListener')\n  @DomName('AbstractWorker.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('AbstractWorker.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @JSName('removeEventListener')\n  @DomName('AbstractWorker.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('AbstractWorker.onerror')\n  @DocsEditable\n  Stream<Event> get onError => errorEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLAnchorElement')\nclass AnchorElement extends Element native \"HTMLAnchorElement\" {\n\n  @DomName('HTMLAnchorElement.HTMLAnchorElement')\n  @DocsEditable\n  factory AnchorElement({String href}) {\n    var e = document.$dom_createElement(\"a\");\n    if (href != null) e.href = href;\n    return e;\n  }\n\n  @DomName('HTMLAnchorElement.download')\n  @DocsEditable\n  String download;\n\n  @DomName('HTMLAnchorElement.hash')\n  @DocsEditable\n  String hash;\n\n  @DomName('HTMLAnchorElement.host')\n  @DocsEditable\n  String host;\n\n  @DomName('HTMLAnchorElement.hostname')\n  @DocsEditable\n  String hostname;\n\n  @DomName('HTMLAnchorElement.href')\n  @DocsEditable\n  String href;\n\n  @DomName('HTMLAnchorElement.hreflang')\n  @DocsEditable\n  String hreflang;\n\n  @DomName('HTMLAnchorElement.name')\n  @DocsEditable\n  String name;\n\n  @DomName('HTMLAnchorElement.origin')\n  @DocsEditable\n  final String origin;\n\n  @DomName('HTMLAnchorElement.pathname')\n  @DocsEditable\n  String pathname;\n\n  @DomName('HTMLAnchorElement.ping')\n  @DocsEditable\n  String ping;\n\n  @DomName('HTMLAnchorElement.port')\n  @DocsEditable\n  String port;\n\n  @DomName('HTMLAnchorElement.protocol')\n  @DocsEditable\n  String protocol;\n\n  @DomName('HTMLAnchorElement.rel')\n  @DocsEditable\n  String rel;\n\n  @DomName('HTMLAnchorElement.search')\n  @DocsEditable\n  String search;\n\n  @DomName('HTMLAnchorElement.target')\n  @DocsEditable\n  String target;\n\n  @DomName('HTMLAnchorElement.type')\n  @DocsEditable\n  String type;\n\n  @DomName('HTMLAnchorElement.toString')\n  @DocsEditable\n  String toString() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebKitAnimationEvent')\nclass AnimationEvent extends Event native \"WebKitAnimationEvent\" {\n\n  @DomName('AnimationEvent.animationName')\n  @DocsEditable\n  final String animationName;\n\n  @DomName('AnimationEvent.elapsedTime')\n  @DocsEditable\n  final num elapsedTime;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DOMApplicationCache')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.OPERA)\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass ApplicationCache extends EventTarget native \"ApplicationCache,DOMApplicationCache,OfflineResourceList\" {\n\n  @DomName('DOMApplicationCache.cachedEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> cachedEvent = const EventStreamProvider<Event>('cached');\n\n  @DomName('DOMApplicationCache.checkingEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> checkingEvent = const EventStreamProvider<Event>('checking');\n\n  @DomName('DOMApplicationCache.downloadingEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> downloadingEvent = const EventStreamProvider<Event>('downloading');\n\n  @DomName('DOMApplicationCache.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('DOMApplicationCache.noupdateEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> noUpdateEvent = const EventStreamProvider<Event>('noupdate');\n\n  @DomName('DOMApplicationCache.obsoleteEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> obsoleteEvent = const EventStreamProvider<Event>('obsolete');\n\n  @DomName('DOMApplicationCache.progressEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> progressEvent = const EventStreamProvider<Event>('progress');\n\n  @DomName('DOMApplicationCache.updatereadyEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> updateReadyEvent = const EventStreamProvider<Event>('updateready');\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.applicationCache)');\n\n  static const int CHECKING = 2;\n\n  static const int DOWNLOADING = 3;\n\n  static const int IDLE = 1;\n\n  static const int OBSOLETE = 5;\n\n  static const int UNCACHED = 0;\n\n  static const int UPDATEREADY = 4;\n\n  @DomName('DOMApplicationCache.status')\n  @DocsEditable\n  final int status;\n\n  @DomName('DOMApplicationCache.abort')\n  @DocsEditable\n  void abort() native;\n\n  @JSName('addEventListener')\n  @DomName('DOMApplicationCache.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('DOMApplicationCache.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @JSName('removeEventListener')\n  @DomName('DOMApplicationCache.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('DOMApplicationCache.swapCache')\n  @DocsEditable\n  void swapCache() native;\n\n  @DomName('DOMApplicationCache.update')\n  @DocsEditable\n  void update() native;\n\n  @DomName('DOMApplicationCache.oncached')\n  @DocsEditable\n  Stream<Event> get onCached => cachedEvent.forTarget(this);\n\n  @DomName('DOMApplicationCache.onchecking')\n  @DocsEditable\n  Stream<Event> get onChecking => checkingEvent.forTarget(this);\n\n  @DomName('DOMApplicationCache.ondownloading')\n  @DocsEditable\n  Stream<Event> get onDownloading => downloadingEvent.forTarget(this);\n\n  @DomName('DOMApplicationCache.onerror')\n  @DocsEditable\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  @DomName('DOMApplicationCache.onnoupdate')\n  @DocsEditable\n  Stream<Event> get onNoUpdate => noUpdateEvent.forTarget(this);\n\n  @DomName('DOMApplicationCache.onobsolete')\n  @DocsEditable\n  Stream<Event> get onObsolete => obsoleteEvent.forTarget(this);\n\n  @DomName('DOMApplicationCache.onprogress')\n  @DocsEditable\n  Stream<Event> get onProgress => progressEvent.forTarget(this);\n\n  @DomName('DOMApplicationCache.onupdateready')\n  @DocsEditable\n  Stream<Event> get onUpdateReady => updateReadyEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n/**\n * DOM Area Element, which links regions of an image map with a hyperlink.\n *\n * The element can also define an uninteractive region of the map.\n *\n * See also:\n *\n * * [<area>](https://developer.mozilla.org/en-US/docs/HTML/Element/area)\n * on MDN.\n */\n@DomName('HTMLAreaElement')\nclass AreaElement extends Element native \"HTMLAreaElement\" {\n\n  @DomName('HTMLAreaElement.HTMLAreaElement')\n  @DocsEditable\n  factory AreaElement() => document.$dom_createElement(\"area\");\n\n  @DomName('HTMLAreaElement.alt')\n  @DocsEditable\n  String alt;\n\n  @DomName('HTMLAreaElement.coords')\n  @DocsEditable\n  String coords;\n\n  @DomName('HTMLAreaElement.hash')\n  @DocsEditable\n  final String hash;\n\n  @DomName('HTMLAreaElement.host')\n  @DocsEditable\n  final String host;\n\n  @DomName('HTMLAreaElement.hostname')\n  @DocsEditable\n  final String hostname;\n\n  @DomName('HTMLAreaElement.href')\n  @DocsEditable\n  String href;\n\n  @DomName('HTMLAreaElement.pathname')\n  @DocsEditable\n  final String pathname;\n\n  @DomName('HTMLAreaElement.ping')\n  @DocsEditable\n  String ping;\n\n  @DomName('HTMLAreaElement.port')\n  @DocsEditable\n  final String port;\n\n  @DomName('HTMLAreaElement.protocol')\n  @DocsEditable\n  final String protocol;\n\n  @DomName('HTMLAreaElement.search')\n  @DocsEditable\n  final String search;\n\n  @DomName('HTMLAreaElement.shape')\n  @DocsEditable\n  String shape;\n\n  @DomName('HTMLAreaElement.target')\n  @DocsEditable\n  String target;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Attr')\nclass Attr extends Node native \"Attr\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLAudioElement')\nclass AudioElement extends MediaElement native \"HTMLAudioElement\" {\n\n  @DomName('HTMLAudioElement.HTMLAudioElement')\n  @DocsEditable\n  factory AudioElement([String src]) {\n    if (?src) {\n      return AudioElement._create_1(src);\n    }\n    return AudioElement._create_2();\n  }\n  static AudioElement _create_1(src) => JS('AudioElement', 'new Audio(#)', src);\n  static AudioElement _create_2() => JS('AudioElement', 'new Audio()');\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('AutocompleteErrorEvent')\nclass AutocompleteErrorEvent extends Event native \"AutocompleteErrorEvent\" {\n\n  @DomName('AutocompleteErrorEvent.reason')\n  @DocsEditable\n  final String reason;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLBRElement')\nclass BRElement extends Element native \"HTMLBRElement\" {\n\n  @DomName('HTMLBRElement.HTMLBRElement')\n  @DocsEditable\n  factory BRElement() => document.$dom_createElement(\"br\");\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('BarInfo')\nclass BarInfo native \"BarInfo\" {\n\n  @DomName('BarInfo.visible')\n  @DocsEditable\n  final bool visible;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLBaseElement')\nclass BaseElement extends Element native \"HTMLBaseElement\" {\n\n  @DomName('HTMLBaseElement.HTMLBaseElement')\n  @DocsEditable\n  factory BaseElement() => document.$dom_createElement(\"base\");\n\n  @DomName('HTMLBaseElement.href')\n  @DocsEditable\n  String href;\n\n  @DomName('HTMLBaseElement.target')\n  @DocsEditable\n  String target;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('BeforeLoadEvent')\nclass BeforeLoadEvent extends Event native \"BeforeLoadEvent\" {\n\n  @DomName('BeforeLoadEvent.url')\n  @DocsEditable\n  final String url;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('Blob')\nclass Blob native \"Blob\" {\n\n  @DomName('Blob.size')\n  @DocsEditable\n  final int size;\n\n  @DomName('Blob.type')\n  @DocsEditable\n  final String type;\n\n  @DomName('Blob.slice')\n  @DocsEditable\n  Blob slice([int start, int end, String contentType]) native;\n\n  factory Blob(List blobParts, [String type, String endings]) {\n    // TODO: validate that blobParts is a JS Array and convert if not.\n    // TODO: any coercions on the elements of blobParts, e.g. coerce a typed\n    // array to ArrayBuffer if it is a total view.\n    var useBlobBuilder;\n    try {\n      JS('var', 'new Blob([\"\"], {type: \"text/plain\"})');\n      useBlobBuilder = false;\n    } catch (_) {\n      useBlobBuilder = true;\n    }\n    if (useBlobBuilder) {\n      var builder = JS('var', 'new WebKitBlobBuilder()');\n      if (endings != null) {\n        for (var part in blobParts) {\n          JS('void', '#.append(#, #)', builder, part, endings);\n        }\n      } else {\n        for (var part in blobParts) {\n          JS('void', '#.append(#)', builder, part);\n        }\n      }\n      if (type != null) {\n        return JS('Blob', '#.getBlob(#)', builder, type);\n      } else {\n        return JS('Blob', '#.getBlob()', builder);\n      }\n    }\n    if (type == null && endings == null) {\n      return _create_1(blobParts);\n    }\n    var bag = _create_bag();\n    if (type != null) _bag_set(bag, 'type', type);\n    if (endings != null) _bag_set(bag, 'endings', endings);\n    return _create_2(blobParts, bag);\n  }\n\n  static _create_1(parts) => JS('Blob', 'new Blob(#)', parts);\n  static _create_2(parts, bag) => JS('Blob', 'new Blob(#, #)', parts, bag);\n\n  static _create_bag() => JS('var', '{}');\n  static _bag_set(bag, key, value) { JS('void', '#[#] = #', bag, key, value); }\n}\n\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLBodyElement')\nclass BodyElement extends Element native \"HTMLBodyElement\" {\n\n  @DomName('HTMLBodyElement.blurEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> blurEvent = const EventStreamProvider<Event>('blur');\n\n  @DomName('HTMLBodyElement.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('HTMLBodyElement.focusEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> focusEvent = const EventStreamProvider<Event>('focus');\n\n  @DomName('HTMLBodyElement.hashchangeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> hashChangeEvent = const EventStreamProvider<Event>('hashchange');\n\n  @DomName('HTMLBodyElement.loadEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> loadEvent = const EventStreamProvider<Event>('load');\n\n  @DomName('HTMLBodyElement.messageEvent')\n  @DocsEditable\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  @DomName('HTMLBodyElement.offlineEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> offlineEvent = const EventStreamProvider<Event>('offline');\n\n  @DomName('HTMLBodyElement.onlineEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> onlineEvent = const EventStreamProvider<Event>('online');\n\n  @DomName('HTMLBodyElement.popstateEvent')\n  @DocsEditable\n  static const EventStreamProvider<PopStateEvent> popStateEvent = const EventStreamProvider<PopStateEvent>('popstate');\n\n  @DomName('HTMLBodyElement.resizeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> resizeEvent = const EventStreamProvider<Event>('resize');\n\n  @DomName('HTMLBodyElement.storageEvent')\n  @DocsEditable\n  static const EventStreamProvider<StorageEvent> storageEvent = const EventStreamProvider<StorageEvent>('storage');\n\n  @DomName('HTMLBodyElement.unloadEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> unloadEvent = const EventStreamProvider<Event>('unload');\n\n  @DomName('HTMLBodyElement.HTMLBodyElement')\n  @DocsEditable\n  factory BodyElement() => document.$dom_createElement(\"body\");\n\n  @DomName('HTMLBodyElement.onblur')\n  @DocsEditable\n  Stream<Event> get onBlur => blurEvent.forTarget(this);\n\n  @DomName('HTMLBodyElement.onerror')\n  @DocsEditable\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  @DomName('HTMLBodyElement.onfocus')\n  @DocsEditable\n  Stream<Event> get onFocus => focusEvent.forTarget(this);\n\n  @DomName('HTMLBodyElement.onhashchange')\n  @DocsEditable\n  Stream<Event> get onHashChange => hashChangeEvent.forTarget(this);\n\n  @DomName('HTMLBodyElement.onload')\n  @DocsEditable\n  Stream<Event> get onLoad => loadEvent.forTarget(this);\n\n  @DomName('HTMLBodyElement.onmessage')\n  @DocsEditable\n  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);\n\n  @DomName('HTMLBodyElement.onoffline')\n  @DocsEditable\n  Stream<Event> get onOffline => offlineEvent.forTarget(this);\n\n  @DomName('HTMLBodyElement.ononline')\n  @DocsEditable\n  Stream<Event> get onOnline => onlineEvent.forTarget(this);\n\n  @DomName('HTMLBodyElement.onpopstate')\n  @DocsEditable\n  Stream<PopStateEvent> get onPopState => popStateEvent.forTarget(this);\n\n  @DomName('HTMLBodyElement.onresize')\n  @DocsEditable\n  Stream<Event> get onResize => resizeEvent.forTarget(this);\n\n  @DomName('HTMLBodyElement.onstorage')\n  @DocsEditable\n  Stream<StorageEvent> get onStorage => storageEvent.forTarget(this);\n\n  @DomName('HTMLBodyElement.onunload')\n  @DocsEditable\n  Stream<Event> get onUnload => unloadEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLButtonElement')\nclass ButtonElement extends Element native \"HTMLButtonElement\" {\n\n  @DomName('HTMLButtonElement.HTMLButtonElement')\n  @DocsEditable\n  factory ButtonElement() => document.$dom_createElement(\"button\");\n\n  @DomName('HTMLButtonElement.autofocus')\n  @DocsEditable\n  bool autofocus;\n\n  @DomName('HTMLButtonElement.disabled')\n  @DocsEditable\n  bool disabled;\n\n  @DomName('HTMLButtonElement.form')\n  @DocsEditable\n  final FormElement form;\n\n  @DomName('HTMLButtonElement.formAction')\n  @DocsEditable\n  String formAction;\n\n  @DomName('HTMLButtonElement.formEnctype')\n  @DocsEditable\n  String formEnctype;\n\n  @DomName('HTMLButtonElement.formMethod')\n  @DocsEditable\n  String formMethod;\n\n  @DomName('HTMLButtonElement.formNoValidate')\n  @DocsEditable\n  bool formNoValidate;\n\n  @DomName('HTMLButtonElement.formTarget')\n  @DocsEditable\n  String formTarget;\n\n  @DomName('HTMLButtonElement.labels')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLButtonElement.name')\n  @DocsEditable\n  String name;\n\n  @DomName('HTMLButtonElement.type')\n  @DocsEditable\n  String type;\n\n  @DomName('HTMLButtonElement.validationMessage')\n  @DocsEditable\n  final String validationMessage;\n\n  @DomName('HTMLButtonElement.validity')\n  @DocsEditable\n  final ValidityState validity;\n\n  @DomName('HTMLButtonElement.value')\n  @DocsEditable\n  String value;\n\n  @DomName('HTMLButtonElement.willValidate')\n  @DocsEditable\n  final bool willValidate;\n\n  @DomName('HTMLButtonElement.checkValidity')\n  @DocsEditable\n  bool checkValidity() native;\n\n  @DomName('HTMLButtonElement.setCustomValidity')\n  @DocsEditable\n  void setCustomValidity(String error) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CDATASection')\nclass CDataSection extends Text native \"CDATASection\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('HTMLCanvasElement')\nclass CanvasElement extends Element implements CanvasImageSource native \"HTMLCanvasElement\" {\n\n  @DomName('HTMLCanvasElement.HTMLCanvasElement')\n  @DocsEditable\n  factory CanvasElement({int width, int height}) {\n    var e = document.$dom_createElement(\"canvas\");\n    if (width != null) e.width = width;\n    if (height != null) e.height = height;\n    return e;\n  }\n\n  /// The height of this canvas element in CSS pixels.\n  @DomName('HTMLCanvasElement.height')\n  @DocsEditable\n  int height;\n\n  /// The width of this canvas element in CSS pixels.\n  @DomName('HTMLCanvasElement.width')\n  @DocsEditable\n  int width;\n\n  @DomName('HTMLCanvasElement.getContext')\n  @DocsEditable\n  CanvasRenderingContext getContext(String contextId, [Map attrs]) {\n    if (?attrs) {\n      var attrs_1 = convertDartToNative_Dictionary(attrs);\n      return _getContext_1(contextId, attrs_1);\n    }\n    return _getContext_2(contextId);\n  }\n  @JSName('getContext')\n  @DomName('HTMLCanvasElement.getContext')\n  @DocsEditable\n  CanvasRenderingContext _getContext_1(contextId, attrs) native;\n  @JSName('getContext')\n  @DomName('HTMLCanvasElement.getContext')\n  @DocsEditable\n  CanvasRenderingContext _getContext_2(contextId) native;\n\n  @JSName('toDataURL')\n  /**\n   * Returns a data URI containing a representation of the image in the\n   * format specified by type (defaults to 'image/png').\n   *\n   * Data Uri format is as follow `data:[<MIME-type>][;charset=<encoding>][;base64],<data>`\n   *\n   * Optional parameter [quality] in the range of 0.0 and 1.0 can be used when requesting [type]\n   * 'image/jpeg' or 'image/webp'. If [quality] is not passed the default\n   * value is used. Note: the default value varies by browser.\n   *\n   * If the height or width of this canvas element is 0, then 'data:' is returned,\n   * representing no data.\n   *\n   * If the type requested is not 'image/png', and the returned value is\n   * 'data:image/png', then the requested type is not supported.\n   *\n   * Example usage:\n   *\n   *     CanvasElement canvas = new CanvasElement();\n   *     var ctx = canvas.context2D\n   *     ..fillStyle = \"rgb(200,0,0)\"\n   *     ..fillRect(10, 10, 55, 50);\n   *     var dataUrl = canvas.toDataURL(\"image/jpeg\", 0.95);\n   *     // The Data Uri would look similar to\n   *     // 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\n   *     // AAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO\n   *     // 9TXL0Y4OHwAAAABJRU5ErkJggg=='\n   *     //Create a new image element from the data URI.\n   *     var img = new ImageElement();\n   *     img.src = dataUrl;\n   *     document.body.children.add(img);\n   *\n   * See also:\n   *\n   * * [Data URI Scheme](http://en.wikipedia.org/wiki/Data_URI_scheme) from Wikipedia.\n   *\n   * * [HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/DOM/HTMLCanvasElement) from MDN.\n   *\n   * * [toDataUrl](http://dev.w3.org/html5/spec/the-canvas-element.html#dom-canvas-todataurl) from W3C.\n   */\n  @DomName('HTMLCanvasElement.toDataURL')\n  @DocsEditable\n  String toDataUrl(String type, [num quality]) native;\n\n  /** An API for drawing on this canvas. */\n  CanvasRenderingContext2D get context2D =>\n      JS('Null|CanvasRenderingContext2D', '#.getContext(#)', this, '2d');\n\n  @deprecated\n  CanvasRenderingContext2D get context2d => this.context2D;\n\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @Experimental\n  gl.RenderingContext getContext3d({alpha: true, depth: true, stencil: false,\n    antialias: true, premultipliedAlpha: true, preserveDrawingBuffer: false}) {\n\n    var options = {\n      'alpha': alpha,\n      'depth': depth,\n      'stencil': stencil,\n      'antialias': antialias,\n      'premultipliedAlpha': premultipliedAlpha,\n      'preserveDrawingBuffer': preserveDrawingBuffer,\n    };\n    var context = getContext('webgl', options);\n    if (context == null) {\n      context = getContext('experimental-webgl', options);\n    }\n    return context;\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n/**\n * An opaque canvas object representing a gradient.\n *\n * Created by calling [createLinearGradient] or [createRadialGradient] on a\n * [CanvasRenderingContext2D] object.\n *\n * Example usage:\n *\n *     var canvas = new CanvasElement(width: 600, height: 600);\n *     var ctx = canvas.context2D;\n *     ctx.clearRect(0, 0, 600, 600);\n *     ctx.save();\n *     // Create radial gradient.\n *     CanvasGradient gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 600);\n *     gradient.addColorStop(0, '#000');\n *     gradient.addColorStop(1, 'rgb(255, 255, 255)');\n *     // Assign gradients to fill.\n *     ctx.fillStyle = gradient;\n *     // Draw a rectangle with a gradient fill.\n *     ctx.fillRect(0, 0, 600, 600);\n *     ctx.save();\n *     document.body.children.add(canvas);\n *\n * See also:\n *\n * * [CanvasGradient](https://developer.mozilla.org/en-US/docs/DOM/CanvasGradient) from MDN.\n * * [CanvasGradient](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvasgradient) from whatwg.\n * * [CanvasGradient](http://www.w3.org/TR/2010/WD-2dcontext-20100304/#canvasgradient) from W3C.\n */\n@DomName('CanvasGradient')\nclass CanvasGradient native \"CanvasGradient\" {\n\n  /**\n   * Adds a color stop to this gradient at the offset.\n   *\n   * The [offset] can range between 0.0 and 1.0.\n   *\n   * See also:\n   *\n   * * [Multiple Color Stops](https://developer.mozilla.org/en-US/docs/CSS/linear-gradient#Gradient_with_multiple_color_stops) from MDN.\n   */\n  @DomName('CanvasGradient.addColorStop')\n  @DocsEditable\n  void addColorStop(num offset, String color) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n/**\n * An opaque object representing a pattern of image, canvas, or video.\n *\n * Created by calling [createPattern] on a [CanvasRenderingContext2D] object.\n *\n * Example usage:\n *\n *     var canvas = new CanvasElement(width: 600, height: 600);\n *     var ctx = canvas.context2D;\n *     var img = new ImageElement();\n *     // Image src needs to be loaded before pattern is applied.\n *     img.onLoad.listen((event) {\n *       // When the image is loaded, create a pattern\n *       // from the ImageElement.\n *       CanvasPattern pattern = ctx.createPattern(img, 'repeat');\n *       ctx.rect(0, 0, canvas.width, canvas.height);\n *       ctx.fillStyle = pattern;\n *       ctx.fill();\n *     });\n *     img.src = \"images/foo.jpg\";\n *     document.body.children.add(canvas);\n *\n * See also:\n * * [CanvasPattern](https://developer.mozilla.org/en-US/docs/DOM/CanvasPattern) from MDN.\n * * [CanvasPattern](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvaspattern) from whatwg.\n * * [CanvasPattern](http://www.w3.org/TR/2010/WD-2dcontext-20100304/#canvaspattern) from W3C.\n */\n@DomName('CanvasPattern')\nclass CanvasPattern native \"CanvasPattern\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CanvasProxy')\nclass CanvasProxy native \"CanvasProxy\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n/**\n * A rendering context for a canvas element.\n *\n * This context is extended by [CanvasRenderingContext2D] and\n * [WebGLRenderingContext].\n */\n@DomName('CanvasRenderingContext')\nclass CanvasRenderingContext native \"CanvasRenderingContext\" {\n\n  /// Reference to the canvas element to which this context belongs.\n  @DomName('CanvasRenderingContext.canvas')\n  @DocsEditable\n  final CanvasElement canvas;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('CanvasRenderingContext2D')\nclass CanvasRenderingContext2D extends CanvasRenderingContext native \"CanvasRenderingContext2D\" {\n\n  @DomName('CanvasRenderingContext2D.currentPath')\n  @DocsEditable\n  DomPath currentPath;\n\n  @DomName('CanvasRenderingContext2D.fillStyle')\n  @DocsEditable\n  @Creates('String|CanvasGradient|CanvasPattern')\n  @Returns('String|CanvasGradient|CanvasPattern')\n  dynamic fillStyle;\n\n  @DomName('CanvasRenderingContext2D.font')\n  @DocsEditable\n  String font;\n\n  @DomName('CanvasRenderingContext2D.globalAlpha')\n  @DocsEditable\n  num globalAlpha;\n\n  @DomName('CanvasRenderingContext2D.globalCompositeOperation')\n  @DocsEditable\n  String globalCompositeOperation;\n\n  @DomName('CanvasRenderingContext2D.lineCap')\n  @DocsEditable\n  String lineCap;\n\n  @DomName('CanvasRenderingContext2D.lineJoin')\n  @DocsEditable\n  String lineJoin;\n\n  @DomName('CanvasRenderingContext2D.lineWidth')\n  @DocsEditable\n  num lineWidth;\n\n  @DomName('CanvasRenderingContext2D.miterLimit')\n  @DocsEditable\n  num miterLimit;\n\n  @DomName('CanvasRenderingContext2D.shadowBlur')\n  @DocsEditable\n  num shadowBlur;\n\n  @DomName('CanvasRenderingContext2D.shadowColor')\n  @DocsEditable\n  String shadowColor;\n\n  @DomName('CanvasRenderingContext2D.shadowOffsetX')\n  @DocsEditable\n  num shadowOffsetX;\n\n  @DomName('CanvasRenderingContext2D.shadowOffsetY')\n  @DocsEditable\n  num shadowOffsetY;\n\n  @DomName('CanvasRenderingContext2D.strokeStyle')\n  @DocsEditable\n  @Creates('String|CanvasGradient|CanvasPattern')\n  @Returns('String|CanvasGradient|CanvasPattern')\n  dynamic strokeStyle;\n\n  @DomName('CanvasRenderingContext2D.textAlign')\n  @DocsEditable\n  String textAlign;\n\n  @DomName('CanvasRenderingContext2D.textBaseline')\n  @DocsEditable\n  String textBaseline;\n\n  @JSName('webkitBackingStorePixelRatio')\n  @DomName('CanvasRenderingContext2D.webkitBackingStorePixelRatio')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final num backingStorePixelRatio;\n\n  @JSName('webkitImageSmoothingEnabled')\n  @DomName('CanvasRenderingContext2D.webkitImageSmoothingEnabled')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  bool imageSmoothingEnabled;\n\n  @JSName('arc')\n  @DomName('CanvasRenderingContext2D.arc')\n  @DocsEditable\n  void $dom_arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise) native;\n\n  @DomName('CanvasRenderingContext2D.arcTo')\n  @DocsEditable\n  void arcTo(num x1, num y1, num x2, num y2, num radius) native;\n\n  @DomName('CanvasRenderingContext2D.beginPath')\n  @DocsEditable\n  void beginPath() native;\n\n  @DomName('CanvasRenderingContext2D.bezierCurveTo')\n  @DocsEditable\n  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y) native;\n\n  @DomName('CanvasRenderingContext2D.clearRect')\n  @DocsEditable\n  void clearRect(num x, num y, num width, num height) native;\n\n  @DomName('CanvasRenderingContext2D.clip')\n  @DocsEditable\n  void clip([String winding]) native;\n\n  @DomName('CanvasRenderingContext2D.closePath')\n  @DocsEditable\n  void closePath() native;\n\n  @DomName('CanvasRenderingContext2D.createImageData')\n  @DocsEditable\n  @Creates('ImageData|=Object')\n  ImageData createImageData(num sw, num sh) {\n    return _convertNativeToDart_ImageData(_createImageData_1(sw, sh));\n  }\n  @JSName('createImageData')\n  @DomName('CanvasRenderingContext2D.createImageData')\n  @DocsEditable\n  @Creates('ImageData|=Object')\n  _createImageData_1(sw, sh) native;\n\n  @DomName('CanvasRenderingContext2D.createImageData')\n  @DocsEditable\n  @Creates('ImageData|=Object')\n  ImageData createImageDataFromImageData(ImageData imagedata) {\n    var imagedata_1 = _convertDartToNative_ImageData(imagedata);\n    return _convertNativeToDart_ImageData(_createImageDataFromImageData_1(imagedata_1));\n  }\n  @JSName('createImageData')\n  @DomName('CanvasRenderingContext2D.createImageData')\n  @DocsEditable\n  @Creates('ImageData|=Object')\n  _createImageDataFromImageData_1(imagedata) native;\n\n  @DomName('CanvasRenderingContext2D.createLinearGradient')\n  @DocsEditable\n  CanvasGradient createLinearGradient(num x0, num y0, num x1, num y1) native;\n\n  @DomName('CanvasRenderingContext2D.createPattern')\n  @DocsEditable\n  CanvasPattern createPattern(canvas_OR_image, String repetitionType) native;\n\n  @DomName('CanvasRenderingContext2D.createRadialGradient')\n  @DocsEditable\n  CanvasGradient createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1) native;\n\n  @DomName('CanvasRenderingContext2D.fill')\n  @DocsEditable\n  void fill([String winding]) native;\n\n  @DomName('CanvasRenderingContext2D.fillRect')\n  @DocsEditable\n  void fillRect(num x, num y, num width, num height) native;\n\n  @DomName('CanvasRenderingContext2D.fillText')\n  @DocsEditable\n  void fillText(String text, num x, num y, [num maxWidth]) native;\n\n  @DomName('CanvasRenderingContext2D.getImageData')\n  @DocsEditable\n  @Creates('ImageData|=Object')\n  ImageData getImageData(num sx, num sy, num sw, num sh) {\n    return _convertNativeToDart_ImageData(_getImageData_1(sx, sy, sw, sh));\n  }\n  @JSName('getImageData')\n  @DomName('CanvasRenderingContext2D.getImageData')\n  @DocsEditable\n  @Creates('ImageData|=Object')\n  _getImageData_1(sx, sy, sw, sh) native;\n\n  @DomName('CanvasRenderingContext2D.getLineDash')\n  @DocsEditable\n  List<num> getLineDash() native;\n\n  @DomName('CanvasRenderingContext2D.isPointInPath')\n  @DocsEditable\n  bool isPointInPath(num x, num y, [String winding]) native;\n\n  @DomName('CanvasRenderingContext2D.isPointInStroke')\n  @DocsEditable\n  bool isPointInStroke(num x, num y) native;\n\n  @DomName('CanvasRenderingContext2D.lineTo')\n  @DocsEditable\n  void lineTo(num x, num y) native;\n\n  @DomName('CanvasRenderingContext2D.measureText')\n  @DocsEditable\n  TextMetrics measureText(String text) native;\n\n  @DomName('CanvasRenderingContext2D.moveTo')\n  @DocsEditable\n  void moveTo(num x, num y) native;\n\n  @DomName('CanvasRenderingContext2D.putImageData')\n  @DocsEditable\n  void putImageData(ImageData imagedata, num dx, num dy, [num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight]) {\n    if (!?dirtyX && !?dirtyY && !?dirtyWidth && !?dirtyHeight) {\n      var imagedata_1 = _convertDartToNative_ImageData(imagedata);\n      _putImageData_1(imagedata_1, dx, dy);\n      return;\n    }\n    var imagedata_2 = _convertDartToNative_ImageData(imagedata);\n    _putImageData_2(imagedata_2, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\n    return;\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  @JSName('putImageData')\n  @DomName('CanvasRenderingContext2D.putImageData')\n  @DocsEditable\n  void _putImageData_1(imagedata, dx, dy) native;\n  @JSName('putImageData')\n  @DomName('CanvasRenderingContext2D.putImageData')\n  @DocsEditable\n  void _putImageData_2(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) native;\n\n  @DomName('CanvasRenderingContext2D.quadraticCurveTo')\n  @DocsEditable\n  void quadraticCurveTo(num cpx, num cpy, num x, num y) native;\n\n  @DomName('CanvasRenderingContext2D.rect')\n  @DocsEditable\n  void rect(num x, num y, num width, num height) native;\n\n  @DomName('CanvasRenderingContext2D.restore')\n  @DocsEditable\n  void restore() native;\n\n  @DomName('CanvasRenderingContext2D.rotate')\n  @DocsEditable\n  void rotate(num angle) native;\n\n  @DomName('CanvasRenderingContext2D.save')\n  @DocsEditable\n  void save() native;\n\n  @DomName('CanvasRenderingContext2D.scale')\n  @DocsEditable\n  void scale(num sx, num sy) native;\n\n  @DomName('CanvasRenderingContext2D.setLineDash')\n  @DocsEditable\n  void setLineDash(List<num> dash) native;\n\n  @DomName('CanvasRenderingContext2D.setTransform')\n  @DocsEditable\n  void setTransform(num m11, num m12, num m21, num m22, num dx, num dy) native;\n\n  @DomName('CanvasRenderingContext2D.stroke')\n  @DocsEditable\n  void stroke() native;\n\n  @DomName('CanvasRenderingContext2D.strokeRect')\n  @DocsEditable\n  void strokeRect(num x, num y, num width, num height, [num lineWidth]) native;\n\n  @DomName('CanvasRenderingContext2D.strokeText')\n  @DocsEditable\n  void strokeText(String text, num x, num y, [num maxWidth]) native;\n\n  @DomName('CanvasRenderingContext2D.transform')\n  @DocsEditable\n  void transform(num m11, num m12, num m21, num m22, num dx, num dy) native;\n\n  @DomName('CanvasRenderingContext2D.translate')\n  @DocsEditable\n  void translate(num tx, num ty) native;\n\n  @DomName('CanvasRenderingContext2D.webkitGetImageDataHD')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  @Creates('ImageData|=Object')\n  ImageData getImageDataHD(num sx, num sy, num sw, num sh) {\n    return _convertNativeToDart_ImageData(_getImageDataHD_1(sx, sy, sw, sh));\n  }\n  @JSName('webkitGetImageDataHD')\n  @DomName('CanvasRenderingContext2D.webkitGetImageDataHD')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  @Creates('ImageData|=Object')\n  _getImageDataHD_1(sx, sy, sw, sh) native;\n\n  @DomName('CanvasRenderingContext2D.webkitPutImageDataHD')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void putImageDataHD(ImageData imagedata, num dx, num dy, [num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight]) {\n    if (!?dirtyX && !?dirtyY && !?dirtyWidth && !?dirtyHeight) {\n      var imagedata_1 = _convertDartToNative_ImageData(imagedata);\n      _putImageDataHD_1(imagedata_1, dx, dy);\n      return;\n    }\n    var imagedata_2 = _convertDartToNative_ImageData(imagedata);\n    _putImageDataHD_2(imagedata_2, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\n    return;\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  @JSName('webkitPutImageDataHD')\n  @DomName('CanvasRenderingContext2D.webkitPutImageDataHD')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void _putImageDataHD_1(imagedata, dx, dy) native;\n  @JSName('webkitPutImageDataHD')\n  @DomName('CanvasRenderingContext2D.webkitPutImageDataHD')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void _putImageDataHD_2(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) native;\n\n\n  /**\n   * Sets the color used inside shapes.\n   * [r], [g], [b] are 0-255, [a] is 0-1.\n   */\n  void setFillColorRgb(int r, int g, int b, [num a = 1]) {\n    this.fillStyle = 'rgba($r, $g, $b, $a)';\n  }\n\n  /**\n   * Sets the color used inside shapes.\n   * [h] is in degrees, 0-360.\n   * [s], [l] are in percent, 0-100.\n   * [a] is 0-1.\n   */\n  void setFillColorHsl(int h, num s, num l, [num a = 1]) {\n    this.fillStyle = 'hsla($h, $s%, $l%, $a)';\n  }\n\n  /**\n   * Sets the color used for stroking shapes.\n   * [r], [g], [b] are 0-255, [a] is 0-1.\n   */\n  void setStrokeColorRgb(int r, int g, int b, [num a = 1]) {\n    this.strokeStyle = 'rgba($r, $g, $b, $a)';\n  }\n\n  /**\n   * Sets the color used for stroking shapes.\n   * [h] is in degrees, 0-360.\n   * [s], [l] are in percent, 0-100.\n   * [a] is 0-1.\n   */\n  void setStrokeColorHsl(int h, num s, num l, [num a = 1]) {\n    this.strokeStyle = 'hsla($h, $s%, $l%, $a)';\n  }\n\n  @DomName('CanvasRenderingContext2D.arc')\n  void arc(num x,  num y,  num radius,  num startAngle, num endAngle,\n      [bool anticlockwise = false]) {\n    $dom_arc(x, y, radius, startAngle, endAngle, anticlockwise);\n  }\n\n  /**\n   * Draws an image from a CanvasImageSource to an area of this canvas.\n   *\n   * The image will be drawn to an area of this canvas defined by\n   * [destRect]. [sourceRect] defines the region of the source image that is\n   * drawn.\n   * If [sourceRect] is not provided, then\n   * the entire rectangular image from [source] will be drawn to this context.\n   *\n   * If the image is larger than canvas\n   * will allow, the image will be clipped to fit the available space.\n   *\n   *     CanvasElement canvas = new CanvasElement(width: 600, height: 600);\n   *     CanvasRenderingContext2D ctx = canvas.context2D;\n   *     ImageElement img = document.query('img');\n   *     img.width = 100;\n   *     img.height = 100;\n   *\n   *     // Scale the image to 20x20.\n   *     ctx.drawImageToRect(img, new Rect(50, 50, 20, 20));\n   *\n   *     VideoElement video = document.query('video');\n   *     video.width = 100;\n   *     video.height = 100;\n   *     // Take the middle 20x20 pixels from the video and stretch them.\n   *     ctx.drawImageToRect(video, new Rect(50, 50, 100, 100),\n   *         sourceRect: new Rect(40, 40, 20, 20));\n   *\n   *     // Draw the top 100x20 pixels from the otherCanvas.\n   *     CanvasElement otherCanvas = document.query('canvas');\n   *     ctx.drawImageToRect(otherCanvas, new Rect(0, 0, 100, 20),\n   *         sourceRect: new Rect(0, 0, 100, 20));\n   *\n   * See also:\n   *\n   *   * [CanvasImageSource] for more information on what data is retrieved\n   * from [source].\n   *   * [drawImage](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage)\n   * from the WHATWG.\n   */\n  @DomName('CanvasRenderingContext2D.drawImage')\n  void drawImageToRect(CanvasImageSource source, Rect destRect,\n      {Rect sourceRect}) {\n    if (sourceRect == null) {\n      drawImageScaled(source,\n          destRect.left,\n          destRect.top,\n          destRect.width,\n          destRect.height);\n    } else {\n      drawImageScaledFromSource(source,\n          sourceRect.left,\n          sourceRect.top,\n          sourceRect.width,\n          sourceRect.height,\n          destRect.left,\n          destRect.top,\n          destRect.width,\n          destRect.height);\n    }\n  }\n\n  /**\n   * Draws an image from a CanvasImageSource to this canvas.\n   *\n   * The entire image from [source] will be drawn to this context with its top\n   * left corner at the point ([destX], [destY]). If the image is\n   * larger than canvas will allow, the image will be clipped to fit the\n   * available space.\n   *\n   *     CanvasElement canvas = new CanvasElement(width: 600, height: 600);\n   *     CanvasRenderingContext2D ctx = canvas.context2D;\n   *     ImageElement img = document.query('img');\n   *\n   *     ctx.drawImage(img, 100, 100);\n   *\n   *     VideoElement video = document.query('video');\n   *     ctx.drawImage(video, 0, 0);\n   *\n   *     CanvasElement otherCanvas = document.query('canvas');\n   *     otherCanvas.width = 100;\n   *     otherCanvas.height = 100;\n   *     ctx.drawImage(otherCanvas, 590, 590); // will get clipped\n   *\n   * See also:\n   *\n   *   * [CanvasImageSource] for more information on what data is retrieved\n   * from [source].\n   *   * [drawImage](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage)\n   * from the WHATWG.\n   */\n  @DomName('CanvasRenderingContext2D.drawImage')\n  @JSName('drawImage')\n  void drawImage(CanvasImageSource source, num destX, num destY) native;\n\n  /**\n   * Draws an image from a CanvasImageSource to an area of this canvas.\n   *\n   * The image will be drawn to this context with its top left corner at the\n   * point ([destX], [destY]) and will be scaled to be [destWidth] wide and\n   * [destHeight] tall.\n   *\n   * If the image is larger than canvas\n   * will allow, the image will be clipped to fit the available space.\n   *\n   *     CanvasElement canvas = new CanvasElement(width: 600, height: 600);\n   *     CanvasRenderingContext2D ctx = canvas.context2D;\n   *     ImageElement img = document.query('img');\n   *     img.width = 100;\n   *     img.height = 100;\n   *\n   *     // Scale the image to 300x50 at the point (20, 20)\n   *     ctx.drawImageScaled(img, 20, 20, 300, 50);\n   *\n   * See also:\n   *\n   *   * [CanvasImageSource] for more information on what data is retrieved\n   * from [source].\n   *   * [drawImage](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage)\n   * from the WHATWG.\n   */\n  @DomName('CanvasRenderingContext2D.drawImage')\n  @JSName('drawImage')\n  void drawImageScaled(CanvasImageSource source,\n      num destX, num destY, num destWidth, num destHeight) native;\n\n  /**\n   * Draws an image from a CanvasImageSource to an area of this canvas.\n   *\n   * The image is a region of [source] that is [sourceWidth] wide and\n   * [destHeight] tall with top left corner at ([sourceX], [sourceY]).\n   * The image will be drawn to this context with its top left corner at the\n   * point ([destX], [destY]) and will be scaled to be [destWidth] wide and\n   * [destHeight] tall.\n   *\n   * If the image is larger than canvas\n   * will allow, the image will be clipped to fit the available space.\n   *\n   *     VideoElement video = document.query('video');\n   *     video.width = 100;\n   *     video.height = 100;\n   *     // Take the middle 20x20 pixels from the video and stretch them.\n   *     ctx.drawImageScaledFromSource(video, 40, 40, 20, 20, 50, 50, 100, 100);\n   *\n   *     // Draw the top 100x20 pixels from the otherCanvas to this one.\n   *     CanvasElement otherCanvas = document.query('canvas');\n   *     ctx.drawImageScaledFromSource(otherCanvas, 0, 0, 100, 20, 0, 0, 100, 20);\n   *\n   * See also:\n   *\n   *   * [CanvasImageSource] for more information on what data is retrieved\n   * from [source].\n   *   * [drawImage](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage)\n   * from the WHATWG.\n   */\n  @DomName('CanvasRenderingContext2D.drawImage')\n  @JSName('drawImage')\n  void drawImageScaledFromSource(CanvasImageSource source,\n      num sourceX, num sourceY, num sourceWidth, num sourceHeight,\n      num destX, num destY, num destWidth, num destHeight) native;\n\n  @DomName('CanvasRenderingContext2D.lineDashOffset')\n  num get lineDashOffset => JS('num',\n      '#.lineDashOffset || #.webkitLineDashOffset', this, this);\n\n  @DomName('CanvasRenderingContext2D.lineDashOffset')\n  void set lineDashOffset(num value) => JS('void', \n      'typeof #.lineDashOffset != \"undefined\" ? #.lineDashOffset = # : '\n      '#.webkitLineDashOffset = #', this, this, value, this, value);\n}\n\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CharacterData')\nclass CharacterData extends Node native \"CharacterData\" {\n\n  @DomName('CharacterData.data')\n  @DocsEditable\n  String data;\n\n  @DomName('CharacterData.length')\n  @DocsEditable\n  final int length;\n\n  @DomName('CharacterData.appendData')\n  @DocsEditable\n  void appendData(String data) native;\n\n  @DomName('CharacterData.deleteData')\n  @DocsEditable\n  void deleteData(int offset, int length) native;\n\n  @DomName('CharacterData.insertData')\n  @DocsEditable\n  void insertData(int offset, String data) native;\n\n  @DomName('CharacterData.replaceData')\n  @DocsEditable\n  void replaceData(int offset, int length, String data) native;\n\n  @DomName('CharacterData.substringData')\n  @DocsEditable\n  String substringData(int offset, int length) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CloseEvent')\nclass CloseEvent extends Event native \"CloseEvent\" {\n\n  @DomName('CloseEvent.code')\n  @DocsEditable\n  final int code;\n\n  @DomName('CloseEvent.reason')\n  @DocsEditable\n  final String reason;\n\n  @DomName('CloseEvent.wasClean')\n  @DocsEditable\n  final bool wasClean;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Comment')\nclass Comment extends CharacterData native \"Comment\" {\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('CompositionEvent')\nclass CompositionEvent extends UIEvent native \"CompositionEvent\" {\n  factory CompositionEvent(String type,\n      {bool canBubble: false, bool cancelable: false, Window view,\n      String data}) {\n    if (view == null) {\n      view = window;\n    }\n    var e = document.$dom_createEvent(\"CompositionEvent\");\n    e.$dom_initCompositionEvent(type, canBubble, cancelable, view, data);\n    return e;\n  }\n\n  @DomName('CompositionEvent.data')\n  @DocsEditable\n  final String data;\n\n  @JSName('initCompositionEvent')\n  @DomName('CompositionEvent.initCompositionEvent')\n  @DocsEditable\n  void $dom_initCompositionEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('Console')\nclass Console {\n\n  static Console safeConsole = new Console();\n\n  bool get _isConsoleDefined => JS('bool', 'typeof console != \"undefined\"');\n\n  @DomName('Console.memory')\n  MemoryInfo get memory => _isConsoleDefined ?\n      JS('MemoryInfo', 'console.memory') : null;\n\n  @DomName('Console.profiles')\n  List<ScriptProfile> get profiles => _isConsoleDefined ?\n      JS('List<ScriptProfile>', 'console.profiles') : null;\n\n  @DomName('Console.assertCondition')\n  void assertCondition(bool condition, Object arg) => _isConsoleDefined ?\n      JS('void', 'console.assertCondition(#, #)', condition, arg) : null;\n\n  @DomName('Console.count')\n  void count(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.count(#)', arg) : null;\n\n  @DomName('Console.debug')\n  void debug(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.debug(#)', arg) : null;\n\n  @DomName('Console.dir')\n  void dir(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.debug(#)', arg) : null;\n\n  @DomName('Console.dirxml')\n  void dirxml(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.dirxml(#)', arg) : null;\n\n  @DomName('Console.error')\n  void error(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.error(#)', arg) : null;\n\n  @DomName('Console.group')\n  void group(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.group(#)', arg) : null;\n\n  @DomName('Console.groupCollapsed')\n  void groupCollapsed(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.groupCollapsed(#)', arg) : null;\n\n  @DomName('Console.groupEnd')\n  void groupEnd() => _isConsoleDefined ?\n      JS('void', 'console.groupEnd()') : null;\n\n  @DomName('Console.info')\n  void info(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.info(#)', arg) : null;\n\n  @DomName('Console.log')\n  void log(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.log(#)', arg) : null;\n\n  @DomName('Console.markTimeline')\n  void markTimeline(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.markTimeline(#)', arg) : null;\n\n  @DomName('Console.profile')\n  void profile(String title) => _isConsoleDefined ?\n      JS('void', 'console.profile(#)', title) : null;\n\n  @DomName('Console.profileEnd')\n  void profileEnd(String title) => _isConsoleDefined ?\n      JS('void', 'console.profileEnd(#)', title) : null;\n\n  @DomName('Console.time')\n  void time(String title) => _isConsoleDefined ?\n      JS('void', 'console.time(#)', title) : null;\n\n  @DomName('Console.timeEnd')\n  void timeEnd(String timerName) => _isConsoleDefined ?\n      JS('void', 'console.timeEnd(#)', timerName) : null;\n\n  @DomName('Console.timeStamp')\n  void timeStamp(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.timeStamp(#)', arg) : null;\n\n  @DomName('Console.trace')\n  void trace(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.trace(#)', arg) : null;\n\n  @DomName('Console.warn')\n  void warn(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.warn(#)', arg) : null;\n\n  @DomName('Console.clear')\n  @DocsEditable\n  void clear(Object arg) native;\n\n  @DomName('Console.table')\n  @DocsEditable\n  void table(Object arg) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLContentElement')\n@SupportedBrowser(SupportedBrowser.CHROME, '26')\n@Experimental\nclass ContentElement extends Element native \"HTMLContentElement\" {\n\n  @DomName('HTMLContentElement.HTMLContentElement')\n  @DocsEditable\n  factory ContentElement() => document.$dom_createElement(\"content\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('content');\n\n  @DomName('HTMLContentElement.resetStyleInheritance')\n  @DocsEditable\n  bool resetStyleInheritance;\n\n  @DomName('HTMLContentElement.select')\n  @DocsEditable\n  String select;\n\n  @DomName('HTMLContentElement.getDistributedNodes')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getDistributedNodes() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Coordinates')\nclass Coordinates native \"Coordinates\" {\n\n  @DomName('Coordinates.accuracy')\n  @DocsEditable\n  final num accuracy;\n\n  @DomName('Coordinates.altitude')\n  @DocsEditable\n  final num altitude;\n\n  @DomName('Coordinates.altitudeAccuracy')\n  @DocsEditable\n  final num altitudeAccuracy;\n\n  @DomName('Coordinates.heading')\n  @DocsEditable\n  final num heading;\n\n  @DomName('Coordinates.latitude')\n  @DocsEditable\n  final num latitude;\n\n  @DomName('Coordinates.longitude')\n  @DocsEditable\n  final num longitude;\n\n  @DomName('Coordinates.speed')\n  @DocsEditable\n  final num speed;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Crypto')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental\nclass Crypto native \"Crypto\" {\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.crypto && window.crypto.getRandomValues)');\n\n  @DomName('Crypto.getRandomValues')\n  @DocsEditable\n  @Creates('TypedData')\n  @Returns('TypedData|Null')\n  TypedData getRandomValues(TypedData array) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CSSCharsetRule')\nclass CssCharsetRule extends CssRule native \"CSSCharsetRule\" {\n\n  @DomName('CSSCharsetRule.encoding')\n  @DocsEditable\n  String encoding;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CSSFontFaceLoadEvent')\nclass CssFontFaceLoadEvent extends Event native \"CSSFontFaceLoadEvent\" {\n\n  @DomName('CSSFontFaceLoadEvent.error')\n  @DocsEditable\n  final DomError error;\n\n  @DomName('CSSFontFaceLoadEvent.fontface')\n  @DocsEditable\n  final CssFontFaceRule fontface;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CSSFontFaceRule')\nclass CssFontFaceRule extends CssRule native \"CSSFontFaceRule\" {\n\n  @DomName('CSSFontFaceRule.style')\n  @DocsEditable\n  final CssStyleDeclaration style;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CSSHostRule')\n@SupportedBrowser(SupportedBrowser.CHROME, '26')\n@Experimental\nclass CssHostRule extends CssRule native \"CSSHostRule\" {\n\n  @DomName('CSSHostRule.cssRules')\n  @DocsEditable\n  @Returns('_CssRuleList')\n  @Creates('_CssRuleList')\n  final List<CssRule> cssRules;\n\n  @DomName('CSSHostRule.deleteRule')\n  @DocsEditable\n  void deleteRule(int index) native;\n\n  @DomName('CSSHostRule.insertRule')\n  @DocsEditable\n  int insertRule(String rule, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CSSImportRule')\nclass CssImportRule extends CssRule native \"CSSImportRule\" {\n\n  @DomName('CSSImportRule.href')\n  @DocsEditable\n  final String href;\n\n  @DomName('CSSImportRule.media')\n  @DocsEditable\n  final MediaList media;\n\n  @DomName('CSSImportRule.styleSheet')\n  @DocsEditable\n  final CssStyleSheet styleSheet;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebKitCSSKeyframeRule')\nclass CssKeyframeRule extends CssRule native \"WebKitCSSKeyframeRule\" {\n\n  @DomName('WebKitCSSKeyframeRule.keyText')\n  @DocsEditable\n  String keyText;\n\n  @DomName('WebKitCSSKeyframeRule.style')\n  @DocsEditable\n  final CssStyleDeclaration style;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebKitCSSKeyframesRule')\nclass CssKeyframesRule extends CssRule native \"WebKitCSSKeyframesRule\" {\n\n  @DomName('WebKitCSSKeyframesRule.cssRules')\n  @DocsEditable\n  @Returns('_CssRuleList')\n  @Creates('_CssRuleList')\n  final List<CssRule> cssRules;\n\n  @DomName('WebKitCSSKeyframesRule.name')\n  @DocsEditable\n  String name;\n\n  @DomName('WebKitCSSKeyframesRule.deleteRule')\n  @DocsEditable\n  void deleteRule(String key) native;\n\n  @DomName('WebKitCSSKeyframesRule.findRule')\n  @DocsEditable\n  CssKeyframeRule findRule(String key) native;\n\n  @DomName('WebKitCSSKeyframesRule.insertRule')\n  @DocsEditable\n  void insertRule(String rule) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CSSMediaRule')\nclass CssMediaRule extends CssRule native \"CSSMediaRule\" {\n\n  @DomName('CSSMediaRule.cssRules')\n  @DocsEditable\n  @Returns('_CssRuleList')\n  @Creates('_CssRuleList')\n  final List<CssRule> cssRules;\n\n  @DomName('CSSMediaRule.media')\n  @DocsEditable\n  final MediaList media;\n\n  @DomName('CSSMediaRule.deleteRule')\n  @DocsEditable\n  void deleteRule(int index) native;\n\n  @DomName('CSSMediaRule.insertRule')\n  @DocsEditable\n  int insertRule(String rule, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CSSPageRule')\nclass CssPageRule extends CssRule native \"CSSPageRule\" {\n\n  @DomName('CSSPageRule.selectorText')\n  @DocsEditable\n  String selectorText;\n\n  @DomName('CSSPageRule.style')\n  @DocsEditable\n  final CssStyleDeclaration style;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CSSRule')\nclass CssRule native \"CSSRule\" {\n\n  static const int CHARSET_RULE = 2;\n\n  static const int FONT_FACE_RULE = 5;\n\n  static const int HOST_RULE = 1001;\n\n  static const int IMPORT_RULE = 3;\n\n  static const int MEDIA_RULE = 4;\n\n  static const int PAGE_RULE = 6;\n\n  static const int STYLE_RULE = 1;\n\n  static const int UNKNOWN_RULE = 0;\n\n  static const int WEBKIT_FILTER_RULE = 17;\n\n  static const int WEBKIT_KEYFRAMES_RULE = 7;\n\n  static const int WEBKIT_KEYFRAME_RULE = 8;\n\n  static const int WEBKIT_REGION_RULE = 16;\n\n  @DomName('CSSRule.cssText')\n  @DocsEditable\n  String cssText;\n\n  @DomName('CSSRule.parentRule')\n  @DocsEditable\n  final CssRule parentRule;\n\n  @DomName('CSSRule.parentStyleSheet')\n  @DocsEditable\n  final CssStyleSheet parentStyleSheet;\n\n  @DomName('CSSRule.type')\n  @DocsEditable\n  final int type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('CSSStyleDeclaration')\nclass CssStyleDeclaration native \"CSSStyleDeclaration\" {\n  factory CssStyleDeclaration() => _CssStyleDeclarationFactoryProvider.createCssStyleDeclaration();\n  factory CssStyleDeclaration.css(String css) =>\n      _CssStyleDeclarationFactoryProvider.createCssStyleDeclaration_css(css);\n\n\n  @DomName('CSSStyleDeclaration.cssText')\n  @DocsEditable\n  String cssText;\n\n  @DomName('CSSStyleDeclaration.length')\n  @DocsEditable\n  final int length;\n\n  @DomName('CSSStyleDeclaration.parentRule')\n  @DocsEditable\n  final CssRule parentRule;\n\n  @JSName('getPropertyValue')\n  @DomName('CSSStyleDeclaration.getPropertyValue')\n  @DocsEditable\n  String _getPropertyValue(String propertyName) native;\n\n  @DomName('CSSStyleDeclaration.getPropertyPriority')\n  @DocsEditable\n  String getPropertyPriority(String propertyName) native;\n\n  @DomName('CSSStyleDeclaration.getPropertyShorthand')\n  @DocsEditable\n  String getPropertyShorthand(String propertyName) native;\n\n  @DomName('CSSStyleDeclaration.isPropertyImplicit')\n  @DocsEditable\n  bool isPropertyImplicit(String propertyName) native;\n\n  @DomName('CSSStyleDeclaration.item')\n  @DocsEditable\n  String item(int index) native;\n\n  @DomName('CSSStyleDeclaration.removeProperty')\n  @DocsEditable\n  String removeProperty(String propertyName) native;\n\n\n  String getPropertyValue(String propertyName) {\n    var propValue = _getPropertyValue(propertyName);\n    return propValue != null ? propValue : '';\n  }\n\n  void setProperty(String propertyName, String value, [String priority]) {\n    // try/catch for IE9 which throws on unsupported values.\n    try {\n      JS('void', '#.setProperty(#, #, #)', this, propertyName, value, priority);\n      // Bug #2772, IE9 requires a poke to actually apply the value.\n      if (JS('bool', '!!#.setAttribute', this)) {\n        JS('void', '#.setAttribute(#, #)', this, propertyName, value);\n      }\n    } catch (e) {}\n  }\n\n  /**\n   * Checks to see if CSS Transitions are supported.\n   */\n  static bool get supportsTransitions {\n    if (JS('bool', '\"transition\" in document.body.style')) {\n      return true;\n    }\n    var propertyName = '${Device.propertyPrefix}Transition';\n    return JS('bool', '# in document.body.style', propertyName);\n  }\n\n  // TODO(jacobr): generate this list of properties using the existing script.\n  /** Gets the value of \"align-content\" */\n  String get alignContent =>\n    getPropertyValue('${Device.cssPrefix}align-content');\n\n  /** Sets the value of \"align-content\" */\n  void set alignContent(String value) {\n    setProperty('${Device.cssPrefix}align-content', value, '');\n  }\n\n  /** Gets the value of \"align-items\" */\n  String get alignItems =>\n    getPropertyValue('${Device.cssPrefix}align-items');\n\n  /** Sets the value of \"align-items\" */\n  void set alignItems(String value) {\n    setProperty('${Device.cssPrefix}align-items', value, '');\n  }\n\n  /** Gets the value of \"align-self\" */\n  String get alignSelf =>\n    getPropertyValue('${Device.cssPrefix}align-self');\n\n  /** Sets the value of \"align-self\" */\n  void set alignSelf(String value) {\n    setProperty('${Device.cssPrefix}align-self', value, '');\n  }\n\n  /** Gets the value of \"animation\" */\n  String get animation =>\n    getPropertyValue('${Device.cssPrefix}animation');\n\n  /** Sets the value of \"animation\" */\n  void set animation(String value) {\n    setProperty('${Device.cssPrefix}animation', value, '');\n  }\n\n  /** Gets the value of \"animation-delay\" */\n  String get animationDelay =>\n    getPropertyValue('${Device.cssPrefix}animation-delay');\n\n  /** Sets the value of \"animation-delay\" */\n  void set animationDelay(String value) {\n    setProperty('${Device.cssPrefix}animation-delay', value, '');\n  }\n\n  /** Gets the value of \"animation-direction\" */\n  String get animationDirection =>\n    getPropertyValue('${Device.cssPrefix}animation-direction');\n\n  /** Sets the value of \"animation-direction\" */\n  void set animationDirection(String value) {\n    setProperty('${Device.cssPrefix}animation-direction', value, '');\n  }\n\n  /** Gets the value of \"animation-duration\" */\n  String get animationDuration =>\n    getPropertyValue('${Device.cssPrefix}animation-duration');\n\n  /** Sets the value of \"animation-duration\" */\n  void set animationDuration(String value) {\n    setProperty('${Device.cssPrefix}animation-duration', value, '');\n  }\n\n  /** Gets the value of \"animation-fill-mode\" */\n  String get animationFillMode =>\n    getPropertyValue('${Device.cssPrefix}animation-fill-mode');\n\n  /** Sets the value of \"animation-fill-mode\" */\n  void set animationFillMode(String value) {\n    setProperty('${Device.cssPrefix}animation-fill-mode', value, '');\n  }\n\n  /** Gets the value of \"animation-iteration-count\" */\n  String get animationIterationCount =>\n    getPropertyValue('${Device.cssPrefix}animation-iteration-count');\n\n  /** Sets the value of \"animation-iteration-count\" */\n  void set animationIterationCount(String value) {\n    setProperty('${Device.cssPrefix}animation-iteration-count', value, '');\n  }\n\n  /** Gets the value of \"animation-name\" */\n  String get animationName =>\n    getPropertyValue('${Device.cssPrefix}animation-name');\n\n  /** Sets the value of \"animation-name\" */\n  void set animationName(String value) {\n    setProperty('${Device.cssPrefix}animation-name', value, '');\n  }\n\n  /** Gets the value of \"animation-play-state\" */\n  String get animationPlayState =>\n    getPropertyValue('${Device.cssPrefix}animation-play-state');\n\n  /** Sets the value of \"animation-play-state\" */\n  void set animationPlayState(String value) {\n    setProperty('${Device.cssPrefix}animation-play-state', value, '');\n  }\n\n  /** Gets the value of \"animation-timing-function\" */\n  String get animationTimingFunction =>\n    getPropertyValue('${Device.cssPrefix}animation-timing-function');\n\n  /** Sets the value of \"animation-timing-function\" */\n  void set animationTimingFunction(String value) {\n    setProperty('${Device.cssPrefix}animation-timing-function', value, '');\n  }\n\n  /** Gets the value of \"app-region\" */\n  String get appRegion =>\n    getPropertyValue('${Device.cssPrefix}app-region');\n\n  /** Sets the value of \"app-region\" */\n  void set appRegion(String value) {\n    setProperty('${Device.cssPrefix}app-region', value, '');\n  }\n\n  /** Gets the value of \"appearance\" */\n  String get appearance =>\n    getPropertyValue('${Device.cssPrefix}appearance');\n\n  /** Sets the value of \"appearance\" */\n  void set appearance(String value) {\n    setProperty('${Device.cssPrefix}appearance', value, '');\n  }\n\n  /** Gets the value of \"aspect-ratio\" */\n  String get aspectRatio =>\n    getPropertyValue('${Device.cssPrefix}aspect-ratio');\n\n  /** Sets the value of \"aspect-ratio\" */\n  void set aspectRatio(String value) {\n    setProperty('${Device.cssPrefix}aspect-ratio', value, '');\n  }\n\n  /** Gets the value of \"backface-visibility\" */\n  String get backfaceVisibility =>\n    getPropertyValue('${Device.cssPrefix}backface-visibility');\n\n  /** Sets the value of \"backface-visibility\" */\n  void set backfaceVisibility(String value) {\n    setProperty('${Device.cssPrefix}backface-visibility', value, '');\n  }\n\n  /** Gets the value of \"background\" */\n  String get background =>\n    getPropertyValue('background');\n\n  /** Sets the value of \"background\" */\n  void set background(String value) {\n    setProperty('background', value, '');\n  }\n\n  /** Gets the value of \"background-attachment\" */\n  String get backgroundAttachment =>\n    getPropertyValue('background-attachment');\n\n  /** Sets the value of \"background-attachment\" */\n  void set backgroundAttachment(String value) {\n    setProperty('background-attachment', value, '');\n  }\n\n  /** Gets the value of \"background-clip\" */\n  String get backgroundClip =>\n    getPropertyValue('background-clip');\n\n  /** Sets the value of \"background-clip\" */\n  void set backgroundClip(String value) {\n    setProperty('background-clip', value, '');\n  }\n\n  /** Gets the value of \"background-color\" */\n  String get backgroundColor =>\n    getPropertyValue('background-color');\n\n  /** Sets the value of \"background-color\" */\n  void set backgroundColor(String value) {\n    setProperty('background-color', value, '');\n  }\n\n  /** Gets the value of \"background-composite\" */\n  String get backgroundComposite =>\n    getPropertyValue('${Device.cssPrefix}background-composite');\n\n  /** Sets the value of \"background-composite\" */\n  void set backgroundComposite(String value) {\n    setProperty('${Device.cssPrefix}background-composite', value, '');\n  }\n\n  /** Gets the value of \"background-image\" */\n  String get backgroundImage =>\n    getPropertyValue('background-image');\n\n  /** Sets the value of \"background-image\" */\n  void set backgroundImage(String value) {\n    setProperty('background-image', value, '');\n  }\n\n  /** Gets the value of \"background-origin\" */\n  String get backgroundOrigin =>\n    getPropertyValue('background-origin');\n\n  /** Sets the value of \"background-origin\" */\n  void set backgroundOrigin(String value) {\n    setProperty('background-origin', value, '');\n  }\n\n  /** Gets the value of \"background-position\" */\n  String get backgroundPosition =>\n    getPropertyValue('background-position');\n\n  /** Sets the value of \"background-position\" */\n  void set backgroundPosition(String value) {\n    setProperty('background-position', value, '');\n  }\n\n  /** Gets the value of \"background-position-x\" */\n  String get backgroundPositionX =>\n    getPropertyValue('background-position-x');\n\n  /** Sets the value of \"background-position-x\" */\n  void set backgroundPositionX(String value) {\n    setProperty('background-position-x', value, '');\n  }\n\n  /** Gets the value of \"background-position-y\" */\n  String get backgroundPositionY =>\n    getPropertyValue('background-position-y');\n\n  /** Sets the value of \"background-position-y\" */\n  void set backgroundPositionY(String value) {\n    setProperty('background-position-y', value, '');\n  }\n\n  /** Gets the value of \"background-repeat\" */\n  String get backgroundRepeat =>\n    getPropertyValue('background-repeat');\n\n  /** Sets the value of \"background-repeat\" */\n  void set backgroundRepeat(String value) {\n    setProperty('background-repeat', value, '');\n  }\n\n  /** Gets the value of \"background-repeat-x\" */\n  String get backgroundRepeatX =>\n    getPropertyValue('background-repeat-x');\n\n  /** Sets the value of \"background-repeat-x\" */\n  void set backgroundRepeatX(String value) {\n    setProperty('background-repeat-x', value, '');\n  }\n\n  /** Gets the value of \"background-repeat-y\" */\n  String get backgroundRepeatY =>\n    getPropertyValue('background-repeat-y');\n\n  /** Sets the value of \"background-repeat-y\" */\n  void set backgroundRepeatY(String value) {\n    setProperty('background-repeat-y', value, '');\n  }\n\n  /** Gets the value of \"background-size\" */\n  String get backgroundSize =>\n    getPropertyValue('background-size');\n\n  /** Sets the value of \"background-size\" */\n  void set backgroundSize(String value) {\n    setProperty('background-size', value, '');\n  }\n\n  /** Gets the value of \"blend-mode\" */\n  String get blendMode =>\n    getPropertyValue('${Device.cssPrefix}blend-mode');\n\n  /** Sets the value of \"blend-mode\" */\n  void set blendMode(String value) {\n    setProperty('${Device.cssPrefix}blend-mode', value, '');\n  }\n\n  /** Gets the value of \"border\" */\n  String get border =>\n    getPropertyValue('border');\n\n  /** Sets the value of \"border\" */\n  void set border(String value) {\n    setProperty('border', value, '');\n  }\n\n  /** Gets the value of \"border-after\" */\n  String get borderAfter =>\n    getPropertyValue('${Device.cssPrefix}border-after');\n\n  /** Sets the value of \"border-after\" */\n  void set borderAfter(String value) {\n    setProperty('${Device.cssPrefix}border-after', value, '');\n  }\n\n  /** Gets the value of \"border-after-color\" */\n  String get borderAfterColor =>\n    getPropertyValue('${Device.cssPrefix}border-after-color');\n\n  /** Sets the value of \"border-after-color\" */\n  void set borderAfterColor(String value) {\n    setProperty('${Device.cssPrefix}border-after-color', value, '');\n  }\n\n  /** Gets the value of \"border-after-style\" */\n  String get borderAfterStyle =>\n    getPropertyValue('${Device.cssPrefix}border-after-style');\n\n  /** Sets the value of \"border-after-style\" */\n  void set borderAfterStyle(String value) {\n    setProperty('${Device.cssPrefix}border-after-style', value, '');\n  }\n\n  /** Gets the value of \"border-after-width\" */\n  String get borderAfterWidth =>\n    getPropertyValue('${Device.cssPrefix}border-after-width');\n\n  /** Sets the value of \"border-after-width\" */\n  void set borderAfterWidth(String value) {\n    setProperty('${Device.cssPrefix}border-after-width', value, '');\n  }\n\n  /** Gets the value of \"border-before\" */\n  String get borderBefore =>\n    getPropertyValue('${Device.cssPrefix}border-before');\n\n  /** Sets the value of \"border-before\" */\n  void set borderBefore(String value) {\n    setProperty('${Device.cssPrefix}border-before', value, '');\n  }\n\n  /** Gets the value of \"border-before-color\" */\n  String get borderBeforeColor =>\n    getPropertyValue('${Device.cssPrefix}border-before-color');\n\n  /** Sets the value of \"border-before-color\" */\n  void set borderBeforeColor(String value) {\n    setProperty('${Device.cssPrefix}border-before-color', value, '');\n  }\n\n  /** Gets the value of \"border-before-style\" */\n  String get borderBeforeStyle =>\n    getPropertyValue('${Device.cssPrefix}border-before-style');\n\n  /** Sets the value of \"border-before-style\" */\n  void set borderBeforeStyle(String value) {\n    setProperty('${Device.cssPrefix}border-before-style', value, '');\n  }\n\n  /** Gets the value of \"border-before-width\" */\n  String get borderBeforeWidth =>\n    getPropertyValue('${Device.cssPrefix}border-before-width');\n\n  /** Sets the value of \"border-before-width\" */\n  void set borderBeforeWidth(String value) {\n    setProperty('${Device.cssPrefix}border-before-width', value, '');\n  }\n\n  /** Gets the value of \"border-bottom\" */\n  String get borderBottom =>\n    getPropertyValue('border-bottom');\n\n  /** Sets the value of \"border-bottom\" */\n  void set borderBottom(String value) {\n    setProperty('border-bottom', value, '');\n  }\n\n  /** Gets the value of \"border-bottom-color\" */\n  String get borderBottomColor =>\n    getPropertyValue('border-bottom-color');\n\n  /** Sets the value of \"border-bottom-color\" */\n  void set borderBottomColor(String value) {\n    setProperty('border-bottom-color', value, '');\n  }\n\n  /** Gets the value of \"border-bottom-left-radius\" */\n  String get borderBottomLeftRadius =>\n    getPropertyValue('border-bottom-left-radius');\n\n  /** Sets the value of \"border-bottom-left-radius\" */\n  void set borderBottomLeftRadius(String value) {\n    setProperty('border-bottom-left-radius', value, '');\n  }\n\n  /** Gets the value of \"border-bottom-right-radius\" */\n  String get borderBottomRightRadius =>\n    getPropertyValue('border-bottom-right-radius');\n\n  /** Sets the value of \"border-bottom-right-radius\" */\n  void set borderBottomRightRadius(String value) {\n    setProperty('border-bottom-right-radius', value, '');\n  }\n\n  /** Gets the value of \"border-bottom-style\" */\n  String get borderBottomStyle =>\n    getPropertyValue('border-bottom-style');\n\n  /** Sets the value of \"border-bottom-style\" */\n  void set borderBottomStyle(String value) {\n    setProperty('border-bottom-style', value, '');\n  }\n\n  /** Gets the value of \"border-bottom-width\" */\n  String get borderBottomWidth =>\n    getPropertyValue('border-bottom-width');\n\n  /** Sets the value of \"border-bottom-width\" */\n  void set borderBottomWidth(String value) {\n    setProperty('border-bottom-width', value, '');\n  }\n\n  /** Gets the value of \"border-collapse\" */\n  String get borderCollapse =>\n    getPropertyValue('border-collapse');\n\n  /** Sets the value of \"border-collapse\" */\n  void set borderCollapse(String value) {\n    setProperty('border-collapse', value, '');\n  }\n\n  /** Gets the value of \"border-color\" */\n  String get borderColor =>\n    getPropertyValue('border-color');\n\n  /** Sets the value of \"border-color\" */\n  void set borderColor(String value) {\n    setProperty('border-color', value, '');\n  }\n\n  /** Gets the value of \"border-end\" */\n  String get borderEnd =>\n    getPropertyValue('${Device.cssPrefix}border-end');\n\n  /** Sets the value of \"border-end\" */\n  void set borderEnd(String value) {\n    setProperty('${Device.cssPrefix}border-end', value, '');\n  }\n\n  /** Gets the value of \"border-end-color\" */\n  String get borderEndColor =>\n    getPropertyValue('${Device.cssPrefix}border-end-color');\n\n  /** Sets the value of \"border-end-color\" */\n  void set borderEndColor(String value) {\n    setProperty('${Device.cssPrefix}border-end-color', value, '');\n  }\n\n  /** Gets the value of \"border-end-style\" */\n  String get borderEndStyle =>\n    getPropertyValue('${Device.cssPrefix}border-end-style');\n\n  /** Sets the value of \"border-end-style\" */\n  void set borderEndStyle(String value) {\n    setProperty('${Device.cssPrefix}border-end-style', value, '');\n  }\n\n  /** Gets the value of \"border-end-width\" */\n  String get borderEndWidth =>\n    getPropertyValue('${Device.cssPrefix}border-end-width');\n\n  /** Sets the value of \"border-end-width\" */\n  void set borderEndWidth(String value) {\n    setProperty('${Device.cssPrefix}border-end-width', value, '');\n  }\n\n  /** Gets the value of \"border-fit\" */\n  String get borderFit =>\n    getPropertyValue('${Device.cssPrefix}border-fit');\n\n  /** Sets the value of \"border-fit\" */\n  void set borderFit(String value) {\n    setProperty('${Device.cssPrefix}border-fit', value, '');\n  }\n\n  /** Gets the value of \"border-horizontal-spacing\" */\n  String get borderHorizontalSpacing =>\n    getPropertyValue('${Device.cssPrefix}border-horizontal-spacing');\n\n  /** Sets the value of \"border-horizontal-spacing\" */\n  void set borderHorizontalSpacing(String value) {\n    setProperty('${Device.cssPrefix}border-horizontal-spacing', value, '');\n  }\n\n  /** Gets the value of \"border-image\" */\n  String get borderImage =>\n    getPropertyValue('border-image');\n\n  /** Sets the value of \"border-image\" */\n  void set borderImage(String value) {\n    setProperty('border-image', value, '');\n  }\n\n  /** Gets the value of \"border-image-outset\" */\n  String get borderImageOutset =>\n    getPropertyValue('border-image-outset');\n\n  /** Sets the value of \"border-image-outset\" */\n  void set borderImageOutset(String value) {\n    setProperty('border-image-outset', value, '');\n  }\n\n  /** Gets the value of \"border-image-repeat\" */\n  String get borderImageRepeat =>\n    getPropertyValue('border-image-repeat');\n\n  /** Sets the value of \"border-image-repeat\" */\n  void set borderImageRepeat(String value) {\n    setProperty('border-image-repeat', value, '');\n  }\n\n  /** Gets the value of \"border-image-slice\" */\n  String get borderImageSlice =>\n    getPropertyValue('border-image-slice');\n\n  /** Sets the value of \"border-image-slice\" */\n  void set borderImageSlice(String value) {\n    setProperty('border-image-slice', value, '');\n  }\n\n  /** Gets the value of \"border-image-source\" */\n  String get borderImageSource =>\n    getPropertyValue('border-image-source');\n\n  /** Sets the value of \"border-image-source\" */\n  void set borderImageSource(String value) {\n    setProperty('border-image-source', value, '');\n  }\n\n  /** Gets the value of \"border-image-width\" */\n  String get borderImageWidth =>\n    getPropertyValue('border-image-width');\n\n  /** Sets the value of \"border-image-width\" */\n  void set borderImageWidth(String value) {\n    setProperty('border-image-width', value, '');\n  }\n\n  /** Gets the value of \"border-left\" */\n  String get borderLeft =>\n    getPropertyValue('border-left');\n\n  /** Sets the value of \"border-left\" */\n  void set borderLeft(String value) {\n    setProperty('border-left', value, '');\n  }\n\n  /** Gets the value of \"border-left-color\" */\n  String get borderLeftColor =>\n    getPropertyValue('border-left-color');\n\n  /** Sets the value of \"border-left-color\" */\n  void set borderLeftColor(String value) {\n    setProperty('border-left-color', value, '');\n  }\n\n  /** Gets the value of \"border-left-style\" */\n  String get borderLeftStyle =>\n    getPropertyValue('border-left-style');\n\n  /** Sets the value of \"border-left-style\" */\n  void set borderLeftStyle(String value) {\n    setProperty('border-left-style', value, '');\n  }\n\n  /** Gets the value of \"border-left-width\" */\n  String get borderLeftWidth =>\n    getPropertyValue('border-left-width');\n\n  /** Sets the value of \"border-left-width\" */\n  void set borderLeftWidth(String value) {\n    setProperty('border-left-width', value, '');\n  }\n\n  /** Gets the value of \"border-radius\" */\n  String get borderRadius =>\n    getPropertyValue('border-radius');\n\n  /** Sets the value of \"border-radius\" */\n  void set borderRadius(String value) {\n    setProperty('border-radius', value, '');\n  }\n\n  /** Gets the value of \"border-right\" */\n  String get borderRight =>\n    getPropertyValue('border-right');\n\n  /** Sets the value of \"border-right\" */\n  void set borderRight(String value) {\n    setProperty('border-right', value, '');\n  }\n\n  /** Gets the value of \"border-right-color\" */\n  String get borderRightColor =>\n    getPropertyValue('border-right-color');\n\n  /** Sets the value of \"border-right-color\" */\n  void set borderRightColor(String value) {\n    setProperty('border-right-color', value, '');\n  }\n\n  /** Gets the value of \"border-right-style\" */\n  String get borderRightStyle =>\n    getPropertyValue('border-right-style');\n\n  /** Sets the value of \"border-right-style\" */\n  void set borderRightStyle(String value) {\n    setProperty('border-right-style', value, '');\n  }\n\n  /** Gets the value of \"border-right-width\" */\n  String get borderRightWidth =>\n    getPropertyValue('border-right-width');\n\n  /** Sets the value of \"border-right-width\" */\n  void set borderRightWidth(String value) {\n    setProperty('border-right-width', value, '');\n  }\n\n  /** Gets the value of \"border-spacing\" */\n  String get borderSpacing =>\n    getPropertyValue('border-spacing');\n\n  /** Sets the value of \"border-spacing\" */\n  void set borderSpacing(String value) {\n    setProperty('border-spacing', value, '');\n  }\n\n  /** Gets the value of \"border-start\" */\n  String get borderStart =>\n    getPropertyValue('${Device.cssPrefix}border-start');\n\n  /** Sets the value of \"border-start\" */\n  void set borderStart(String value) {\n    setProperty('${Device.cssPrefix}border-start', value, '');\n  }\n\n  /** Gets the value of \"border-start-color\" */\n  String get borderStartColor =>\n    getPropertyValue('${Device.cssPrefix}border-start-color');\n\n  /** Sets the value of \"border-start-color\" */\n  void set borderStartColor(String value) {\n    setProperty('${Device.cssPrefix}border-start-color', value, '');\n  }\n\n  /** Gets the value of \"border-start-style\" */\n  String get borderStartStyle =>\n    getPropertyValue('${Device.cssPrefix}border-start-style');\n\n  /** Sets the value of \"border-start-style\" */\n  void set borderStartStyle(String value) {\n    setProperty('${Device.cssPrefix}border-start-style', value, '');\n  }\n\n  /** Gets the value of \"border-start-width\" */\n  String get borderStartWidth =>\n    getPropertyValue('${Device.cssPrefix}border-start-width');\n\n  /** Sets the value of \"border-start-width\" */\n  void set borderStartWidth(String value) {\n    setProperty('${Device.cssPrefix}border-start-width', value, '');\n  }\n\n  /** Gets the value of \"border-style\" */\n  String get borderStyle =>\n    getPropertyValue('border-style');\n\n  /** Sets the value of \"border-style\" */\n  void set borderStyle(String value) {\n    setProperty('border-style', value, '');\n  }\n\n  /** Gets the value of \"border-top\" */\n  String get borderTop =>\n    getPropertyValue('border-top');\n\n  /** Sets the value of \"border-top\" */\n  void set borderTop(String value) {\n    setProperty('border-top', value, '');\n  }\n\n  /** Gets the value of \"border-top-color\" */\n  String get borderTopColor =>\n    getPropertyValue('border-top-color');\n\n  /** Sets the value of \"border-top-color\" */\n  void set borderTopColor(String value) {\n    setProperty('border-top-color', value, '');\n  }\n\n  /** Gets the value of \"border-top-left-radius\" */\n  String get borderTopLeftRadius =>\n    getPropertyValue('border-top-left-radius');\n\n  /** Sets the value of \"border-top-left-radius\" */\n  void set borderTopLeftRadius(String value) {\n    setProperty('border-top-left-radius', value, '');\n  }\n\n  /** Gets the value of \"border-top-right-radius\" */\n  String get borderTopRightRadius =>\n    getPropertyValue('border-top-right-radius');\n\n  /** Sets the value of \"border-top-right-radius\" */\n  void set borderTopRightRadius(String value) {\n    setProperty('border-top-right-radius', value, '');\n  }\n\n  /** Gets the value of \"border-top-style\" */\n  String get borderTopStyle =>\n    getPropertyValue('border-top-style');\n\n  /** Sets the value of \"border-top-style\" */\n  void set borderTopStyle(String value) {\n    setProperty('border-top-style', value, '');\n  }\n\n  /** Gets the value of \"border-top-width\" */\n  String get borderTopWidth =>\n    getPropertyValue('border-top-width');\n\n  /** Sets the value of \"border-top-width\" */\n  void set borderTopWidth(String value) {\n    setProperty('border-top-width', value, '');\n  }\n\n  /** Gets the value of \"border-vertical-spacing\" */\n  String get borderVerticalSpacing =>\n    getPropertyValue('${Device.cssPrefix}border-vertical-spacing');\n\n  /** Sets the value of \"border-vertical-spacing\" */\n  void set borderVerticalSpacing(String value) {\n    setProperty('${Device.cssPrefix}border-vertical-spacing', value, '');\n  }\n\n  /** Gets the value of \"border-width\" */\n  String get borderWidth =>\n    getPropertyValue('border-width');\n\n  /** Sets the value of \"border-width\" */\n  void set borderWidth(String value) {\n    setProperty('border-width', value, '');\n  }\n\n  /** Gets the value of \"bottom\" */\n  String get bottom =>\n    getPropertyValue('bottom');\n\n  /** Sets the value of \"bottom\" */\n  void set bottom(String value) {\n    setProperty('bottom', value, '');\n  }\n\n  /** Gets the value of \"box-align\" */\n  String get boxAlign =>\n    getPropertyValue('${Device.cssPrefix}box-align');\n\n  /** Sets the value of \"box-align\" */\n  void set boxAlign(String value) {\n    setProperty('${Device.cssPrefix}box-align', value, '');\n  }\n\n  /** Gets the value of \"box-decoration-break\" */\n  String get boxDecorationBreak =>\n    getPropertyValue('${Device.cssPrefix}box-decoration-break');\n\n  /** Sets the value of \"box-decoration-break\" */\n  void set boxDecorationBreak(String value) {\n    setProperty('${Device.cssPrefix}box-decoration-break', value, '');\n  }\n\n  /** Gets the value of \"box-direction\" */\n  String get boxDirection =>\n    getPropertyValue('${Device.cssPrefix}box-direction');\n\n  /** Sets the value of \"box-direction\" */\n  void set boxDirection(String value) {\n    setProperty('${Device.cssPrefix}box-direction', value, '');\n  }\n\n  /** Gets the value of \"box-flex\" */\n  String get boxFlex =>\n    getPropertyValue('${Device.cssPrefix}box-flex');\n\n  /** Sets the value of \"box-flex\" */\n  void set boxFlex(String value) {\n    setProperty('${Device.cssPrefix}box-flex', value, '');\n  }\n\n  /** Gets the value of \"box-flex-group\" */\n  String get boxFlexGroup =>\n    getPropertyValue('${Device.cssPrefix}box-flex-group');\n\n  /** Sets the value of \"box-flex-group\" */\n  void set boxFlexGroup(String value) {\n    setProperty('${Device.cssPrefix}box-flex-group', value, '');\n  }\n\n  /** Gets the value of \"box-lines\" */\n  String get boxLines =>\n    getPropertyValue('${Device.cssPrefix}box-lines');\n\n  /** Sets the value of \"box-lines\" */\n  void set boxLines(String value) {\n    setProperty('${Device.cssPrefix}box-lines', value, '');\n  }\n\n  /** Gets the value of \"box-ordinal-group\" */\n  String get boxOrdinalGroup =>\n    getPropertyValue('${Device.cssPrefix}box-ordinal-group');\n\n  /** Sets the value of \"box-ordinal-group\" */\n  void set boxOrdinalGroup(String value) {\n    setProperty('${Device.cssPrefix}box-ordinal-group', value, '');\n  }\n\n  /** Gets the value of \"box-orient\" */\n  String get boxOrient =>\n    getPropertyValue('${Device.cssPrefix}box-orient');\n\n  /** Sets the value of \"box-orient\" */\n  void set boxOrient(String value) {\n    setProperty('${Device.cssPrefix}box-orient', value, '');\n  }\n\n  /** Gets the value of \"box-pack\" */\n  String get boxPack =>\n    getPropertyValue('${Device.cssPrefix}box-pack');\n\n  /** Sets the value of \"box-pack\" */\n  void set boxPack(String value) {\n    setProperty('${Device.cssPrefix}box-pack', value, '');\n  }\n\n  /** Gets the value of \"box-reflect\" */\n  String get boxReflect =>\n    getPropertyValue('${Device.cssPrefix}box-reflect');\n\n  /** Sets the value of \"box-reflect\" */\n  void set boxReflect(String value) {\n    setProperty('${Device.cssPrefix}box-reflect', value, '');\n  }\n\n  /** Gets the value of \"box-shadow\" */\n  String get boxShadow =>\n    getPropertyValue('box-shadow');\n\n  /** Sets the value of \"box-shadow\" */\n  void set boxShadow(String value) {\n    setProperty('box-shadow', value, '');\n  }\n\n  /** Gets the value of \"box-sizing\" */\n  String get boxSizing =>\n    getPropertyValue('box-sizing');\n\n  /** Sets the value of \"box-sizing\" */\n  void set boxSizing(String value) {\n    setProperty('box-sizing', value, '');\n  }\n\n  /** Gets the value of \"caption-side\" */\n  String get captionSide =>\n    getPropertyValue('caption-side');\n\n  /** Sets the value of \"caption-side\" */\n  void set captionSide(String value) {\n    setProperty('caption-side', value, '');\n  }\n\n  /** Gets the value of \"clear\" */\n  String get clear =>\n    getPropertyValue('clear');\n\n  /** Sets the value of \"clear\" */\n  void set clear(String value) {\n    setProperty('clear', value, '');\n  }\n\n  /** Gets the value of \"clip\" */\n  String get clip =>\n    getPropertyValue('clip');\n\n  /** Sets the value of \"clip\" */\n  void set clip(String value) {\n    setProperty('clip', value, '');\n  }\n\n  /** Gets the value of \"clip-path\" */\n  String get clipPath =>\n    getPropertyValue('${Device.cssPrefix}clip-path');\n\n  /** Sets the value of \"clip-path\" */\n  void set clipPath(String value) {\n    setProperty('${Device.cssPrefix}clip-path', value, '');\n  }\n\n  /** Gets the value of \"color\" */\n  String get color =>\n    getPropertyValue('color');\n\n  /** Sets the value of \"color\" */\n  void set color(String value) {\n    setProperty('color', value, '');\n  }\n\n  /** Gets the value of \"color-correction\" */\n  String get colorCorrection =>\n    getPropertyValue('${Device.cssPrefix}color-correction');\n\n  /** Sets the value of \"color-correction\" */\n  void set colorCorrection(String value) {\n    setProperty('${Device.cssPrefix}color-correction', value, '');\n  }\n\n  /** Gets the value of \"column-axis\" */\n  String get columnAxis =>\n    getPropertyValue('${Device.cssPrefix}column-axis');\n\n  /** Sets the value of \"column-axis\" */\n  void set columnAxis(String value) {\n    setProperty('${Device.cssPrefix}column-axis', value, '');\n  }\n\n  /** Gets the value of \"column-break-after\" */\n  String get columnBreakAfter =>\n    getPropertyValue('${Device.cssPrefix}column-break-after');\n\n  /** Sets the value of \"column-break-after\" */\n  void set columnBreakAfter(String value) {\n    setProperty('${Device.cssPrefix}column-break-after', value, '');\n  }\n\n  /** Gets the value of \"column-break-before\" */\n  String get columnBreakBefore =>\n    getPropertyValue('${Device.cssPrefix}column-break-before');\n\n  /** Sets the value of \"column-break-before\" */\n  void set columnBreakBefore(String value) {\n    setProperty('${Device.cssPrefix}column-break-before', value, '');\n  }\n\n  /** Gets the value of \"column-break-inside\" */\n  String get columnBreakInside =>\n    getPropertyValue('${Device.cssPrefix}column-break-inside');\n\n  /** Sets the value of \"column-break-inside\" */\n  void set columnBreakInside(String value) {\n    setProperty('${Device.cssPrefix}column-break-inside', value, '');\n  }\n\n  /** Gets the value of \"column-count\" */\n  String get columnCount =>\n    getPropertyValue('${Device.cssPrefix}column-count');\n\n  /** Sets the value of \"column-count\" */\n  void set columnCount(String value) {\n    setProperty('${Device.cssPrefix}column-count', value, '');\n  }\n\n  /** Gets the value of \"column-gap\" */\n  String get columnGap =>\n    getPropertyValue('${Device.cssPrefix}column-gap');\n\n  /** Sets the value of \"column-gap\" */\n  void set columnGap(String value) {\n    setProperty('${Device.cssPrefix}column-gap', value, '');\n  }\n\n  /** Gets the value of \"column-progression\" */\n  String get columnProgression =>\n    getPropertyValue('${Device.cssPrefix}column-progression');\n\n  /** Sets the value of \"column-progression\" */\n  void set columnProgression(String value) {\n    setProperty('${Device.cssPrefix}column-progression', value, '');\n  }\n\n  /** Gets the value of \"column-rule\" */\n  String get columnRule =>\n    getPropertyValue('${Device.cssPrefix}column-rule');\n\n  /** Sets the value of \"column-rule\" */\n  void set columnRule(String value) {\n    setProperty('${Device.cssPrefix}column-rule', value, '');\n  }\n\n  /** Gets the value of \"column-rule-color\" */\n  String get columnRuleColor =>\n    getPropertyValue('${Device.cssPrefix}column-rule-color');\n\n  /** Sets the value of \"column-rule-color\" */\n  void set columnRuleColor(String value) {\n    setProperty('${Device.cssPrefix}column-rule-color', value, '');\n  }\n\n  /** Gets the value of \"column-rule-style\" */\n  String get columnRuleStyle =>\n    getPropertyValue('${Device.cssPrefix}column-rule-style');\n\n  /** Sets the value of \"column-rule-style\" */\n  void set columnRuleStyle(String value) {\n    setProperty('${Device.cssPrefix}column-rule-style', value, '');\n  }\n\n  /** Gets the value of \"column-rule-width\" */\n  String get columnRuleWidth =>\n    getPropertyValue('${Device.cssPrefix}column-rule-width');\n\n  /** Sets the value of \"column-rule-width\" */\n  void set columnRuleWidth(String value) {\n    setProperty('${Device.cssPrefix}column-rule-width', value, '');\n  }\n\n  /** Gets the value of \"column-span\" */\n  String get columnSpan =>\n    getPropertyValue('${Device.cssPrefix}column-span');\n\n  /** Sets the value of \"column-span\" */\n  void set columnSpan(String value) {\n    setProperty('${Device.cssPrefix}column-span', value, '');\n  }\n\n  /** Gets the value of \"column-width\" */\n  String get columnWidth =>\n    getPropertyValue('${Device.cssPrefix}column-width');\n\n  /** Sets the value of \"column-width\" */\n  void set columnWidth(String value) {\n    setProperty('${Device.cssPrefix}column-width', value, '');\n  }\n\n  /** Gets the value of \"columns\" */\n  String get columns =>\n    getPropertyValue('${Device.cssPrefix}columns');\n\n  /** Sets the value of \"columns\" */\n  void set columns(String value) {\n    setProperty('${Device.cssPrefix}columns', value, '');\n  }\n\n  /** Gets the value of \"content\" */\n  String get content =>\n    getPropertyValue('content');\n\n  /** Sets the value of \"content\" */\n  void set content(String value) {\n    setProperty('content', value, '');\n  }\n\n  /** Gets the value of \"counter-increment\" */\n  String get counterIncrement =>\n    getPropertyValue('counter-increment');\n\n  /** Sets the value of \"counter-increment\" */\n  void set counterIncrement(String value) {\n    setProperty('counter-increment', value, '');\n  }\n\n  /** Gets the value of \"counter-reset\" */\n  String get counterReset =>\n    getPropertyValue('counter-reset');\n\n  /** Sets the value of \"counter-reset\" */\n  void set counterReset(String value) {\n    setProperty('counter-reset', value, '');\n  }\n\n  /** Gets the value of \"cursor\" */\n  String get cursor =>\n    getPropertyValue('cursor');\n\n  /** Sets the value of \"cursor\" */\n  void set cursor(String value) {\n    setProperty('cursor', value, '');\n  }\n\n  /** Gets the value of \"dashboard-region\" */\n  String get dashboardRegion =>\n    getPropertyValue('${Device.cssPrefix}dashboard-region');\n\n  /** Sets the value of \"dashboard-region\" */\n  void set dashboardRegion(String value) {\n    setProperty('${Device.cssPrefix}dashboard-region', value, '');\n  }\n\n  /** Gets the value of \"direction\" */\n  String get direction =>\n    getPropertyValue('direction');\n\n  /** Sets the value of \"direction\" */\n  void set direction(String value) {\n    setProperty('direction', value, '');\n  }\n\n  /** Gets the value of \"display\" */\n  String get display =>\n    getPropertyValue('display');\n\n  /** Sets the value of \"display\" */\n  void set display(String value) {\n    setProperty('display', value, '');\n  }\n\n  /** Gets the value of \"empty-cells\" */\n  String get emptyCells =>\n    getPropertyValue('empty-cells');\n\n  /** Sets the value of \"empty-cells\" */\n  void set emptyCells(String value) {\n    setProperty('empty-cells', value, '');\n  }\n\n  /** Gets the value of \"filter\" */\n  String get filter =>\n    getPropertyValue('${Device.cssPrefix}filter');\n\n  /** Sets the value of \"filter\" */\n  void set filter(String value) {\n    setProperty('${Device.cssPrefix}filter', value, '');\n  }\n\n  /** Gets the value of \"flex\" */\n  String get flex =>\n    getPropertyValue('${Device.cssPrefix}flex');\n\n  /** Sets the value of \"flex\" */\n  void set flex(String value) {\n    setProperty('${Device.cssPrefix}flex', value, '');\n  }\n\n  /** Gets the value of \"flex-basis\" */\n  String get flexBasis =>\n    getPropertyValue('${Device.cssPrefix}flex-basis');\n\n  /** Sets the value of \"flex-basis\" */\n  void set flexBasis(String value) {\n    setProperty('${Device.cssPrefix}flex-basis', value, '');\n  }\n\n  /** Gets the value of \"flex-direction\" */\n  String get flexDirection =>\n    getPropertyValue('${Device.cssPrefix}flex-direction');\n\n  /** Sets the value of \"flex-direction\" */\n  void set flexDirection(String value) {\n    setProperty('${Device.cssPrefix}flex-direction', value, '');\n  }\n\n  /** Gets the value of \"flex-flow\" */\n  String get flexFlow =>\n    getPropertyValue('${Device.cssPrefix}flex-flow');\n\n  /** Sets the value of \"flex-flow\" */\n  void set flexFlow(String value) {\n    setProperty('${Device.cssPrefix}flex-flow', value, '');\n  }\n\n  /** Gets the value of \"flex-grow\" */\n  String get flexGrow =>\n    getPropertyValue('${Device.cssPrefix}flex-grow');\n\n  /** Sets the value of \"flex-grow\" */\n  void set flexGrow(String value) {\n    setProperty('${Device.cssPrefix}flex-grow', value, '');\n  }\n\n  /** Gets the value of \"flex-shrink\" */\n  String get flexShrink =>\n    getPropertyValue('${Device.cssPrefix}flex-shrink');\n\n  /** Sets the value of \"flex-shrink\" */\n  void set flexShrink(String value) {\n    setProperty('${Device.cssPrefix}flex-shrink', value, '');\n  }\n\n  /** Gets the value of \"flex-wrap\" */\n  String get flexWrap =>\n    getPropertyValue('${Device.cssPrefix}flex-wrap');\n\n  /** Sets the value of \"flex-wrap\" */\n  void set flexWrap(String value) {\n    setProperty('${Device.cssPrefix}flex-wrap', value, '');\n  }\n\n  /** Gets the value of \"float\" */\n  String get float =>\n    getPropertyValue('float');\n\n  /** Sets the value of \"float\" */\n  void set float(String value) {\n    setProperty('float', value, '');\n  }\n\n  /** Gets the value of \"flow-from\" */\n  String get flowFrom =>\n    getPropertyValue('${Device.cssPrefix}flow-from');\n\n  /** Sets the value of \"flow-from\" */\n  void set flowFrom(String value) {\n    setProperty('${Device.cssPrefix}flow-from', value, '');\n  }\n\n  /** Gets the value of \"flow-into\" */\n  String get flowInto =>\n    getPropertyValue('${Device.cssPrefix}flow-into');\n\n  /** Sets the value of \"flow-into\" */\n  void set flowInto(String value) {\n    setProperty('${Device.cssPrefix}flow-into', value, '');\n  }\n\n  /** Gets the value of \"font\" */\n  String get font =>\n    getPropertyValue('font');\n\n  /** Sets the value of \"font\" */\n  void set font(String value) {\n    setProperty('font', value, '');\n  }\n\n  /** Gets the value of \"font-family\" */\n  String get fontFamily =>\n    getPropertyValue('font-family');\n\n  /** Sets the value of \"font-family\" */\n  void set fontFamily(String value) {\n    setProperty('font-family', value, '');\n  }\n\n  /** Gets the value of \"font-feature-settings\" */\n  String get fontFeatureSettings =>\n    getPropertyValue('${Device.cssPrefix}font-feature-settings');\n\n  /** Sets the value of \"font-feature-settings\" */\n  void set fontFeatureSettings(String value) {\n    setProperty('${Device.cssPrefix}font-feature-settings', value, '');\n  }\n\n  /** Gets the value of \"font-kerning\" */\n  String get fontKerning =>\n    getPropertyValue('${Device.cssPrefix}font-kerning');\n\n  /** Sets the value of \"font-kerning\" */\n  void set fontKerning(String value) {\n    setProperty('${Device.cssPrefix}font-kerning', value, '');\n  }\n\n  /** Gets the value of \"font-size\" */\n  String get fontSize =>\n    getPropertyValue('font-size');\n\n  /** Sets the value of \"font-size\" */\n  void set fontSize(String value) {\n    setProperty('font-size', value, '');\n  }\n\n  /** Gets the value of \"font-size-delta\" */\n  String get fontSizeDelta =>\n    getPropertyValue('${Device.cssPrefix}font-size-delta');\n\n  /** Sets the value of \"font-size-delta\" */\n  void set fontSizeDelta(String value) {\n    setProperty('${Device.cssPrefix}font-size-delta', value, '');\n  }\n\n  /** Gets the value of \"font-smoothing\" */\n  String get fontSmoothing =>\n    getPropertyValue('${Device.cssPrefix}font-smoothing');\n\n  /** Sets the value of \"font-smoothing\" */\n  void set fontSmoothing(String value) {\n    setProperty('${Device.cssPrefix}font-smoothing', value, '');\n  }\n\n  /** Gets the value of \"font-stretch\" */\n  String get fontStretch =>\n    getPropertyValue('font-stretch');\n\n  /** Sets the value of \"font-stretch\" */\n  void set fontStretch(String value) {\n    setProperty('font-stretch', value, '');\n  }\n\n  /** Gets the value of \"font-style\" */\n  String get fontStyle =>\n    getPropertyValue('font-style');\n\n  /** Sets the value of \"font-style\" */\n  void set fontStyle(String value) {\n    setProperty('font-style', value, '');\n  }\n\n  /** Gets the value of \"font-variant\" */\n  String get fontVariant =>\n    getPropertyValue('font-variant');\n\n  /** Sets the value of \"font-variant\" */\n  void set fontVariant(String value) {\n    setProperty('font-variant', value, '');\n  }\n\n  /** Gets the value of \"font-variant-ligatures\" */\n  String get fontVariantLigatures =>\n    getPropertyValue('${Device.cssPrefix}font-variant-ligatures');\n\n  /** Sets the value of \"font-variant-ligatures\" */\n  void set fontVariantLigatures(String value) {\n    setProperty('${Device.cssPrefix}font-variant-ligatures', value, '');\n  }\n\n  /** Gets the value of \"font-weight\" */\n  String get fontWeight =>\n    getPropertyValue('font-weight');\n\n  /** Sets the value of \"font-weight\" */\n  void set fontWeight(String value) {\n    setProperty('font-weight', value, '');\n  }\n\n  /** Gets the value of \"grid-column\" */\n  String get gridColumn =>\n    getPropertyValue('${Device.cssPrefix}grid-column');\n\n  /** Sets the value of \"grid-column\" */\n  void set gridColumn(String value) {\n    setProperty('${Device.cssPrefix}grid-column', value, '');\n  }\n\n  /** Gets the value of \"grid-columns\" */\n  String get gridColumns =>\n    getPropertyValue('${Device.cssPrefix}grid-columns');\n\n  /** Sets the value of \"grid-columns\" */\n  void set gridColumns(String value) {\n    setProperty('${Device.cssPrefix}grid-columns', value, '');\n  }\n\n  /** Gets the value of \"grid-row\" */\n  String get gridRow =>\n    getPropertyValue('${Device.cssPrefix}grid-row');\n\n  /** Sets the value of \"grid-row\" */\n  void set gridRow(String value) {\n    setProperty('${Device.cssPrefix}grid-row', value, '');\n  }\n\n  /** Gets the value of \"grid-rows\" */\n  String get gridRows =>\n    getPropertyValue('${Device.cssPrefix}grid-rows');\n\n  /** Sets the value of \"grid-rows\" */\n  void set gridRows(String value) {\n    setProperty('${Device.cssPrefix}grid-rows', value, '');\n  }\n\n  /** Gets the value of \"height\" */\n  String get height =>\n    getPropertyValue('height');\n\n  /** Sets the value of \"height\" */\n  void set height(String value) {\n    setProperty('height', value, '');\n  }\n\n  /** Gets the value of \"highlight\" */\n  String get highlight =>\n    getPropertyValue('${Device.cssPrefix}highlight');\n\n  /** Sets the value of \"highlight\" */\n  void set highlight(String value) {\n    setProperty('${Device.cssPrefix}highlight', value, '');\n  }\n\n  /** Gets the value of \"hyphenate-character\" */\n  String get hyphenateCharacter =>\n    getPropertyValue('${Device.cssPrefix}hyphenate-character');\n\n  /** Sets the value of \"hyphenate-character\" */\n  void set hyphenateCharacter(String value) {\n    setProperty('${Device.cssPrefix}hyphenate-character', value, '');\n  }\n\n  /** Gets the value of \"hyphenate-limit-after\" */\n  String get hyphenateLimitAfter =>\n    getPropertyValue('${Device.cssPrefix}hyphenate-limit-after');\n\n  /** Sets the value of \"hyphenate-limit-after\" */\n  void set hyphenateLimitAfter(String value) {\n    setProperty('${Device.cssPrefix}hyphenate-limit-after', value, '');\n  }\n\n  /** Gets the value of \"hyphenate-limit-before\" */\n  String get hyphenateLimitBefore =>\n    getPropertyValue('${Device.cssPrefix}hyphenate-limit-before');\n\n  /** Sets the value of \"hyphenate-limit-before\" */\n  void set hyphenateLimitBefore(String value) {\n    setProperty('${Device.cssPrefix}hyphenate-limit-before', value, '');\n  }\n\n  /** Gets the value of \"hyphenate-limit-lines\" */\n  String get hyphenateLimitLines =>\n    getPropertyValue('${Device.cssPrefix}hyphenate-limit-lines');\n\n  /** Sets the value of \"hyphenate-limit-lines\" */\n  void set hyphenateLimitLines(String value) {\n    setProperty('${Device.cssPrefix}hyphenate-limit-lines', value, '');\n  }\n\n  /** Gets the value of \"hyphens\" */\n  String get hyphens =>\n    getPropertyValue('${Device.cssPrefix}hyphens');\n\n  /** Sets the value of \"hyphens\" */\n  void set hyphens(String value) {\n    setProperty('${Device.cssPrefix}hyphens', value, '');\n  }\n\n  /** Gets the value of \"image-orientation\" */\n  String get imageOrientation =>\n    getPropertyValue('image-orientation');\n\n  /** Sets the value of \"image-orientation\" */\n  void set imageOrientation(String value) {\n    setProperty('image-orientation', value, '');\n  }\n\n  /** Gets the value of \"image-rendering\" */\n  String get imageRendering =>\n    getPropertyValue('image-rendering');\n\n  /** Sets the value of \"image-rendering\" */\n  void set imageRendering(String value) {\n    setProperty('image-rendering', value, '');\n  }\n\n  /** Gets the value of \"image-resolution\" */\n  String get imageResolution =>\n    getPropertyValue('image-resolution');\n\n  /** Sets the value of \"image-resolution\" */\n  void set imageResolution(String value) {\n    setProperty('image-resolution', value, '');\n  }\n\n  /** Gets the value of \"justify-content\" */\n  String get justifyContent =>\n    getPropertyValue('${Device.cssPrefix}justify-content');\n\n  /** Sets the value of \"justify-content\" */\n  void set justifyContent(String value) {\n    setProperty('${Device.cssPrefix}justify-content', value, '');\n  }\n\n  /** Gets the value of \"left\" */\n  String get left =>\n    getPropertyValue('left');\n\n  /** Sets the value of \"left\" */\n  void set left(String value) {\n    setProperty('left', value, '');\n  }\n\n  /** Gets the value of \"letter-spacing\" */\n  String get letterSpacing =>\n    getPropertyValue('letter-spacing');\n\n  /** Sets the value of \"letter-spacing\" */\n  void set letterSpacing(String value) {\n    setProperty('letter-spacing', value, '');\n  }\n\n  /** Gets the value of \"line-align\" */\n  String get lineAlign =>\n    getPropertyValue('${Device.cssPrefix}line-align');\n\n  /** Sets the value of \"line-align\" */\n  void set lineAlign(String value) {\n    setProperty('${Device.cssPrefix}line-align', value, '');\n  }\n\n  /** Gets the value of \"line-box-contain\" */\n  String get lineBoxContain =>\n    getPropertyValue('${Device.cssPrefix}line-box-contain');\n\n  /** Sets the value of \"line-box-contain\" */\n  void set lineBoxContain(String value) {\n    setProperty('${Device.cssPrefix}line-box-contain', value, '');\n  }\n\n  /** Gets the value of \"line-break\" */\n  String get lineBreak =>\n    getPropertyValue('${Device.cssPrefix}line-break');\n\n  /** Sets the value of \"line-break\" */\n  void set lineBreak(String value) {\n    setProperty('${Device.cssPrefix}line-break', value, '');\n  }\n\n  /** Gets the value of \"line-clamp\" */\n  String get lineClamp =>\n    getPropertyValue('${Device.cssPrefix}line-clamp');\n\n  /** Sets the value of \"line-clamp\" */\n  void set lineClamp(String value) {\n    setProperty('${Device.cssPrefix}line-clamp', value, '');\n  }\n\n  /** Gets the value of \"line-grid\" */\n  String get lineGrid =>\n    getPropertyValue('${Device.cssPrefix}line-grid');\n\n  /** Sets the value of \"line-grid\" */\n  void set lineGrid(String value) {\n    setProperty('${Device.cssPrefix}line-grid', value, '');\n  }\n\n  /** Gets the value of \"line-height\" */\n  String get lineHeight =>\n    getPropertyValue('line-height');\n\n  /** Sets the value of \"line-height\" */\n  void set lineHeight(String value) {\n    setProperty('line-height', value, '');\n  }\n\n  /** Gets the value of \"line-snap\" */\n  String get lineSnap =>\n    getPropertyValue('${Device.cssPrefix}line-snap');\n\n  /** Sets the value of \"line-snap\" */\n  void set lineSnap(String value) {\n    setProperty('${Device.cssPrefix}line-snap', value, '');\n  }\n\n  /** Gets the value of \"list-style\" */\n  String get listStyle =>\n    getPropertyValue('list-style');\n\n  /** Sets the value of \"list-style\" */\n  void set listStyle(String value) {\n    setProperty('list-style', value, '');\n  }\n\n  /** Gets the value of \"list-style-image\" */\n  String get listStyleImage =>\n    getPropertyValue('list-style-image');\n\n  /** Sets the value of \"list-style-image\" */\n  void set listStyleImage(String value) {\n    setProperty('list-style-image', value, '');\n  }\n\n  /** Gets the value of \"list-style-position\" */\n  String get listStylePosition =>\n    getPropertyValue('list-style-position');\n\n  /** Sets the value of \"list-style-position\" */\n  void set listStylePosition(String value) {\n    setProperty('list-style-position', value, '');\n  }\n\n  /** Gets the value of \"list-style-type\" */\n  String get listStyleType =>\n    getPropertyValue('list-style-type');\n\n  /** Sets the value of \"list-style-type\" */\n  void set listStyleType(String value) {\n    setProperty('list-style-type', value, '');\n  }\n\n  /** Gets the value of \"locale\" */\n  String get locale =>\n    getPropertyValue('${Device.cssPrefix}locale');\n\n  /** Sets the value of \"locale\" */\n  void set locale(String value) {\n    setProperty('${Device.cssPrefix}locale', value, '');\n  }\n\n  /** Gets the value of \"logical-height\" */\n  String get logicalHeight =>\n    getPropertyValue('${Device.cssPrefix}logical-height');\n\n  /** Sets the value of \"logical-height\" */\n  void set logicalHeight(String value) {\n    setProperty('${Device.cssPrefix}logical-height', value, '');\n  }\n\n  /** Gets the value of \"logical-width\" */\n  String get logicalWidth =>\n    getPropertyValue('${Device.cssPrefix}logical-width');\n\n  /** Sets the value of \"logical-width\" */\n  void set logicalWidth(String value) {\n    setProperty('${Device.cssPrefix}logical-width', value, '');\n  }\n\n  /** Gets the value of \"margin\" */\n  String get margin =>\n    getPropertyValue('margin');\n\n  /** Sets the value of \"margin\" */\n  void set margin(String value) {\n    setProperty('margin', value, '');\n  }\n\n  /** Gets the value of \"margin-after\" */\n  String get marginAfter =>\n    getPropertyValue('${Device.cssPrefix}margin-after');\n\n  /** Sets the value of \"margin-after\" */\n  void set marginAfter(String value) {\n    setProperty('${Device.cssPrefix}margin-after', value, '');\n  }\n\n  /** Gets the value of \"margin-after-collapse\" */\n  String get marginAfterCollapse =>\n    getPropertyValue('${Device.cssPrefix}margin-after-collapse');\n\n  /** Sets the value of \"margin-after-collapse\" */\n  void set marginAfterCollapse(String value) {\n    setProperty('${Device.cssPrefix}margin-after-collapse', value, '');\n  }\n\n  /** Gets the value of \"margin-before\" */\n  String get marginBefore =>\n    getPropertyValue('${Device.cssPrefix}margin-before');\n\n  /** Sets the value of \"margin-before\" */\n  void set marginBefore(String value) {\n    setProperty('${Device.cssPrefix}margin-before', value, '');\n  }\n\n  /** Gets the value of \"margin-before-collapse\" */\n  String get marginBeforeCollapse =>\n    getPropertyValue('${Device.cssPrefix}margin-before-collapse');\n\n  /** Sets the value of \"margin-before-collapse\" */\n  void set marginBeforeCollapse(String value) {\n    setProperty('${Device.cssPrefix}margin-before-collapse', value, '');\n  }\n\n  /** Gets the value of \"margin-bottom\" */\n  String get marginBottom =>\n    getPropertyValue('margin-bottom');\n\n  /** Sets the value of \"margin-bottom\" */\n  void set marginBottom(String value) {\n    setProperty('margin-bottom', value, '');\n  }\n\n  /** Gets the value of \"margin-bottom-collapse\" */\n  String get marginBottomCollapse =>\n    getPropertyValue('${Device.cssPrefix}margin-bottom-collapse');\n\n  /** Sets the value of \"margin-bottom-collapse\" */\n  void set marginBottomCollapse(String value) {\n    setProperty('${Device.cssPrefix}margin-bottom-collapse', value, '');\n  }\n\n  /** Gets the value of \"margin-collapse\" */\n  String get marginCollapse =>\n    getPropertyValue('${Device.cssPrefix}margin-collapse');\n\n  /** Sets the value of \"margin-collapse\" */\n  void set marginCollapse(String value) {\n    setProperty('${Device.cssPrefix}margin-collapse', value, '');\n  }\n\n  /** Gets the value of \"margin-end\" */\n  String get marginEnd =>\n    getPropertyValue('${Device.cssPrefix}margin-end');\n\n  /** Sets the value of \"margin-end\" */\n  void set marginEnd(String value) {\n    setProperty('${Device.cssPrefix}margin-end', value, '');\n  }\n\n  /** Gets the value of \"margin-left\" */\n  String get marginLeft =>\n    getPropertyValue('margin-left');\n\n  /** Sets the value of \"margin-left\" */\n  void set marginLeft(String value) {\n    setProperty('margin-left', value, '');\n  }\n\n  /** Gets the value of \"margin-right\" */\n  String get marginRight =>\n    getPropertyValue('margin-right');\n\n  /** Sets the value of \"margin-right\" */\n  void set marginRight(String value) {\n    setProperty('margin-right', value, '');\n  }\n\n  /** Gets the value of \"margin-start\" */\n  String get marginStart =>\n    getPropertyValue('${Device.cssPrefix}margin-start');\n\n  /** Sets the value of \"margin-start\" */\n  void set marginStart(String value) {\n    setProperty('${Device.cssPrefix}margin-start', value, '');\n  }\n\n  /** Gets the value of \"margin-top\" */\n  String get marginTop =>\n    getPropertyValue('margin-top');\n\n  /** Sets the value of \"margin-top\" */\n  void set marginTop(String value) {\n    setProperty('margin-top', value, '');\n  }\n\n  /** Gets the value of \"margin-top-collapse\" */\n  String get marginTopCollapse =>\n    getPropertyValue('${Device.cssPrefix}margin-top-collapse');\n\n  /** Sets the value of \"margin-top-collapse\" */\n  void set marginTopCollapse(String value) {\n    setProperty('${Device.cssPrefix}margin-top-collapse', value, '');\n  }\n\n  /** Gets the value of \"marquee\" */\n  String get marquee =>\n    getPropertyValue('${Device.cssPrefix}marquee');\n\n  /** Sets the value of \"marquee\" */\n  void set marquee(String value) {\n    setProperty('${Device.cssPrefix}marquee', value, '');\n  }\n\n  /** Gets the value of \"marquee-direction\" */\n  String get marqueeDirection =>\n    getPropertyValue('${Device.cssPrefix}marquee-direction');\n\n  /** Sets the value of \"marquee-direction\" */\n  void set marqueeDirection(String value) {\n    setProperty('${Device.cssPrefix}marquee-direction', value, '');\n  }\n\n  /** Gets the value of \"marquee-increment\" */\n  String get marqueeIncrement =>\n    getPropertyValue('${Device.cssPrefix}marquee-increment');\n\n  /** Sets the value of \"marquee-increment\" */\n  void set marqueeIncrement(String value) {\n    setProperty('${Device.cssPrefix}marquee-increment', value, '');\n  }\n\n  /** Gets the value of \"marquee-repetition\" */\n  String get marqueeRepetition =>\n    getPropertyValue('${Device.cssPrefix}marquee-repetition');\n\n  /** Sets the value of \"marquee-repetition\" */\n  void set marqueeRepetition(String value) {\n    setProperty('${Device.cssPrefix}marquee-repetition', value, '');\n  }\n\n  /** Gets the value of \"marquee-speed\" */\n  String get marqueeSpeed =>\n    getPropertyValue('${Device.cssPrefix}marquee-speed');\n\n  /** Sets the value of \"marquee-speed\" */\n  void set marqueeSpeed(String value) {\n    setProperty('${Device.cssPrefix}marquee-speed', value, '');\n  }\n\n  /** Gets the value of \"marquee-style\" */\n  String get marqueeStyle =>\n    getPropertyValue('${Device.cssPrefix}marquee-style');\n\n  /** Sets the value of \"marquee-style\" */\n  void set marqueeStyle(String value) {\n    setProperty('${Device.cssPrefix}marquee-style', value, '');\n  }\n\n  /** Gets the value of \"mask\" */\n  String get mask =>\n    getPropertyValue('${Device.cssPrefix}mask');\n\n  /** Sets the value of \"mask\" */\n  void set mask(String value) {\n    setProperty('${Device.cssPrefix}mask', value, '');\n  }\n\n  /** Gets the value of \"mask-attachment\" */\n  String get maskAttachment =>\n    getPropertyValue('${Device.cssPrefix}mask-attachment');\n\n  /** Sets the value of \"mask-attachment\" */\n  void set maskAttachment(String value) {\n    setProperty('${Device.cssPrefix}mask-attachment', value, '');\n  }\n\n  /** Gets the value of \"mask-box-image\" */\n  String get maskBoxImage =>\n    getPropertyValue('${Device.cssPrefix}mask-box-image');\n\n  /** Sets the value of \"mask-box-image\" */\n  void set maskBoxImage(String value) {\n    setProperty('${Device.cssPrefix}mask-box-image', value, '');\n  }\n\n  /** Gets the value of \"mask-box-image-outset\" */\n  String get maskBoxImageOutset =>\n    getPropertyValue('${Device.cssPrefix}mask-box-image-outset');\n\n  /** Sets the value of \"mask-box-image-outset\" */\n  void set maskBoxImageOutset(String value) {\n    setProperty('${Device.cssPrefix}mask-box-image-outset', value, '');\n  }\n\n  /** Gets the value of \"mask-box-image-repeat\" */\n  String get maskBoxImageRepeat =>\n    getPropertyValue('${Device.cssPrefix}mask-box-image-repeat');\n\n  /** Sets the value of \"mask-box-image-repeat\" */\n  void set maskBoxImageRepeat(String value) {\n    setProperty('${Device.cssPrefix}mask-box-image-repeat', value, '');\n  }\n\n  /** Gets the value of \"mask-box-image-slice\" */\n  String get maskBoxImageSlice =>\n    getPropertyValue('${Device.cssPrefix}mask-box-image-slice');\n\n  /** Sets the value of \"mask-box-image-slice\" */\n  void set maskBoxImageSlice(String value) {\n    setProperty('${Device.cssPrefix}mask-box-image-slice', value, '');\n  }\n\n  /** Gets the value of \"mask-box-image-source\" */\n  String get maskBoxImageSource =>\n    getPropertyValue('${Device.cssPrefix}mask-box-image-source');\n\n  /** Sets the value of \"mask-box-image-source\" */\n  void set maskBoxImageSource(String value) {\n    setProperty('${Device.cssPrefix}mask-box-image-source', value, '');\n  }\n\n  /** Gets the value of \"mask-box-image-width\" */\n  String get maskBoxImageWidth =>\n    getPropertyValue('${Device.cssPrefix}mask-box-image-width');\n\n  /** Sets the value of \"mask-box-image-width\" */\n  void set maskBoxImageWidth(String value) {\n    setProperty('${Device.cssPrefix}mask-box-image-width', value, '');\n  }\n\n  /** Gets the value of \"mask-clip\" */\n  String get maskClip =>\n    getPropertyValue('${Device.cssPrefix}mask-clip');\n\n  /** Sets the value of \"mask-clip\" */\n  void set maskClip(String value) {\n    setProperty('${Device.cssPrefix}mask-clip', value, '');\n  }\n\n  /** Gets the value of \"mask-composite\" */\n  String get maskComposite =>\n    getPropertyValue('${Device.cssPrefix}mask-composite');\n\n  /** Sets the value of \"mask-composite\" */\n  void set maskComposite(String value) {\n    setProperty('${Device.cssPrefix}mask-composite', value, '');\n  }\n\n  /** Gets the value of \"mask-image\" */\n  String get maskImage =>\n    getPropertyValue('${Device.cssPrefix}mask-image');\n\n  /** Sets the value of \"mask-image\" */\n  void set maskImage(String value) {\n    setProperty('${Device.cssPrefix}mask-image', value, '');\n  }\n\n  /** Gets the value of \"mask-origin\" */\n  String get maskOrigin =>\n    getPropertyValue('${Device.cssPrefix}mask-origin');\n\n  /** Sets the value of \"mask-origin\" */\n  void set maskOrigin(String value) {\n    setProperty('${Device.cssPrefix}mask-origin', value, '');\n  }\n\n  /** Gets the value of \"mask-position\" */\n  String get maskPosition =>\n    getPropertyValue('${Device.cssPrefix}mask-position');\n\n  /** Sets the value of \"mask-position\" */\n  void set maskPosition(String value) {\n    setProperty('${Device.cssPrefix}mask-position', value, '');\n  }\n\n  /** Gets the value of \"mask-position-x\" */\n  String get maskPositionX =>\n    getPropertyValue('${Device.cssPrefix}mask-position-x');\n\n  /** Sets the value of \"mask-position-x\" */\n  void set maskPositionX(String value) {\n    setProperty('${Device.cssPrefix}mask-position-x', value, '');\n  }\n\n  /** Gets the value of \"mask-position-y\" */\n  String get maskPositionY =>\n    getPropertyValue('${Device.cssPrefix}mask-position-y');\n\n  /** Sets the value of \"mask-position-y\" */\n  void set maskPositionY(String value) {\n    setProperty('${Device.cssPrefix}mask-position-y', value, '');\n  }\n\n  /** Gets the value of \"mask-repeat\" */\n  String get maskRepeat =>\n    getPropertyValue('${Device.cssPrefix}mask-repeat');\n\n  /** Sets the value of \"mask-repeat\" */\n  void set maskRepeat(String value) {\n    setProperty('${Device.cssPrefix}mask-repeat', value, '');\n  }\n\n  /** Gets the value of \"mask-repeat-x\" */\n  String get maskRepeatX =>\n    getPropertyValue('${Device.cssPrefix}mask-repeat-x');\n\n  /** Sets the value of \"mask-repeat-x\" */\n  void set maskRepeatX(String value) {\n    setProperty('${Device.cssPrefix}mask-repeat-x', value, '');\n  }\n\n  /** Gets the value of \"mask-repeat-y\" */\n  String get maskRepeatY =>\n    getPropertyValue('${Device.cssPrefix}mask-repeat-y');\n\n  /** Sets the value of \"mask-repeat-y\" */\n  void set maskRepeatY(String value) {\n    setProperty('${Device.cssPrefix}mask-repeat-y', value, '');\n  }\n\n  /** Gets the value of \"mask-size\" */\n  String get maskSize =>\n    getPropertyValue('${Device.cssPrefix}mask-size');\n\n  /** Sets the value of \"mask-size\" */\n  void set maskSize(String value) {\n    setProperty('${Device.cssPrefix}mask-size', value, '');\n  }\n\n  /** Gets the value of \"max-height\" */\n  String get maxHeight =>\n    getPropertyValue('max-height');\n\n  /** Sets the value of \"max-height\" */\n  void set maxHeight(String value) {\n    setProperty('max-height', value, '');\n  }\n\n  /** Gets the value of \"max-logical-height\" */\n  String get maxLogicalHeight =>\n    getPropertyValue('${Device.cssPrefix}max-logical-height');\n\n  /** Sets the value of \"max-logical-height\" */\n  void set maxLogicalHeight(String value) {\n    setProperty('${Device.cssPrefix}max-logical-height', value, '');\n  }\n\n  /** Gets the value of \"max-logical-width\" */\n  String get maxLogicalWidth =>\n    getPropertyValue('${Device.cssPrefix}max-logical-width');\n\n  /** Sets the value of \"max-logical-width\" */\n  void set maxLogicalWidth(String value) {\n    setProperty('${Device.cssPrefix}max-logical-width', value, '');\n  }\n\n  /** Gets the value of \"max-width\" */\n  String get maxWidth =>\n    getPropertyValue('max-width');\n\n  /** Sets the value of \"max-width\" */\n  void set maxWidth(String value) {\n    setProperty('max-width', value, '');\n  }\n\n  /** Gets the value of \"max-zoom\" */\n  String get maxZoom =>\n    getPropertyValue('max-zoom');\n\n  /** Sets the value of \"max-zoom\" */\n  void set maxZoom(String value) {\n    setProperty('max-zoom', value, '');\n  }\n\n  /** Gets the value of \"min-height\" */\n  String get minHeight =>\n    getPropertyValue('min-height');\n\n  /** Sets the value of \"min-height\" */\n  void set minHeight(String value) {\n    setProperty('min-height', value, '');\n  }\n\n  /** Gets the value of \"min-logical-height\" */\n  String get minLogicalHeight =>\n    getPropertyValue('${Device.cssPrefix}min-logical-height');\n\n  /** Sets the value of \"min-logical-height\" */\n  void set minLogicalHeight(String value) {\n    setProperty('${Device.cssPrefix}min-logical-height', value, '');\n  }\n\n  /** Gets the value of \"min-logical-width\" */\n  String get minLogicalWidth =>\n    getPropertyValue('${Device.cssPrefix}min-logical-width');\n\n  /** Sets the value of \"min-logical-width\" */\n  void set minLogicalWidth(String value) {\n    setProperty('${Device.cssPrefix}min-logical-width', value, '');\n  }\n\n  /** Gets the value of \"min-width\" */\n  String get minWidth =>\n    getPropertyValue('min-width');\n\n  /** Sets the value of \"min-width\" */\n  void set minWidth(String value) {\n    setProperty('min-width', value, '');\n  }\n\n  /** Gets the value of \"min-zoom\" */\n  String get minZoom =>\n    getPropertyValue('min-zoom');\n\n  /** Sets the value of \"min-zoom\" */\n  void set minZoom(String value) {\n    setProperty('min-zoom', value, '');\n  }\n\n  /** Gets the value of \"nbsp-mode\" */\n  String get nbspMode =>\n    getPropertyValue('${Device.cssPrefix}nbsp-mode');\n\n  /** Sets the value of \"nbsp-mode\" */\n  void set nbspMode(String value) {\n    setProperty('${Device.cssPrefix}nbsp-mode', value, '');\n  }\n\n  /** Gets the value of \"opacity\" */\n  String get opacity =>\n    getPropertyValue('opacity');\n\n  /** Sets the value of \"opacity\" */\n  void set opacity(String value) {\n    setProperty('opacity', value, '');\n  }\n\n  /** Gets the value of \"order\" */\n  String get order =>\n    getPropertyValue('${Device.cssPrefix}order');\n\n  /** Sets the value of \"order\" */\n  void set order(String value) {\n    setProperty('${Device.cssPrefix}order', value, '');\n  }\n\n  /** Gets the value of \"orientation\" */\n  String get orientation =>\n    getPropertyValue('orientation');\n\n  /** Sets the value of \"orientation\" */\n  void set orientation(String value) {\n    setProperty('orientation', value, '');\n  }\n\n  /** Gets the value of \"orphans\" */\n  String get orphans =>\n    getPropertyValue('orphans');\n\n  /** Sets the value of \"orphans\" */\n  void set orphans(String value) {\n    setProperty('orphans', value, '');\n  }\n\n  /** Gets the value of \"outline\" */\n  String get outline =>\n    getPropertyValue('outline');\n\n  /** Sets the value of \"outline\" */\n  void set outline(String value) {\n    setProperty('outline', value, '');\n  }\n\n  /** Gets the value of \"outline-color\" */\n  String get outlineColor =>\n    getPropertyValue('outline-color');\n\n  /** Sets the value of \"outline-color\" */\n  void set outlineColor(String value) {\n    setProperty('outline-color', value, '');\n  }\n\n  /** Gets the value of \"outline-offset\" */\n  String get outlineOffset =>\n    getPropertyValue('outline-offset');\n\n  /** Sets the value of \"outline-offset\" */\n  void set outlineOffset(String value) {\n    setProperty('outline-offset', value, '');\n  }\n\n  /** Gets the value of \"outline-style\" */\n  String get outlineStyle =>\n    getPropertyValue('outline-style');\n\n  /** Sets the value of \"outline-style\" */\n  void set outlineStyle(String value) {\n    setProperty('outline-style', value, '');\n  }\n\n  /** Gets the value of \"outline-width\" */\n  String get outlineWidth =>\n    getPropertyValue('outline-width');\n\n  /** Sets the value of \"outline-width\" */\n  void set outlineWidth(String value) {\n    setProperty('outline-width', value, '');\n  }\n\n  /** Gets the value of \"overflow\" */\n  String get overflow =>\n    getPropertyValue('overflow');\n\n  /** Sets the value of \"overflow\" */\n  void set overflow(String value) {\n    setProperty('overflow', value, '');\n  }\n\n  /** Gets the value of \"overflow-scrolling\" */\n  String get overflowScrolling =>\n    getPropertyValue('${Device.cssPrefix}overflow-scrolling');\n\n  /** Sets the value of \"overflow-scrolling\" */\n  void set overflowScrolling(String value) {\n    setProperty('${Device.cssPrefix}overflow-scrolling', value, '');\n  }\n\n  /** Gets the value of \"overflow-wrap\" */\n  String get overflowWrap =>\n    getPropertyValue('overflow-wrap');\n\n  /** Sets the value of \"overflow-wrap\" */\n  void set overflowWrap(String value) {\n    setProperty('overflow-wrap', value, '');\n  }\n\n  /** Gets the value of \"overflow-x\" */\n  String get overflowX =>\n    getPropertyValue('overflow-x');\n\n  /** Sets the value of \"overflow-x\" */\n  void set overflowX(String value) {\n    setProperty('overflow-x', value, '');\n  }\n\n  /** Gets the value of \"overflow-y\" */\n  String get overflowY =>\n    getPropertyValue('overflow-y');\n\n  /** Sets the value of \"overflow-y\" */\n  void set overflowY(String value) {\n    setProperty('overflow-y', value, '');\n  }\n\n  /** Gets the value of \"padding\" */\n  String get padding =>\n    getPropertyValue('padding');\n\n  /** Sets the value of \"padding\" */\n  void set padding(String value) {\n    setProperty('padding', value, '');\n  }\n\n  /** Gets the value of \"padding-after\" */\n  String get paddingAfter =>\n    getPropertyValue('${Device.cssPrefix}padding-after');\n\n  /** Sets the value of \"padding-after\" */\n  void set paddingAfter(String value) {\n    setProperty('${Device.cssPrefix}padding-after', value, '');\n  }\n\n  /** Gets the value of \"padding-before\" */\n  String get paddingBefore =>\n    getPropertyValue('${Device.cssPrefix}padding-before');\n\n  /** Sets the value of \"padding-before\" */\n  void set paddingBefore(String value) {\n    setProperty('${Device.cssPrefix}padding-before', value, '');\n  }\n\n  /** Gets the value of \"padding-bottom\" */\n  String get paddingBottom =>\n    getPropertyValue('padding-bottom');\n\n  /** Sets the value of \"padding-bottom\" */\n  void set paddingBottom(String value) {\n    setProperty('padding-bottom', value, '');\n  }\n\n  /** Gets the value of \"padding-end\" */\n  String get paddingEnd =>\n    getPropertyValue('${Device.cssPrefix}padding-end');\n\n  /** Sets the value of \"padding-end\" */\n  void set paddingEnd(String value) {\n    setProperty('${Device.cssPrefix}padding-end', value, '');\n  }\n\n  /** Gets the value of \"padding-left\" */\n  String get paddingLeft =>\n    getPropertyValue('padding-left');\n\n  /** Sets the value of \"padding-left\" */\n  void set paddingLeft(String value) {\n    setProperty('padding-left', value, '');\n  }\n\n  /** Gets the value of \"padding-right\" */\n  String get paddingRight =>\n    getPropertyValue('padding-right');\n\n  /** Sets the value of \"padding-right\" */\n  void set paddingRight(String value) {\n    setProperty('padding-right', value, '');\n  }\n\n  /** Gets the value of \"padding-start\" */\n  String get paddingStart =>\n    getPropertyValue('${Device.cssPrefix}padding-start');\n\n  /** Sets the value of \"padding-start\" */\n  void set paddingStart(String value) {\n    setProperty('${Device.cssPrefix}padding-start', value, '');\n  }\n\n  /** Gets the value of \"padding-top\" */\n  String get paddingTop =>\n    getPropertyValue('padding-top');\n\n  /** Sets the value of \"padding-top\" */\n  void set paddingTop(String value) {\n    setProperty('padding-top', value, '');\n  }\n\n  /** Gets the value of \"page\" */\n  String get page =>\n    getPropertyValue('page');\n\n  /** Sets the value of \"page\" */\n  void set page(String value) {\n    setProperty('page', value, '');\n  }\n\n  /** Gets the value of \"page-break-after\" */\n  String get pageBreakAfter =>\n    getPropertyValue('page-break-after');\n\n  /** Sets the value of \"page-break-after\" */\n  void set pageBreakAfter(String value) {\n    setProperty('page-break-after', value, '');\n  }\n\n  /** Gets the value of \"page-break-before\" */\n  String get pageBreakBefore =>\n    getPropertyValue('page-break-before');\n\n  /** Sets the value of \"page-break-before\" */\n  void set pageBreakBefore(String value) {\n    setProperty('page-break-before', value, '');\n  }\n\n  /** Gets the value of \"page-break-inside\" */\n  String get pageBreakInside =>\n    getPropertyValue('page-break-inside');\n\n  /** Sets the value of \"page-break-inside\" */\n  void set pageBreakInside(String value) {\n    setProperty('page-break-inside', value, '');\n  }\n\n  /** Gets the value of \"perspective\" */\n  String get perspective =>\n    getPropertyValue('${Device.cssPrefix}perspective');\n\n  /** Sets the value of \"perspective\" */\n  void set perspective(String value) {\n    setProperty('${Device.cssPrefix}perspective', value, '');\n  }\n\n  /** Gets the value of \"perspective-origin\" */\n  String get perspectiveOrigin =>\n    getPropertyValue('${Device.cssPrefix}perspective-origin');\n\n  /** Sets the value of \"perspective-origin\" */\n  void set perspectiveOrigin(String value) {\n    setProperty('${Device.cssPrefix}perspective-origin', value, '');\n  }\n\n  /** Gets the value of \"perspective-origin-x\" */\n  String get perspectiveOriginX =>\n    getPropertyValue('${Device.cssPrefix}perspective-origin-x');\n\n  /** Sets the value of \"perspective-origin-x\" */\n  void set perspectiveOriginX(String value) {\n    setProperty('${Device.cssPrefix}perspective-origin-x', value, '');\n  }\n\n  /** Gets the value of \"perspective-origin-y\" */\n  String get perspectiveOriginY =>\n    getPropertyValue('${Device.cssPrefix}perspective-origin-y');\n\n  /** Sets the value of \"perspective-origin-y\" */\n  void set perspectiveOriginY(String value) {\n    setProperty('${Device.cssPrefix}perspective-origin-y', value, '');\n  }\n\n  /** Gets the value of \"pointer-events\" */\n  String get pointerEvents =>\n    getPropertyValue('pointer-events');\n\n  /** Sets the value of \"pointer-events\" */\n  void set pointerEvents(String value) {\n    setProperty('pointer-events', value, '');\n  }\n\n  /** Gets the value of \"position\" */\n  String get position =>\n    getPropertyValue('position');\n\n  /** Sets the value of \"position\" */\n  void set position(String value) {\n    setProperty('position', value, '');\n  }\n\n  /** Gets the value of \"print-color-adjust\" */\n  String get printColorAdjust =>\n    getPropertyValue('${Device.cssPrefix}print-color-adjust');\n\n  /** Sets the value of \"print-color-adjust\" */\n  void set printColorAdjust(String value) {\n    setProperty('${Device.cssPrefix}print-color-adjust', value, '');\n  }\n\n  /** Gets the value of \"quotes\" */\n  String get quotes =>\n    getPropertyValue('quotes');\n\n  /** Sets the value of \"quotes\" */\n  void set quotes(String value) {\n    setProperty('quotes', value, '');\n  }\n\n  /** Gets the value of \"region-break-after\" */\n  String get regionBreakAfter =>\n    getPropertyValue('${Device.cssPrefix}region-break-after');\n\n  /** Sets the value of \"region-break-after\" */\n  void set regionBreakAfter(String value) {\n    setProperty('${Device.cssPrefix}region-break-after', value, '');\n  }\n\n  /** Gets the value of \"region-break-before\" */\n  String get regionBreakBefore =>\n    getPropertyValue('${Device.cssPrefix}region-break-before');\n\n  /** Sets the value of \"region-break-before\" */\n  void set regionBreakBefore(String value) {\n    setProperty('${Device.cssPrefix}region-break-before', value, '');\n  }\n\n  /** Gets the value of \"region-break-inside\" */\n  String get regionBreakInside =>\n    getPropertyValue('${Device.cssPrefix}region-break-inside');\n\n  /** Sets the value of \"region-break-inside\" */\n  void set regionBreakInside(String value) {\n    setProperty('${Device.cssPrefix}region-break-inside', value, '');\n  }\n\n  /** Gets the value of \"region-overflow\" */\n  String get regionOverflow =>\n    getPropertyValue('${Device.cssPrefix}region-overflow');\n\n  /** Sets the value of \"region-overflow\" */\n  void set regionOverflow(String value) {\n    setProperty('${Device.cssPrefix}region-overflow', value, '');\n  }\n\n  /** Gets the value of \"resize\" */\n  String get resize =>\n    getPropertyValue('resize');\n\n  /** Sets the value of \"resize\" */\n  void set resize(String value) {\n    setProperty('resize', value, '');\n  }\n\n  /** Gets the value of \"right\" */\n  String get right =>\n    getPropertyValue('right');\n\n  /** Sets the value of \"right\" */\n  void set right(String value) {\n    setProperty('right', value, '');\n  }\n\n  /** Gets the value of \"rtl-ordering\" */\n  String get rtlOrdering =>\n    getPropertyValue('${Device.cssPrefix}rtl-ordering');\n\n  /** Sets the value of \"rtl-ordering\" */\n  void set rtlOrdering(String value) {\n    setProperty('${Device.cssPrefix}rtl-ordering', value, '');\n  }\n\n  /** Gets the value of \"shape-inside\" */\n  String get shapeInside =>\n    getPropertyValue('${Device.cssPrefix}shape-inside');\n\n  /** Sets the value of \"shape-inside\" */\n  void set shapeInside(String value) {\n    setProperty('${Device.cssPrefix}shape-inside', value, '');\n  }\n\n  /** Gets the value of \"shape-margin\" */\n  String get shapeMargin =>\n    getPropertyValue('${Device.cssPrefix}shape-margin');\n\n  /** Sets the value of \"shape-margin\" */\n  void set shapeMargin(String value) {\n    setProperty('${Device.cssPrefix}shape-margin', value, '');\n  }\n\n  /** Gets the value of \"shape-outside\" */\n  String get shapeOutside =>\n    getPropertyValue('${Device.cssPrefix}shape-outside');\n\n  /** Sets the value of \"shape-outside\" */\n  void set shapeOutside(String value) {\n    setProperty('${Device.cssPrefix}shape-outside', value, '');\n  }\n\n  /** Gets the value of \"shape-padding\" */\n  String get shapePadding =>\n    getPropertyValue('${Device.cssPrefix}shape-padding');\n\n  /** Sets the value of \"shape-padding\" */\n  void set shapePadding(String value) {\n    setProperty('${Device.cssPrefix}shape-padding', value, '');\n  }\n\n  /** Gets the value of \"size\" */\n  String get size =>\n    getPropertyValue('size');\n\n  /** Sets the value of \"size\" */\n  void set size(String value) {\n    setProperty('size', value, '');\n  }\n\n  /** Gets the value of \"speak\" */\n  String get speak =>\n    getPropertyValue('speak');\n\n  /** Sets the value of \"speak\" */\n  void set speak(String value) {\n    setProperty('speak', value, '');\n  }\n\n  /** Gets the value of \"src\" */\n  String get src =>\n    getPropertyValue('src');\n\n  /** Sets the value of \"src\" */\n  void set src(String value) {\n    setProperty('src', value, '');\n  }\n\n  /** Gets the value of \"tab-size\" */\n  String get tabSize =>\n    getPropertyValue('tab-size');\n\n  /** Sets the value of \"tab-size\" */\n  void set tabSize(String value) {\n    setProperty('tab-size', value, '');\n  }\n\n  /** Gets the value of \"table-layout\" */\n  String get tableLayout =>\n    getPropertyValue('table-layout');\n\n  /** Sets the value of \"table-layout\" */\n  void set tableLayout(String value) {\n    setProperty('table-layout', value, '');\n  }\n\n  /** Gets the value of \"tap-highlight-color\" */\n  String get tapHighlightColor =>\n    getPropertyValue('${Device.cssPrefix}tap-highlight-color');\n\n  /** Sets the value of \"tap-highlight-color\" */\n  void set tapHighlightColor(String value) {\n    setProperty('${Device.cssPrefix}tap-highlight-color', value, '');\n  }\n\n  /** Gets the value of \"text-align\" */\n  String get textAlign =>\n    getPropertyValue('text-align');\n\n  /** Sets the value of \"text-align\" */\n  void set textAlign(String value) {\n    setProperty('text-align', value, '');\n  }\n\n  /** Gets the value of \"text-align-last\" */\n  String get textAlignLast =>\n    getPropertyValue('${Device.cssPrefix}text-align-last');\n\n  /** Sets the value of \"text-align-last\" */\n  void set textAlignLast(String value) {\n    setProperty('${Device.cssPrefix}text-align-last', value, '');\n  }\n\n  /** Gets the value of \"text-combine\" */\n  String get textCombine =>\n    getPropertyValue('${Device.cssPrefix}text-combine');\n\n  /** Sets the value of \"text-combine\" */\n  void set textCombine(String value) {\n    setProperty('${Device.cssPrefix}text-combine', value, '');\n  }\n\n  /** Gets the value of \"text-decoration\" */\n  String get textDecoration =>\n    getPropertyValue('text-decoration');\n\n  /** Sets the value of \"text-decoration\" */\n  void set textDecoration(String value) {\n    setProperty('text-decoration', value, '');\n  }\n\n  /** Gets the value of \"text-decoration-line\" */\n  String get textDecorationLine =>\n    getPropertyValue('${Device.cssPrefix}text-decoration-line');\n\n  /** Sets the value of \"text-decoration-line\" */\n  void set textDecorationLine(String value) {\n    setProperty('${Device.cssPrefix}text-decoration-line', value, '');\n  }\n\n  /** Gets the value of \"text-decoration-style\" */\n  String get textDecorationStyle =>\n    getPropertyValue('${Device.cssPrefix}text-decoration-style');\n\n  /** Sets the value of \"text-decoration-style\" */\n  void set textDecorationStyle(String value) {\n    setProperty('${Device.cssPrefix}text-decoration-style', value, '');\n  }\n\n  /** Gets the value of \"text-decorations-in-effect\" */\n  String get textDecorationsInEffect =>\n    getPropertyValue('${Device.cssPrefix}text-decorations-in-effect');\n\n  /** Sets the value of \"text-decorations-in-effect\" */\n  void set textDecorationsInEffect(String value) {\n    setProperty('${Device.cssPrefix}text-decorations-in-effect', value, '');\n  }\n\n  /** Gets the value of \"text-emphasis\" */\n  String get textEmphasis =>\n    getPropertyValue('${Device.cssPrefix}text-emphasis');\n\n  /** Sets the value of \"text-emphasis\" */\n  void set textEmphasis(String value) {\n    setProperty('${Device.cssPrefix}text-emphasis', value, '');\n  }\n\n  /** Gets the value of \"text-emphasis-color\" */\n  String get textEmphasisColor =>\n    getPropertyValue('${Device.cssPrefix}text-emphasis-color');\n\n  /** Sets the value of \"text-emphasis-color\" */\n  void set textEmphasisColor(String value) {\n    setProperty('${Device.cssPrefix}text-emphasis-color', value, '');\n  }\n\n  /** Gets the value of \"text-emphasis-position\" */\n  String get textEmphasisPosition =>\n    getPropertyValue('${Device.cssPrefix}text-emphasis-position');\n\n  /** Sets the value of \"text-emphasis-position\" */\n  void set textEmphasisPosition(String value) {\n    setProperty('${Device.cssPrefix}text-emphasis-position', value, '');\n  }\n\n  /** Gets the value of \"text-emphasis-style\" */\n  String get textEmphasisStyle =>\n    getPropertyValue('${Device.cssPrefix}text-emphasis-style');\n\n  /** Sets the value of \"text-emphasis-style\" */\n  void set textEmphasisStyle(String value) {\n    setProperty('${Device.cssPrefix}text-emphasis-style', value, '');\n  }\n\n  /** Gets the value of \"text-fill-color\" */\n  String get textFillColor =>\n    getPropertyValue('${Device.cssPrefix}text-fill-color');\n\n  /** Sets the value of \"text-fill-color\" */\n  void set textFillColor(String value) {\n    setProperty('${Device.cssPrefix}text-fill-color', value, '');\n  }\n\n  /** Gets the value of \"text-indent\" */\n  String get textIndent =>\n    getPropertyValue('text-indent');\n\n  /** Sets the value of \"text-indent\" */\n  void set textIndent(String value) {\n    setProperty('text-indent', value, '');\n  }\n\n  /** Gets the value of \"text-line-through\" */\n  String get textLineThrough =>\n    getPropertyValue('text-line-through');\n\n  /** Sets the value of \"text-line-through\" */\n  void set textLineThrough(String value) {\n    setProperty('text-line-through', value, '');\n  }\n\n  /** Gets the value of \"text-line-through-color\" */\n  String get textLineThroughColor =>\n    getPropertyValue('text-line-through-color');\n\n  /** Sets the value of \"text-line-through-color\" */\n  void set textLineThroughColor(String value) {\n    setProperty('text-line-through-color', value, '');\n  }\n\n  /** Gets the value of \"text-line-through-mode\" */\n  String get textLineThroughMode =>\n    getPropertyValue('text-line-through-mode');\n\n  /** Sets the value of \"text-line-through-mode\" */\n  void set textLineThroughMode(String value) {\n    setProperty('text-line-through-mode', value, '');\n  }\n\n  /** Gets the value of \"text-line-through-style\" */\n  String get textLineThroughStyle =>\n    getPropertyValue('text-line-through-style');\n\n  /** Sets the value of \"text-line-through-style\" */\n  void set textLineThroughStyle(String value) {\n    setProperty('text-line-through-style', value, '');\n  }\n\n  /** Gets the value of \"text-line-through-width\" */\n  String get textLineThroughWidth =>\n    getPropertyValue('text-line-through-width');\n\n  /** Sets the value of \"text-line-through-width\" */\n  void set textLineThroughWidth(String value) {\n    setProperty('text-line-through-width', value, '');\n  }\n\n  /** Gets the value of \"text-orientation\" */\n  String get textOrientation =>\n    getPropertyValue('${Device.cssPrefix}text-orientation');\n\n  /** Sets the value of \"text-orientation\" */\n  void set textOrientation(String value) {\n    setProperty('${Device.cssPrefix}text-orientation', value, '');\n  }\n\n  /** Gets the value of \"text-overflow\" */\n  String get textOverflow =>\n    getPropertyValue('text-overflow');\n\n  /** Sets the value of \"text-overflow\" */\n  void set textOverflow(String value) {\n    setProperty('text-overflow', value, '');\n  }\n\n  /** Gets the value of \"text-overline\" */\n  String get textOverline =>\n    getPropertyValue('text-overline');\n\n  /** Sets the value of \"text-overline\" */\n  void set textOverline(String value) {\n    setProperty('text-overline', value, '');\n  }\n\n  /** Gets the value of \"text-overline-color\" */\n  String get textOverlineColor =>\n    getPropertyValue('text-overline-color');\n\n  /** Sets the value of \"text-overline-color\" */\n  void set textOverlineColor(String value) {\n    setProperty('text-overline-color', value, '');\n  }\n\n  /** Gets the value of \"text-overline-mode\" */\n  String get textOverlineMode =>\n    getPropertyValue('text-overline-mode');\n\n  /** Sets the value of \"text-overline-mode\" */\n  void set textOverlineMode(String value) {\n    setProperty('text-overline-mode', value, '');\n  }\n\n  /** Gets the value of \"text-overline-style\" */\n  String get textOverlineStyle =>\n    getPropertyValue('text-overline-style');\n\n  /** Sets the value of \"text-overline-style\" */\n  void set textOverlineStyle(String value) {\n    setProperty('text-overline-style', value, '');\n  }\n\n  /** Gets the value of \"text-overline-width\" */\n  String get textOverlineWidth =>\n    getPropertyValue('text-overline-width');\n\n  /** Sets the value of \"text-overline-width\" */\n  void set textOverlineWidth(String value) {\n    setProperty('text-overline-width', value, '');\n  }\n\n  /** Gets the value of \"text-rendering\" */\n  String get textRendering =>\n    getPropertyValue('text-rendering');\n\n  /** Sets the value of \"text-rendering\" */\n  void set textRendering(String value) {\n    setProperty('text-rendering', value, '');\n  }\n\n  /** Gets the value of \"text-security\" */\n  String get textSecurity =>\n    getPropertyValue('${Device.cssPrefix}text-security');\n\n  /** Sets the value of \"text-security\" */\n  void set textSecurity(String value) {\n    setProperty('${Device.cssPrefix}text-security', value, '');\n  }\n\n  /** Gets the value of \"text-shadow\" */\n  String get textShadow =>\n    getPropertyValue('text-shadow');\n\n  /** Sets the value of \"text-shadow\" */\n  void set textShadow(String value) {\n    setProperty('text-shadow', value, '');\n  }\n\n  /** Gets the value of \"text-size-adjust\" */\n  String get textSizeAdjust =>\n    getPropertyValue('${Device.cssPrefix}text-size-adjust');\n\n  /** Sets the value of \"text-size-adjust\" */\n  void set textSizeAdjust(String value) {\n    setProperty('${Device.cssPrefix}text-size-adjust', value, '');\n  }\n\n  /** Gets the value of \"text-stroke\" */\n  String get textStroke =>\n    getPropertyValue('${Device.cssPrefix}text-stroke');\n\n  /** Sets the value of \"text-stroke\" */\n  void set textStroke(String value) {\n    setProperty('${Device.cssPrefix}text-stroke', value, '');\n  }\n\n  /** Gets the value of \"text-stroke-color\" */\n  String get textStrokeColor =>\n    getPropertyValue('${Device.cssPrefix}text-stroke-color');\n\n  /** Sets the value of \"text-stroke-color\" */\n  void set textStrokeColor(String value) {\n    setProperty('${Device.cssPrefix}text-stroke-color', value, '');\n  }\n\n  /** Gets the value of \"text-stroke-width\" */\n  String get textStrokeWidth =>\n    getPropertyValue('${Device.cssPrefix}text-stroke-width');\n\n  /** Sets the value of \"text-stroke-width\" */\n  void set textStrokeWidth(String value) {\n    setProperty('${Device.cssPrefix}text-stroke-width', value, '');\n  }\n\n  /** Gets the value of \"text-transform\" */\n  String get textTransform =>\n    getPropertyValue('text-transform');\n\n  /** Sets the value of \"text-transform\" */\n  void set textTransform(String value) {\n    setProperty('text-transform', value, '');\n  }\n\n  /** Gets the value of \"text-underline\" */\n  String get textUnderline =>\n    getPropertyValue('text-underline');\n\n  /** Sets the value of \"text-underline\" */\n  void set textUnderline(String value) {\n    setProperty('text-underline', value, '');\n  }\n\n  /** Gets the value of \"text-underline-color\" */\n  String get textUnderlineColor =>\n    getPropertyValue('text-underline-color');\n\n  /** Sets the value of \"text-underline-color\" */\n  void set textUnderlineColor(String value) {\n    setProperty('text-underline-color', value, '');\n  }\n\n  /** Gets the value of \"text-underline-mode\" */\n  String get textUnderlineMode =>\n    getPropertyValue('text-underline-mode');\n\n  /** Sets the value of \"text-underline-mode\" */\n  void set textUnderlineMode(String value) {\n    setProperty('text-underline-mode', value, '');\n  }\n\n  /** Gets the value of \"text-underline-style\" */\n  String get textUnderlineStyle =>\n    getPropertyValue('text-underline-style');\n\n  /** Sets the value of \"text-underline-style\" */\n  void set textUnderlineStyle(String value) {\n    setProperty('text-underline-style', value, '');\n  }\n\n  /** Gets the value of \"text-underline-width\" */\n  String get textUnderlineWidth =>\n    getPropertyValue('text-underline-width');\n\n  /** Sets the value of \"text-underline-width\" */\n  void set textUnderlineWidth(String value) {\n    setProperty('text-underline-width', value, '');\n  }\n\n  /** Gets the value of \"top\" */\n  String get top =>\n    getPropertyValue('top');\n\n  /** Sets the value of \"top\" */\n  void set top(String value) {\n    setProperty('top', value, '');\n  }\n\n  /** Gets the value of \"transform\" */\n  String get transform =>\n    getPropertyValue('${Device.cssPrefix}transform');\n\n  /** Sets the value of \"transform\" */\n  void set transform(String value) {\n    setProperty('${Device.cssPrefix}transform', value, '');\n  }\n\n  /** Gets the value of \"transform-origin\" */\n  String get transformOrigin =>\n    getPropertyValue('${Device.cssPrefix}transform-origin');\n\n  /** Sets the value of \"transform-origin\" */\n  void set transformOrigin(String value) {\n    setProperty('${Device.cssPrefix}transform-origin', value, '');\n  }\n\n  /** Gets the value of \"transform-origin-x\" */\n  String get transformOriginX =>\n    getPropertyValue('${Device.cssPrefix}transform-origin-x');\n\n  /** Sets the value of \"transform-origin-x\" */\n  void set transformOriginX(String value) {\n    setProperty('${Device.cssPrefix}transform-origin-x', value, '');\n  }\n\n  /** Gets the value of \"transform-origin-y\" */\n  String get transformOriginY =>\n    getPropertyValue('${Device.cssPrefix}transform-origin-y');\n\n  /** Sets the value of \"transform-origin-y\" */\n  void set transformOriginY(String value) {\n    setProperty('${Device.cssPrefix}transform-origin-y', value, '');\n  }\n\n  /** Gets the value of \"transform-origin-z\" */\n  String get transformOriginZ =>\n    getPropertyValue('${Device.cssPrefix}transform-origin-z');\n\n  /** Sets the value of \"transform-origin-z\" */\n  void set transformOriginZ(String value) {\n    setProperty('${Device.cssPrefix}transform-origin-z', value, '');\n  }\n\n  /** Gets the value of \"transform-style\" */\n  String get transformStyle =>\n    getPropertyValue('${Device.cssPrefix}transform-style');\n\n  /** Sets the value of \"transform-style\" */\n  void set transformStyle(String value) {\n    setProperty('${Device.cssPrefix}transform-style', value, '');\n  }\n\n  /** Gets the value of \"transition\" */\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  String get transition =>\n    getPropertyValue('${Device.cssPrefix}transition');\n\n  /** Sets the value of \"transition\" */\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  void set transition(String value) {\n    setProperty('${Device.cssPrefix}transition', value, '');\n  }\n\n  /** Gets the value of \"transition-delay\" */\n  String get transitionDelay =>\n    getPropertyValue('${Device.cssPrefix}transition-delay');\n\n  /** Sets the value of \"transition-delay\" */\n  void set transitionDelay(String value) {\n    setProperty('${Device.cssPrefix}transition-delay', value, '');\n  }\n\n  /** Gets the value of \"transition-duration\" */\n  String get transitionDuration =>\n    getPropertyValue('${Device.cssPrefix}transition-duration');\n\n  /** Sets the value of \"transition-duration\" */\n  void set transitionDuration(String value) {\n    setProperty('${Device.cssPrefix}transition-duration', value, '');\n  }\n\n  /** Gets the value of \"transition-property\" */\n  String get transitionProperty =>\n    getPropertyValue('${Device.cssPrefix}transition-property');\n\n  /** Sets the value of \"transition-property\" */\n  void set transitionProperty(String value) {\n    setProperty('${Device.cssPrefix}transition-property', value, '');\n  }\n\n  /** Gets the value of \"transition-timing-function\" */\n  String get transitionTimingFunction =>\n    getPropertyValue('${Device.cssPrefix}transition-timing-function');\n\n  /** Sets the value of \"transition-timing-function\" */\n  void set transitionTimingFunction(String value) {\n    setProperty('${Device.cssPrefix}transition-timing-function', value, '');\n  }\n\n  /** Gets the value of \"unicode-bidi\" */\n  String get unicodeBidi =>\n    getPropertyValue('unicode-bidi');\n\n  /** Sets the value of \"unicode-bidi\" */\n  void set unicodeBidi(String value) {\n    setProperty('unicode-bidi', value, '');\n  }\n\n  /** Gets the value of \"unicode-range\" */\n  String get unicodeRange =>\n    getPropertyValue('unicode-range');\n\n  /** Sets the value of \"unicode-range\" */\n  void set unicodeRange(String value) {\n    setProperty('unicode-range', value, '');\n  }\n\n  /** Gets the value of \"user-drag\" */\n  String get userDrag =>\n    getPropertyValue('${Device.cssPrefix}user-drag');\n\n  /** Sets the value of \"user-drag\" */\n  void set userDrag(String value) {\n    setProperty('${Device.cssPrefix}user-drag', value, '');\n  }\n\n  /** Gets the value of \"user-modify\" */\n  String get userModify =>\n    getPropertyValue('${Device.cssPrefix}user-modify');\n\n  /** Sets the value of \"user-modify\" */\n  void set userModify(String value) {\n    setProperty('${Device.cssPrefix}user-modify', value, '');\n  }\n\n  /** Gets the value of \"user-select\" */\n  String get userSelect =>\n    getPropertyValue('${Device.cssPrefix}user-select');\n\n  /** Sets the value of \"user-select\" */\n  void set userSelect(String value) {\n    setProperty('${Device.cssPrefix}user-select', value, '');\n  }\n\n  /** Gets the value of \"user-zoom\" */\n  String get userZoom =>\n    getPropertyValue('user-zoom');\n\n  /** Sets the value of \"user-zoom\" */\n  void set userZoom(String value) {\n    setProperty('user-zoom', value, '');\n  }\n\n  /** Gets the value of \"vertical-align\" */\n  String get verticalAlign =>\n    getPropertyValue('vertical-align');\n\n  /** Sets the value of \"vertical-align\" */\n  void set verticalAlign(String value) {\n    setProperty('vertical-align', value, '');\n  }\n\n  /** Gets the value of \"visibility\" */\n  String get visibility =>\n    getPropertyValue('visibility');\n\n  /** Sets the value of \"visibility\" */\n  void set visibility(String value) {\n    setProperty('visibility', value, '');\n  }\n\n  /** Gets the value of \"white-space\" */\n  String get whiteSpace =>\n    getPropertyValue('white-space');\n\n  /** Sets the value of \"white-space\" */\n  void set whiteSpace(String value) {\n    setProperty('white-space', value, '');\n  }\n\n  /** Gets the value of \"widows\" */\n  String get widows =>\n    getPropertyValue('widows');\n\n  /** Sets the value of \"widows\" */\n  void set widows(String value) {\n    setProperty('widows', value, '');\n  }\n\n  /** Gets the value of \"width\" */\n  String get width =>\n    getPropertyValue('width');\n\n  /** Sets the value of \"width\" */\n  void set width(String value) {\n    setProperty('width', value, '');\n  }\n\n  /** Gets the value of \"word-break\" */\n  String get wordBreak =>\n    getPropertyValue('word-break');\n\n  /** Sets the value of \"word-break\" */\n  void set wordBreak(String value) {\n    setProperty('word-break', value, '');\n  }\n\n  /** Gets the value of \"word-spacing\" */\n  String get wordSpacing =>\n    getPropertyValue('word-spacing');\n\n  /** Sets the value of \"word-spacing\" */\n  void set wordSpacing(String value) {\n    setProperty('word-spacing', value, '');\n  }\n\n  /** Gets the value of \"word-wrap\" */\n  String get wordWrap =>\n    getPropertyValue('word-wrap');\n\n  /** Sets the value of \"word-wrap\" */\n  void set wordWrap(String value) {\n    setProperty('word-wrap', value, '');\n  }\n\n  /** Gets the value of \"wrap\" */\n  String get wrap =>\n    getPropertyValue('${Device.cssPrefix}wrap');\n\n  /** Sets the value of \"wrap\" */\n  void set wrap(String value) {\n    setProperty('${Device.cssPrefix}wrap', value, '');\n  }\n\n  /** Gets the value of \"wrap-flow\" */\n  String get wrapFlow =>\n    getPropertyValue('${Device.cssPrefix}wrap-flow');\n\n  /** Sets the value of \"wrap-flow\" */\n  void set wrapFlow(String value) {\n    setProperty('${Device.cssPrefix}wrap-flow', value, '');\n  }\n\n  /** Gets the value of \"wrap-through\" */\n  String get wrapThrough =>\n    getPropertyValue('${Device.cssPrefix}wrap-through');\n\n  /** Sets the value of \"wrap-through\" */\n  void set wrapThrough(String value) {\n    setProperty('${Device.cssPrefix}wrap-through', value, '');\n  }\n\n  /** Gets the value of \"writing-mode\" */\n  String get writingMode =>\n    getPropertyValue('${Device.cssPrefix}writing-mode');\n\n  /** Sets the value of \"writing-mode\" */\n  void set writingMode(String value) {\n    setProperty('${Device.cssPrefix}writing-mode', value, '');\n  }\n\n  /** Gets the value of \"z-index\" */\n  String get zIndex =>\n    getPropertyValue('z-index');\n\n  /** Sets the value of \"z-index\" */\n  void set zIndex(String value) {\n    setProperty('z-index', value, '');\n  }\n\n  /** Gets the value of \"zoom\" */\n  String get zoom =>\n    getPropertyValue('zoom');\n\n  /** Sets the value of \"zoom\" */\n  void set zoom(String value) {\n    setProperty('zoom', value, '');\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CSSStyleRule')\nclass CssStyleRule extends CssRule native \"CSSStyleRule\" {\n\n  @DomName('CSSStyleRule.selectorText')\n  @DocsEditable\n  String selectorText;\n\n  @DomName('CSSStyleRule.style')\n  @DocsEditable\n  final CssStyleDeclaration style;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CSSStyleSheet')\nclass CssStyleSheet extends StyleSheet native \"CSSStyleSheet\" {\n\n  @DomName('CSSStyleSheet.cssRules')\n  @DocsEditable\n  @Returns('_CssRuleList')\n  @Creates('_CssRuleList')\n  final List<CssRule> cssRules;\n\n  @DomName('CSSStyleSheet.ownerRule')\n  @DocsEditable\n  final CssRule ownerRule;\n\n  @DomName('CSSStyleSheet.rules')\n  @DocsEditable\n  @Returns('_CssRuleList')\n  @Creates('_CssRuleList')\n  final List<CssRule> rules;\n\n  @DomName('CSSStyleSheet.addRule')\n  @DocsEditable\n  int addRule(String selector, String style, [int index]) native;\n\n  @DomName('CSSStyleSheet.deleteRule')\n  @DocsEditable\n  void deleteRule(int index) native;\n\n  @DomName('CSSStyleSheet.insertRule')\n  @DocsEditable\n  int insertRule(String rule, int index) native;\n\n  @DomName('CSSStyleSheet.removeRule')\n  @DocsEditable\n  void removeRule(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CSSUnknownRule')\nclass CssUnknownRule extends CssRule native \"CSSUnknownRule\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CustomElementConstructor')\nclass CustomElementConstructor native \"CustomElementConstructor\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('CustomEvent')\nclass CustomEvent extends Event native \"CustomEvent\" {\n  factory CustomEvent(String type,\n      {bool canBubble: true, bool cancelable: true, Object detail}) {\n\n    final CustomEvent e = document.$dom_createEvent(\"CustomEvent\");\n    e.$dom_initCustomEvent(type, canBubble, cancelable, detail);\n\n    return e;\n  }\n\n  @DomName('CustomEvent.detail')\n  @DocsEditable\n  final Object detail;\n\n  @JSName('initCustomEvent')\n  @DomName('CustomEvent.initCustomEvent')\n  @DocsEditable\n  void $dom_initCustomEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object detailArg) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLDListElement')\nclass DListElement extends Element native \"HTMLDListElement\" {\n\n  @DomName('HTMLDListElement.HTMLDListElement')\n  @DocsEditable\n  factory DListElement() => document.$dom_createElement(\"dl\");\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLDataListElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass DataListElement extends Element native \"HTMLDataListElement\" {\n\n  @DomName('HTMLDataListElement.HTMLDataListElement')\n  @DocsEditable\n  factory DataListElement() => document.$dom_createElement(\"datalist\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('datalist');\n\n  @DomName('HTMLDataListElement.options')\n  @DocsEditable\n  final HtmlCollection options;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Clipboard')\nclass DataTransfer native \"Clipboard\" {\n\n  @DomName('Clipboard.dropEffect')\n  @DocsEditable\n  String dropEffect;\n\n  @DomName('Clipboard.effectAllowed')\n  @DocsEditable\n  String effectAllowed;\n\n  @DomName('Clipboard.files')\n  @DocsEditable\n  @Returns('FileList')\n  @Creates('FileList')\n  final List<File> files;\n\n  @DomName('Clipboard.items')\n  @DocsEditable\n  final DataTransferItemList items;\n\n  @DomName('Clipboard.types')\n  @DocsEditable\n  final List types;\n\n  @DomName('Clipboard.clearData')\n  @DocsEditable\n  void clearData([String type]) native;\n\n  /**\n   * Gets the data for the specified type.\n   *\n   * The data is only available from within a drop operation (such as an\n   * [Element.onDrop] event) and will return `null` before the event is\n   * triggered.\n   *\n   * Data transfer is prohibited across domains. If a drag originates\n   * from content from another domain or protocol (HTTP vs HTTPS) then the\n   * data cannot be accessed.\n   *\n   * The [type] can have values such as:\n   *\n   * * `'Text'`\n   * * `'URL'`\n   */\n  @DomName('Clipboard.getData')\n  @DocsEditable\n  String getData(String type) native;\n\n  @DomName('Clipboard.setData')\n  @DocsEditable\n  bool setData(String type, String data) native;\n\n  @DomName('Clipboard.setDragImage')\n  @DocsEditable\n  void setDragImage(ImageElement image, int x, int y) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DataTransferItem')\nclass DataTransferItem native \"DataTransferItem\" {\n\n  @DomName('DataTransferItem.kind')\n  @DocsEditable\n  final String kind;\n\n  @DomName('DataTransferItem.type')\n  @DocsEditable\n  final String type;\n\n  @DomName('DataTransferItem.getAsFile')\n  @DocsEditable\n  Blob getAsFile() native;\n\n  @JSName('getAsString')\n  @DomName('DataTransferItem.getAsString')\n  @DocsEditable\n  void _getAsString([_StringCallback callback]) native;\n\n  @JSName('getAsString')\n  @DomName('DataTransferItem.getAsString')\n  @DocsEditable\n  Future<String> getAsString() {\n    var completer = new Completer<String>();\n    _getAsString(\n        (value) { completer.complete(value); });\n    return completer.future;\n  }\n\n  @JSName('webkitGetAsEntry')\n  @DomName('DataTransferItem.webkitGetAsEntry')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  Entry getAsEntry() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DataTransferItemList')\nclass DataTransferItemList native \"DataTransferItemList\" {\n\n  @DomName('DataTransferItemList.length')\n  @DocsEditable\n  final int length;\n\n  @DomName('DataTransferItemList.add')\n  @DocsEditable\n  void add(data_OR_file, [String type]) native;\n\n  @DomName('DataTransferItemList.clear')\n  @DocsEditable\n  void clear() native;\n\n  @DomName('DataTransferItemList.item')\n  @DocsEditable\n  DataTransferItem item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void DatabaseCallback(database);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLDetailsElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental\nclass DetailsElement extends Element native \"HTMLDetailsElement\" {\n\n  @DomName('HTMLDetailsElement.HTMLDetailsElement')\n  @DocsEditable\n  factory DetailsElement() => document.$dom_createElement(\"details\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('details');\n\n  @DomName('HTMLDetailsElement.open')\n  @DocsEditable\n  bool open;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DeviceAcceleration')\nclass DeviceAcceleration native \"DeviceAcceleration\" {\n\n  @DomName('DeviceAcceleration.x')\n  @DocsEditable\n  final num x;\n\n  @DomName('DeviceAcceleration.y')\n  @DocsEditable\n  final num y;\n\n  @DomName('DeviceAcceleration.z')\n  @DocsEditable\n  final num z;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DeviceMotionEvent')\nclass DeviceMotionEvent extends Event native \"DeviceMotionEvent\" {\n\n  @DomName('DeviceMotionEvent.acceleration')\n  @DocsEditable\n  final DeviceAcceleration acceleration;\n\n  @DomName('DeviceMotionEvent.accelerationIncludingGravity')\n  @DocsEditable\n  final DeviceAcceleration accelerationIncludingGravity;\n\n  @DomName('DeviceMotionEvent.interval')\n  @DocsEditable\n  final num interval;\n\n  @DomName('DeviceMotionEvent.rotationRate')\n  @DocsEditable\n  final DeviceRotationRate rotationRate;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n@DomName('DeviceOrientationEvent')\n\nclass DeviceOrientationEvent extends Event native \"DeviceOrientationEvent\" {\n  factory DeviceOrientationEvent(String type,\n      {bool canBubble: true, bool cancelable: true, num alpha: 0, num beta: 0,\n      num gamma: 0, bool absolute: false}) {\n    var e = document.$dom_createEvent(\"DeviceOrientationEvent\");\n    e.$dom_initDeviceOrientationEvent(type, canBubble, cancelable, alpha, beta,\n        gamma, absolute);\n    return e;\n  }\n\n  @DomName('DeviceOrientationEvent.absolute')\n  @DocsEditable\n  final bool absolute;\n\n  @DomName('DeviceOrientationEvent.alpha')\n  @DocsEditable\n  final num alpha;\n\n  @DomName('DeviceOrientationEvent.beta')\n  @DocsEditable\n  final num beta;\n\n  @DomName('DeviceOrientationEvent.gamma')\n  @DocsEditable\n  final num gamma;\n\n  @JSName('initDeviceOrientationEvent')\n  @DomName('DeviceOrientationEvent.initDeviceOrientationEvent')\n  @DocsEditable\n  void $dom_initDeviceOrientationEvent(String type, bool bubbles, bool cancelable, num alpha, num beta, num gamma, bool absolute) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DeviceRotationRate')\nclass DeviceRotationRate native \"DeviceRotationRate\" {\n\n  @DomName('DeviceRotationRate.alpha')\n  @DocsEditable\n  final num alpha;\n\n  @DomName('DeviceRotationRate.beta')\n  @DocsEditable\n  final num beta;\n\n  @DomName('DeviceRotationRate.gamma')\n  @DocsEditable\n  final num gamma;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLDialogElement')\nclass DialogElement extends Element native \"HTMLDialogElement\" {\n\n  @DomName('HTMLDialogElement.open')\n  @DocsEditable\n  bool open;\n\n  @DomName('HTMLDialogElement.close')\n  @DocsEditable\n  void close() native;\n\n  @DomName('HTMLDialogElement.show')\n  @DocsEditable\n  void show() native;\n\n  @DomName('HTMLDialogElement.showModal')\n  @DocsEditable\n  void showModal() native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('DirectoryEntry')\nclass DirectoryEntry extends Entry native \"DirectoryEntry\" {\n  \n  /**\n   * Create a new directory with the specified `path`. If `exclusive` is true,\n   * the returned Future will complete with an error if a directory already\n   * exists with the specified `path`.\n   */\n  Future<Entry> createDirectory(String path, {bool exclusive: false}) {\n    return _getDirectory(path, options: \n        {'create': true, 'exclusive': exclusive});\n  }\n\n  /**\n   * Retrieve an already existing directory entry. The returned future will\n   * result in an error if a directory at `path` does not exist or if the item\n   * at `path` is not a directory.\n   */\n  Future<Entry> getDirectory(String path) {\n    return _getDirectory(path);\n  }\n\n  /**\n   * Create a new file with the specified `path`. If `exclusive` is true,\n   * the returned Future will complete with an error if a file already\n   * exists at the specified `path`.\n   */\n  Future<Entry> createFile(String path, {bool exclusive: false}) {\n    return _getFile(path, options: {'create': true, 'exclusive': exclusive});\n  }\n  \n  /**\n   * Retrieve an already existing file entry. The returned future will\n   * result in an error if a file at `path` does not exist or if the item at\n   * `path` is not a file.\n   */\n  Future<Entry> getFile(String path) {\n    return _getFile(path);\n  }\n\n  @DomName('DirectoryEntry.createReader')\n  @DocsEditable\n  DirectoryReader createReader() native;\n\n  @DomName('DirectoryEntry.getDirectory')\n  @DocsEditable\n  void __getDirectory(String path, {Map options, _EntryCallback successCallback, _ErrorCallback errorCallback}) {\n    if (?errorCallback) {\n      var options_1 = convertDartToNative_Dictionary(options);\n      ___getDirectory_1(path, options_1, successCallback, errorCallback);\n      return;\n    }\n    if (?successCallback) {\n      var options_2 = convertDartToNative_Dictionary(options);\n      ___getDirectory_2(path, options_2, successCallback);\n      return;\n    }\n    if (?options) {\n      var options_3 = convertDartToNative_Dictionary(options);\n      ___getDirectory_3(path, options_3);\n      return;\n    }\n    ___getDirectory_4(path);\n    return;\n  }\n  @JSName('getDirectory')\n  @DomName('DirectoryEntry.getDirectory')\n  @DocsEditable\n  void ___getDirectory_1(path, options, _EntryCallback successCallback, _ErrorCallback errorCallback) native;\n  @JSName('getDirectory')\n  @DomName('DirectoryEntry.getDirectory')\n  @DocsEditable\n  void ___getDirectory_2(path, options, _EntryCallback successCallback) native;\n  @JSName('getDirectory')\n  @DomName('DirectoryEntry.getDirectory')\n  @DocsEditable\n  void ___getDirectory_3(path, options) native;\n  @JSName('getDirectory')\n  @DomName('DirectoryEntry.getDirectory')\n  @DocsEditable\n  void ___getDirectory_4(path) native;\n\n  @JSName('getDirectory')\n  @DomName('DirectoryEntry.getDirectory')\n  @DocsEditable\n  Future<Entry> _getDirectory(String path, {Map options}) {\n    var completer = new Completer<Entry>();\n    __getDirectory(path, options : options,\n        successCallback : (value) { completer.complete(value); },\n        errorCallback : (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @DomName('DirectoryEntry.getFile')\n  @DocsEditable\n  void __getFile(String path, {Map options, _EntryCallback successCallback, _ErrorCallback errorCallback}) {\n    if (?errorCallback) {\n      var options_1 = convertDartToNative_Dictionary(options);\n      ___getFile_1(path, options_1, successCallback, errorCallback);\n      return;\n    }\n    if (?successCallback) {\n      var options_2 = convertDartToNative_Dictionary(options);\n      ___getFile_2(path, options_2, successCallback);\n      return;\n    }\n    if (?options) {\n      var options_3 = convertDartToNative_Dictionary(options);\n      ___getFile_3(path, options_3);\n      return;\n    }\n    ___getFile_4(path);\n    return;\n  }\n  @JSName('getFile')\n  @DomName('DirectoryEntry.getFile')\n  @DocsEditable\n  void ___getFile_1(path, options, _EntryCallback successCallback, _ErrorCallback errorCallback) native;\n  @JSName('getFile')\n  @DomName('DirectoryEntry.getFile')\n  @DocsEditable\n  void ___getFile_2(path, options, _EntryCallback successCallback) native;\n  @JSName('getFile')\n  @DomName('DirectoryEntry.getFile')\n  @DocsEditable\n  void ___getFile_3(path, options) native;\n  @JSName('getFile')\n  @DomName('DirectoryEntry.getFile')\n  @DocsEditable\n  void ___getFile_4(path) native;\n\n  @JSName('getFile')\n  @DomName('DirectoryEntry.getFile')\n  @DocsEditable\n  Future<Entry> _getFile(String path, {Map options}) {\n    var completer = new Completer<Entry>();\n    __getFile(path, options : options,\n        successCallback : (value) { completer.complete(value); },\n        errorCallback : (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('removeRecursively')\n  @DomName('DirectoryEntry.removeRecursively')\n  @DocsEditable\n  void _removeRecursively(VoidCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('removeRecursively')\n  @DomName('DirectoryEntry.removeRecursively')\n  @DocsEditable\n  Future removeRecursively() {\n    var completer = new Completer();\n    _removeRecursively(\n        () { completer.complete(); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n}\n\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DirectoryReader')\nclass DirectoryReader native \"DirectoryReader\" {\n\n  @JSName('readEntries')\n  @DomName('DirectoryReader.readEntries')\n  @DocsEditable\n  void _readEntries(_EntriesCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('readEntries')\n  @DomName('DirectoryReader.readEntries')\n  @DocsEditable\n  Future<List<Entry>> readEntries() {\n    var completer = new Completer<List<Entry>>();\n    _readEntries(\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n/**\n * Represents an HTML <div> element.\n *\n * The [DivElement] is a generic container for content and does not have any\n * special significance. It is functionally similar to [SpanElement].\n *\n * The [DivElement] is a block-level element, as opposed to [SpanElement],\n * which is an inline-level element.\n *\n * Example usage:\n *\n *     DivElement div = new DivElement();\n *     div.text = 'Here's my new DivElem\n *     document.body.elements.add(elem);\n *\n * See also:\n *\n * * [HTML <div> element](http://www.w3.org/TR/html-markup/div.html) from W3C.\n * * [Block-level element](http://www.w3.org/TR/CSS2/visuren.html#block-boxes) from W3C.\n * * [Inline-level element](http://www.w3.org/TR/CSS2/visuren.html#inline-boxes) from W3C.\n */\n@DomName('HTMLDivElement')\nclass DivElement extends Element native \"HTMLDivElement\" {\n\n  @DomName('HTMLDivElement.HTMLDivElement')\n  @DocsEditable\n  factory DivElement() => document.$dom_createElement(\"div\");\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * The base class for all documents.\n *\n * Each web page loaded in the browser has its own [Document] object, which is\n * typically an [HtmlDocument].\n *\n * If you aren't comfortable with DOM concepts, see the Dart tutorial\n * [Target 2: Connect Dart & HTML](http://www.dartlang.org/docs/tutorials/connect-dart-html/).\n */\n@DomName('Document')\nclass Document extends Node  native \"Document\"\n{\n\n\n  @DomName('Document.readystatechangeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> readyStateChangeEvent = const EventStreamProvider<Event>('readystatechange');\n\n  @DomName('Document.selectionchangeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> selectionChangeEvent = const EventStreamProvider<Event>('selectionchange');\n\n  @DomName('Document.webkitpointerlockchangeEvent')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  static const EventStreamProvider<Event> pointerLockChangeEvent = const EventStreamProvider<Event>('webkitpointerlockchange');\n\n  @DomName('Document.webkitpointerlockerrorEvent')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  static const EventStreamProvider<Event> pointerLockErrorEvent = const EventStreamProvider<Event>('webkitpointerlockerror');\n\n  @JSName('body')\n  /// Moved to [HtmlDocument].\n  @DomName('Document.body')\n  @DocsEditable\n  Element $dom_body;\n\n  @DomName('Document.charset')\n  @DocsEditable\n  String charset;\n\n  @DomName('Document.cookie')\n  @DocsEditable\n  String cookie;\n\n  WindowBase get window => _convertNativeToDart_Window(this._get_window);\n  @JSName('defaultView')\n  @DomName('Document.window')\n  @DocsEditable\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_window;\n\n  @DomName('Document.documentElement')\n  @DocsEditable\n  final Element documentElement;\n\n  @DomName('Document.domain')\n  @DocsEditable\n  final String domain;\n\n  @DomName('Document.fontloader')\n  @DocsEditable\n  final FontLoader fontloader;\n\n  @JSName('head')\n  /// Moved to [HtmlDocument].\n  @DomName('Document.head')\n  @DocsEditable\n  final HeadElement $dom_head;\n\n  @DomName('Document.implementation')\n  @DocsEditable\n  final DomImplementation implementation;\n\n  @JSName('lastModified')\n  /// Moved to [HtmlDocument].\n  @DomName('Document.lastModified')\n  @DocsEditable\n  final String $dom_lastModified;\n\n  @JSName('preferredStylesheetSet')\n  @DomName('Document.preferredStylesheetSet')\n  @DocsEditable\n  final String $dom_preferredStylesheetSet;\n\n  @DomName('Document.readyState')\n  @DocsEditable\n  final String readyState;\n\n  @JSName('referrer')\n  /// Moved to [HtmlDocument].\n  @DomName('Document.referrer')\n  @DocsEditable\n  final String $dom_referrer;\n\n  @DomName('Document.securityPolicy')\n  @DocsEditable\n  final DomSecurityPolicy securityPolicy;\n\n  @JSName('selectedStylesheetSet')\n  @DomName('Document.selectedStylesheetSet')\n  @DocsEditable\n  String $dom_selectedStylesheetSet;\n\n  @JSName('styleSheets')\n  /// Moved to [HtmlDocument]\n  @DomName('Document.styleSheets')\n  @DocsEditable\n  @Returns('_StyleSheetList')\n  @Creates('_StyleSheetList')\n  final List<StyleSheet> $dom_styleSheets;\n\n  @JSName('title')\n  /// Moved to [HtmlDocument].\n  @DomName('Document.title')\n  @DocsEditable\n  String $dom_title;\n\n  @JSName('webkitFullscreenElement')\n  /// Moved to [HtmlDocument].\n  @DomName('Document.webkitFullscreenElement')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final Element $dom_webkitFullscreenElement;\n\n  @JSName('webkitFullscreenEnabled')\n  /// Moved to [HtmlDocument].\n  @DomName('Document.webkitFullscreenEnabled')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final bool $dom_webkitFullscreenEnabled;\n\n  @JSName('webkitHidden')\n  /// Moved to [HtmlDocument].\n  @DomName('Document.webkitHidden')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final bool $dom_webkitHidden;\n\n  @JSName('webkitIsFullScreen')\n  /// Moved to [HtmlDocument].\n  @DomName('Document.webkitIsFullScreen')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final bool $dom_webkitIsFullScreen;\n\n  @JSName('webkitPointerLockElement')\n  /// Moved to [HtmlDocument].\n  @DomName('Document.webkitPointerLockElement')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final Element $dom_webkitPointerLockElement;\n\n  @JSName('webkitVisibilityState')\n  @DomName('Document.webkitVisibilityState')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final String $dom_webkitVisibilityState;\n\n  @JSName('caretRangeFromPoint')\n  /// Use the [Range] constructor instead.\n  @DomName('Document.caretRangeFromPoint')\n  @DocsEditable\n  Range $dom_caretRangeFromPoint(int x, int y) native;\n\n  @JSName('createCDATASection')\n  @DomName('Document.createCDATASection')\n  @DocsEditable\n  CDataSection createCDataSection(String data) native;\n\n  @DomName('Document.createDocumentFragment')\n  @DocsEditable\n  DocumentFragment createDocumentFragment() native;\n\n  @JSName('createElement')\n  /// Deprecated: use new Element.tag(tagName) instead.\n  @DomName('Document.createElement')\n  @DocsEditable\n  Element $dom_createElement(String localName_OR_tagName, [String typeExtension]) native;\n\n  @JSName('createElementNS')\n  @DomName('Document.createElementNS')\n  @DocsEditable\n  Element $dom_createElementNS(String namespaceURI, String qualifiedName, [String typeExtension]) native;\n\n  @JSName('createEvent')\n  @DomName('Document.createEvent')\n  @DocsEditable\n  Event $dom_createEvent(String eventType) native;\n\n  @JSName('createRange')\n  @DomName('Document.createRange')\n  @DocsEditable\n  Range $dom_createRange() native;\n\n  @JSName('createTextNode')\n  @DomName('Document.createTextNode')\n  @DocsEditable\n  Text $dom_createTextNode(String data) native;\n\n  @DomName('Document.createTouch')\n  @DocsEditable\n  Touch $dom_createTouch(Window window, EventTarget target, int identifier, int pageX, int pageY, int screenX, int screenY, int webkitRadiusX, int webkitRadiusY, num webkitRotationAngle, num webkitForce) {\n    var target_1 = _convertDartToNative_EventTarget(target);\n    return _$dom_createTouch_1(window, target_1, identifier, pageX, pageY, screenX, screenY, webkitRadiusX, webkitRadiusY, webkitRotationAngle, webkitForce);\n  }\n  @JSName('createTouch')\n  @DomName('Document.createTouch')\n  @DocsEditable\n  Touch _$dom_createTouch_1(Window window, target, identifier, pageX, pageY, screenX, screenY, webkitRadiusX, webkitRadiusY, webkitRotationAngle, webkitForce) native;\n\n  @JSName('createTouchList')\n  /// Use the [TouchList] constructor instead.\n  @DomName('Document.createTouchList')\n  @DocsEditable\n  TouchList $dom_createTouchList() native;\n\n  @JSName('elementFromPoint')\n  @DomName('Document.elementFromPoint')\n  @DocsEditable\n  Element $dom_elementFromPoint(int x, int y) native;\n\n  @DomName('Document.execCommand')\n  @DocsEditable\n  bool execCommand(String command, bool userInterface, String value) native;\n\n  @JSName('getCSSCanvasContext')\n  /// Moved to [HtmlDocument].\n  @DomName('Document.getCSSCanvasContext')\n  @DocsEditable\n  CanvasRenderingContext $dom_getCssCanvasContext(String contextId, String name, int width, int height) native;\n\n  @DomName('Document.getElementById')\n  @DocsEditable\n  Element getElementById(String elementId) native;\n\n  @DomName('Document.getElementsByClassName')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getElementsByClassName(String tagname) native;\n\n  @DomName('Document.getElementsByName')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getElementsByName(String elementName) native;\n\n  @DomName('Document.getElementsByTagName')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getElementsByTagName(String tagname) native;\n\n  @DomName('Document.queryCommandEnabled')\n  @DocsEditable\n  bool queryCommandEnabled(String command) native;\n\n  @DomName('Document.queryCommandIndeterm')\n  @DocsEditable\n  bool queryCommandIndeterm(String command) native;\n\n  @DomName('Document.queryCommandState')\n  @DocsEditable\n  bool queryCommandState(String command) native;\n\n  @DomName('Document.queryCommandSupported')\n  @DocsEditable\n  bool queryCommandSupported(String command) native;\n\n  @DomName('Document.queryCommandValue')\n  @DocsEditable\n  String queryCommandValue(String command) native;\n\n  @JSName('querySelector')\n  /**\n * Finds the first descendant element of this document that matches the\n * specified group of selectors.\n *\n * Unless your webpage contains multiple documents, the top-level query\n * method behaves the same as this method, so you should use it instead to\n * save typing a few characters.\n *\n * [selectors] should be a string using CSS selector syntax.\n *     var element1 = document.query('.className');\n *     var element2 = document.query('#id');\n *\n * For details about CSS selector syntax, see the\n * [CSS selector specification](http://www.w3.org/TR/css3-selectors/).\n */\n  @DomName('Document.querySelector')\n  @DocsEditable\n  Element query(String selectors) native;\n\n  @JSName('querySelectorAll')\n  /// Deprecated: use query(\"#$elementId\") instead.\n  @DomName('Document.querySelectorAll')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> $dom_querySelectorAll(String selectors) native;\n\n  @JSName('webkitCancelFullScreen')\n  /// Moved to [HtmlDocument].\n  @DomName('Document.webkitCancelFullScreen')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void $dom_webkitCancelFullScreen() native;\n\n  @JSName('webkitExitFullscreen')\n  /// Moved to [HtmlDocument].\n  @DomName('Document.webkitExitFullscreen')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void $dom_webkitExitFullscreen() native;\n\n  @JSName('webkitExitPointerLock')\n  /// Moved to [HtmlDocument].\n  @DomName('Document.webkitExitPointerLock')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void $dom_webkitExitPointerLock() native;\n\n  @JSName('webkitGetNamedFlows')\n  @DomName('Document.webkitGetNamedFlows')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  DomNamedFlowCollection getNamedFlows() native;\n\n  @DomName('Document.webkitRegister')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  CustomElementConstructor register(String name, [Map options]) {\n    if (?options) {\n      var options_1 = convertDartToNative_Dictionary(options);\n      return _register_1(name, options_1);\n    }\n    return _register_2(name);\n  }\n  @JSName('webkitRegister')\n  @DomName('Document.webkitRegister')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  CustomElementConstructor _register_1(name, options) native;\n  @JSName('webkitRegister')\n  @DomName('Document.webkitRegister')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  CustomElementConstructor _register_2(name) native;\n\n  @DomName('Document.onabort')\n  @DocsEditable\n  Stream<Event> get onAbort => Element.abortEvent.forTarget(this);\n\n  @DomName('Document.onbeforecopy')\n  @DocsEditable\n  Stream<Event> get onBeforeCopy => Element.beforeCopyEvent.forTarget(this);\n\n  @DomName('Document.onbeforecut')\n  @DocsEditable\n  Stream<Event> get onBeforeCut => Element.beforeCutEvent.forTarget(this);\n\n  @DomName('Document.onbeforepaste')\n  @DocsEditable\n  Stream<Event> get onBeforePaste => Element.beforePasteEvent.forTarget(this);\n\n  @DomName('Document.onblur')\n  @DocsEditable\n  Stream<Event> get onBlur => Element.blurEvent.forTarget(this);\n\n  @DomName('Document.onchange')\n  @DocsEditable\n  Stream<Event> get onChange => Element.changeEvent.forTarget(this);\n\n  @DomName('Document.onclick')\n  @DocsEditable\n  Stream<MouseEvent> get onClick => Element.clickEvent.forTarget(this);\n\n  @DomName('Document.oncontextmenu')\n  @DocsEditable\n  Stream<MouseEvent> get onContextMenu => Element.contextMenuEvent.forTarget(this);\n\n  @DomName('Document.oncopy')\n  @DocsEditable\n  Stream<Event> get onCopy => Element.copyEvent.forTarget(this);\n\n  @DomName('Document.oncut')\n  @DocsEditable\n  Stream<Event> get onCut => Element.cutEvent.forTarget(this);\n\n  @DomName('Document.ondblclick')\n  @DocsEditable\n  Stream<Event> get onDoubleClick => Element.doubleClickEvent.forTarget(this);\n\n  @DomName('Document.ondrag')\n  @DocsEditable\n  Stream<MouseEvent> get onDrag => Element.dragEvent.forTarget(this);\n\n  @DomName('Document.ondragend')\n  @DocsEditable\n  Stream<MouseEvent> get onDragEnd => Element.dragEndEvent.forTarget(this);\n\n  @DomName('Document.ondragenter')\n  @DocsEditable\n  Stream<MouseEvent> get onDragEnter => Element.dragEnterEvent.forTarget(this);\n\n  @DomName('Document.ondragleave')\n  @DocsEditable\n  Stream<MouseEvent> get onDragLeave => Element.dragLeaveEvent.forTarget(this);\n\n  @DomName('Document.ondragover')\n  @DocsEditable\n  Stream<MouseEvent> get onDragOver => Element.dragOverEvent.forTarget(this);\n\n  @DomName('Document.ondragstart')\n  @DocsEditable\n  Stream<MouseEvent> get onDragStart => Element.dragStartEvent.forTarget(this);\n\n  @DomName('Document.ondrop')\n  @DocsEditable\n  Stream<MouseEvent> get onDrop => Element.dropEvent.forTarget(this);\n\n  @DomName('Document.onerror')\n  @DocsEditable\n  Stream<Event> get onError => Element.errorEvent.forTarget(this);\n\n  @DomName('Document.onfocus')\n  @DocsEditable\n  Stream<Event> get onFocus => Element.focusEvent.forTarget(this);\n\n  @DomName('Document.oninput')\n  @DocsEditable\n  Stream<Event> get onInput => Element.inputEvent.forTarget(this);\n\n  @DomName('Document.oninvalid')\n  @DocsEditable\n  Stream<Event> get onInvalid => Element.invalidEvent.forTarget(this);\n\n  @DomName('Document.onkeydown')\n  @DocsEditable\n  Stream<KeyboardEvent> get onKeyDown => Element.keyDownEvent.forTarget(this);\n\n  @DomName('Document.onkeypress')\n  @DocsEditable\n  Stream<KeyboardEvent> get onKeyPress => Element.keyPressEvent.forTarget(this);\n\n  @DomName('Document.onkeyup')\n  @DocsEditable\n  Stream<KeyboardEvent> get onKeyUp => Element.keyUpEvent.forTarget(this);\n\n  @DomName('Document.onload')\n  @DocsEditable\n  Stream<Event> get onLoad => Element.loadEvent.forTarget(this);\n\n  @DomName('Document.onmousedown')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseDown => Element.mouseDownEvent.forTarget(this);\n\n  @DomName('Document.onmousemove')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseMove => Element.mouseMoveEvent.forTarget(this);\n\n  @DomName('Document.onmouseout')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseOut => Element.mouseOutEvent.forTarget(this);\n\n  @DomName('Document.onmouseover')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseOver => Element.mouseOverEvent.forTarget(this);\n\n  @DomName('Document.onmouseup')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseUp => Element.mouseUpEvent.forTarget(this);\n\n  @DomName('Document.onmousewheel')\n  @DocsEditable\n  Stream<WheelEvent> get onMouseWheel => Element.mouseWheelEvent.forTarget(this);\n\n  @DomName('Document.onpaste')\n  @DocsEditable\n  Stream<Event> get onPaste => Element.pasteEvent.forTarget(this);\n\n  @DomName('Document.onreadystatechange')\n  @DocsEditable\n  Stream<Event> get onReadyStateChange => readyStateChangeEvent.forTarget(this);\n\n  @DomName('Document.onreset')\n  @DocsEditable\n  Stream<Event> get onReset => Element.resetEvent.forTarget(this);\n\n  @DomName('Document.onscroll')\n  @DocsEditable\n  Stream<Event> get onScroll => Element.scrollEvent.forTarget(this);\n\n  @DomName('Document.onsearch')\n  @DocsEditable\n  Stream<Event> get onSearch => Element.searchEvent.forTarget(this);\n\n  @DomName('Document.onselect')\n  @DocsEditable\n  Stream<Event> get onSelect => Element.selectEvent.forTarget(this);\n\n  @DomName('Document.onselectionchange')\n  @DocsEditable\n  Stream<Event> get onSelectionChange => selectionChangeEvent.forTarget(this);\n\n  @DomName('Document.onselectstart')\n  @DocsEditable\n  Stream<Event> get onSelectStart => Element.selectStartEvent.forTarget(this);\n\n  @DomName('Document.onsubmit')\n  @DocsEditable\n  Stream<Event> get onSubmit => Element.submitEvent.forTarget(this);\n\n  @DomName('Document.ontouchcancel')\n  @DocsEditable\n  Stream<TouchEvent> get onTouchCancel => Element.touchCancelEvent.forTarget(this);\n\n  @DomName('Document.ontouchend')\n  @DocsEditable\n  Stream<TouchEvent> get onTouchEnd => Element.touchEndEvent.forTarget(this);\n\n  @DomName('Document.ontouchmove')\n  @DocsEditable\n  Stream<TouchEvent> get onTouchMove => Element.touchMoveEvent.forTarget(this);\n\n  @DomName('Document.ontouchstart')\n  @DocsEditable\n  Stream<TouchEvent> get onTouchStart => Element.touchStartEvent.forTarget(this);\n\n  @DomName('Document.onwebkitfullscreenchange')\n  @DocsEditable\n  Stream<Event> get onFullscreenChange => Element.fullscreenChangeEvent.forTarget(this);\n\n  @DomName('Document.onwebkitfullscreenerror')\n  @DocsEditable\n  Stream<Event> get onFullscreenError => Element.fullscreenErrorEvent.forTarget(this);\n\n  @DomName('Document.onwebkitpointerlockchange')\n  @DocsEditable\n  Stream<Event> get onPointerLockChange => pointerLockChangeEvent.forTarget(this);\n\n  @DomName('Document.onwebkitpointerlockerror')\n  @DocsEditable\n  Stream<Event> get onPointerLockError => pointerLockErrorEvent.forTarget(this);\n\n\n  /**\n   * Finds all descendant elements of this document that match the specified\n   * group of selectors.\n   *\n   * Unless your webpage contains multiple documents, the top-level queryAll\n   * method behaves the same as this method, so you should use it instead to\n   * save typing a few characters.\n   *\n   * [selectors] should be a string using CSS selector syntax.\n   *     var items = document.queryAll('.itemClassName');\n   *\n   * For details about CSS selector syntax, see the\n   * [CSS selector specification](http://www.w3.org/TR/css3-selectors/).\n   */\n  List<Element> queryAll(String selectors) {\n    return new _FrozenElementList._wrap($dom_querySelectorAll(selectors));\n  }\n}\n// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('DocumentFragment')\nclass DocumentFragment extends Node native \"DocumentFragment\" {\n  factory DocumentFragment() => _DocumentFragmentFactoryProvider.createDocumentFragment();\n\n  factory DocumentFragment.html(String html) =>\n      _DocumentFragmentFactoryProvider.createDocumentFragment_html(html);\n\n  factory DocumentFragment.svg(String svgContent) =>\n      _DocumentFragmentFactoryProvider.createDocumentFragment_svg(svgContent);\n\n  // Native field is used only by Dart code so does not lead to instantiation\n  // of native classes\n  @Creates('Null')\n  List<Element> _children;\n\n  List<Element> get children {\n    if (_children == null) {\n      _children = new FilteredElementList(this);\n    }\n    return _children;\n  }\n\n  void set children(List<Element> value) {\n    // Copy list first since we don't want liveness during iteration.\n    List copy = new List.from(value);\n    var children = this.children;\n    children.clear();\n    children.addAll(copy);\n  }\n\n  Element query(String selectors) => $dom_querySelector(selectors);\n\n  List<Element> queryAll(String selectors) =>\n    new _FrozenElementList._wrap($dom_querySelectorAll(selectors));\n\n  String get innerHtml {\n    final e = new Element.tag(\"div\");\n    e.append(this.clone(true));\n    return e.innerHtml;\n  }\n\n  // TODO(nweiz): Do we want to support some variant of innerHtml for XML and/or\n  // SVG strings?\n  void set innerHtml(String value) {\n    this.nodes.clear();\n\n    final e = new Element.tag(\"div\");\n    e.innerHtml = value;\n\n    // Copy list first since we don't want liveness during iteration.\n    List nodes = new List.from(e.nodes);\n    this.nodes.addAll(nodes);\n  }\n\n  /**\n   * Adds the specified text as a text node after the last child of this\n   * document fragment.\n   */\n  void appendText(String text) {\n    this.append(new Text(text));\n  }\n\n\n  /**\n   * Parses the specified text as HTML and adds the resulting node after the\n   * last child of this document fragment.\n   */\n  void appendHtml(String text) {\n    this.append(new DocumentFragment.html(text));\n  }\n\n\n  @JSName('querySelector')\n  @DomName('DocumentFragment.querySelector')\n  @DocsEditable\n  Element $dom_querySelector(String selectors) native;\n\n  @JSName('querySelectorAll')\n  @DomName('DocumentFragment.querySelectorAll')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> $dom_querySelectorAll(String selectors) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DocumentType')\nclass DocumentType extends Node native \"DocumentType\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DOMError')\nclass DomError native \"DOMError\" {\n\n  @DomName('DOMError.name')\n  @DocsEditable\n  final String name;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('DOMException')\nclass DomException native \"DOMException\" {\n\n  static const String INDEX_SIZE = 'IndexSizeError';\n  static const String HIERARCHY_REQUEST = 'HierarchyRequestError';\n  static const String WRONG_DOCUMENT = 'WrongDocumentError';\n  static const String INVALID_CHARACTER = 'InvalidCharacterError';\n  static const String NO_MODIFICATION_ALLOWED = 'NoModificationAllowedError';\n  static const String NOT_FOUND = 'NotFoundError';\n  static const String NOT_SUPPORTED = 'NotSupportedError';\n  static const String INVALID_STATE = 'InvalidStateError';\n  static const String SYNTAX = 'SyntaxError';\n  static const String INVALID_MODIFICATION = 'InvalidModificationError';\n  static const String NAMESPACE = 'NamespaceError';\n  static const String INVALID_ACCESS = 'InvalidAccessError';\n  static const String TYPE_MISMATCH = 'TypeMismatchError';\n  static const String SECURITY = 'SecurityError';\n  static const String NETWORK = 'NetworkError';\n  static const String ABORT = 'AbortError';\n  static const String URL_MISMATCH = 'URLMismatchError';\n  static const String QUOTA_EXCEEDED = 'QuotaExceededError';\n  static const String TIMEOUT = 'TimeoutError';\n  static const String INVALID_NODE_TYPE = 'InvalidNodeTypeError';\n  static const String DATA_CLONE = 'DataCloneError';\n\n  String get name {\n    var errorName = JS('String', '#.name', this);\n    // Although Safari nightly has updated the name to SecurityError, Safari 5\n    // and 6 still return SECURITY_ERR.\n    if (Device.isWebKit && errorName == 'SECURITY_ERR') return 'SecurityError';\n    // Chrome release still uses old string, remove this line when Chrome stable\n    // also prints out SyntaxError.\n    if (Device.isWebKit && errorName == 'SYNTAX_ERR') return 'SyntaxError';\n    return errorName;\n  }\n\n  @DomName('DOMCoreException.message')\n  @DocsEditable\n  final String message;\n\n  @DomName('DOMCoreException.toString')\n  @DocsEditable\n  String toString() native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DOMImplementation')\nclass DomImplementation native \"DOMImplementation\" {\n\n  @JSName('createCSSStyleSheet')\n  @DomName('DOMImplementation.createCSSStyleSheet')\n  @DocsEditable\n  CssStyleSheet createCssStyleSheet(String title, String media) native;\n\n  @DomName('DOMImplementation.createDocument')\n  @DocsEditable\n  Document createDocument(String namespaceURI, String qualifiedName, DocumentType doctype) native;\n\n  @DomName('DOMImplementation.createDocumentType')\n  @DocsEditable\n  DocumentType createDocumentType(String qualifiedName, String publicId, String systemId) native;\n\n  @JSName('createHTMLDocument')\n  @DomName('DOMImplementation.createHTMLDocument')\n  @DocsEditable\n  HtmlDocument createHtmlDocument(String title) native;\n\n  @DomName('DOMImplementation.hasFeature')\n  @DocsEditable\n  bool hasFeature(String feature, String version) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MimeType')\nclass DomMimeType native \"MimeType\" {\n\n  @DomName('DOMMimeType.description')\n  @DocsEditable\n  final String description;\n\n  @DomName('DOMMimeType.enabledPlugin')\n  @DocsEditable\n  final DomPlugin enabledPlugin;\n\n  @DomName('DOMMimeType.suffixes')\n  @DocsEditable\n  final String suffixes;\n\n  @DomName('DOMMimeType.type')\n  @DocsEditable\n  final String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MimeTypeArray')\nclass DomMimeTypeArray implements JavaScriptIndexingBehavior, List<DomMimeType> native \"MimeTypeArray\" {\n\n  @DomName('DOMMimeTypeArray.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  DomMimeType operator[](int index) => JS(\"DomMimeType\", \"#[#]\", this, index);\n\n  void operator[]=(int index, DomMimeType value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<DomMimeType> mixins.\n  // DomMimeType is the element type.\n\n  // From Iterable<DomMimeType>:\n\n  Iterator<DomMimeType> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<DomMimeType>(this);\n  }\n\n  DomMimeType reduce(DomMimeType combine(DomMimeType value, DomMimeType element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, DomMimeType element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(DomMimeType element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(DomMimeType element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(DomMimeType element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<DomMimeType> where(bool f(DomMimeType element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(DomMimeType element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(DomMimeType element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(DomMimeType element)) => IterableMixinWorkaround.any(this, f);\n\n  List<DomMimeType> toList({ bool growable: true }) =>\n      new List<DomMimeType>.from(this, growable: growable);\n\n  Set<DomMimeType> toSet() => new Set<DomMimeType>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<DomMimeType> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<DomMimeType> takeWhile(bool test(DomMimeType value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<DomMimeType> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<DomMimeType> skipWhile(bool test(DomMimeType value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  DomMimeType firstWhere(bool test(DomMimeType value), { DomMimeType orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  DomMimeType lastWhere(bool test(DomMimeType value), {DomMimeType orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  DomMimeType singleWhere(bool test(DomMimeType value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  DomMimeType elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<DomMimeType>:\n\n  void add(DomMimeType value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<DomMimeType> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<DomMimeType>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<DomMimeType> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(DomMimeType a, DomMimeType b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(DomMimeType element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(DomMimeType element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  DomMimeType get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  DomMimeType get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  DomMimeType get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, DomMimeType element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<DomMimeType> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<DomMimeType> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  DomMimeType removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  DomMimeType removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(DomMimeType element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(DomMimeType element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<DomMimeType> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<DomMimeType> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [DomMimeType fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<DomMimeType> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<DomMimeType> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <DomMimeType>[]);\n  }\n\n  Map<int, DomMimeType> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<DomMimeType> mixins.\n\n  @DomName('DOMMimeTypeArray.item')\n  @DocsEditable\n  DomMimeType item(int index) native;\n\n  @DomName('DOMMimeTypeArray.namedItem')\n  @DocsEditable\n  DomMimeType namedItem(String name) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebKitNamedFlowCollection')\nclass DomNamedFlowCollection native \"WebKitNamedFlowCollection\" {\n\n  @DomName('DOMNamedFlowCollection.length')\n  @DocsEditable\n  final int length;\n\n  @DomName('DOMNamedFlowCollection.item')\n  @DocsEditable\n  NamedFlow item(int index) native;\n\n  @DomName('DOMNamedFlowCollection.namedItem')\n  @DocsEditable\n  NamedFlow namedItem(String name) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DOMParser')\nclass DomParser native \"DOMParser\" {\n\n  @DomName('DOMParser.DOMParser')\n  @DocsEditable\n  factory DomParser() {\n    return DomParser._create_1();\n  }\n  static DomParser _create_1() => JS('DomParser', 'new DOMParser()');\n\n  @DomName('DOMParser.parseFromString')\n  @DocsEditable\n  Document parseFromString(String str, String contentType) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Path')\nclass DomPath native \"Path\" {\n\n  @DomName('DOMPath.DOMPath')\n  @DocsEditable\n  factory DomPath([path_OR_text]) {\n    if (!?path_OR_text) {\n      return DomPath._create_1();\n    }\n    if ((path_OR_text is DomPath || path_OR_text == null)) {\n      return DomPath._create_2(path_OR_text);\n    }\n    if ((path_OR_text is String || path_OR_text == null)) {\n      return DomPath._create_3(path_OR_text);\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  static DomPath _create_1() => JS('DomPath', 'new Path()');\n  static DomPath _create_2(path_OR_text) => JS('DomPath', 'new Path(#)', path_OR_text);\n  static DomPath _create_3(path_OR_text) => JS('DomPath', 'new Path(#)', path_OR_text);\n\n  @DomName('DOMPath.arc')\n  @DocsEditable\n  void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise) native;\n\n  @DomName('DOMPath.arcTo')\n  @DocsEditable\n  void arcTo(num x1, num y1, num x2, num y2, num radius) native;\n\n  @DomName('DOMPath.bezierCurveTo')\n  @DocsEditable\n  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y) native;\n\n  @DomName('DOMPath.closePath')\n  @DocsEditable\n  void closePath() native;\n\n  @DomName('DOMPath.lineTo')\n  @DocsEditable\n  void lineTo(num x, num y) native;\n\n  @DomName('DOMPath.moveTo')\n  @DocsEditable\n  void moveTo(num x, num y) native;\n\n  @DomName('DOMPath.quadraticCurveTo')\n  @DocsEditable\n  void quadraticCurveTo(num cpx, num cpy, num x, num y) native;\n\n  @DomName('DOMPath.rect')\n  @DocsEditable\n  void rect(num x, num y, num width, num height) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Plugin')\nclass DomPlugin native \"Plugin\" {\n\n  @DomName('DOMPlugin.description')\n  @DocsEditable\n  final String description;\n\n  @DomName('DOMPlugin.filename')\n  @DocsEditable\n  final String filename;\n\n  @DomName('DOMPlugin.length')\n  @DocsEditable\n  final int length;\n\n  @DomName('DOMPlugin.name')\n  @DocsEditable\n  final String name;\n\n  @DomName('DOMPlugin.item')\n  @DocsEditable\n  DomMimeType item(int index) native;\n\n  @DomName('DOMPlugin.namedItem')\n  @DocsEditable\n  DomMimeType namedItem(String name) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('PluginArray')\nclass DomPluginArray implements JavaScriptIndexingBehavior, List<DomPlugin> native \"PluginArray\" {\n\n  @DomName('DOMPluginArray.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  DomPlugin operator[](int index) => JS(\"DomPlugin\", \"#[#]\", this, index);\n\n  void operator[]=(int index, DomPlugin value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<DomPlugin> mixins.\n  // DomPlugin is the element type.\n\n  // From Iterable<DomPlugin>:\n\n  Iterator<DomPlugin> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<DomPlugin>(this);\n  }\n\n  DomPlugin reduce(DomPlugin combine(DomPlugin value, DomPlugin element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, DomPlugin element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(DomPlugin element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(DomPlugin element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(DomPlugin element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<DomPlugin> where(bool f(DomPlugin element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(DomPlugin element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(DomPlugin element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(DomPlugin element)) => IterableMixinWorkaround.any(this, f);\n\n  List<DomPlugin> toList({ bool growable: true }) =>\n      new List<DomPlugin>.from(this, growable: growable);\n\n  Set<DomPlugin> toSet() => new Set<DomPlugin>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<DomPlugin> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<DomPlugin> takeWhile(bool test(DomPlugin value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<DomPlugin> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<DomPlugin> skipWhile(bool test(DomPlugin value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  DomPlugin firstWhere(bool test(DomPlugin value), { DomPlugin orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  DomPlugin lastWhere(bool test(DomPlugin value), {DomPlugin orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  DomPlugin singleWhere(bool test(DomPlugin value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  DomPlugin elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<DomPlugin>:\n\n  void add(DomPlugin value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<DomPlugin> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<DomPlugin>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<DomPlugin> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(DomPlugin a, DomPlugin b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(DomPlugin element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(DomPlugin element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  DomPlugin get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  DomPlugin get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  DomPlugin get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, DomPlugin element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<DomPlugin> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<DomPlugin> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  DomPlugin removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  DomPlugin removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(DomPlugin element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(DomPlugin element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<DomPlugin> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<DomPlugin> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [DomPlugin fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<DomPlugin> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<DomPlugin> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <DomPlugin>[]);\n  }\n\n  Map<int, DomPlugin> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<DomPlugin> mixins.\n\n  @DomName('DOMPluginArray.item')\n  @DocsEditable\n  DomPlugin item(int index) native;\n\n  @DomName('DOMPluginArray.namedItem')\n  @DocsEditable\n  DomPlugin namedItem(String name) native;\n\n  @DomName('DOMPluginArray.refresh')\n  @DocsEditable\n  void refresh(bool reload) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SecurityPolicy')\nclass DomSecurityPolicy native \"SecurityPolicy\" {\n\n  @DomName('DOMSecurityPolicy.allowsEval')\n  @DocsEditable\n  final bool allowsEval;\n\n  @DomName('DOMSecurityPolicy.allowsInlineScript')\n  @DocsEditable\n  final bool allowsInlineScript;\n\n  @DomName('DOMSecurityPolicy.allowsInlineStyle')\n  @DocsEditable\n  final bool allowsInlineStyle;\n\n  @DomName('DOMSecurityPolicy.isActive')\n  @DocsEditable\n  final bool isActive;\n\n  @DomName('DOMSecurityPolicy.reportURIs')\n  @DocsEditable\n  @Returns('DomStringList')\n  @Creates('DomStringList')\n  final List<String> reportURIs;\n\n  @DomName('DOMSecurityPolicy.allowsConnectionTo')\n  @DocsEditable\n  bool allowsConnectionTo(String url) native;\n\n  @DomName('DOMSecurityPolicy.allowsFontFrom')\n  @DocsEditable\n  bool allowsFontFrom(String url) native;\n\n  @DomName('DOMSecurityPolicy.allowsFormAction')\n  @DocsEditable\n  bool allowsFormAction(String url) native;\n\n  @DomName('DOMSecurityPolicy.allowsFrameFrom')\n  @DocsEditable\n  bool allowsFrameFrom(String url) native;\n\n  @DomName('DOMSecurityPolicy.allowsImageFrom')\n  @DocsEditable\n  bool allowsImageFrom(String url) native;\n\n  @DomName('DOMSecurityPolicy.allowsMediaFrom')\n  @DocsEditable\n  bool allowsMediaFrom(String url) native;\n\n  @DomName('DOMSecurityPolicy.allowsObjectFrom')\n  @DocsEditable\n  bool allowsObjectFrom(String url) native;\n\n  @DomName('DOMSecurityPolicy.allowsPluginType')\n  @DocsEditable\n  bool allowsPluginType(String type) native;\n\n  @DomName('DOMSecurityPolicy.allowsScriptFrom')\n  @DocsEditable\n  bool allowsScriptFrom(String url) native;\n\n  @DomName('DOMSecurityPolicy.allowsStyleFrom')\n  @DocsEditable\n  bool allowsStyleFrom(String url) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Selection')\nclass DomSelection native \"Selection\" {\n\n  @DomName('DOMSelection.anchorNode')\n  @DocsEditable\n  final Node anchorNode;\n\n  @DomName('DOMSelection.anchorOffset')\n  @DocsEditable\n  final int anchorOffset;\n\n  @DomName('DOMSelection.baseNode')\n  @DocsEditable\n  final Node baseNode;\n\n  @DomName('DOMSelection.baseOffset')\n  @DocsEditable\n  final int baseOffset;\n\n  @DomName('DOMSelection.extentNode')\n  @DocsEditable\n  final Node extentNode;\n\n  @DomName('DOMSelection.extentOffset')\n  @DocsEditable\n  final int extentOffset;\n\n  @DomName('DOMSelection.focusNode')\n  @DocsEditable\n  final Node focusNode;\n\n  @DomName('DOMSelection.focusOffset')\n  @DocsEditable\n  final int focusOffset;\n\n  @DomName('DOMSelection.isCollapsed')\n  @DocsEditable\n  final bool isCollapsed;\n\n  @DomName('DOMSelection.rangeCount')\n  @DocsEditable\n  final int rangeCount;\n\n  @DomName('DOMSelection.type')\n  @DocsEditable\n  final String type;\n\n  @DomName('DOMSelection.addRange')\n  @DocsEditable\n  void addRange(Range range) native;\n\n  @DomName('DOMSelection.collapse')\n  @DocsEditable\n  void collapse(Node node, int index) native;\n\n  @DomName('DOMSelection.collapseToEnd')\n  @DocsEditable\n  void collapseToEnd() native;\n\n  @DomName('DOMSelection.collapseToStart')\n  @DocsEditable\n  void collapseToStart() native;\n\n  @DomName('DOMSelection.containsNode')\n  @DocsEditable\n  bool containsNode(Node node, bool allowPartial) native;\n\n  @DomName('DOMSelection.deleteFromDocument')\n  @DocsEditable\n  void deleteFromDocument() native;\n\n  @DomName('DOMSelection.empty')\n  @DocsEditable\n  void empty() native;\n\n  @DomName('DOMSelection.extend')\n  @DocsEditable\n  void extend(Node node, int offset) native;\n\n  @DomName('DOMSelection.getRangeAt')\n  @DocsEditable\n  Range getRangeAt(int index) native;\n\n  @DomName('DOMSelection.modify')\n  @DocsEditable\n  void modify(String alter, String direction, String granularity) native;\n\n  @DomName('DOMSelection.removeAllRanges')\n  @DocsEditable\n  void removeAllRanges() native;\n\n  @DomName('DOMSelection.selectAllChildren')\n  @DocsEditable\n  void selectAllChildren(Node node) native;\n\n  @DomName('DOMSelection.setBaseAndExtent')\n  @DocsEditable\n  void setBaseAndExtent(Node baseNode, int baseOffset, Node extentNode, int extentOffset) native;\n\n  @DomName('DOMSelection.setPosition')\n  @DocsEditable\n  void setPosition(Node node, int offset) native;\n\n  @DomName('DOMSelection.toString')\n  @DocsEditable\n  String toString() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DOMSettableTokenList')\nclass DomSettableTokenList extends DomTokenList native \"DOMSettableTokenList\" {\n\n  @DomName('DOMSettableTokenList.value')\n  @DocsEditable\n  String value;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DOMStringList')\nclass DomStringList implements JavaScriptIndexingBehavior, List<String> native \"DOMStringList\" {\n\n  @DomName('DOMStringList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  String operator[](int index) => JS(\"String\", \"#[#]\", this, index);\n\n  void operator[]=(int index, String value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<String> mixins.\n  // String is the element type.\n\n  // From Iterable<String>:\n\n  Iterator<String> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<String>(this);\n  }\n\n  String reduce(String combine(String value, String element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, String element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  // contains() defined by IDL.\n\n  void forEach(void f(String element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(String element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<String> where(bool f(String element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(String element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(String element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(String element)) => IterableMixinWorkaround.any(this, f);\n\n  List<String> toList({ bool growable: true }) =>\n      new List<String>.from(this, growable: growable);\n\n  Set<String> toSet() => new Set<String>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<String> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<String> takeWhile(bool test(String value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<String> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<String> skipWhile(bool test(String value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  String firstWhere(bool test(String value), { String orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  String lastWhere(bool test(String value), {String orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  String singleWhere(bool test(String value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  String elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<String>:\n\n  void add(String value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<String> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<String>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<String> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(String a, String b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(String element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(String element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  String get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  String get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  String get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, String element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<String> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<String> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  String removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  String removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(String element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(String element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<String> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<String> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [String fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<String> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<String> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <String>[]);\n  }\n\n  Map<int, String> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<String> mixins.\n\n  @DomName('DOMStringList.contains')\n  @DocsEditable\n  bool contains(String string) native;\n\n  @DomName('DOMStringList.item')\n  @DocsEditable\n  String item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('DOMStringMap')\nabstract class DomStringMap {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DOMTokenList')\nclass DomTokenList native \"DOMTokenList\" {\n\n  @DomName('DOMTokenList.length')\n  @DocsEditable\n  final int length;\n\n  @DomName('DOMTokenList.contains')\n  @DocsEditable\n  bool contains(String token) native;\n\n  @DomName('DOMTokenList.item')\n  @DocsEditable\n  String item(int index) native;\n\n  @DomName('DOMTokenList.toString')\n  @DocsEditable\n  String toString() native;\n\n  @DomName('DOMTokenList.toggle')\n  @DocsEditable\n  bool toggle(String token, [bool force]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n// TODO(jacobr): use _Lists.dart to remove some of the duplicated\n// functionality.\nclass _ChildrenElementList extends ListBase<Element> {\n  // Raw Element.\n  final Element _element;\n  final HtmlCollection _childElements;\n\n  _ChildrenElementList._wrap(Element element)\n    : _childElements = element.$dom_children,\n      _element = element;\n\n  List<Element> toList({ bool growable: true }) {\n    List<Element> output;\n    if (growable) {\n      output = <Element>[];\n      output.length = _childElements.length;\n    } else {\n      output = new List<Element>(_childElements.length);\n    }\n    for (int i = 0, len = _childElements.length; i < len; i++) {\n      output[i] = _childElements[i];\n    }\n    return output;\n  }\n\n  Set<Element> toSet() {\n    final output = new Set<Element>();\n    for (int i = 0, len = _childElements.length; i < len; i++) {\n      output.add(_childElements[i]);\n    }\n    return output;\n  }\n\n  bool contains(Element element) => _childElements.contains(element);\n\n  void forEach(void f(Element element)) {\n    for (Element element in _childElements) {\n      f(element);\n    }\n  }\n\n  bool every(bool f(Element element)) {\n    for (Element element in this) {\n      if (!f(element)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  bool any(bool f(Element element)) {\n    for (Element element in this) {\n      if (f(element)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  String join([String separator = \"\"]) {\n    return _childElements.join(separator);\n  }\n\n  Iterable map(f(Element element)) {\n    return _childElements.map(f);\n  }\n\n  Iterable<Element> where(bool f(Element element)) {\n    return _childElements.where(f);\n  }\n\n  Iterable expand(Iterable f(Element element)) {\n    return _childElements.expand(f);\n  }\n\n  bool get isEmpty {\n    return _element.$dom_firstElementChild == null;\n  }\n\n  Iterable<Element> take(int n) {\n    return _childElements.take(n);\n  }\n\n  Iterable<Element> takeWhile(bool test(Element value)) {\n    return _childElements.takeWhile(test);\n  }\n\n  Iterable<Element> skip(int n) {\n    return _childElements.skip(n);\n  }\n\n  Iterable<Element> skipWhile(bool test(Element value)) {\n    return _childElements.skipWhile(test);\n  }\n\n  Element firstWhere(bool test(Element value), {Element orElse()}) {\n    return _childElements.firstWhere(test, orElse: orElse);\n  }\n\n  Element lastWhere(bool test(Element value), {Element orElse()}) {\n    return _childElements.lastWhere(test, orElse: orElse);\n  }\n\n  Element singleWhere(bool test(Element value)) {\n    return _childElements.singleWhere(test);\n  }\n\n  Element elementAt(int index) {\n    return this[index];\n  }\n\n  int get length {\n    return _childElements.length;\n  }\n\n  Element operator [](int index) {\n    return _childElements[index];\n  }\n\n  void operator []=(int index, Element value) {\n    _element.$dom_replaceChild(value, _childElements[index]);\n  }\n\n  void set length(int newLength) {\n    // TODO(jacobr): remove children when length is reduced.\n    throw new UnsupportedError('');\n  }\n\n  Element add(Element value) {\n    _element.append(value);\n    return value;\n  }\n\n  Iterator<Element> get iterator => toList().iterator;\n\n  void addAll(Iterable<Element> iterable) {\n    if (iterable is _ChildNodeListLazy) {\n      iterable = new List.from(iterable);\n    }\n\n    for (Element element in iterable) {\n      _element.append(element);\n    }\n  }\n\n  Iterable<Element> get reversed {\n    return _childElements.reversed;\n  }\n\n  void sort([int compare(Element a, Element b)]) {\n    throw new UnsupportedError('TODO(jacobr): should we impl?');\n  }\n\n  Element reduce(Element combine(Element value, Element element)) {\n    return _childElements.reduce(combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n      dynamic combine(dynamic previousValue, Element element)) {\n    return _childElements.fold(initialValue, combine);\n  }\n\n  void setRange(int start, int end, Iterable<Element> iterable,\n                [int skipCount = 0]) {\n    throw new UnimplementedError();\n  }\n\n  void replaceRange(int start, int end, Iterable<Element> iterable) {\n    throw new UnimplementedError();\n  }\n\n  void fillRange(int start, int end, [Element fillValue]) {\n    throw new UnimplementedError();\n  }\n\n  bool remove(Object object) {\n    if (object is Element) {\n      Element element = object;\n      if (identical(element.parentNode, _element)) {\n        _element.$dom_removeChild(element);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  void removeWhere(bool test(Element element)) {\n    _childElements.removeWhere(test);\n  }\n\n  void retainWhere(bool test(Element element)) {\n    _childElements.retainWhere(test);\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnimplementedError();\n  }\n\n  Iterable getRange(int start, int end)  {\n    throw new UnimplementedError();\n  }\n\n  List sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return new _FrozenElementList._wrap(Lists.getRange(this, start, end, []));\n  }\n\n  int indexOf(Element element, [int start = 0]) {\n    return Lists.indexOf(this, element, start, this.length);\n  }\n\n  int lastIndexOf(Element element, [int start = null]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  void insert(int index, Element element) {\n    if (index < 0 || index > length) {\n      throw new RangeError.range(index, 0, length);\n    }\n    if (index == length) {\n      _element.append(element);\n    } else {\n      _element.insertBefore(element, this[index]);\n    }\n  }\n\n  void insertAll(int index, Iterable<Element> iterable) {\n    throw new UnimplementedError();\n  }\n\n  void setAll(int index, Iterable<Element> iterable) {\n    throw new UnimplementedError();\n  }\n\n  void clear() {\n    // It is unclear if we want to keep non element nodes?\n    _element.text = '';\n  }\n\n  Element removeAt(int index) {\n    final result = this[index];\n    if (result != null) {\n      _element.$dom_removeChild(result);\n    }\n    return result;\n  }\n\n  Element removeLast() {\n    final result = this.last;\n    if (result != null) {\n      _element.$dom_removeChild(result);\n    }\n    return result;\n  }\n\n  Element get first {\n    Element result = _element.$dom_firstElementChild;\n    if (result == null) throw new StateError(\"No elements\");\n    return result;\n  }\n\n\n  Element get last {\n    Element result = _element.$dom_lastElementChild;\n    if (result == null) throw new StateError(\"No elements\");\n    return result;\n  }\n\n  Element get single {\n    if (length > 1) throw new StateError(\"More than one element\");\n    return first;\n  }\n\n  Map<int, Element> asMap() {\n    return _childElements.asMap();\n  }\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n}\n\n// TODO(jacobr): this is an inefficient implementation but it is hard to see\n// a better option given that we cannot quite force NodeList to be an\n// ElementList as there are valid cases where a NodeList JavaScript object\n// contains Node objects that are not Elements.\nclass _FrozenElementList extends ListBase {\n  final List<Node> _nodeList;\n\n  _FrozenElementList._wrap(this._nodeList);\n\n  int get length => _nodeList.length;\n\n  Element operator [](int index) => _nodeList[index];\n\n  void operator []=(int index, Element value) {\n    throw new UnsupportedError('');\n  }\n\n  void set length(int newLength) {\n    _nodeList.length = newLength;\n  }\n\n  void add(Element value) {\n    throw new UnsupportedError('');\n  }\n\n  void addAll(Iterable<Element> iterable) {\n    throw new UnsupportedError('');\n  }\n\n  void sort([int compare(Element a, Element b)]) {\n    throw new UnsupportedError('');\n  }\n\n  void setRange(int start, int end, Iterable<Element> iterable,\n                [int skipCount = 0]) {\n    throw new UnsupportedError('');\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError('');\n  }\n\n  List<Element> sublist(int start, [int end]) {\n    return new _FrozenElementList._wrap(_nodeList.sublist(start, end));\n  }\n\n  void clear() {\n    throw new UnsupportedError('');\n  }\n\n  Element removeAt(int index) {\n    throw new UnsupportedError('');\n  }\n\n  Element removeLast() {\n    throw new UnsupportedError('');\n  }\n\n  bool remove(Object element) {\n    throw new UnsupportedError('');\n  }\n\n  void removeWhere(bool test(Element element)) {\n    throw new UnsupportedError('');\n  }\n\n  void retainWhere(bool test(Element element)) {\n    throw new UnsupportedError('');\n  }\n\n  Element get first => _nodeList.first;\n\n  Element get last => _nodeList.last;\n\n  Element get single => _nodeList.single;\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n}\n\nclass _ElementCssClassSet extends CssClassSet {\n\n  final Element _element;\n\n  _ElementCssClassSet(this._element);\n\n  Set<String> readClasses() {\n    var s = new LinkedHashSet<String>();\n    var classname = _element.$dom_className;\n\n    for (String name in classname.split(' ')) {\n      String trimmed = name.trim();\n      if (!trimmed.isEmpty) {\n        s.add(trimmed);\n      }\n    }\n    return s;\n  }\n\n  void writeClasses(Set<String> s) {\n    List list = new List.from(s);\n    _element.$dom_className = s.join(' ');\n  }\n}\n\n/**\n * An abstract class, which all HTML elements extend.\n */\n@DomName('Element')\nabstract class Element extends Node implements ElementTraversal native \"Element\" {\n\n  /**\n   * Creates an HTML element from a valid fragment of HTML.\n   *\n   * The [html] fragment must represent valid HTML with a single element root,\n   * which will be parsed and returned.\n   *\n   * Important: the contents of [html] should not contain any user-supplied\n   * data. Without strict data validation it is impossible to prevent script\n   * injection exploits.\n   *\n   * It is instead recommended that elements be constructed via [Element.tag]\n   * and text be added via [text].\n   *\n   *     var element = new Element.html('<div class=\"foo\">content</div>');\n   */\n  factory Element.html(String html) =>\n      _ElementFactoryProvider.createElement_html(html);\n\n  /**\n   * Creates the HTML element specified by the tag name.\n   *\n   * This is similar to [Document.createElement].\n   * [tag] should be a valid HTML tag name. If [tag] is an unknown tag then\n   * this will create an [UnknownElement].\n   *\n   *     var divElement = new Element.tag('div');\n   *     print(divElement is DivElement); // 'true'\n   *     var myElement = new Element.tag('unknownTag');\n   *     print(myElement is UnknownElement); // 'true'\n   *\n   * For standard elements it is more preferable to use the type constructors:\n   *     var element = new DivElement();\n   *\n   * See also:\n   *\n   * * [isTagSupported]\n   */\n  factory Element.tag(String tag) =>\n      _ElementFactoryProvider.createElement_tag(tag);\n\n  /**\n   * All attributes on this element.\n   *\n   * Any modifications to the attribute map will automatically be applied to\n   * this element.\n   *\n   * This only includes attributes which are not in a namespace\n   * (such as 'xlink:href'), additional attributes can be accessed via\n   * [getNamespacedAttributes].\n   */\n  Map<String, String> get attributes => new _ElementAttributeMap(this);\n\n  void set attributes(Map<String, String> value) {\n    Map<String, String> attributes = this.attributes;\n    attributes.clear();\n    for (String key in value.keys) {\n      attributes[key] = value[key];\n    }\n  }\n\n  /**\n   * List of the direct children of this element.\n   *\n   * This collection can be used to add and remove elements from the document.\n   *\n   *     var item = new DivElement();\n   *     item.text = 'Something';\n   *     document.body.children.add(item) // Item is now displayed on the page.\n   *     for (var element in document.body.children) {\n   *       element.style.background = 'red'; // Turns every child of body red.\n   *     }\n   */\n  List<Element> get children => new _ChildrenElementList._wrap(this);\n\n  void set children(List<Element> value) {\n    // Copy list first since we don't want liveness during iteration.\n    List copy = new List.from(value);\n    var children = this.children;\n    children.clear();\n    children.addAll(copy);\n  }\n\n  /**\n   * Finds all descendent elements of this element that match the specified\n   * group of selectors.\n   *\n   * [selectors] should be a string using CSS selector syntax.\n   *\n   *     var items = element.query('.itemClassName');\n   */\n  List<Element> queryAll(String selectors) =>\n    new _FrozenElementList._wrap($dom_querySelectorAll(selectors));\n\n  /**\n   * The set of CSS classes applied to this element.\n   *\n   * This set makes it easy to add, remove or toggle the classes applied to\n   * this element.\n   *\n   *     element.classes.add('selected');\n   *     element.classes.toggle('isOnline');\n   *     element.classes.remove('selected');\n   */\n  CssClassSet get classes => new _ElementCssClassSet(this);\n\n  void set classes(Iterable<String> value) {\n    CssClassSet classSet = classes;\n    classSet.clear();\n    classSet.addAll(value);\n  }\n\n  /**\n   * Allows access to all custom data attributes (data-*) set on this element.\n   *\n   * The keys for the map must follow these rules:\n   *\n   * * The name must not begin with 'xml'.\n   * * The name cannot contain a semi-colon (';').\n   * * The name cannot contain any capital letters.\n   *\n   * Any keys from markup will be converted to camel-cased keys in the map.\n   *\n   * For example, HTML specified as:\n   *\n   *     <div data-my-random-value='value'></div>\n   *\n   * Would be accessed in Dart as:\n   *\n   *     var value = element.dataset['myRandomValue'];\n   *\n   * See also:\n   *\n   * * [Custom data attributes](http://www.w3.org/TR/html5/global-attributes.html#custom-data-attribute)\n   */\n  Map<String, String> get dataset =>\n    new _DataAttributeMap(attributes);\n\n  void set dataset(Map<String, String> value) {\n    final data = this.dataset;\n    data.clear();\n    for (String key in value.keys) {\n      data[key] = value[key];\n    }\n  }\n\n  /**\n   * Gets a map for manipulating the attributes of a particular namespace.\n   *\n   * This is primarily useful for SVG attributes such as xref:link.\n   */\n  Map<String, String> getNamespacedAttributes(String namespace) {\n    return new _NamespacedAttributeMap(this, namespace);\n  }\n\n  /**\n   * The set of all CSS values applied to this element, including inherited\n   * and default values.\n   *\n   * The computedStyle contains values that are inherited from other\n   * sources, such as parent elements or stylesheets. This differs from the\n   * [style] property, which contains only the values specified directly on this\n   * element.\n   *\n   * PseudoElement can be values such as `::after`, `::before`, `::marker`,\n   * `::line-marker`.\n   *\n   * See also:\n   *\n   * * [CSS Inheritance and Cascade](http://docs.webplatform.org/wiki/tutorials/inheritance_and_cascade)\n   * * [Pseudo-elements](http://docs.webplatform.org/wiki/css/selectors/pseudo-elements)\n   */\n  CssStyleDeclaration getComputedStyle([String pseudoElement]) {\n    if (pseudoElement == null) {\n      pseudoElement = '';\n    }\n    // TODO(jacobr): last param should be null, see b/5045788\n    return window.$dom_getComputedStyle(this, pseudoElement);\n  }\n\n  /**\n   * Gets the position of this element relative to the client area of the page.\n   */\n  Rect get client => new Rect(clientLeft, clientTop, clientWidth, clientHeight);\n\n  /**\n   * Gets the offset of this element relative to its offsetParent.\n   */\n  Rect get offset => new Rect(offsetLeft, offsetTop, offsetWidth, offsetHeight);\n\n  /**\n   * Adds the specified text as a text node after the last child of this\n   * element.\n   */\n  void appendText(String text) {\n    this.insertAdjacentText('beforeend', text);\n  }\n\n  /**\n   * Parses the specified text as HTML and adds the resulting node after the\n   * last child of this element.\n   */\n  void appendHtml(String text) {\n    this.insertAdjacentHtml('beforeend', text);\n  }\n\n  /**\n   * Checks to see if the tag name is supported by the current platform.\n   *\n   * The tag should be a valid HTML tag name.\n   */\n  static bool isTagSupported(String tag) {\n    var e = _ElementFactoryProvider.createElement_tag(tag);\n    return e is Element && !(e is UnknownElement);\n  }\n\n  /**\n   * Called by the DOM when this element has been instantiated.\n   */\n  @Experimental\n  void onCreated() {}\n\n  // Hooks to support custom WebComponents.\n  /**\n   * Experimental support for [web components][wc]. This field stores a\n   * reference to the component implementation. It was inspired by Mozilla's\n   * [x-tags][] project. Please note: in the future it may be possible to\n   * `extend Element` from your class, in which case this field will be\n   * deprecated and will simply return this [Element] object.\n   *\n   * [wc]: http://dvcs.w3.org/hg/webcomponents/raw-file/tip/explainer/index.html\n   * [x-tags]: http://x-tags.org/\n   */\n  @Creates('Null')  // Set from Dart code; does not instantiate a native type.\n  var xtag;\n\n  /**\n   * Scrolls this element into view.\n   *\n   * Only one of of the alignment options may be specified at a time.\n   *\n   * If no options are specified then this will attempt to scroll the minimum\n   * amount needed to bring the element into view.\n   *\n   * Note that alignCenter is currently only supported on WebKit platforms. If\n   * alignCenter is specified but not supported then this will fall back to\n   * alignTop.\n   *\n   * See also:\n   *\n   * * [scrollIntoView](http://docs.webplatform.org/wiki/dom/methods/scrollIntoView)\n   * * [scrollIntoViewIfNeeded](http://docs.webplatform.org/wiki/dom/methods/scrollIntoViewIfNeeded)\n   */\n  void scrollIntoView([ScrollAlignment alignment]) {\n    var hasScrollIntoViewIfNeeded = false;\n    hasScrollIntoViewIfNeeded =\n        JS('bool', '!!(#.scrollIntoViewIfNeeded)', this);\n    if (alignment == ScrollAlignment.TOP) {\n      this.$dom_scrollIntoView(true);\n    } else if (alignment == ScrollAlignment.BOTTOM) {\n      this.$dom_scrollIntoView(false);\n    } else if (hasScrollIntoViewIfNeeded) {\n      if (alignment == ScrollAlignment.CENTER) {\n        this.$dom_scrollIntoViewIfNeeded(true);\n      } else {\n        this.$dom_scrollIntoViewIfNeeded();\n      }\n    } else {\n      this.$dom_scrollIntoView();\n    }\n  }\n\n  @DomName('Element.mouseWheelEvent')\n  static const EventStreamProvider<WheelEvent> mouseWheelEvent =\n      const _CustomEventStreamProvider<WheelEvent>(\n        Element._determineMouseWheelEventType);\n\n  static String _determineMouseWheelEventType(EventTarget e) {\n    if (JS('bool', '#.onwheel !== undefined', e)) {\n      // W3C spec, and should be IE9+, but IE has a bug exposing onwheel.\n      return 'wheel';\n    } else if (JS('bool', '#.onmousewheel !== undefined', e)) {\n      // Chrome & IE\n      return 'mousewheel';\n    } else {\n      // Firefox\n      return 'DOMMouseScroll';\n    }\n  }\n\n  @DomName('Element.webkitTransitionEndEvent')\n  static const EventStreamProvider<TransitionEvent> transitionEndEvent =\n      const _CustomEventStreamProvider<TransitionEvent>(\n        Element._determineTransitionEventType);\n\n  static String _determineTransitionEventType(EventTarget e) {\n    // Unfortunately the normal 'ontransitionend' style checks don't work here.\n    if (Device.isWebKit) {\n      return 'webkitTransitionEnd';\n    } else if (Device.isOpera) {\n      return 'oTransitionEnd';\n    }\n    return 'transitionend';\n  }\n  /**\n   * Creates a text node and inserts it into the DOM at the specified location.\n   *\n   * To see the possible values for [where], read the doc for\n   * [insertAdjacentHtml].\n   *\n   * See also:\n   *\n   * * [insertAdjacentHtml]\n   */\n  void insertAdjacentText(String where, String text) {\n    if (JS('bool', '!!#.insertAdjacentText', this)) {\n      _insertAdjacentText(where, text);\n    } else {\n      _insertAdjacentNode(where, new Text(text));\n    }\n  }\n\n  @JSName('insertAdjacentText')\n  void _insertAdjacentText(String where, String text) native;\n\n  /**\n   * Parses text as an HTML fragment and inserts it into the DOM at the\n   * specified location.\n   *\n   * The [where] parameter indicates where to insert the HTML fragment:\n   *\n   * * 'beforeBegin': Immediately before this element.\n   * * 'afterBegin': As the first child of this element.\n   * * 'beforeEnd': As the last child of this element.\n   * * 'afterEnd': Immediately after this element.\n   *\n   *     var html = '<div class=\"something\">content</div>';\n   *     // Inserts as the first child\n   *     document.body.insertAdjacentHtml('afterBegin', html);\n   *     var createdElement = document.body.children[0];\n   *     print(createdElement.classes[0]); // Prints 'something'\n   *\n   * See also:\n   *\n   * * [insertAdjacentText]\n   * * [insertAdjacentElement]\n   */\n  void insertAdjacentHtml(String where, String text) {\n    if (JS('bool', '!!#.insertAdjacentHtml', this)) {\n      _insertAdjacentHtml(where, text);\n    } else {\n      _insertAdjacentNode(where, new DocumentFragment.html(text));\n    }\n  }\n\n  @JSName('insertAdjacentHTML')\n  void _insertAdjacentHTML(String where, String text) native;\n\n  /**\n   * Inserts [element] into the DOM at the specified location.\n   *\n   * To see the possible values for [where], read the doc for\n   * [insertAdjacentHtml].\n   *\n   * See also:\n   *\n   * * [insertAdjacentHtml]\n   */\n  Element insertAdjacentElement(String where, Element element) {\n    if (JS('bool', '!!#.insertAdjacentElement', this)) {\n      _insertAdjacentElement(where, element);\n    } else {\n      _insertAdjacentNode(where, element);\n    }\n    return element;\n  }\n\n  @JSName('insertAdjacentElement')\n  void _insertAdjacentElement(String where, Element element) native;\n\n  void _insertAdjacentNode(String where, Node node) {\n    switch (where.toLowerCase()) {\n      case 'beforebegin':\n        this.parentNode.insertBefore(node, this);\n        break;\n      case 'afterbegin':\n        var first = this.nodes.length > 0 ? this.nodes[0] : null;\n        this.insertBefore(node, first);\n        break;\n      case 'beforeend':\n        this.append(node);\n        break;\n      case 'afterend':\n        this.parentNode.insertBefore(node, this.nextNode);\n        break;\n      default:\n        throw new ArgumentError(\"Invalid position ${where}\");\n    }\n  }\n\n  /**\n   * Checks if this element matches the CSS selectors.\n   */\n  @Experimental\n  bool matches(String selectors) {\n    if (JS('bool', '!!#.matches', this)) {\n      return JS('bool', '#.matches(#)', this, selectors);\n    } else if (JS('bool', '!!#.webkitMatchesSelector', this)) {\n      return JS('bool', '#.webkitMatchesSelector(#)', this, selectors);\n    } else if (JS('bool', '!!#.mozMatchesSelector', this)) {\n      return JS('bool', '#.mozMatchesSelector(#)', this, selectors);\n    } else if (JS('bool', '!!#.msMatchesSelector', this)) {\n      return JS('bool', '#.msMatchesSelector(#)', this, selectors);\n    }\n    throw new UnsupportedError(\"Not supported on this platform\");\n  }\n\n\n  @DomName('Element.abortEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> abortEvent = const EventStreamProvider<Event>('abort');\n\n  @DomName('Element.beforecopyEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> beforeCopyEvent = const EventStreamProvider<Event>('beforecopy');\n\n  @DomName('Element.beforecutEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> beforeCutEvent = const EventStreamProvider<Event>('beforecut');\n\n  @DomName('Element.beforepasteEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> beforePasteEvent = const EventStreamProvider<Event>('beforepaste');\n\n  @DomName('Element.blurEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> blurEvent = const EventStreamProvider<Event>('blur');\n\n  @DomName('Element.changeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> changeEvent = const EventStreamProvider<Event>('change');\n\n  @DomName('Element.clickEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> clickEvent = const EventStreamProvider<MouseEvent>('click');\n\n  @DomName('Element.contextmenuEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> contextMenuEvent = const EventStreamProvider<MouseEvent>('contextmenu');\n\n  @DomName('Element.copyEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> copyEvent = const EventStreamProvider<Event>('copy');\n\n  @DomName('Element.cutEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> cutEvent = const EventStreamProvider<Event>('cut');\n\n  @DomName('Element.dblclickEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> doubleClickEvent = const EventStreamProvider<Event>('dblclick');\n\n  @DomName('Element.dragEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> dragEvent = const EventStreamProvider<MouseEvent>('drag');\n\n  @DomName('Element.dragendEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> dragEndEvent = const EventStreamProvider<MouseEvent>('dragend');\n\n  @DomName('Element.dragenterEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> dragEnterEvent = const EventStreamProvider<MouseEvent>('dragenter');\n\n  @DomName('Element.dragleaveEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> dragLeaveEvent = const EventStreamProvider<MouseEvent>('dragleave');\n\n  @DomName('Element.dragoverEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> dragOverEvent = const EventStreamProvider<MouseEvent>('dragover');\n\n  @DomName('Element.dragstartEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> dragStartEvent = const EventStreamProvider<MouseEvent>('dragstart');\n\n  @DomName('Element.dropEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> dropEvent = const EventStreamProvider<MouseEvent>('drop');\n\n  @DomName('Element.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('Element.focusEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> focusEvent = const EventStreamProvider<Event>('focus');\n\n  @DomName('Element.inputEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> inputEvent = const EventStreamProvider<Event>('input');\n\n  @DomName('Element.invalidEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> invalidEvent = const EventStreamProvider<Event>('invalid');\n\n  @DomName('Element.keydownEvent')\n  @DocsEditable\n  static const EventStreamProvider<KeyboardEvent> keyDownEvent = const EventStreamProvider<KeyboardEvent>('keydown');\n\n  @DomName('Element.keypressEvent')\n  @DocsEditable\n  static const EventStreamProvider<KeyboardEvent> keyPressEvent = const EventStreamProvider<KeyboardEvent>('keypress');\n\n  @DomName('Element.keyupEvent')\n  @DocsEditable\n  static const EventStreamProvider<KeyboardEvent> keyUpEvent = const EventStreamProvider<KeyboardEvent>('keyup');\n\n  @DomName('Element.loadEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> loadEvent = const EventStreamProvider<Event>('load');\n\n  @DomName('Element.mousedownEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> mouseDownEvent = const EventStreamProvider<MouseEvent>('mousedown');\n\n  @DomName('Element.mousemoveEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> mouseMoveEvent = const EventStreamProvider<MouseEvent>('mousemove');\n\n  @DomName('Element.mouseoutEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> mouseOutEvent = const EventStreamProvider<MouseEvent>('mouseout');\n\n  @DomName('Element.mouseoverEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> mouseOverEvent = const EventStreamProvider<MouseEvent>('mouseover');\n\n  @DomName('Element.mouseupEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> mouseUpEvent = const EventStreamProvider<MouseEvent>('mouseup');\n\n  @DomName('Element.pasteEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> pasteEvent = const EventStreamProvider<Event>('paste');\n\n  @DomName('Element.resetEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> resetEvent = const EventStreamProvider<Event>('reset');\n\n  @DomName('Element.scrollEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> scrollEvent = const EventStreamProvider<Event>('scroll');\n\n  @DomName('Element.searchEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> searchEvent = const EventStreamProvider<Event>('search');\n\n  @DomName('Element.selectEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> selectEvent = const EventStreamProvider<Event>('select');\n\n  @DomName('Element.selectstartEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> selectStartEvent = const EventStreamProvider<Event>('selectstart');\n\n  @DomName('Element.submitEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> submitEvent = const EventStreamProvider<Event>('submit');\n\n  @DomName('Element.touchcancelEvent')\n  @DocsEditable\n  static const EventStreamProvider<TouchEvent> touchCancelEvent = const EventStreamProvider<TouchEvent>('touchcancel');\n\n  @DomName('Element.touchendEvent')\n  @DocsEditable\n  static const EventStreamProvider<TouchEvent> touchEndEvent = const EventStreamProvider<TouchEvent>('touchend');\n\n  @DomName('Element.touchenterEvent')\n  @DocsEditable\n  static const EventStreamProvider<TouchEvent> touchEnterEvent = const EventStreamProvider<TouchEvent>('touchenter');\n\n  @DomName('Element.touchleaveEvent')\n  @DocsEditable\n  static const EventStreamProvider<TouchEvent> touchLeaveEvent = const EventStreamProvider<TouchEvent>('touchleave');\n\n  @DomName('Element.touchmoveEvent')\n  @DocsEditable\n  static const EventStreamProvider<TouchEvent> touchMoveEvent = const EventStreamProvider<TouchEvent>('touchmove');\n\n  @DomName('Element.touchstartEvent')\n  @DocsEditable\n  static const EventStreamProvider<TouchEvent> touchStartEvent = const EventStreamProvider<TouchEvent>('touchstart');\n\n  @DomName('Element.webkitfullscreenchangeEvent')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  static const EventStreamProvider<Event> fullscreenChangeEvent = const EventStreamProvider<Event>('webkitfullscreenchange');\n\n  @DomName('Element.webkitfullscreenerrorEvent')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  static const EventStreamProvider<Event> fullscreenErrorEvent = const EventStreamProvider<Event>('webkitfullscreenerror');\n\n  @JSName('children')\n  @DomName('Element.children')\n  @DocsEditable\n  final HtmlCollection $dom_children;\n\n  @DomName('Element.contentEditable')\n  @DocsEditable\n  String contentEditable;\n\n  @DomName('Element.dir')\n  @DocsEditable\n  String dir;\n\n  @DomName('Element.draggable')\n  @DocsEditable\n  bool draggable;\n\n  @DomName('Element.hidden')\n  @DocsEditable\n  bool hidden;\n\n  @DomName('Element.id')\n  @DocsEditable\n  String id;\n\n  @JSName('innerHTML')\n  @DomName('Element.innerHTML')\n  @DocsEditable\n  String innerHtml;\n\n  @DomName('Element.isContentEditable')\n  @DocsEditable\n  final bool isContentEditable;\n\n  @DomName('Element.lang')\n  @DocsEditable\n  String lang;\n\n  @JSName('outerHTML')\n  @DomName('Element.outerHTML')\n  @DocsEditable\n  final String outerHtml;\n\n  @DomName('Element.spellcheck')\n  @DocsEditable\n  bool spellcheck;\n\n  @DomName('Element.tabIndex')\n  @DocsEditable\n  int tabIndex;\n\n  @DomName('Element.title')\n  @DocsEditable\n  String title;\n\n  @DomName('Element.translate')\n  @DocsEditable\n  bool translate;\n\n  @JSName('webkitdropzone')\n  @DomName('Element.webkitdropzone')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  String dropzone;\n\n  @DomName('Element.click')\n  @DocsEditable\n  void click() native;\n\n  static const int ALLOW_KEYBOARD_INPUT = 1;\n\n  @JSName('attributes')\n  @DomName('Element.attributes')\n  @DocsEditable\n  final _NamedNodeMap $dom_attributes;\n\n  @JSName('childElementCount')\n  @DomName('Element.childElementCount')\n  @DocsEditable\n  final int $dom_childElementCount;\n\n  @JSName('className')\n  @DomName('Element.className')\n  @DocsEditable\n  String $dom_className;\n\n  @DomName('Element.clientHeight')\n  @DocsEditable\n  final int clientHeight;\n\n  @DomName('Element.clientLeft')\n  @DocsEditable\n  final int clientLeft;\n\n  @DomName('Element.clientTop')\n  @DocsEditable\n  final int clientTop;\n\n  @DomName('Element.clientWidth')\n  @DocsEditable\n  final int clientWidth;\n\n  @JSName('firstElementChild')\n  @DomName('Element.firstElementChild')\n  @DocsEditable\n  final Element $dom_firstElementChild;\n\n  @JSName('lastElementChild')\n  @DomName('Element.lastElementChild')\n  @DocsEditable\n  final Element $dom_lastElementChild;\n\n  @DomName('Element.nextElementSibling')\n  @DocsEditable\n  final Element nextElementSibling;\n\n  @DomName('Element.offsetHeight')\n  @DocsEditable\n  final int offsetHeight;\n\n  @DomName('Element.offsetLeft')\n  @DocsEditable\n  final int offsetLeft;\n\n  @DomName('Element.offsetParent')\n  @DocsEditable\n  final Element offsetParent;\n\n  @DomName('Element.offsetTop')\n  @DocsEditable\n  final int offsetTop;\n\n  @DomName('Element.offsetWidth')\n  @DocsEditable\n  final int offsetWidth;\n\n  @DomName('Element.previousElementSibling')\n  @DocsEditable\n  final Element previousElementSibling;\n\n  @DomName('Element.scrollHeight')\n  @DocsEditable\n  final int scrollHeight;\n\n  @DomName('Element.scrollLeft')\n  @DocsEditable\n  int scrollLeft;\n\n  @DomName('Element.scrollTop')\n  @DocsEditable\n  int scrollTop;\n\n  @DomName('Element.scrollWidth')\n  @DocsEditable\n  final int scrollWidth;\n\n  @DomName('Element.style')\n  @DocsEditable\n  final CssStyleDeclaration style;\n\n  @DomName('Element.tagName')\n  @DocsEditable\n  final String tagName;\n\n  @JSName('webkitInsertionParent')\n  @DomName('Element.webkitInsertionParent')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final Node insertionParent;\n\n  @JSName('webkitPseudo')\n  @DomName('Element.webkitPseudo')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  String pseudo;\n\n  @JSName('webkitRegionOverset')\n  @DomName('Element.webkitRegionOverset')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final String regionOverset;\n\n  @JSName('webkitShadowRoot')\n  @DomName('Element.webkitShadowRoot')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final ShadowRoot shadowRoot;\n\n  @DomName('Element.blur')\n  @DocsEditable\n  void blur() native;\n\n  @DomName('Element.focus')\n  @DocsEditable\n  void focus() native;\n\n  @JSName('getAttribute')\n  @DomName('Element.getAttribute')\n  @DocsEditable\n  String $dom_getAttribute(String name) native;\n\n  @JSName('getAttributeNS')\n  @DomName('Element.getAttributeNS')\n  @DocsEditable\n  String $dom_getAttributeNS(String namespaceURI, String localName) native;\n\n  @DomName('Element.getBoundingClientRect')\n  @DocsEditable\n  Rect getBoundingClientRect() native;\n\n  @DomName('Element.getClientRects')\n  @DocsEditable\n  @Returns('_ClientRectList')\n  @Creates('_ClientRectList')\n  List<Rect> getClientRects() native;\n\n  @DomName('Element.getElementsByClassName')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getElementsByClassName(String name) native;\n\n  @JSName('getElementsByTagName')\n  @DomName('Element.getElementsByTagName')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> $dom_getElementsByTagName(String name) native;\n\n  @JSName('hasAttribute')\n  @DomName('Element.hasAttribute')\n  @DocsEditable\n  bool $dom_hasAttribute(String name) native;\n\n  @JSName('hasAttributeNS')\n  @DomName('Element.hasAttributeNS')\n  @DocsEditable\n  bool $dom_hasAttributeNS(String namespaceURI, String localName) native;\n\n  @JSName('querySelector')\n  /**\n * Finds the first descendant element of this element that matches the\n * specified group of selectors.\n *\n * [selectors] should be a string using CSS selector syntax.\n *\n *     // Gets the first descendant with the class 'classname'\n *     var element = element.query('.className');\n *     // Gets the element with id 'id'\n *     var element = element.query('#id');\n *     // Gets the first descendant [ImageElement]\n *     var img = element.query('img');\n *\n * See also:\n *\n * * [CSS Selectors](http://docs.webplatform.org/wiki/css/selectors)\n */\n  @DomName('Element.querySelector')\n  @DocsEditable\n  Element query(String selectors) native;\n\n  @JSName('querySelectorAll')\n  @DomName('Element.querySelectorAll')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> $dom_querySelectorAll(String selectors) native;\n\n  @JSName('removeAttribute')\n  @DomName('Element.removeAttribute')\n  @DocsEditable\n  void $dom_removeAttribute(String name) native;\n\n  @JSName('removeAttributeNS')\n  @DomName('Element.removeAttributeNS')\n  @DocsEditable\n  void $dom_removeAttributeNS(String namespaceURI, String localName) native;\n\n  @DomName('Element.scrollByLines')\n  @DocsEditable\n  void scrollByLines(int lines) native;\n\n  @DomName('Element.scrollByPages')\n  @DocsEditable\n  void scrollByPages(int pages) native;\n\n  @JSName('scrollIntoView')\n  @DomName('Element.scrollIntoView')\n  @DocsEditable\n  void $dom_scrollIntoView([bool alignWithTop]) native;\n\n  @JSName('scrollIntoViewIfNeeded')\n  @DomName('Element.scrollIntoViewIfNeeded')\n  @DocsEditable\n  void $dom_scrollIntoViewIfNeeded([bool centerIfNeeded]) native;\n\n  @JSName('setAttribute')\n  @DomName('Element.setAttribute')\n  @DocsEditable\n  void $dom_setAttribute(String name, String value) native;\n\n  @JSName('setAttributeNS')\n  @DomName('Element.setAttributeNS')\n  @DocsEditable\n  void $dom_setAttributeNS(String namespaceURI, String qualifiedName, String value) native;\n\n  @JSName('webkitCreateShadowRoot')\n  @DomName('Element.webkitCreateShadowRoot')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME, '25')\n  @Experimental\n  ShadowRoot createShadowRoot() native;\n\n  @JSName('webkitGetRegionFlowRanges')\n  @DomName('Element.webkitGetRegionFlowRanges')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  List<Range> getRegionFlowRanges() native;\n\n  @JSName('webkitRequestFullScreen')\n  @DomName('Element.webkitRequestFullScreen')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void requestFullScreen(int flags) native;\n\n  @JSName('webkitRequestFullscreen')\n  @DomName('Element.webkitRequestFullscreen')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void requestFullscreen() native;\n\n  @JSName('webkitRequestPointerLock')\n  @DomName('Element.webkitRequestPointerLock')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void requestPointerLock() native;\n\n  @DomName('Element.onabort')\n  @DocsEditable\n  Stream<Event> get onAbort => abortEvent.forTarget(this);\n\n  @DomName('Element.onbeforecopy')\n  @DocsEditable\n  Stream<Event> get onBeforeCopy => beforeCopyEvent.forTarget(this);\n\n  @DomName('Element.onbeforecut')\n  @DocsEditable\n  Stream<Event> get onBeforeCut => beforeCutEvent.forTarget(this);\n\n  @DomName('Element.onbeforepaste')\n  @DocsEditable\n  Stream<Event> get onBeforePaste => beforePasteEvent.forTarget(this);\n\n  @DomName('Element.onblur')\n  @DocsEditable\n  Stream<Event> get onBlur => blurEvent.forTarget(this);\n\n  @DomName('Element.onchange')\n  @DocsEditable\n  Stream<Event> get onChange => changeEvent.forTarget(this);\n\n  @DomName('Element.onclick')\n  @DocsEditable\n  Stream<MouseEvent> get onClick => clickEvent.forTarget(this);\n\n  @DomName('Element.oncontextmenu')\n  @DocsEditable\n  Stream<MouseEvent> get onContextMenu => contextMenuEvent.forTarget(this);\n\n  @DomName('Element.oncopy')\n  @DocsEditable\n  Stream<Event> get onCopy => copyEvent.forTarget(this);\n\n  @DomName('Element.oncut')\n  @DocsEditable\n  Stream<Event> get onCut => cutEvent.forTarget(this);\n\n  @DomName('Element.ondblclick')\n  @DocsEditable\n  Stream<Event> get onDoubleClick => doubleClickEvent.forTarget(this);\n\n  @DomName('Element.ondrag')\n  @DocsEditable\n  Stream<MouseEvent> get onDrag => dragEvent.forTarget(this);\n\n  @DomName('Element.ondragend')\n  @DocsEditable\n  Stream<MouseEvent> get onDragEnd => dragEndEvent.forTarget(this);\n\n  @DomName('Element.ondragenter')\n  @DocsEditable\n  Stream<MouseEvent> get onDragEnter => dragEnterEvent.forTarget(this);\n\n  @DomName('Element.ondragleave')\n  @DocsEditable\n  Stream<MouseEvent> get onDragLeave => dragLeaveEvent.forTarget(this);\n\n  @DomName('Element.ondragover')\n  @DocsEditable\n  Stream<MouseEvent> get onDragOver => dragOverEvent.forTarget(this);\n\n  @DomName('Element.ondragstart')\n  @DocsEditable\n  Stream<MouseEvent> get onDragStart => dragStartEvent.forTarget(this);\n\n  @DomName('Element.ondrop')\n  @DocsEditable\n  Stream<MouseEvent> get onDrop => dropEvent.forTarget(this);\n\n  @DomName('Element.onerror')\n  @DocsEditable\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  @DomName('Element.onfocus')\n  @DocsEditable\n  Stream<Event> get onFocus => focusEvent.forTarget(this);\n\n  @DomName('Element.oninput')\n  @DocsEditable\n  Stream<Event> get onInput => inputEvent.forTarget(this);\n\n  @DomName('Element.oninvalid')\n  @DocsEditable\n  Stream<Event> get onInvalid => invalidEvent.forTarget(this);\n\n  @DomName('Element.onkeydown')\n  @DocsEditable\n  Stream<KeyboardEvent> get onKeyDown => keyDownEvent.forTarget(this);\n\n  @DomName('Element.onkeypress')\n  @DocsEditable\n  Stream<KeyboardEvent> get onKeyPress => keyPressEvent.forTarget(this);\n\n  @DomName('Element.onkeyup')\n  @DocsEditable\n  Stream<KeyboardEvent> get onKeyUp => keyUpEvent.forTarget(this);\n\n  @DomName('Element.onload')\n  @DocsEditable\n  Stream<Event> get onLoad => loadEvent.forTarget(this);\n\n  @DomName('Element.onmousedown')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseDown => mouseDownEvent.forTarget(this);\n\n  @DomName('Element.onmousemove')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseMove => mouseMoveEvent.forTarget(this);\n\n  @DomName('Element.onmouseout')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseOut => mouseOutEvent.forTarget(this);\n\n  @DomName('Element.onmouseover')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseOver => mouseOverEvent.forTarget(this);\n\n  @DomName('Element.onmouseup')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseUp => mouseUpEvent.forTarget(this);\n\n  @DomName('Element.onmousewheel')\n  @DocsEditable\n  Stream<WheelEvent> get onMouseWheel => mouseWheelEvent.forTarget(this);\n\n  @DomName('Element.onpaste')\n  @DocsEditable\n  Stream<Event> get onPaste => pasteEvent.forTarget(this);\n\n  @DomName('Element.onreset')\n  @DocsEditable\n  Stream<Event> get onReset => resetEvent.forTarget(this);\n\n  @DomName('Element.onscroll')\n  @DocsEditable\n  Stream<Event> get onScroll => scrollEvent.forTarget(this);\n\n  @DomName('Element.onsearch')\n  @DocsEditable\n  Stream<Event> get onSearch => searchEvent.forTarget(this);\n\n  @DomName('Element.onselect')\n  @DocsEditable\n  Stream<Event> get onSelect => selectEvent.forTarget(this);\n\n  @DomName('Element.onselectstart')\n  @DocsEditable\n  Stream<Event> get onSelectStart => selectStartEvent.forTarget(this);\n\n  @DomName('Element.onsubmit')\n  @DocsEditable\n  Stream<Event> get onSubmit => submitEvent.forTarget(this);\n\n  @DomName('Element.ontouchcancel')\n  @DocsEditable\n  Stream<TouchEvent> get onTouchCancel => touchCancelEvent.forTarget(this);\n\n  @DomName('Element.ontouchend')\n  @DocsEditable\n  Stream<TouchEvent> get onTouchEnd => touchEndEvent.forTarget(this);\n\n  @DomName('Element.ontouchenter')\n  @DocsEditable\n  Stream<TouchEvent> get onTouchEnter => touchEnterEvent.forTarget(this);\n\n  @DomName('Element.ontouchleave')\n  @DocsEditable\n  Stream<TouchEvent> get onTouchLeave => touchLeaveEvent.forTarget(this);\n\n  @DomName('Element.ontouchmove')\n  @DocsEditable\n  Stream<TouchEvent> get onTouchMove => touchMoveEvent.forTarget(this);\n\n  @DomName('Element.ontouchstart')\n  @DocsEditable\n  Stream<TouchEvent> get onTouchStart => touchStartEvent.forTarget(this);\n\n  @DomName('Element.onwebkitTransitionEnd')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  Stream<TransitionEvent> get onTransitionEnd => transitionEndEvent.forTarget(this);\n\n  @DomName('Element.onwebkitfullscreenchange')\n  @DocsEditable\n  Stream<Event> get onFullscreenChange => fullscreenChangeEvent.forTarget(this);\n\n  @DomName('Element.onwebkitfullscreenerror')\n  @DocsEditable\n  Stream<Event> get onFullscreenError => fullscreenErrorEvent.forTarget(this);\n\n}\n\nfinal _START_TAG_REGEXP = new RegExp('<(\\\\w+)');\nclass _ElementFactoryProvider {\n  static const _CUSTOM_PARENT_TAG_MAP = const {\n    'body' : 'html',\n    'head' : 'html',\n    'caption' : 'table',\n    'td': 'tr',\n    'th': 'tr',\n    'colgroup': 'table',\n    'col' : 'colgroup',\n    'tr' : 'tbody',\n    'tbody' : 'table',\n    'tfoot' : 'table',\n    'thead' : 'table',\n    'track' : 'audio',\n  };\n\n  // TODO(jmesserly): const set would be better\n  static const _TABLE_TAGS = const {\n    'caption': null,\n    'col': null,\n    'colgroup': null,\n    'tbody': null,\n    'td': null,\n    'tfoot': null,\n    'th': null,\n    'thead': null,\n    'tr': null,\n  };\n\n  @DomName('Document.createElement')\n  static Element createElement_html(String html) {\n    // TODO(jacobr): this method can be made more robust and performant.\n    // 1) Cache the dummy parent elements required to use innerHTML rather than\n    //    creating them every call.\n    // 2) Verify that the html does not contain leading or trailing text nodes.\n    // 3) Verify that the html does not contain both <head> and <body> tags.\n    // 4) Detatch the created element from its dummy parent.\n    String parentTag = 'div';\n    String tag;\n    final match = _START_TAG_REGEXP.firstMatch(html);\n    if (match != null) {\n      tag = match.group(1).toLowerCase();\n      if (Device.isIE && _TABLE_TAGS.containsKey(tag)) {\n        return _createTableForIE(html, tag);\n      }\n      parentTag = _CUSTOM_PARENT_TAG_MAP[tag];\n      if (parentTag == null) parentTag = 'div';\n    }\n\n    final temp = new Element.tag(parentTag);\n    temp.innerHtml = html;\n\n    Element element;\n    if (temp.children.length == 1) {\n      element = temp.children[0];\n    } else if (parentTag == 'html' && temp.children.length == 2) {\n      // In html5 the root <html> tag will always have a <body> and a <head>,\n      // even though the inner html only contains one of them.\n      element = temp.children[tag == 'head' ? 0 : 1];\n    } else {\n      _singleNode(temp.children);\n    }\n    element.remove();\n    return element;\n  }\n\n  /**\n   * IE table elements don't support innerHTML (even in standards mode).\n   * Instead we use a div and inject the table element in the innerHtml string.\n   * This technique works on other browsers too, but it's probably slower,\n   * so we only use it when running on IE.\n   *\n   * See also innerHTML:\n   * <http://msdn.microsoft.com/en-us/library/ie/ms533897(v=vs.85).aspx>\n   * and Building Tables Dynamically:\n   * <http://msdn.microsoft.com/en-us/library/ie/ms532998(v=vs.85).aspx>.\n   */\n  static Element _createTableForIE(String html, String tag) {\n    var div = new Element.tag('div');\n    div.innerHtml = '<table>$html</table>';\n    var table = _singleNode(div.children);\n    Element element;\n    switch (tag) {\n      case 'td':\n      case 'th':\n        TableRowElement row = _singleNode(table.rows);\n        element = _singleNode(row.cells);\n        break;\n      case 'tr':\n        element = _singleNode(table.rows);\n        break;\n      case 'tbody':\n        element = _singleNode(table.tBodies);\n        break;\n      case 'thead':\n        element = table.tHead;\n        break;\n      case 'tfoot':\n        element = table.tFoot;\n        break;\n      case 'caption':\n        element = table.caption;\n        break;\n      case 'colgroup':\n        element = _getColgroup(table);\n        break;\n      case 'col':\n        element = _singleNode(_getColgroup(table).children);\n        break;\n    }\n    element.remove();\n    return element;\n  }\n\n  static TableColElement _getColgroup(TableElement table) {\n    // TODO(jmesserly): is there a better way to do this?\n    return _singleNode(table.children.where((n) => n.tagName == 'COLGROUP')\n        .toList());\n  }\n\n  static Node _singleNode(List<Node> list) {\n    if (list.length == 1) return list[0];\n    throw new ArgumentError('HTML had ${list.length} '\n        'top level elements but 1 expected');\n  }\n\n  @DomName('Document.createElement')\n  // Optimization to improve performance until the dart2js compiler inlines this\n  // method.\n  static dynamic createElement_tag(String tag) =>\n      // Firefox may return a JS function for some types (Embed, Object).\n      JS('Element|=Object', 'document.createElement(#)', tag);\n}\n\n\n/**\n * Options for Element.scrollIntoView.\n */\nclass ScrollAlignment {\n  final _value;\n  const ScrollAlignment._internal(this._value);\n  toString() => 'ScrollAlignment.$_value';\n\n  /// Attempt to align the element to the top of the scrollable area.\n  static const TOP = const ScrollAlignment._internal('TOP');\n  /// Attempt to center the element in the scrollable area.\n  static const CENTER = const ScrollAlignment._internal('CENTER');\n  /// Attempt to align the element to the bottom of the scrollable area.\n  static const BOTTOM = const ScrollAlignment._internal('BOTTOM');\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('ElementTraversal')\nabstract class ElementTraversal {\n\n  int $dom_childElementCount;\n\n  Element $dom_firstElementChild;\n\n  Element $dom_lastElementChild;\n\n  Element nextElementSibling;\n\n  Element previousElementSibling;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLEmbedElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.IE)\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass EmbedElement extends Element native \"HTMLEmbedElement\" {\n\n  @DomName('HTMLEmbedElement.HTMLEmbedElement')\n  @DocsEditable\n  factory EmbedElement() => document.$dom_createElement(\"embed\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('embed');\n\n  @DomName('HTMLEmbedElement.align')\n  @DocsEditable\n  String align;\n\n  @DomName('HTMLEmbedElement.height')\n  @DocsEditable\n  String height;\n\n  @DomName('HTMLEmbedElement.name')\n  @DocsEditable\n  String name;\n\n  @DomName('HTMLEmbedElement.src')\n  @DocsEditable\n  String src;\n\n  @DomName('HTMLEmbedElement.type')\n  @DocsEditable\n  String type;\n\n  @DomName('HTMLEmbedElement.width')\n  @DocsEditable\n  String width;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('EntityReference')\nclass EntityReference extends Node native \"EntityReference\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void _EntriesCallback(List<Entry> entries);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Entry')\nclass Entry native \"Entry\" {\n\n  @DomName('Entry.filesystem')\n  @DocsEditable\n  final FileSystem filesystem;\n\n  @DomName('Entry.fullPath')\n  @DocsEditable\n  final String fullPath;\n\n  @DomName('Entry.isDirectory')\n  @DocsEditable\n  final bool isDirectory;\n\n  @DomName('Entry.isFile')\n  @DocsEditable\n  final bool isFile;\n\n  @DomName('Entry.name')\n  @DocsEditable\n  final String name;\n\n  @JSName('copyTo')\n  @DomName('Entry.copyTo')\n  @DocsEditable\n  void _copyTo(DirectoryEntry parent, {String name, _EntryCallback successCallback, _ErrorCallback errorCallback}) native;\n\n  @JSName('copyTo')\n  @DomName('Entry.copyTo')\n  @DocsEditable\n  Future<Entry> copyTo(DirectoryEntry parent, {String name}) {\n    var completer = new Completer<Entry>();\n    _copyTo(parent, name : name,\n        successCallback : (value) { completer.complete(value); },\n        errorCallback : (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('getMetadata')\n  @DomName('Entry.getMetadata')\n  @DocsEditable\n  void _getMetadata(MetadataCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('getMetadata')\n  @DomName('Entry.getMetadata')\n  @DocsEditable\n  Future<Metadata> getMetadata() {\n    var completer = new Completer<Metadata>();\n    _getMetadata(\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('getParent')\n  @DomName('Entry.getParent')\n  @DocsEditable\n  void _getParent([_EntryCallback successCallback, _ErrorCallback errorCallback]) native;\n\n  @JSName('getParent')\n  @DomName('Entry.getParent')\n  @DocsEditable\n  Future<Entry> getParent() {\n    var completer = new Completer<Entry>();\n    _getParent(\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('moveTo')\n  @DomName('Entry.moveTo')\n  @DocsEditable\n  void _moveTo(DirectoryEntry parent, {String name, _EntryCallback successCallback, _ErrorCallback errorCallback}) native;\n\n  @JSName('moveTo')\n  @DomName('Entry.moveTo')\n  @DocsEditable\n  Future<Entry> moveTo(DirectoryEntry parent, {String name}) {\n    var completer = new Completer<Entry>();\n    _moveTo(parent, name : name,\n        successCallback : (value) { completer.complete(value); },\n        errorCallback : (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('remove')\n  @DomName('Entry.remove')\n  @DocsEditable\n  void _remove(VoidCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('remove')\n  @DomName('Entry.remove')\n  @DocsEditable\n  Future remove() {\n    var completer = new Completer();\n    _remove(\n        () { completer.complete(); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('toURL')\n  @DomName('Entry.toURL')\n  @DocsEditable\n  String toUrl() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void _EntryCallback(Entry entry);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void _ErrorCallback(FileError error);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('ErrorEvent')\nclass ErrorEvent extends Event native \"ErrorEvent\" {\n\n  @DomName('ErrorEvent.filename')\n  @DocsEditable\n  final String filename;\n\n  @DomName('ErrorEvent.lineno')\n  @DocsEditable\n  final int lineno;\n\n  @DomName('ErrorEvent.message')\n  @DocsEditable\n  final String message;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('Event')\nclass Event native \"Event\" {\n  // In JS, canBubble and cancelable are technically required parameters to\n  // init*Event. In practice, though, if they aren't provided they simply\n  // default to false (since that's Boolean(undefined)).\n  //\n  // Contrary to JS, we default canBubble and cancelable to true, since that's\n  // what people want most of the time anyway.\n  factory Event(String type,\n      {bool canBubble: true, bool cancelable: true}) {\n    return new Event.eventType('Event', type, canBubble: canBubble,\n        cancelable: canBubble);\n  }\n\n  /**\n   * Creates a new Event object of the specified type.\n   *\n   * This is analogous to document.createEvent.\n   * Normally events should be created via their constructors, if available.\n   *\n   *     var e = new Event.type('MouseEvent', 'mousedown', true, true);\n   */\n  factory Event.eventType(String type, String name, {bool canBubble: true,\n      bool cancelable: true}) {\n    final Event e = document.$dom_createEvent(type);\n    e.$dom_initEvent(name, canBubble, cancelable);\n    return e;\n  }\n\n  static const int AT_TARGET = 2;\n\n  static const int BLUR = 8192;\n\n  static const int BUBBLING_PHASE = 3;\n\n  static const int CAPTURING_PHASE = 1;\n\n  static const int CHANGE = 32768;\n\n  static const int CLICK = 64;\n\n  static const int DBLCLICK = 128;\n\n  static const int DRAGDROP = 2048;\n\n  static const int FOCUS = 4096;\n\n  static const int KEYDOWN = 256;\n\n  static const int KEYPRESS = 1024;\n\n  static const int KEYUP = 512;\n\n  static const int MOUSEDOWN = 1;\n\n  static const int MOUSEDRAG = 32;\n\n  static const int MOUSEMOVE = 16;\n\n  static const int MOUSEOUT = 8;\n\n  static const int MOUSEOVER = 4;\n\n  static const int MOUSEUP = 2;\n\n  static const int NONE = 0;\n\n  static const int SELECT = 16384;\n\n  @DomName('Event.bubbles')\n  @DocsEditable\n  final bool bubbles;\n\n  @DomName('Event.cancelBubble')\n  @DocsEditable\n  bool cancelBubble;\n\n  @DomName('Event.cancelable')\n  @DocsEditable\n  final bool cancelable;\n\n  @DomName('Event.clipboardData')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final DataTransfer clipboardData;\n\n  EventTarget get currentTarget => _convertNativeToDart_EventTarget(this._get_currentTarget);\n  @JSName('currentTarget')\n  @DomName('Event.currentTarget')\n  @DocsEditable\n  @Creates('Null')\n  @Returns('EventTarget|=Object')\n  final dynamic _get_currentTarget;\n\n  @DomName('Event.defaultPrevented')\n  @DocsEditable\n  final bool defaultPrevented;\n\n  @DomName('Event.eventPhase')\n  @DocsEditable\n  final int eventPhase;\n\n  EventTarget get target => _convertNativeToDart_EventTarget(this._get_target);\n  @JSName('target')\n  @DomName('Event.target')\n  @DocsEditable\n  @Creates('Node')\n  @Returns('EventTarget|=Object')\n  final dynamic _get_target;\n\n  @DomName('Event.timeStamp')\n  @DocsEditable\n  final int timeStamp;\n\n  @DomName('Event.type')\n  @DocsEditable\n  final String type;\n\n  @JSName('initEvent')\n  @DomName('Event.initEvent')\n  @DocsEditable\n  void $dom_initEvent(String eventTypeArg, bool canBubbleArg, bool cancelableArg) native;\n\n  @DomName('Event.preventDefault')\n  @DocsEditable\n  void preventDefault() native;\n\n  @DomName('Event.stopImmediatePropagation')\n  @DocsEditable\n  void stopImmediatePropagation() native;\n\n  @DomName('Event.stopPropagation')\n  @DocsEditable\n  void stopPropagation() native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('EventException')\nclass EventException native \"EventException\" {\n\n  static const int DISPATCH_REQUEST_ERR = 1;\n\n  static const int UNSPECIFIED_EVENT_TYPE_ERR = 0;\n\n  @DomName('EventException.code')\n  @DocsEditable\n  final int code;\n\n  @DomName('EventException.message')\n  @DocsEditable\n  final String message;\n\n  @DomName('EventException.name')\n  @DocsEditable\n  final String name;\n\n  @DomName('EventException.toString')\n  @DocsEditable\n  String toString() native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('EventSource')\nclass EventSource extends EventTarget native \"EventSource\" {\n  factory EventSource(String title, {withCredentials: false}) {\n    var parsedOptions = {\n      'withCredentials': withCredentials,\n    };\n    return EventSource._factoryEventSource(title, parsedOptions);\n  }\n\n  @DomName('EventSource.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('EventSource.messageEvent')\n  @DocsEditable\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  @DomName('EventSource.openEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> openEvent = const EventStreamProvider<Event>('open');\n\n  @DomName('EventSource.EventSource')\n  @DocsEditable\n  static EventSource _factoryEventSource(String url, [Map eventSourceInit]) {\n    if (?eventSourceInit) {\n      return EventSource._create_1(url, eventSourceInit);\n    }\n    return EventSource._create_2(url);\n  }\n  static EventSource _create_1(url, eventSourceInit) => JS('EventSource', 'new EventSource(#,#)', url, eventSourceInit);\n  static EventSource _create_2(url) => JS('EventSource', 'new EventSource(#)', url);\n\n  static const int CLOSED = 2;\n\n  static const int CONNECTING = 0;\n\n  static const int OPEN = 1;\n\n  @DomName('EventSource.readyState')\n  @DocsEditable\n  final int readyState;\n\n  @DomName('EventSource.url')\n  @DocsEditable\n  final String url;\n\n  @DomName('EventSource.withCredentials')\n  @DocsEditable\n  final bool withCredentials;\n\n  @JSName('addEventListener')\n  @DomName('EventSource.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('EventSource.close')\n  @DocsEditable\n  void close() native;\n\n  @DomName('EventSource.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @JSName('removeEventListener')\n  @DomName('EventSource.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('EventSource.onerror')\n  @DocsEditable\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  @DomName('EventSource.onmessage')\n  @DocsEditable\n  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);\n\n  @DomName('EventSource.onopen')\n  @DocsEditable\n  Stream<Event> get onOpen => openEvent.forTarget(this);\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Base class that supports listening for and dispatching browser events.\n *\n * Normally events are accessed via the Stream getter:\n *\n *     element.onMouseOver.listen((e) => print('Mouse over!'));\n *\n * To access bubbling events which are declared on one element, but may bubble\n * up to another element type (common for MediaElement events):\n *\n *     MediaElement.pauseEvent.forTarget(document.body).listen(...);\n *\n * To useCapture on events:\n *\n *     Element.keyDownEvent.forTarget(element, useCapture: true).listen(...);\n *\n * Custom events can be declared as:\n *\n *    class DataGenerator {\n *      static EventStreamProvider<Event> dataEvent =\n *          new EventStreamProvider('data');\n *    }\n *\n * Then listeners should access the event with:\n *\n *     DataGenerator.dataEvent.forTarget(element).listen(...);\n *\n * Custom events can also be accessed as:\n *\n *     element.on['some_event'].listen(...);\n *\n * This approach is generally discouraged as it loses the event typing and\n * some DOM events may have multiple platform-dependent event names under the\n * covers. By using the standard Stream getters you will get the platform\n * specific event name automatically.\n */\nclass Events {\n  /* Raw event target. */\n  final EventTarget _ptr;\n\n  Events(this._ptr);\n\n  Stream operator [](String type) {\n    return new _EventStream(_ptr, type, false);\n  }\n}\n\n/**\n * Base class for all browser objects that support events.\n *\n * Use the [on] property to add, and remove events (rather than\n * [$dom_addEventListener] and [$dom_removeEventListener]\n * for compile-time type checks and a more concise API.\n */\n@DomName('EventTarget')\nclass EventTarget native \"EventTarget\" {\n\n  /**\n   * This is an ease-of-use accessor for event streams which should only be\n   * used when an explicit accessor is not available.\n   */\n  Events get on => new Events(this);\n\n  @JSName('addEventListener')\n  @DomName('EventTarget.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('EventTarget.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event event) native;\n\n  @JSName('removeEventListener')\n  @DomName('EventTarget.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLFieldSetElement')\nclass FieldSetElement extends Element native \"HTMLFieldSetElement\" {\n\n  @DomName('HTMLFieldSetElement.HTMLFieldSetElement')\n  @DocsEditable\n  factory FieldSetElement() => document.$dom_createElement(\"fieldset\");\n\n  @DomName('HTMLFieldSetElement.disabled')\n  @DocsEditable\n  bool disabled;\n\n  @DomName('HTMLFieldSetElement.elements')\n  @DocsEditable\n  final HtmlCollection elements;\n\n  @DomName('HTMLFieldSetElement.form')\n  @DocsEditable\n  final FormElement form;\n\n  @DomName('HTMLFieldSetElement.name')\n  @DocsEditable\n  String name;\n\n  @DomName('HTMLFieldSetElement.type')\n  @DocsEditable\n  final String type;\n\n  @DomName('HTMLFieldSetElement.validationMessage')\n  @DocsEditable\n  final String validationMessage;\n\n  @DomName('HTMLFieldSetElement.validity')\n  @DocsEditable\n  final ValidityState validity;\n\n  @DomName('HTMLFieldSetElement.willValidate')\n  @DocsEditable\n  final bool willValidate;\n\n  @DomName('HTMLFieldSetElement.checkValidity')\n  @DocsEditable\n  bool checkValidity() native;\n\n  @DomName('HTMLFieldSetElement.setCustomValidity')\n  @DocsEditable\n  void setCustomValidity(String error) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('File')\nclass File extends Blob native \"File\" {\n\n  DateTime get lastModifiedDate => _convertNativeToDart_DateTime(this._get_lastModifiedDate);\n  @JSName('lastModifiedDate')\n  @DomName('File.lastModifiedDate')\n  @DocsEditable\n  final dynamic _get_lastModifiedDate;\n\n  @DomName('File.name')\n  @DocsEditable\n  final String name;\n\n  @JSName('webkitRelativePath')\n  @DomName('File.webkitRelativePath')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final String relativePath;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void _FileCallback(File file);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('FileEntry')\nclass FileEntry extends Entry native \"FileEntry\" {\n\n  @JSName('createWriter')\n  @DomName('FileEntry.createWriter')\n  @DocsEditable\n  void _createWriter(_FileWriterCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('createWriter')\n  @DomName('FileEntry.createWriter')\n  @DocsEditable\n  Future<FileWriter> createWriter() {\n    var completer = new Completer<FileWriter>();\n    _createWriter(\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('file')\n  @DomName('FileEntry.file')\n  @DocsEditable\n  void _file(_FileCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('file')\n  @DomName('FileEntry.file')\n  @DocsEditable\n  Future<File> file() {\n    var completer = new Completer<File>();\n    _file(\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('FileError')\nclass FileError native \"FileError\" {\n\n  static const int ABORT_ERR = 3;\n\n  static const int ENCODING_ERR = 5;\n\n  static const int INVALID_MODIFICATION_ERR = 9;\n\n  static const int INVALID_STATE_ERR = 7;\n\n  static const int NOT_FOUND_ERR = 1;\n\n  static const int NOT_READABLE_ERR = 4;\n\n  static const int NO_MODIFICATION_ALLOWED_ERR = 6;\n\n  static const int PATH_EXISTS_ERR = 12;\n\n  static const int QUOTA_EXCEEDED_ERR = 10;\n\n  static const int SECURITY_ERR = 2;\n\n  static const int SYNTAX_ERR = 8;\n\n  static const int TYPE_MISMATCH_ERR = 11;\n\n  @DomName('FileError.code')\n  @DocsEditable\n  final int code;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('FileException')\nclass FileException native \"FileException\" {\n\n  static const int ABORT_ERR = 3;\n\n  static const int ENCODING_ERR = 5;\n\n  static const int INVALID_MODIFICATION_ERR = 9;\n\n  static const int INVALID_STATE_ERR = 7;\n\n  static const int NOT_FOUND_ERR = 1;\n\n  static const int NOT_READABLE_ERR = 4;\n\n  static const int NO_MODIFICATION_ALLOWED_ERR = 6;\n\n  static const int PATH_EXISTS_ERR = 12;\n\n  static const int QUOTA_EXCEEDED_ERR = 10;\n\n  static const int SECURITY_ERR = 2;\n\n  static const int SYNTAX_ERR = 8;\n\n  static const int TYPE_MISMATCH_ERR = 11;\n\n  @DomName('FileException.code')\n  @DocsEditable\n  final int code;\n\n  @DomName('FileException.message')\n  @DocsEditable\n  final String message;\n\n  @DomName('FileException.name')\n  @DocsEditable\n  final String name;\n\n  @DomName('FileException.toString')\n  @DocsEditable\n  String toString() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('FileList')\nclass FileList implements JavaScriptIndexingBehavior, List<File> native \"FileList\" {\n\n  @DomName('FileList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  File operator[](int index) => JS(\"File\", \"#[#]\", this, index);\n\n  void operator[]=(int index, File value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<File> mixins.\n  // File is the element type.\n\n  // From Iterable<File>:\n\n  Iterator<File> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<File>(this);\n  }\n\n  File reduce(File combine(File value, File element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, File element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(File element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(File element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(File element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<File> where(bool f(File element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(File element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(File element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(File element)) => IterableMixinWorkaround.any(this, f);\n\n  List<File> toList({ bool growable: true }) =>\n      new List<File>.from(this, growable: growable);\n\n  Set<File> toSet() => new Set<File>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<File> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<File> takeWhile(bool test(File value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<File> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<File> skipWhile(bool test(File value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  File firstWhere(bool test(File value), { File orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  File lastWhere(bool test(File value), {File orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  File singleWhere(bool test(File value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  File elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<File>:\n\n  void add(File value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<File> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<File>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<File> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(File a, File b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(File element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(File element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  File get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  File get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  File get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, File element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<File> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<File> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  File removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  File removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(File element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(File element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<File> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<File> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [File fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<File> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<File> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <File>[]);\n  }\n\n  Map<int, File> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<File> mixins.\n\n  @DomName('FileList.item')\n  @DocsEditable\n  File item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('FileReader')\nclass FileReader extends EventTarget native \"FileReader\" {\n\n  @DomName('FileReader.abortEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> abortEvent = const EventStreamProvider<ProgressEvent>('abort');\n\n  @DomName('FileReader.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('FileReader.loadEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> loadEvent = const EventStreamProvider<ProgressEvent>('load');\n\n  @DomName('FileReader.loadendEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> loadEndEvent = const EventStreamProvider<ProgressEvent>('loadend');\n\n  @DomName('FileReader.loadstartEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> loadStartEvent = const EventStreamProvider<ProgressEvent>('loadstart');\n\n  @DomName('FileReader.progressEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> progressEvent = const EventStreamProvider<ProgressEvent>('progress');\n\n  @DomName('FileReader.FileReader')\n  @DocsEditable\n  factory FileReader() {\n    return FileReader._create_1();\n  }\n  static FileReader _create_1() => JS('FileReader', 'new FileReader()');\n\n  static const int DONE = 2;\n\n  static const int EMPTY = 0;\n\n  static const int LOADING = 1;\n\n  @DomName('FileReader.error')\n  @DocsEditable\n  final FileError error;\n\n  @DomName('FileReader.readyState')\n  @DocsEditable\n  final int readyState;\n\n  @DomName('FileReader.result')\n  @DocsEditable\n  @Creates('String|ByteBuffer|Null')\n  final Object result;\n\n  @DomName('FileReader.abort')\n  @DocsEditable\n  void abort() native;\n\n  @JSName('addEventListener')\n  @DomName('FileReader.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('FileReader.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @DomName('FileReader.readAsArrayBuffer')\n  @DocsEditable\n  void readAsArrayBuffer(Blob blob) native;\n\n  @DomName('FileReader.readAsBinaryString')\n  @DocsEditable\n  void readAsBinaryString(Blob blob) native;\n\n  @JSName('readAsDataURL')\n  @DomName('FileReader.readAsDataURL')\n  @DocsEditable\n  void readAsDataUrl(Blob blob) native;\n\n  @DomName('FileReader.readAsText')\n  @DocsEditable\n  void readAsText(Blob blob, [String encoding]) native;\n\n  @JSName('removeEventListener')\n  @DomName('FileReader.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('FileReader.onabort')\n  @DocsEditable\n  Stream<ProgressEvent> get onAbort => abortEvent.forTarget(this);\n\n  @DomName('FileReader.onerror')\n  @DocsEditable\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  @DomName('FileReader.onload')\n  @DocsEditable\n  Stream<ProgressEvent> get onLoad => loadEvent.forTarget(this);\n\n  @DomName('FileReader.onloadend')\n  @DocsEditable\n  Stream<ProgressEvent> get onLoadEnd => loadEndEvent.forTarget(this);\n\n  @DomName('FileReader.onloadstart')\n  @DocsEditable\n  Stream<ProgressEvent> get onLoadStart => loadStartEvent.forTarget(this);\n\n  @DomName('FileReader.onprogress')\n  @DocsEditable\n  Stream<ProgressEvent> get onProgress => progressEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DOMFileSystem')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental\nclass FileSystem native \"DOMFileSystem\" {\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.webkitRequestFileSystem)');\n\n  @DomName('DOMFileSystem.name')\n  @DocsEditable\n  final String name;\n\n  @DomName('DOMFileSystem.root')\n  @DocsEditable\n  final DirectoryEntry root;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void _FileSystemCallback(FileSystem fileSystem);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('FileWriter')\nclass FileWriter extends EventTarget native \"FileWriter\" {\n\n  @DomName('FileWriter.abortEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> abortEvent = const EventStreamProvider<ProgressEvent>('abort');\n\n  @DomName('FileWriter.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('FileWriter.progressEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> progressEvent = const EventStreamProvider<ProgressEvent>('progress');\n\n  @DomName('FileWriter.writeEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> writeEvent = const EventStreamProvider<ProgressEvent>('write');\n\n  @DomName('FileWriter.writeendEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> writeEndEvent = const EventStreamProvider<ProgressEvent>('writeend');\n\n  @DomName('FileWriter.writestartEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> writeStartEvent = const EventStreamProvider<ProgressEvent>('writestart');\n\n  static const int DONE = 2;\n\n  static const int INIT = 0;\n\n  static const int WRITING = 1;\n\n  @DomName('FileWriter.error')\n  @DocsEditable\n  final FileError error;\n\n  @DomName('FileWriter.length')\n  @DocsEditable\n  final int length;\n\n  @DomName('FileWriter.position')\n  @DocsEditable\n  final int position;\n\n  @DomName('FileWriter.readyState')\n  @DocsEditable\n  final int readyState;\n\n  @DomName('FileWriter.abort')\n  @DocsEditable\n  void abort() native;\n\n  @JSName('addEventListener')\n  @DomName('FileWriter.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('FileWriter.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @JSName('removeEventListener')\n  @DomName('FileWriter.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('FileWriter.seek')\n  @DocsEditable\n  void seek(int position) native;\n\n  @DomName('FileWriter.truncate')\n  @DocsEditable\n  void truncate(int size) native;\n\n  @DomName('FileWriter.write')\n  @DocsEditable\n  void write(Blob data) native;\n\n  @DomName('FileWriter.onabort')\n  @DocsEditable\n  Stream<ProgressEvent> get onAbort => abortEvent.forTarget(this);\n\n  @DomName('FileWriter.onerror')\n  @DocsEditable\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  @DomName('FileWriter.onprogress')\n  @DocsEditable\n  Stream<ProgressEvent> get onProgress => progressEvent.forTarget(this);\n\n  @DomName('FileWriter.onwrite')\n  @DocsEditable\n  Stream<ProgressEvent> get onWrite => writeEvent.forTarget(this);\n\n  @DomName('FileWriter.onwriteend')\n  @DocsEditable\n  Stream<ProgressEvent> get onWriteEnd => writeEndEvent.forTarget(this);\n\n  @DomName('FileWriter.onwritestart')\n  @DocsEditable\n  Stream<ProgressEvent> get onWriteStart => writeStartEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void _FileWriterCallback(FileWriter fileWriter);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('FocusEvent')\nclass FocusEvent extends UIEvent native \"FocusEvent\" {\n\n  EventTarget get relatedTarget => _convertNativeToDart_EventTarget(this._get_relatedTarget);\n  @JSName('relatedTarget')\n  @DomName('FocusEvent.relatedTarget')\n  @DocsEditable\n  final dynamic _get_relatedTarget;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('FontLoader')\nclass FontLoader extends EventTarget native \"FontLoader\" {\n\n  @DomName('FontLoader.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('FontLoader.loadEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> loadEvent = const EventStreamProvider<Event>('load');\n\n  @DomName('FontLoader.loading')\n  @DocsEditable\n  final bool loading;\n\n  @JSName('addEventListener')\n  @DomName('FontLoader.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('FontLoader.checkFont')\n  @DocsEditable\n  bool checkFont(String font, String text) native;\n\n  @DomName('FontLoader.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @DomName('FontLoader.loadFont')\n  @DocsEditable\n  void loadFont(Map params) {\n    var params_1 = convertDartToNative_Dictionary(params);\n    _loadFont_1(params_1);\n    return;\n  }\n  @JSName('loadFont')\n  @DomName('FontLoader.loadFont')\n  @DocsEditable\n  void _loadFont_1(params) native;\n\n  @DomName('FontLoader.notifyWhenFontsReady')\n  @DocsEditable\n  void notifyWhenFontsReady(VoidCallback callback) native;\n\n  @JSName('removeEventListener')\n  @DomName('FontLoader.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('FontLoader.onerror')\n  @DocsEditable\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  @DomName('FontLoader.onload')\n  @DocsEditable\n  Stream<Event> get onLoad => loadEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('FormData')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FormData native \"FormData\" {\n\n  @DomName('DOMFormData.DOMFormData')\n  @DocsEditable\n  factory FormData([FormElement form]) {\n    if (?form) {\n      return FormData._create_1(form);\n    }\n    return FormData._create_2();\n  }\n  static FormData _create_1(form) => JS('FormData', 'new FormData(#)', form);\n  static FormData _create_2() => JS('FormData', 'new FormData()');\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.FormData)');\n\n  @DomName('DOMFormData.append')\n  @DocsEditable\n  void append(String name, value, [String filename]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLFormElement')\nclass FormElement extends Element native \"HTMLFormElement\" {\n\n  @DomName('HTMLFormElement.HTMLFormElement')\n  @DocsEditable\n  factory FormElement() => document.$dom_createElement(\"form\");\n\n  @DomName('HTMLFormElement.acceptCharset')\n  @DocsEditable\n  String acceptCharset;\n\n  @DomName('HTMLFormElement.action')\n  @DocsEditable\n  String action;\n\n  @DomName('HTMLFormElement.autocomplete')\n  @DocsEditable\n  String autocomplete;\n\n  @DomName('HTMLFormElement.encoding')\n  @DocsEditable\n  String encoding;\n\n  @DomName('HTMLFormElement.enctype')\n  @DocsEditable\n  String enctype;\n\n  @DomName('HTMLFormElement.length')\n  @DocsEditable\n  final int length;\n\n  @DomName('HTMLFormElement.method')\n  @DocsEditable\n  String method;\n\n  @DomName('HTMLFormElement.name')\n  @DocsEditable\n  String name;\n\n  @DomName('HTMLFormElement.noValidate')\n  @DocsEditable\n  bool noValidate;\n\n  @DomName('HTMLFormElement.target')\n  @DocsEditable\n  String target;\n\n  @DomName('HTMLFormElement.checkValidity')\n  @DocsEditable\n  bool checkValidity() native;\n\n  @DomName('HTMLFormElement.requestAutocomplete')\n  @DocsEditable\n  void requestAutocomplete() native;\n\n  @DomName('HTMLFormElement.reset')\n  @DocsEditable\n  void reset() native;\n\n  @DomName('HTMLFormElement.submit')\n  @DocsEditable\n  void submit() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Gamepad')\nclass Gamepad native \"Gamepad\" {\n\n  @DomName('Gamepad.axes')\n  @DocsEditable\n  final List<num> axes;\n\n  @DomName('Gamepad.buttons')\n  @DocsEditable\n  final List<num> buttons;\n\n  @DomName('Gamepad.id')\n  @DocsEditable\n  final String id;\n\n  @DomName('Gamepad.index')\n  @DocsEditable\n  final int index;\n\n  @DomName('Gamepad.timestamp')\n  @DocsEditable\n  final int timestamp;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Geolocation')\nclass Geolocation native \"Geolocation\" {\n\n  @DomName('Geolocation.getCurrentPosition')\n  Future<Geoposition> getCurrentPosition({bool enableHighAccuracy,\n      Duration timeout, Duration maximumAge}) {\n    var options = {};\n    if (enableHighAccuracy != null) {\n      options['enableHighAccuracy'] = enableHighAccuracy;\n    }\n    if (timeout != null) {\n      options['timeout'] = timeout.inMilliseconds;\n    }\n    if (maximumAge != null) {\n      options['maximumAge'] = maximumAge.inMilliseconds;\n    }\n    var completer = new Completer<Geoposition>();\n    try {\n      $dom_getCurrentPosition(\n          (position) {\n            completer.complete(_ensurePosition(position));\n          },\n          (error) {\n            completer.completeError(error);\n          },\n          options);\n    } catch (e, stacktrace) {\n      completer.completeError(e, stacktrace);\n    }\n    return completer.future;\n  }\n\n  @DomName('Geolocation.watchPosition')\n  Stream<Geoposition> watchPosition({bool enableHighAccuracy,\n      Duration timeout, Duration maximumAge}) {\n\n    var options = {};\n    if (enableHighAccuracy != null) {\n      options['enableHighAccuracy'] = enableHighAccuracy;\n    }\n    if (timeout != null) {\n      options['timeout'] = timeout.inMilliseconds;\n    }\n    if (maximumAge != null) {\n      options['maximumAge'] = maximumAge.inMilliseconds;\n    }\n\n    int watchId;\n    var controller;\n    controller = new StreamController<Geoposition>(\n      onListen: () {\n        assert(watchId == null);\n        watchId = $dom_watchPosition(\n            (position) {\n              controller.add(_ensurePosition(position));\n            },\n            (error) {\n              controller.addError(error);\n            },\n            options);\n      },\n      onCancel: () {\n        assert(watchId != null);\n        $dom_clearWatch(watchId);\n      });\n\n    return controller.stream;\n  }\n\n  Geoposition _ensurePosition(domPosition) {\n    try {\n      // Firefox may throw on this.\n      if (domPosition is Geoposition) {\n        return domPosition;\n      }\n    } catch(e) {}\n    return new _GeopositionWrapper(domPosition);\n  }\n\n\n  @JSName('clearWatch')\n  @DomName('Geolocation.clearWatch')\n  @DocsEditable\n  void $dom_clearWatch(int watchID) native;\n\n  @JSName('getCurrentPosition')\n  @DomName('Geolocation.getCurrentPosition')\n  @DocsEditable\n  void $dom_getCurrentPosition(_PositionCallback successCallback, [_PositionErrorCallback errorCallback, Object options]) native;\n\n  @JSName('watchPosition')\n  @DomName('Geolocation.watchPosition')\n  @DocsEditable\n  int $dom_watchPosition(_PositionCallback successCallback, [_PositionErrorCallback errorCallback, Object options]) native;\n}\n\n/**\n * Wrapper for Firefox- it returns an object which we cannot map correctly.\n * Basically Firefox was returning a [xpconnect wrapped nsIDOMGeoPosition] but\n * which has further oddities.\n */\nclass _GeopositionWrapper implements Geoposition {\n  var _ptr;\n  _GeopositionWrapper(this._ptr);\n\n  Coordinates get coords => JS('Coordinates', '#.coords', _ptr);\n  int get timestamp => JS('int', '#.timestamp', _ptr);\n}\n\n\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Geoposition')\nclass Geoposition native \"Geoposition\" {\n\n  @DomName('Geoposition.coords')\n  @DocsEditable\n  final Coordinates coords;\n\n  @DomName('Geoposition.timestamp')\n  @DocsEditable\n  final int timestamp;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n/**\n * An `<hr>` tag.\n */\n@DomName('HTMLHRElement')\nclass HRElement extends Element native \"HTMLHRElement\" {\n\n  @DomName('HTMLHRElement.HTMLHRElement')\n  @DocsEditable\n  factory HRElement() => document.$dom_createElement(\"hr\");\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n@DomName('HashChangeEvent')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n\nclass HashChangeEvent extends Event native \"HashChangeEvent\" {\n  factory HashChangeEvent(String type,\n      {bool canBubble: true, bool cancelable: true, String oldUrl,\n      String newUrl}) {\n    var event = document.$dom_createEvent(\"HashChangeEvent\");\n    event.$dom_initHashChangeEvent(type, canBubble, cancelable, oldUrl, newUrl);\n    return event;\n  }\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Device.isEventTypeSupported('HashChangeEvent');\n\n  @JSName('newURL')\n  @DomName('HashChangeEvent.newURL')\n  @DocsEditable\n  final String newUrl;\n\n  @JSName('oldURL')\n  @DomName('HashChangeEvent.oldURL')\n  @DocsEditable\n  final String oldUrl;\n\n  @JSName('initHashChangeEvent')\n  @DomName('HashChangeEvent.initHashChangeEvent')\n  @DocsEditable\n  void $dom_initHashChangeEvent(String type, bool canBubble, bool cancelable, String oldURL, String newURL) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLHeadElement')\nclass HeadElement extends Element native \"HTMLHeadElement\" {\n\n  @DomName('HTMLHeadElement.HTMLHeadElement')\n  @DocsEditable\n  factory HeadElement() => document.$dom_createElement(\"head\");\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLHeadingElement')\nclass HeadingElement extends Element native \"HTMLHeadingElement\" {\n\n  @DomName('HTMLHeadingElement.HTMLHeadingElement')\n  @DocsEditable\n  factory HeadingElement.h1() => document.$dom_createElement(\"h1\");\n\n  @DomName('HTMLHeadingElement.HTMLHeadingElement')\n  @DocsEditable\n  factory HeadingElement.h2() => document.$dom_createElement(\"h2\");\n\n  @DomName('HTMLHeadingElement.HTMLHeadingElement')\n  @DocsEditable\n  factory HeadingElement.h3() => document.$dom_createElement(\"h3\");\n\n  @DomName('HTMLHeadingElement.HTMLHeadingElement')\n  @DocsEditable\n  factory HeadingElement.h4() => document.$dom_createElement(\"h4\");\n\n  @DomName('HTMLHeadingElement.HTMLHeadingElement')\n  @DocsEditable\n  factory HeadingElement.h5() => document.$dom_createElement(\"h5\");\n\n  @DomName('HTMLHeadingElement.HTMLHeadingElement')\n  @DocsEditable\n  factory HeadingElement.h6() => document.$dom_createElement(\"h6\");\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('History')\nclass History implements HistoryBase native \"History\" {\n\n  /**\n   * Checks if the State APIs are supported on the current platform.\n   *\n   * See also:\n   *\n   * * [pushState]\n   * * [replaceState]\n   * * [state]\n   */\n  static bool get supportsState => JS('bool', '!!window.history.pushState');\n\n  @DomName('History.length')\n  @DocsEditable\n  final int length;\n\n  dynamic get state => _convertNativeToDart_SerializedScriptValue(this._get_state);\n  @JSName('state')\n  @DomName('History.state')\n  @DocsEditable\n  @annotation_Creates_SerializedScriptValue\n  @annotation_Returns_SerializedScriptValue\n  final dynamic _get_state;\n\n  @DomName('History.back')\n  @DocsEditable\n  void back() native;\n\n  @DomName('History.forward')\n  @DocsEditable\n  void forward() native;\n\n  @DomName('History.go')\n  @DocsEditable\n  void go(int distance) native;\n\n  @DomName('History.pushState')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  void pushState(Object data, String title, [String url]) native;\n\n  @DomName('History.replaceState')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  void replaceState(Object data, String title, [String url]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLAllCollection')\nclass HtmlAllCollection implements JavaScriptIndexingBehavior, List<Node> native \"HTMLAllCollection\" {\n\n  @DomName('HTMLAllCollection.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Node operator[](int index) => JS(\"Node\", \"#[#]\", this, index);\n\n  void operator[]=(int index, Node value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Node> mixins.\n  // Node is the element type.\n\n  // From Iterable<Node>:\n\n  Iterator<Node> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<Node>(this);\n  }\n\n  Node reduce(Node combine(Node value, Node element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, Node element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(Node element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(Node element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(Node element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<Node> where(bool f(Node element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(Node element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(Node element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(Node element)) => IterableMixinWorkaround.any(this, f);\n\n  List<Node> toList({ bool growable: true }) =>\n      new List<Node>.from(this, growable: growable);\n\n  Set<Node> toSet() => new Set<Node>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<Node> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<Node> takeWhile(bool test(Node value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<Node> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<Node> skipWhile(bool test(Node value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  Node firstWhere(bool test(Node value), { Node orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  Node lastWhere(bool test(Node value), {Node orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  Node singleWhere(bool test(Node value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  Node elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<Node>:\n\n  void add(Node value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<Node>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<Node> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(Node a, Node b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(Node element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(Node element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  Node get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  Node get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  Node get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, Node element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Node removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  Node removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(Node element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(Node element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<Node> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [Node fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<Node> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<Node> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <Node>[]);\n  }\n\n  Map<int, Node> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<Node> mixins.\n\n  @DomName('HTMLAllCollection.item')\n  @DocsEditable\n  Node item(int index) native;\n\n  @DomName('HTMLAllCollection.namedItem')\n  @DocsEditable\n  Node namedItem(String name) native;\n\n  @DomName('HTMLAllCollection.tags')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> tags(String name) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLCollection')\nclass HtmlCollection implements JavaScriptIndexingBehavior, List<Node> native \"HTMLCollection\" {\n\n  @DomName('HTMLCollection.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Node operator[](int index) => JS(\"Node\", \"#[#]\", this, index);\n\n  void operator[]=(int index, Node value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Node> mixins.\n  // Node is the element type.\n\n  // From Iterable<Node>:\n\n  Iterator<Node> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<Node>(this);\n  }\n\n  Node reduce(Node combine(Node value, Node element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, Node element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(Node element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(Node element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(Node element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<Node> where(bool f(Node element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(Node element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(Node element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(Node element)) => IterableMixinWorkaround.any(this, f);\n\n  List<Node> toList({ bool growable: true }) =>\n      new List<Node>.from(this, growable: growable);\n\n  Set<Node> toSet() => new Set<Node>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<Node> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<Node> takeWhile(bool test(Node value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<Node> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<Node> skipWhile(bool test(Node value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  Node firstWhere(bool test(Node value), { Node orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  Node lastWhere(bool test(Node value), {Node orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  Node singleWhere(bool test(Node value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  Node elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<Node>:\n\n  void add(Node value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<Node>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<Node> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(Node a, Node b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(Node element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(Node element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  Node get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  Node get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  Node get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, Node element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Node removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  Node removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(Node element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(Node element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<Node> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [Node fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<Node> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<Node> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <Node>[]);\n  }\n\n  Map<int, Node> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<Node> mixins.\n\n  @DomName('HTMLCollection.item')\n  @DocsEditable\n  Node item(int index) native;\n\n  @DomName('HTMLCollection.namedItem')\n  @DocsEditable\n  Node namedItem(String name) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('HTMLDocument')\nclass HtmlDocument extends Document native \"HTMLDocument\" {\n\n  @DomName('HTMLDocument.activeElement')\n  @DocsEditable\n  final Element activeElement;\n\n\n  @DomName('Document.body')\n  BodyElement body;\n\n  @DomName('Document.caretRangeFromPoint')\n  Range caretRangeFromPoint(int x, int y) {\n    return $dom_caretRangeFromPoint(x, y);\n  }\n\n  @DomName('Document.elementFromPoint')\n  Element elementFromPoint(int x, int y) {\n    return $dom_elementFromPoint(x, y);\n  }\n\n  /**\n   * Checks if the getCssCanvasContext API is supported on the current platform.\n   *\n   * See also:\n   *\n   * * [getCssCanvasContext]\n   */\n  static bool get supportsCssCanvasContext =>\n      JS('bool', '!!(document.getCSSCanvasContext)');\n\n\n  /**\n   * Gets a CanvasRenderingContext which can be used as the CSS background of an\n   * element.\n   *\n   * CSS:\n   *\n   *     background: -webkit-canvas(backgroundCanvas)\n   *\n   * Generate the canvas:\n   *\n   *     var context = document.getCssCanvasContext('2d', 'backgroundCanvas',\n   *         100, 100);\n   *     context.fillStyle = 'red';\n   *     context.fillRect(0, 0, 100, 100);\n   *\n   * See also:\n   *\n   * * [supportsCssCanvasContext]\n   * * [CanvasElement.getContext]\n   */\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  @DomName('Document.getCSSCanvasContext')\n  CanvasRenderingContext getCssCanvasContext(String contextId, String name,\n      int width, int height) {\n    return $dom_getCssCanvasContext(contextId, name, width, height);\n  }\n\n  @DomName('Document.head')\n  HeadElement get head => $dom_head;\n\n  @DomName('Document.lastModified')\n  String get lastModified => $dom_lastModified;\n\n  @DomName('Document.preferredStylesheetSet')\n  String get preferredStylesheetSet => $dom_preferredStylesheetSet;\n\n  @DomName('Document.referrer')\n  String get referrer => $dom_referrer;\n\n  @DomName('Document.selectedStylesheetSet')\n  String get selectedStylesheetSet => $dom_selectedStylesheetSet;\n  void set selectedStylesheetSet(String value) {\n    $dom_selectedStylesheetSet = value;\n  }\n\n  @DomName('Document.styleSheets')\n  List<StyleSheet> get styleSheets => $dom_styleSheets;\n\n  @DomName('Document.title')\n  String get title => $dom_title;\n\n  @DomName('Document.title')\n  void set title(String value) {\n    $dom_title = value;\n  }\n\n  @DomName('Document.webkitCancelFullScreen')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void cancelFullScreen() {\n    $dom_webkitCancelFullScreen();\n  }\n\n  @DomName('Document.webkitExitFullscreen')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void exitFullscreen() {\n    $dom_webkitExitFullscreen();\n  }\n\n  @DomName('Document.webkitExitPointerLock')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void exitPointerLock() {\n    $dom_webkitExitPointerLock();\n  }\n\n  @DomName('Document.webkitFullscreenElement')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  Element get fullscreenElement => $dom_webkitFullscreenElement;\n\n  @DomName('Document.webkitFullscreenEnabled')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  bool get fullscreenEnabled => $dom_webkitFullscreenEnabled;\n\n  @DomName('Document.webkitHidden')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  bool get hidden => $dom_webkitHidden;\n\n  @DomName('Document.webkitIsFullScreen')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  bool get isFullScreen => $dom_webkitIsFullScreen;\n\n  @DomName('Document.webkitPointerLockElement')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  Element get pointerLockElement =>\n      $dom_webkitPointerLockElement;\n\n  @DomName('Document.webkitVisibilityState')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  String get visibilityState => $dom_webkitVisibilityState;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLHtmlElement')\nclass HtmlElement extends Element native \"HTMLHtmlElement\" {\n\n  @DomName('HTMLHtmlElement.HTMLHtmlElement')\n  @DocsEditable\n  factory HtmlElement() => document.$dom_createElement(\"html\");\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLFormControlsCollection')\nclass HtmlFormControlsCollection extends HtmlCollection native \"HTMLFormControlsCollection\" {\n\n  @DomName('HTMLFormControlsCollection.namedItem')\n  @DocsEditable\n  Node namedItem(String name) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLOptionsCollection')\nclass HtmlOptionsCollection extends HtmlCollection native \"HTMLOptionsCollection\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * A utility for retrieving data from a URL.\n *\n * HttpRequest can be used to obtain data from http, ftp, and file\n * protocols.\n *\n * For example, suppose we're developing these API docs, and we\n * wish to retrieve the HTML of the top-level page and print it out.\n * The easiest way to do that would be:\n *\n *     HttpRequest.getString('http://api.dartlang.org').then((response) {\n *       print(response);\n *     });\n *\n * **Important**: With the default behavior of this class, your\n * code making the request should be served from the same origin (domain name,\n * port, and application layer protocol) as the URL you are trying to access\n * with HttpRequest. However, there are ways to\n * [get around this restriction](http://www.dartlang.org/articles/json-web-service/#note-on-jsonp).\n *\n * See also:\n *\n * * [Dart article on using HttpRequests](http://www.dartlang.org/articles/json-web-service/#getting-data)\n * * [JS XMLHttpRequest](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest)\n * * [Using XMLHttpRequest](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest)\n */\n@DomName('XMLHttpRequest')\nclass HttpRequest extends EventTarget native \"XMLHttpRequest\" {\n\n  /**\n   * Creates a URL get request for the specified [url].\n   *\n   * The server response must be a `text/` mime type for this request to\n   * succeed.\n   *\n   * This is similar to [request] but specialized for HTTP GET requests which\n   * return text content.\n   *\n   * See also:\n   *\n   * * [request]\n   */\n  static Future<String> getString(String url,\n      {bool withCredentials, void onProgress(ProgressEvent e)}) {\n    return request(url, withCredentials: withCredentials,\n        onProgress: onProgress).then((xhr) => xhr.responseText);\n  }\n\n  /**\n   * Creates a URL request for the specified [url].\n   *\n   * By default this will do an HTTP GET request, this can be overridden with\n   * [method].\n   *\n   * The Future is completed when the response is available.\n   *\n   * The [withCredentials] parameter specified that credentials such as a cookie\n   * (already) set in the header or\n   * [authorization headers](http://tools.ietf.org/html/rfc1945#section-10.2)\n   * should be specified for the request. Details to keep in mind when using\n   * credentials:\n   *\n   * * Using credentials is only useful for cross-origin requests.\n   * * The `Access-Control-Allow-Origin` header of `url` cannot contain a wildcard (*).\n   * * The `Access-Control-Allow-Credentials` header of `url` must be set to true.\n   * * If `Access-Control-Expose-Headers` has not been set to true, only a subset of all the response headers will be returned when calling [getAllRequestHeaders].\n   *\n   * Note that requests for file:// URIs are only supported by Chrome extensions\n   * with appropriate permissions in their manifest. Requests to file:// URIs\n   * will also never fail- the Future will always complete successfully, even\n   * when the file cannot be found.\n   *\n   * See also: [authorization headers](http://en.wikipedia.org/wiki/Basic_access_authentication).\n   */\n  static Future<HttpRequest> request(String url,\n      {String method, bool withCredentials, String responseType, sendData,\n      void onProgress(ProgressEvent e)}) {\n    var completer = new Completer<HttpRequest>();\n\n    var xhr = new HttpRequest();\n    if (method == null) {\n      method = 'GET';\n    }\n    xhr.open(method, url, async: true);\n\n    if (withCredentials != null) {\n      xhr.withCredentials = withCredentials;\n    }\n\n    if (responseType != null) {\n      xhr.responseType = responseType;\n    }\n\n    if (onProgress != null) {\n      xhr.onProgress.listen(onProgress);\n    }\n\n    xhr.onLoad.listen((e) {\n      // Note: file:// URIs have status of 0.\n      if ((xhr.status >= 200 && xhr.status < 300) ||\n          xhr.status == 0 || xhr.status == 304) {\n        completer.complete(xhr);\n      } else {\n        completer.completeError(e);\n      }\n    });\n\n    xhr.onError.listen((e) {\n      completer.completeError(e);\n    });\n\n    if (sendData != null) {\n      xhr.send(sendData);\n    } else {\n      xhr.send();\n    }\n\n    return completer.future;\n  }\n\n  /**\n   * Checks to see if the Progress event is supported on the current platform.\n   */\n  static bool get supportsProgressEvent {\n    var xhr = new HttpRequest();\n    return JS('bool', '(\"onprogress\" in #)', xhr);\n  }\n\n  /**\n   * Checks to see if the current platform supports making cross origin\n   * requests.\n   *\n   * Note that even if cross origin requests are supported, they still may fail\n   * if the destination server does not support CORS requests.\n   */\n  static bool get supportsCrossOrigin {\n    var xhr = new HttpRequest();\n    return JS('bool', '(\"withCredentials\" in #)', xhr);\n  }\n\n  /**\n   * Checks to see if the LoadEnd event is supported on the current platform.\n   */\n  static bool get supportsLoadEndEvent {\n    var xhr = new HttpRequest();\n    return JS('bool', '(\"onloadend\" in #)', xhr);\n  }\n\n\n  @DomName('XMLHttpRequest.abortEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> abortEvent = const EventStreamProvider<ProgressEvent>('abort');\n\n  @DomName('XMLHttpRequest.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> errorEvent = const EventStreamProvider<ProgressEvent>('error');\n\n  @DomName('XMLHttpRequest.loadEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> loadEvent = const EventStreamProvider<ProgressEvent>('load');\n\n  @DomName('XMLHttpRequest.loadendEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> loadEndEvent = const EventStreamProvider<ProgressEvent>('loadend');\n\n  @DomName('XMLHttpRequest.loadstartEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> loadStartEvent = const EventStreamProvider<ProgressEvent>('loadstart');\n\n  @DomName('XMLHttpRequest.progressEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> progressEvent = const EventStreamProvider<ProgressEvent>('progress');\n\n  @DomName('XMLHttpRequest.readystatechangeEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> readyStateChangeEvent = const EventStreamProvider<ProgressEvent>('readystatechange');\n\n  /**\n   * General constructor for any type of request (GET, POST, etc).\n   *\n   * This call is used in conjunction with [open]:\n   *\n   *     var request = new HttpRequest();\n   *     request.open('GET', 'http://dartlang.org')\n   *     request.on.load.add((event) => print('Request complete'));\n   *\n   * is the (more verbose) equivalent of\n   *\n   *     var request = new HttpRequest.get('http://dartlang.org',\n   *         (event) => print('Request complete'));\n   */\n  @DomName('XMLHttpRequest.XMLHttpRequest')\n  @DocsEditable\n  factory HttpRequest() {\n    return HttpRequest._create_1();\n  }\n  static HttpRequest _create_1() => JS('HttpRequest', 'new XMLHttpRequest()');\n\n  static const int DONE = 4;\n\n  static const int HEADERS_RECEIVED = 2;\n\n  static const int LOADING = 3;\n\n  static const int OPENED = 1;\n\n  static const int UNSENT = 0;\n\n  /**\n   * Indicator of the current state of the request:\n   *\n   * <table>\n   *   <tr>\n   *     <td>Value</td>\n   *     <td>State</td>\n   *     <td>Meaning</td>\n   *   </tr>\n   *   <tr>\n   *     <td>0</td>\n   *     <td>unsent</td>\n   *     <td><code>open()</code> has not yet been called</td>\n   *   </tr>\n   *   <tr>\n   *     <td>1</td>\n   *     <td>opened</td>\n   *     <td><code>send()</code> has not yet been called</td>\n   *   </tr>\n   *   <tr>\n   *     <td>2</td>\n   *     <td>headers received</td>\n   *     <td><code>sent()</code> has been called; response headers and <code>status</code> are available</td>\n   *   </tr>\n   *   <tr>\n   *     <td>3</td> <td>loading</td> <td><code>responseText</code> holds some data</td>\n   *   </tr>\n   *   <tr>\n   *     <td>4</td> <td>done</td> <td>request is complete</td>\n   *   </tr>\n   * </table>\n   */\n  @DomName('XMLHttpRequest.readyState')\n  @DocsEditable\n  final int readyState;\n\n  /**\n   * The data received as a reponse from the request.\n   *\n   * The data could be in the\n   * form of a [String], [ArrayBuffer], [Document], [Blob], or json (also a\n   * [String]). `null` indicates request failure.\n   */\n  @DomName('XMLHttpRequest.response')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Creates('ByteBuffer|Blob|Document|=Object|=List|String|num')\n  final Object response;\n\n  /**\n   * The response in string form or `null on failure.\n   */\n  @DomName('XMLHttpRequest.responseText')\n  @DocsEditable\n  final String responseText;\n\n  /**\n   * [String] telling the server the desired response format.\n   *\n   * Default is `String`.\n   * Other options are one of 'arraybuffer', 'blob', 'document', 'json',\n   * 'text'. Some newer browsers will throw NS_ERROR_DOM_INVALID_ACCESS_ERR if\n   * `responseType` is set while performing a synchronous request.\n   *\n   * See also: [MDN responseType](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType)\n   */\n  @DomName('XMLHttpRequest.responseType')\n  @DocsEditable\n  String responseType;\n\n  @JSName('responseXML')\n  /**\n   * The request response, or null on failure.\n   *\n   * The response is processed as\n   * `text/xml` stream, unless responseType = 'document' and the request is\n   * synchronous.\n   */\n  @DomName('XMLHttpRequest.responseXML')\n  @DocsEditable\n  final Document responseXml;\n\n  /**\n   * The http result code from the request (200, 404, etc).\n   * See also: [Http Status Codes](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes)\n   */\n  @DomName('XMLHttpRequest.status')\n  @DocsEditable\n  final int status;\n\n  /**\n   * The request response string (such as \\\"200 OK\\\").\n   * See also: [Http Status Codes](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes)\n   */\n  @DomName('XMLHttpRequest.statusText')\n  @DocsEditable\n  final String statusText;\n\n  /**\n   * [EventTarget] that can hold listeners to track the progress of the request.\n   * The events fired will be members of [HttpRequestUploadEvents].\n   */\n  @DomName('XMLHttpRequest.upload')\n  @DocsEditable\n  final HttpRequestUpload upload;\n\n  /**\n   * True if cross-site requests should use credentials such as cookies\n   * or authorization headers; false otherwise.\n   *\n   * This value is ignored for same-site requests.\n   */\n  @DomName('XMLHttpRequest.withCredentials')\n  @DocsEditable\n  bool withCredentials;\n\n  /**\n   * Stop the current request.\n   *\n   * The request can only be stopped if readyState is `HEADERS_RECIEVED` or\n   * `LOADING`. If this method is not in the process of being sent, the method\n   * has no effect.\n   */\n  @DomName('XMLHttpRequest.abort')\n  @DocsEditable\n  void abort() native;\n\n  @JSName('addEventListener')\n  @DomName('XMLHttpRequest.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('XMLHttpRequest.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  /**\n   * Retrieve all the response headers from a request.\n   *\n   * `null` if no headers have been received. For multipart requests,\n   * `getAllResponseHeaders` will return the response headers for the current\n   * part of the request.\n   *\n   * See also [HTTP response headers](http://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Responses)\n   * for a list of common response headers.\n   */\n  @DomName('XMLHttpRequest.getAllResponseHeaders')\n  @DocsEditable\n  String getAllResponseHeaders() native;\n\n  /**\n   * Return the response header named `header`, or `null` if not found.\n   *\n   * See also [HTTP response headers](http://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Responses)\n   * for a list of common response headers.\n   */\n  @DomName('XMLHttpRequest.getResponseHeader')\n  @DocsEditable\n  String getResponseHeader(String header) native;\n\n  /**\n   * Specify the desired `url`, and `method` to use in making the request.\n   *\n   * By default the request is done asyncronously, with no user or password\n   * authentication information. If `async` is false, the request will be send\n   * synchronously.\n   *\n   * Calling `open` again on a currently active request is equivalent to\n   * calling `abort`.\n   */\n  @DomName('XMLHttpRequest.open')\n  @DocsEditable\n  void open(String method, String url, {bool async, String user, String password}) native;\n\n  /**\n   * Specify a particular MIME type (such as `text/xml`) desired for the\n   * response.\n   *\n   * This value must be set before the request has been sent. See also the list\n   * of [common MIME types](http://en.wikipedia.org/wiki/Internet_media_type#List_of_common_media_types)\n   */\n  @DomName('XMLHttpRequest.overrideMimeType')\n  @DocsEditable\n  void overrideMimeType(String override) native;\n\n  @JSName('removeEventListener')\n  @DomName('XMLHttpRequest.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  /**\n   * Send the request with any given `data`.\n   *\n   * See also:\n   *\n   *   * [send](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#send%28%29)\n   * from MDN.\n   */\n  @DomName('XMLHttpRequest.send')\n  @DocsEditable\n  void send([data]) native;\n\n  @DomName('XMLHttpRequest.setRequestHeader')\n  @DocsEditable\n  void setRequestHeader(String header, String value) native;\n\n  /**\n   * Event listeners to be notified when request has been aborted,\n   * generally due to calling `httpRequest.abort()`.\n   */\n  @DomName('XMLHttpRequest.onabort')\n  @DocsEditable\n  Stream<ProgressEvent> get onAbort => abortEvent.forTarget(this);\n\n  /**\n   * Event listeners to be notified when a request has failed, such as when a\n   * cross-domain error occurred or the file wasn't found on the server.\n   */\n  @DomName('XMLHttpRequest.onerror')\n  @DocsEditable\n  Stream<ProgressEvent> get onError => errorEvent.forTarget(this);\n\n  /**\n   * Event listeners to be notified once the request has completed\n   * *successfully*.\n   */\n  @DomName('XMLHttpRequest.onload')\n  @DocsEditable\n  Stream<ProgressEvent> get onLoad => loadEvent.forTarget(this);\n\n  /**\n   * Event listeners to be notified once the request has completed (on\n   * either success or failure).\n   */\n  @DomName('XMLHttpRequest.onloadend')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  Stream<ProgressEvent> get onLoadEnd => loadEndEvent.forTarget(this);\n\n  /**\n   * Event listeners to be notified when the request starts, once\n   * `httpRequest.send()` has been called.\n   */\n  @DomName('XMLHttpRequest.onloadstart')\n  @DocsEditable\n  Stream<ProgressEvent> get onLoadStart => loadStartEvent.forTarget(this);\n\n  /**\n   * Event listeners to be notified when data for the request\n   * is being sent or loaded.\n   *\n   * Progress events are fired every 50ms or for every byte transmitted,\n   * whichever is less frequent.\n   */\n  @DomName('XMLHttpRequest.onprogress')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  Stream<ProgressEvent> get onProgress => progressEvent.forTarget(this);\n\n  /**\n   * Event listeners to be notified every time the [HttpRequest]\n   * object's `readyState` changes values.\n   */\n  @DomName('XMLHttpRequest.onreadystatechange')\n  @DocsEditable\n  Stream<ProgressEvent> get onReadyStateChange => readyStateChangeEvent.forTarget(this);\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('XMLHttpRequestException')\nclass HttpRequestException native \"XMLHttpRequestException\" {\n\n  static const int ABORT_ERR = 102;\n\n  static const int NETWORK_ERR = 101;\n\n  @DomName('XMLHttpRequestException.code')\n  @DocsEditable\n  final int code;\n\n  @DomName('XMLHttpRequestException.message')\n  @DocsEditable\n  final String message;\n\n  @DomName('XMLHttpRequestException.name')\n  @DocsEditable\n  final String name;\n\n  @DomName('XMLHttpRequestException.toString')\n  @DocsEditable\n  String toString() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('XMLHttpRequestProgressEvent')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental\nclass HttpRequestProgressEvent extends ProgressEvent native \"XMLHttpRequestProgressEvent\" {\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Device.isEventTypeSupported('XMLHttpRequestProgressEvent');\n\n  @DomName('XMLHttpRequestProgressEvent.position')\n  @DocsEditable\n  final int position;\n\n  @DomName('XMLHttpRequestProgressEvent.totalSize')\n  @DocsEditable\n  final int totalSize;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('XMLHttpRequestUpload')\nclass HttpRequestUpload extends EventTarget native \"XMLHttpRequestUpload\" {\n\n  @DomName('XMLHttpRequestUpload.abortEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> abortEvent = const EventStreamProvider<ProgressEvent>('abort');\n\n  @DomName('XMLHttpRequestUpload.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> errorEvent = const EventStreamProvider<ProgressEvent>('error');\n\n  @DomName('XMLHttpRequestUpload.loadEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> loadEvent = const EventStreamProvider<ProgressEvent>('load');\n\n  @DomName('XMLHttpRequestUpload.loadendEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> loadEndEvent = const EventStreamProvider<ProgressEvent>('loadend');\n\n  @DomName('XMLHttpRequestUpload.loadstartEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> loadStartEvent = const EventStreamProvider<ProgressEvent>('loadstart');\n\n  @DomName('XMLHttpRequestUpload.progressEvent')\n  @DocsEditable\n  static const EventStreamProvider<ProgressEvent> progressEvent = const EventStreamProvider<ProgressEvent>('progress');\n\n  @JSName('addEventListener')\n  @DomName('XMLHttpRequestUpload.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('XMLHttpRequestUpload.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @JSName('removeEventListener')\n  @DomName('XMLHttpRequestUpload.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('XMLHttpRequestUpload.onabort')\n  @DocsEditable\n  Stream<ProgressEvent> get onAbort => abortEvent.forTarget(this);\n\n  @DomName('XMLHttpRequestUpload.onerror')\n  @DocsEditable\n  Stream<ProgressEvent> get onError => errorEvent.forTarget(this);\n\n  @DomName('XMLHttpRequestUpload.onload')\n  @DocsEditable\n  Stream<ProgressEvent> get onLoad => loadEvent.forTarget(this);\n\n  @DomName('XMLHttpRequestUpload.onloadend')\n  @DocsEditable\n  Stream<ProgressEvent> get onLoadEnd => loadEndEvent.forTarget(this);\n\n  @DomName('XMLHttpRequestUpload.onloadstart')\n  @DocsEditable\n  Stream<ProgressEvent> get onLoadStart => loadStartEvent.forTarget(this);\n\n  @DomName('XMLHttpRequestUpload.onprogress')\n  @DocsEditable\n  Stream<ProgressEvent> get onProgress => progressEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLIFrameElement')\nclass IFrameElement extends Element native \"HTMLIFrameElement\" {\n\n  @DomName('HTMLIFrameElement.HTMLIFrameElement')\n  @DocsEditable\n  factory IFrameElement() => document.$dom_createElement(\"iframe\");\n\n  WindowBase get contentWindow => _convertNativeToDart_Window(this._get_contentWindow);\n  @JSName('contentWindow')\n  @DomName('HTMLIFrameElement.contentWindow')\n  @DocsEditable\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_contentWindow;\n\n  @DomName('HTMLIFrameElement.height')\n  @DocsEditable\n  String height;\n\n  @DomName('HTMLIFrameElement.name')\n  @DocsEditable\n  String name;\n\n  @DomName('HTMLIFrameElement.sandbox')\n  @DocsEditable\n  String sandbox;\n\n  @DomName('HTMLIFrameElement.seamless')\n  @DocsEditable\n  bool seamless;\n\n  @DomName('HTMLIFrameElement.src')\n  @DocsEditable\n  String src;\n\n  @DomName('HTMLIFrameElement.srcdoc')\n  @DocsEditable\n  String srcdoc;\n\n  @DomName('HTMLIFrameElement.width')\n  @DocsEditable\n  String width;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n@DomName('ImageData')\n\nclass ImageData native \"ImageData\" {\n\n\n  @DomName('ImageData.data')\n  @DocsEditable\n  final List<int> data;\n\n  @DomName('ImageData.height')\n  @DocsEditable\n  final int height;\n\n  @DomName('ImageData.width')\n  @DocsEditable\n  final int width;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('HTMLImageElement')\nclass ImageElement extends Element implements CanvasImageSource native \"HTMLImageElement\" {\n\n  @DomName('HTMLImageElement.HTMLImageElement')\n  @DocsEditable\n  factory ImageElement({String src, int width, int height}) {\n    var e = document.$dom_createElement(\"img\");\n    if (src != null) e.src = src;\n    if (width != null) e.width = width;\n    if (height != null) e.height = height;\n    return e;\n  }\n\n  @DomName('HTMLImageElement.alt')\n  @DocsEditable\n  String alt;\n\n  @DomName('HTMLImageElement.border')\n  @DocsEditable\n  String border;\n\n  @DomName('HTMLImageElement.complete')\n  @DocsEditable\n  final bool complete;\n\n  @DomName('HTMLImageElement.crossOrigin')\n  @DocsEditable\n  String crossOrigin;\n\n  @DomName('HTMLImageElement.height')\n  @DocsEditable\n  int height;\n\n  @DomName('HTMLImageElement.isMap')\n  @DocsEditable\n  bool isMap;\n\n  @DomName('HTMLImageElement.lowsrc')\n  @DocsEditable\n  String lowsrc;\n\n  @DomName('HTMLImageElement.naturalHeight')\n  @DocsEditable\n  final int naturalHeight;\n\n  @DomName('HTMLImageElement.naturalWidth')\n  @DocsEditable\n  final int naturalWidth;\n\n  @DomName('HTMLImageElement.src')\n  @DocsEditable\n  String src;\n\n  @DomName('HTMLImageElement.useMap')\n  @DocsEditable\n  String useMap;\n\n  @DomName('HTMLImageElement.width')\n  @DocsEditable\n  int width;\n\n  @DomName('HTMLImageElement.x')\n  @DocsEditable\n  final int x;\n\n  @DomName('HTMLImageElement.y')\n  @DocsEditable\n  final int y;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('HTMLInputElement')\nclass InputElement extends Element implements\n    HiddenInputElement,\n    SearchInputElement,\n    TextInputElement,\n    UrlInputElement,\n    TelephoneInputElement,\n    EmailInputElement,\n    PasswordInputElement,\n    DateInputElement,\n    MonthInputElement,\n    WeekInputElement,\n    TimeInputElement,\n    LocalDateTimeInputElement,\n    NumberInputElement,\n    RangeInputElement,\n    CheckboxInputElement,\n    RadioButtonInputElement,\n    FileUploadInputElement,\n    SubmitButtonInputElement,\n    ImageButtonInputElement,\n    ResetButtonInputElement,\n    ButtonInputElement\n     native \"HTMLInputElement\" {\n\n  factory InputElement({String type}) {\n    var e = document.$dom_createElement(\"input\");\n    if (type != null) {\n      try {\n        // IE throws an exception for unknown types.\n        e.type = type;\n      } catch(_) {}\n    }\n    return e;\n  }\n\n  @DomName('HTMLInputElement.webkitSpeechChangeEvent')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  static const EventStreamProvider<Event> speechChangeEvent = const EventStreamProvider<Event>('webkitSpeechChange');\n\n  @DomName('HTMLInputElement.accept')\n  @DocsEditable\n  String accept;\n\n  @DomName('HTMLInputElement.alt')\n  @DocsEditable\n  String alt;\n\n  @DomName('HTMLInputElement.autocomplete')\n  @DocsEditable\n  String autocomplete;\n\n  @DomName('HTMLInputElement.autofocus')\n  @DocsEditable\n  bool autofocus;\n\n  @DomName('HTMLInputElement.checked')\n  @DocsEditable\n  bool checked;\n\n  @DomName('HTMLInputElement.defaultChecked')\n  @DocsEditable\n  bool defaultChecked;\n\n  @DomName('HTMLInputElement.defaultValue')\n  @DocsEditable\n  String defaultValue;\n\n  @DomName('HTMLInputElement.dirName')\n  @DocsEditable\n  String dirName;\n\n  @DomName('HTMLInputElement.disabled')\n  @DocsEditable\n  bool disabled;\n\n  @DomName('HTMLInputElement.files')\n  @DocsEditable\n  @Returns('FileList')\n  @Creates('FileList')\n  List<File> files;\n\n  @DomName('HTMLInputElement.form')\n  @DocsEditable\n  final FormElement form;\n\n  @DomName('HTMLInputElement.formAction')\n  @DocsEditable\n  String formAction;\n\n  @DomName('HTMLInputElement.formEnctype')\n  @DocsEditable\n  String formEnctype;\n\n  @DomName('HTMLInputElement.formMethod')\n  @DocsEditable\n  String formMethod;\n\n  @DomName('HTMLInputElement.formNoValidate')\n  @DocsEditable\n  bool formNoValidate;\n\n  @DomName('HTMLInputElement.formTarget')\n  @DocsEditable\n  String formTarget;\n\n  @DomName('HTMLInputElement.height')\n  @DocsEditable\n  int height;\n\n  @DomName('HTMLInputElement.incremental')\n  @DocsEditable\n  bool incremental;\n\n  @DomName('HTMLInputElement.indeterminate')\n  @DocsEditable\n  bool indeterminate;\n\n  @DomName('HTMLInputElement.labels')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLInputElement.list')\n  @DocsEditable\n  final Element list;\n\n  @DomName('HTMLInputElement.max')\n  @DocsEditable\n  String max;\n\n  @DomName('HTMLInputElement.maxLength')\n  @DocsEditable\n  int maxLength;\n\n  @DomName('HTMLInputElement.min')\n  @DocsEditable\n  String min;\n\n  @DomName('HTMLInputElement.multiple')\n  @DocsEditable\n  bool multiple;\n\n  @DomName('HTMLInputElement.name')\n  @DocsEditable\n  String name;\n\n  @DomName('HTMLInputElement.pattern')\n  @DocsEditable\n  String pattern;\n\n  @DomName('HTMLInputElement.placeholder')\n  @DocsEditable\n  String placeholder;\n\n  @DomName('HTMLInputElement.readOnly')\n  @DocsEditable\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  @DocsEditable\n  bool required;\n\n  @DomName('HTMLInputElement.selectionDirection')\n  @DocsEditable\n  String selectionDirection;\n\n  @DomName('HTMLInputElement.selectionEnd')\n  @DocsEditable\n  int selectionEnd;\n\n  @DomName('HTMLInputElement.selectionStart')\n  @DocsEditable\n  int selectionStart;\n\n  @DomName('HTMLInputElement.size')\n  @DocsEditable\n  int size;\n\n  @DomName('HTMLInputElement.src')\n  @DocsEditable\n  String src;\n\n  @DomName('HTMLInputElement.step')\n  @DocsEditable\n  String step;\n\n  @DomName('HTMLInputElement.type')\n  @DocsEditable\n  String type;\n\n  @DomName('HTMLInputElement.useMap')\n  @DocsEditable\n  String useMap;\n\n  @DomName('HTMLInputElement.validationMessage')\n  @DocsEditable\n  final String validationMessage;\n\n  @DomName('HTMLInputElement.validity')\n  @DocsEditable\n  final ValidityState validity;\n\n  @DomName('HTMLInputElement.value')\n  @DocsEditable\n  String value;\n\n  DateTime get valueAsDate => _convertNativeToDart_DateTime(this._get_valueAsDate);\n  @JSName('valueAsDate')\n  @DomName('HTMLInputElement.valueAsDate')\n  @DocsEditable\n  final dynamic _get_valueAsDate;\n\n  void set valueAsDate(DateTime value) {\n    this._set_valueAsDate = _convertDartToNative_DateTime(value);\n  }\n  void set _set_valueAsDate(/*dynamic*/ value) {\n    JS(\"void\", \"#.valueAsDate = #\", this, value);\n  }\n\n  @DomName('HTMLInputElement.valueAsNumber')\n  @DocsEditable\n  num valueAsNumber;\n\n  @JSName('webkitEntries')\n  @DomName('HTMLInputElement.webkitEntries')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  @Returns('_EntryArray')\n  @Creates('_EntryArray')\n  final List<Entry> entries;\n\n  @JSName('webkitGrammar')\n  @DomName('HTMLInputElement.webkitGrammar')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  bool grammar;\n\n  @JSName('webkitSpeech')\n  @DomName('HTMLInputElement.webkitSpeech')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  bool speech;\n\n  @JSName('webkitdirectory')\n  @DomName('HTMLInputElement.webkitdirectory')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  bool directory;\n\n  @DomName('HTMLInputElement.width')\n  @DocsEditable\n  int width;\n\n  @DomName('HTMLInputElement.willValidate')\n  @DocsEditable\n  final bool willValidate;\n\n  @DomName('HTMLInputElement.checkValidity')\n  @DocsEditable\n  bool checkValidity() native;\n\n  @DomName('HTMLInputElement.select')\n  @DocsEditable\n  void select() native;\n\n  @DomName('HTMLInputElement.setCustomValidity')\n  @DocsEditable\n  void setCustomValidity(String error) native;\n\n  @DomName('HTMLInputElement.setRangeText')\n  @DocsEditable\n  void setRangeText(String replacement, {int start, int end, String selectionMode}) native;\n\n  @DomName('HTMLInputElement.setSelectionRange')\n  @DocsEditable\n  void setSelectionRange(int start, int end, [String direction]) native;\n\n  @DomName('HTMLInputElement.stepDown')\n  @DocsEditable\n  void stepDown([int n]) native;\n\n  @DomName('HTMLInputElement.stepUp')\n  @DocsEditable\n  void stepUp([int n]) native;\n\n  @DomName('HTMLInputElement.onwebkitSpeechChange')\n  @DocsEditable\n  Stream<Event> get onSpeechChange => speechChangeEvent.forTarget(this);\n\n}\n\n\n// Interfaces representing the InputElement APIs which are supported\n// for the various types of InputElement.\n// From http://dev.w3.org/html5/spec/the-input-element.html#the-input-element.\n\n/**\n * Exposes the functionality common between all InputElement types.\n */\nabstract class InputElementBase implements Element {\n  @DomName('HTMLInputElement.autofocus')\n  bool autofocus;\n\n  @DomName('HTMLInputElement.disabled')\n  bool disabled;\n\n  @DomName('HTMLInputElement.incremental')\n  bool incremental;\n\n  @DomName('HTMLInputElement.indeterminate')\n  bool indeterminate;\n\n  @DomName('HTMLInputElement.labels')\n  List<Node> get labels;\n\n  @DomName('HTMLInputElement.name')\n  String name;\n\n  @DomName('HTMLInputElement.validationMessage')\n  String get validationMessage;\n\n  @DomName('HTMLInputElement.validity')\n  ValidityState get validity;\n\n  @DomName('HTMLInputElement.value')\n  String value;\n\n  @DomName('HTMLInputElement.willValidate')\n  bool get willValidate;\n\n  @DomName('HTMLInputElement.checkValidity')\n  bool checkValidity();\n\n  @DomName('HTMLInputElement.setCustomValidity')\n  void setCustomValidity(String error);\n}\n\n/**\n * Hidden input which is not intended to be seen or edited by the user.\n */\nabstract class HiddenInputElement implements Element {\n  factory HiddenInputElement() => new InputElement(type: 'hidden');\n}\n\n\n/**\n * Base interface for all inputs which involve text editing.\n */\nabstract class TextInputElementBase implements InputElementBase {\n  @DomName('HTMLInputElement.autocomplete')\n  String autocomplete;\n\n  @DomName('HTMLInputElement.maxLength')\n  int maxLength;\n\n  @DomName('HTMLInputElement.pattern')\n  String pattern;\n\n  @DomName('HTMLInputElement.placeholder')\n  String placeholder;\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  @DomName('HTMLInputElement.size')\n  int size;\n\n  @DomName('HTMLInputElement.select')\n  void select();\n\n  @DomName('HTMLInputElement.selectionDirection')\n  String selectionDirection;\n\n  @DomName('HTMLInputElement.selectionEnd')\n  int selectionEnd;\n\n  @DomName('HTMLInputElement.selectionStart')\n  int selectionStart;\n\n  @DomName('HTMLInputElement.setSelectionRange')\n  void setSelectionRange(int start, int end, [String direction]);\n}\n\n/**\n * Similar to [TextInputElement], but on platforms where search is styled\n * differently this will get the search style.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nabstract class SearchInputElement implements TextInputElementBase {\n  factory SearchInputElement() => new InputElement(type: 'search');\n\n  @DomName('HTMLInputElement.dirName')\n  String dirName;\n\n  @DomName('HTMLInputElement.list')\n  Element get list;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'search')).type == 'search';\n  }\n}\n\n/**\n * A basic text input editor control.\n */\nabstract class TextInputElement implements TextInputElementBase {\n  factory TextInputElement() => new InputElement(type: 'text');\n\n  @DomName('HTMLInputElement.dirName')\n  String dirName;\n\n  @DomName('HTMLInputElement.list')\n  Element get list;\n}\n\n/**\n * A control for editing an absolute URL.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nabstract class UrlInputElement implements TextInputElementBase {\n  factory UrlInputElement() => new InputElement(type: 'url');\n\n  @DomName('HTMLInputElement.list')\n  Element get list;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'url')).type == 'url';\n  }\n}\n\n/**\n * Represents a control for editing a telephone number.\n *\n * This provides a single line of text with minimal formatting help since\n * there is a wide variety of telephone numbers.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nabstract class TelephoneInputElement implements TextInputElementBase {\n  factory TelephoneInputElement() => new InputElement(type: 'tel');\n\n  @DomName('HTMLInputElement.list')\n  Element get list;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'tel')).type == 'tel';\n  }\n}\n\n/**\n * An e-mail address or list of e-mail addresses.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nabstract class EmailInputElement implements TextInputElementBase {\n  factory EmailInputElement() => new InputElement(type: 'email');\n\n  @DomName('HTMLInputElement.autocomplete')\n  String autocomplete;\n\n  @DomName('HTMLInputElement.autofocus')\n  bool autofocus;\n\n  @DomName('HTMLInputElement.list')\n  Element get list;\n\n  @DomName('HTMLInputElement.maxLength')\n  int maxLength;\n\n  @DomName('HTMLInputElement.multiple')\n  bool multiple;\n\n  @DomName('HTMLInputElement.pattern')\n  String pattern;\n\n  @DomName('HTMLInputElement.placeholder')\n  String placeholder;\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  @DomName('HTMLInputElement.size')\n  int size;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'email')).type == 'email';\n  }\n}\n\n/**\n * Text with no line breaks (sensitive information).\n */\nabstract class PasswordInputElement implements TextInputElementBase {\n  factory PasswordInputElement() => new InputElement(type: 'password');\n}\n\n/**\n * Base interface for all input element types which involve ranges.\n */\nabstract class RangeInputElementBase implements InputElementBase {\n\n  @DomName('HTMLInputElement.list')\n  Element get list;\n\n  @DomName('HTMLInputElement.max')\n  String max;\n\n  @DomName('HTMLInputElement.min')\n  String min;\n\n  @DomName('HTMLInputElement.step')\n  String step;\n\n  @DomName('HTMLInputElement.valueAsNumber')\n  num valueAsNumber;\n\n  @DomName('HTMLInputElement.stepDown')\n  void stepDown([int n]);\n\n  @DomName('HTMLInputElement.stepUp')\n  void stepUp([int n]);\n}\n\n/**\n * A date (year, month, day) with no time zone.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental\nabstract class DateInputElement implements RangeInputElementBase {\n  factory DateInputElement() => new InputElement(type: 'date');\n\n  @DomName('HTMLInputElement.valueAsDate')\n  DateTime valueAsDate;\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'date')).type == 'date';\n  }\n}\n\n/**\n * A date consisting of a year and a month with no time zone.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental\nabstract class MonthInputElement implements RangeInputElementBase {\n  factory MonthInputElement() => new InputElement(type: 'month');\n\n  @DomName('HTMLInputElement.valueAsDate')\n  DateTime valueAsDate;\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'month')).type == 'month';\n  }\n}\n\n/**\n * A date consisting of a week-year number and a week number with no time zone.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental\nabstract class WeekInputElement implements RangeInputElementBase {\n  factory WeekInputElement() => new InputElement(type: 'week');\n\n  @DomName('HTMLInputElement.valueAsDate')\n  DateTime valueAsDate;\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'week')).type == 'week';\n  }\n}\n\n/**\n * A time (hour, minute, seconds, fractional seconds) with no time zone.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental\nabstract class TimeInputElement implements RangeInputElementBase {\n  factory TimeInputElement() => new InputElement(type: 'time');\n\n  @DomName('HTMLInputElement.valueAsDate')\n  DateTime valueAsDate;\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'time')).type == 'time';\n  }\n}\n\n/**\n * A date and time (year, month, day, hour, minute, second, fraction of a\n * second) with no time zone.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental\nabstract class LocalDateTimeInputElement implements RangeInputElementBase {\n  factory LocalDateTimeInputElement() =>\n      new InputElement(type: 'datetime-local');\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'datetime-local')).type == 'datetime-local';\n  }\n}\n\n/**\n * A numeric editor control.\n */\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.IE)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental\nabstract class NumberInputElement implements RangeInputElementBase {\n  factory NumberInputElement() => new InputElement(type: 'number');\n\n  @DomName('HTMLInputElement.placeholder')\n  String placeholder;\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'number')).type == 'number';\n  }\n}\n\n/**\n * Similar to [NumberInputElement] but the browser may provide more optimal\n * styling (such as a slider control).\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@Experimental\nabstract class RangeInputElement implements RangeInputElementBase {\n  factory RangeInputElement() => new InputElement(type: 'range');\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'range')).type == 'range';\n  }\n}\n\n/**\n * A boolean editor control.\n *\n * Note that if [indeterminate] is set then this control is in a third\n * indeterminate state.\n */\nabstract class CheckboxInputElement implements InputElementBase {\n  factory CheckboxInputElement() => new InputElement(type: 'checkbox');\n\n  @DomName('HTMLInputElement.checked')\n  bool checked;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n}\n\n\n/**\n * A control that when used with other [ReadioButtonInputElement] controls\n * forms a radio button group in which only one control can be checked at a\n * time.\n *\n * Radio buttons are considered to be in the same radio button group if:\n *\n * * They are all of type 'radio'.\n * * They all have either the same [FormElement] owner, or no owner.\n * * Their name attributes contain the same name.\n */\nabstract class RadioButtonInputElement implements InputElementBase {\n  factory RadioButtonInputElement() => new InputElement(type: 'radio');\n\n  @DomName('HTMLInputElement.checked')\n  bool checked;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n}\n\n/**\n * A control for picking files from the user's computer.\n */\nabstract class FileUploadInputElement implements InputElementBase {\n  factory FileUploadInputElement() => new InputElement(type: 'file');\n\n  @DomName('HTMLInputElement.accept')\n  String accept;\n\n  @DomName('HTMLInputElement.multiple')\n  bool multiple;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  @DomName('HTMLInputElement.files')\n  List<File> files;\n}\n\n/**\n * A button, which when clicked, submits the form.\n */\nabstract class SubmitButtonInputElement implements InputElementBase {\n  factory SubmitButtonInputElement() => new InputElement(type: 'submit');\n\n  @DomName('HTMLInputElement.formAction')\n  String formAction;\n\n  @DomName('HTMLInputElement.formEnctype')\n  String formEnctype;\n\n  @DomName('HTMLInputElement.formMethod')\n  String formMethod;\n\n  @DomName('HTMLInputElement.formNoValidate')\n  bool formNoValidate;\n\n  @DomName('HTMLInputElement.formTarget')\n  String formTarget;\n}\n\n/**\n * Either an image which the user can select a coordinate to or a form\n * submit button.\n */\nabstract class ImageButtonInputElement implements InputElementBase {\n  factory ImageButtonInputElement() => new InputElement(type: 'image');\n\n  @DomName('HTMLInputElement.alt')\n  String alt;\n\n  @DomName('HTMLInputElement.formAction')\n  String formAction;\n\n  @DomName('HTMLInputElement.formEnctype')\n  String formEnctype;\n\n  @DomName('HTMLInputElement.formMethod')\n  String formMethod;\n\n  @DomName('HTMLInputElement.formNoValidate')\n  bool formNoValidate;\n\n  @DomName('HTMLInputElement.formTarget')\n  String formTarget;\n\n  @DomName('HTMLInputElement.height')\n  int height;\n\n  @DomName('HTMLInputElement.src')\n  String src;\n\n  @DomName('HTMLInputElement.width')\n  int width;\n}\n\n/**\n * A button, which when clicked, resets the form.\n */\nabstract class ResetButtonInputElement implements InputElementBase {\n  factory ResetButtonInputElement() => new InputElement(type: 'reset');\n}\n\n/**\n * A button, with no default behavior.\n */\nabstract class ButtonInputElement implements InputElementBase {\n  factory ButtonInputElement() => new InputElement(type: 'button');\n}\n\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('KeyboardEvent')\nclass KeyboardEvent extends UIEvent native \"KeyboardEvent\" {\n\n  factory KeyboardEvent(String type,\n      {Window view, bool canBubble: true, bool cancelable: true,\n      String keyIdentifier: \"\", int keyLocation: 1, bool ctrlKey: false,\n      bool altKey: false, bool shiftKey: false, bool metaKey: false,\n      bool altGraphKey: false}) {\n    if (view == null) {\n      view = window;\n    }\n    final e = document.$dom_createEvent(\"KeyboardEvent\");\n    e.$dom_initKeyboardEvent(type, canBubble, cancelable, view, keyIdentifier,\n        keyLocation, ctrlKey, altKey, shiftKey, metaKey, altGraphKey);\n    return e;\n  }\n\n  @DomName('KeyboardEvent.initKeyboardEvent')\n  void $dom_initKeyboardEvent(String type, bool canBubble, bool cancelable,\n      Window view, String keyIdentifier, int keyLocation, bool ctrlKey,\n      bool altKey, bool shiftKey, bool metaKey, bool altGraphKey) {\n    if (JS('bool', 'typeof(#.initKeyEvent) == \"function\"', this)) {\n      // initKeyEvent is only in Firefox (instead of initKeyboardEvent). It has\n      // a slightly different signature, and allows you to specify keyCode and\n      // charCode as the last two arguments, but we just set them as the default\n      // since they can't be specified in other browsers.\n      JS('void', '#.initKeyEvent(#, #, #, #, #, #, #, #, 0, 0)', this,\n          type, canBubble, cancelable, view,\n          ctrlKey, altKey, shiftKey, metaKey);\n    } else {\n      // initKeyboardEvent is for all other browsers.\n      JS('void', '#.initKeyboardEvent(#, #, #, #, #, #, #, #, #, #, #)', this,\n          type, canBubble, cancelable, view, keyIdentifier, keyLocation,\n          ctrlKey, altKey, shiftKey, metaKey, altGraphKey);\n    }\n  }\n\n  @DomName('KeyboardEvent.keyCode')\n  int get keyCode => $dom_keyCode;\n\n  @DomName('KeyboardEvent.charCode')\n  int get charCode => $dom_charCode;\n\n  @DomName('KeyboardEvent.altGraphKey')\n  @DocsEditable\n  final bool altGraphKey;\n\n  @DomName('KeyboardEvent.altKey')\n  @DocsEditable\n  final bool altKey;\n\n  @DomName('KeyboardEvent.ctrlKey')\n  @DocsEditable\n  final bool ctrlKey;\n\n  @JSName('keyIdentifier')\n  @DomName('KeyboardEvent.keyIdentifier')\n  @DocsEditable\n  final String $dom_keyIdentifier;\n\n  @DomName('KeyboardEvent.keyLocation')\n  @DocsEditable\n  final int keyLocation;\n\n  @DomName('KeyboardEvent.metaKey')\n  @DocsEditable\n  final bool metaKey;\n\n  @DomName('KeyboardEvent.shiftKey')\n  @DocsEditable\n  final bool shiftKey;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLKeygenElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental\nclass KeygenElement extends Element native \"HTMLKeygenElement\" {\n\n  @DomName('HTMLKeygenElement.HTMLKeygenElement')\n  @DocsEditable\n  factory KeygenElement() => document.$dom_createElement(\"keygen\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('keygen') && (new Element.tag('keygen') is KeygenElement);\n\n  @DomName('HTMLKeygenElement.autofocus')\n  @DocsEditable\n  bool autofocus;\n\n  @DomName('HTMLKeygenElement.challenge')\n  @DocsEditable\n  String challenge;\n\n  @DomName('HTMLKeygenElement.disabled')\n  @DocsEditable\n  bool disabled;\n\n  @DomName('HTMLKeygenElement.form')\n  @DocsEditable\n  final FormElement form;\n\n  @DomName('HTMLKeygenElement.keytype')\n  @DocsEditable\n  String keytype;\n\n  @DomName('HTMLKeygenElement.labels')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLKeygenElement.name')\n  @DocsEditable\n  String name;\n\n  @DomName('HTMLKeygenElement.type')\n  @DocsEditable\n  final String type;\n\n  @DomName('HTMLKeygenElement.validationMessage')\n  @DocsEditable\n  final String validationMessage;\n\n  @DomName('HTMLKeygenElement.validity')\n  @DocsEditable\n  final ValidityState validity;\n\n  @DomName('HTMLKeygenElement.willValidate')\n  @DocsEditable\n  final bool willValidate;\n\n  @DomName('HTMLKeygenElement.checkValidity')\n  @DocsEditable\n  bool checkValidity() native;\n\n  @DomName('HTMLKeygenElement.setCustomValidity')\n  @DocsEditable\n  void setCustomValidity(String error) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLLIElement')\nclass LIElement extends Element native \"HTMLLIElement\" {\n\n  @DomName('HTMLLIElement.HTMLLIElement')\n  @DocsEditable\n  factory LIElement() => document.$dom_createElement(\"li\");\n\n  @DomName('HTMLLIElement.type')\n  @DocsEditable\n  String type;\n\n  @DomName('HTMLLIElement.value')\n  @DocsEditable\n  int value;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLLabelElement')\nclass LabelElement extends Element native \"HTMLLabelElement\" {\n\n  @DomName('HTMLLabelElement.HTMLLabelElement')\n  @DocsEditable\n  factory LabelElement() => document.$dom_createElement(\"label\");\n\n  @DomName('HTMLLabelElement.control')\n  @DocsEditable\n  final Element control;\n\n  @DomName('HTMLLabelElement.form')\n  @DocsEditable\n  final FormElement form;\n\n  @DomName('HTMLLabelElement.htmlFor')\n  @DocsEditable\n  String htmlFor;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLLegendElement')\nclass LegendElement extends Element native \"HTMLLegendElement\" {\n\n  @DomName('HTMLLegendElement.HTMLLegendElement')\n  @DocsEditable\n  factory LegendElement() => document.$dom_createElement(\"legend\");\n\n  @DomName('HTMLLegendElement.form')\n  @DocsEditable\n  final FormElement form;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLLinkElement')\nclass LinkElement extends Element native \"HTMLLinkElement\" {\n\n  @DomName('HTMLLinkElement.HTMLLinkElement')\n  @DocsEditable\n  factory LinkElement() => document.$dom_createElement(\"link\");\n\n  @DomName('HTMLLinkElement.disabled')\n  @DocsEditable\n  bool disabled;\n\n  @DomName('HTMLLinkElement.href')\n  @DocsEditable\n  String href;\n\n  @DomName('HTMLLinkElement.hreflang')\n  @DocsEditable\n  String hreflang;\n\n  @DomName('HTMLLinkElement.media')\n  @DocsEditable\n  String media;\n\n  @DomName('HTMLLinkElement.rel')\n  @DocsEditable\n  String rel;\n\n  @DomName('HTMLLinkElement.sheet')\n  @DocsEditable\n  final StyleSheet sheet;\n\n  @DomName('HTMLLinkElement.sizes')\n  @DocsEditable\n  DomSettableTokenList sizes;\n\n  @DomName('HTMLLinkElement.type')\n  @DocsEditable\n  String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('LocalMediaStream')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental\nclass LocalMediaStream extends MediaStream implements EventTarget native \"LocalMediaStream\" {\n\n  @DomName('LocalMediaStream.stop')\n  @DocsEditable\n  void stop() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Location')\nclass Location implements LocationBase native \"Location\" {\n\n  @DomName('Location.ancestorOrigins')\n  @DocsEditable\n  @Returns('DomStringList')\n  @Creates('DomStringList')\n  final List<String> ancestorOrigins;\n\n  @DomName('Location.hash')\n  @DocsEditable\n  String hash;\n\n  @DomName('Location.host')\n  @DocsEditable\n  String host;\n\n  @DomName('Location.hostname')\n  @DocsEditable\n  String hostname;\n\n  @DomName('Location.href')\n  @DocsEditable\n  String href;\n\n  @DomName('Location.origin')\n  @DocsEditable\n  final String origin;\n\n  @DomName('Location.pathname')\n  @DocsEditable\n  String pathname;\n\n  @DomName('Location.port')\n  @DocsEditable\n  String port;\n\n  @DomName('Location.protocol')\n  @DocsEditable\n  String protocol;\n\n  @DomName('Location.search')\n  @DocsEditable\n  String search;\n\n  @DomName('Location.assign')\n  @DocsEditable\n  void assign(String url) native;\n\n  @DomName('Location.reload')\n  @DocsEditable\n  void reload() native;\n\n  @DomName('Location.replace')\n  @DocsEditable\n  void replace(String url) native;\n\n  @DomName('Location.toString')\n  @DocsEditable\n  String toString() native;\n\n  @DomName('Location.valueOf')\n  @DocsEditable\n  Object valueOf() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLMapElement')\nclass MapElement extends Element native \"HTMLMapElement\" {\n\n  @DomName('HTMLMapElement.HTMLMapElement')\n  @DocsEditable\n  factory MapElement() => document.$dom_createElement(\"map\");\n\n  @DomName('HTMLMapElement.areas')\n  @DocsEditable\n  final HtmlCollection areas;\n\n  @DomName('HTMLMapElement.name')\n  @DocsEditable\n  String name;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MediaController')\nclass MediaController extends EventTarget native \"MediaController\" {\n\n  @DomName('MediaController.MediaController')\n  @DocsEditable\n  factory MediaController() {\n    return MediaController._create_1();\n  }\n  static MediaController _create_1() => JS('MediaController', 'new MediaController()');\n\n  @DomName('MediaController.buffered')\n  @DocsEditable\n  final TimeRanges buffered;\n\n  @DomName('MediaController.currentTime')\n  @DocsEditable\n  num currentTime;\n\n  @DomName('MediaController.defaultPlaybackRate')\n  @DocsEditable\n  num defaultPlaybackRate;\n\n  @DomName('MediaController.duration')\n  @DocsEditable\n  final num duration;\n\n  @DomName('MediaController.muted')\n  @DocsEditable\n  bool muted;\n\n  @DomName('MediaController.paused')\n  @DocsEditable\n  final bool paused;\n\n  @DomName('MediaController.playbackRate')\n  @DocsEditable\n  num playbackRate;\n\n  @DomName('MediaController.playbackState')\n  @DocsEditable\n  final String playbackState;\n\n  @DomName('MediaController.played')\n  @DocsEditable\n  final TimeRanges played;\n\n  @DomName('MediaController.seekable')\n  @DocsEditable\n  final TimeRanges seekable;\n\n  @DomName('MediaController.volume')\n  @DocsEditable\n  num volume;\n\n  @JSName('addEventListener')\n  @DomName('MediaController.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('MediaController.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @DomName('MediaController.pause')\n  @DocsEditable\n  void pause() native;\n\n  @DomName('MediaController.play')\n  @DocsEditable\n  void play() native;\n\n  @JSName('removeEventListener')\n  @DomName('MediaController.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('MediaController.unpause')\n  @DocsEditable\n  void unpause() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLMediaElement')\nclass MediaElement extends Element native \"HTMLMediaElement\" {\n\n  @DomName('HTMLMediaElement.canplayEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> canPlayEvent = const EventStreamProvider<Event>('canplay');\n\n  @DomName('HTMLMediaElement.canplaythroughEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> canPlayThroughEvent = const EventStreamProvider<Event>('canplaythrough');\n\n  @DomName('HTMLMediaElement.durationchangeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> durationChangeEvent = const EventStreamProvider<Event>('durationchange');\n\n  @DomName('HTMLMediaElement.emptiedEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> emptiedEvent = const EventStreamProvider<Event>('emptied');\n\n  @DomName('HTMLMediaElement.endedEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> endedEvent = const EventStreamProvider<Event>('ended');\n\n  @DomName('HTMLMediaElement.loadeddataEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> loadedDataEvent = const EventStreamProvider<Event>('loadeddata');\n\n  @DomName('HTMLMediaElement.loadedmetadataEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> loadedMetadataEvent = const EventStreamProvider<Event>('loadedmetadata');\n\n  @DomName('HTMLMediaElement.loadstartEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> loadStartEvent = const EventStreamProvider<Event>('loadstart');\n\n  @DomName('HTMLMediaElement.pauseEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> pauseEvent = const EventStreamProvider<Event>('pause');\n\n  @DomName('HTMLMediaElement.playEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> playEvent = const EventStreamProvider<Event>('play');\n\n  @DomName('HTMLMediaElement.playingEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> playingEvent = const EventStreamProvider<Event>('playing');\n\n  @DomName('HTMLMediaElement.progressEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> progressEvent = const EventStreamProvider<Event>('progress');\n\n  @DomName('HTMLMediaElement.ratechangeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> rateChangeEvent = const EventStreamProvider<Event>('ratechange');\n\n  @DomName('HTMLMediaElement.seekedEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> seekedEvent = const EventStreamProvider<Event>('seeked');\n\n  @DomName('HTMLMediaElement.seekingEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> seekingEvent = const EventStreamProvider<Event>('seeking');\n\n  @DomName('HTMLMediaElement.showEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> showEvent = const EventStreamProvider<Event>('show');\n\n  @DomName('HTMLMediaElement.stalledEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> stalledEvent = const EventStreamProvider<Event>('stalled');\n\n  @DomName('HTMLMediaElement.suspendEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> suspendEvent = const EventStreamProvider<Event>('suspend');\n\n  @DomName('HTMLMediaElement.timeupdateEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> timeUpdateEvent = const EventStreamProvider<Event>('timeupdate');\n\n  @DomName('HTMLMediaElement.volumechangeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> volumeChangeEvent = const EventStreamProvider<Event>('volumechange');\n\n  @DomName('HTMLMediaElement.waitingEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> waitingEvent = const EventStreamProvider<Event>('waiting');\n\n  @DomName('HTMLMediaElement.webkitkeyaddedEvent')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  static const EventStreamProvider<MediaKeyEvent> keyAddedEvent = const EventStreamProvider<MediaKeyEvent>('webkitkeyadded');\n\n  @DomName('HTMLMediaElement.webkitkeyerrorEvent')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  static const EventStreamProvider<MediaKeyEvent> keyErrorEvent = const EventStreamProvider<MediaKeyEvent>('webkitkeyerror');\n\n  @DomName('HTMLMediaElement.webkitkeymessageEvent')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  static const EventStreamProvider<MediaKeyEvent> keyMessageEvent = const EventStreamProvider<MediaKeyEvent>('webkitkeymessage');\n\n  @DomName('HTMLMediaElement.webkitneedkeyEvent')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  static const EventStreamProvider<MediaKeyEvent> needKeyEvent = const EventStreamProvider<MediaKeyEvent>('webkitneedkey');\n\n  static const int HAVE_CURRENT_DATA = 2;\n\n  static const int HAVE_ENOUGH_DATA = 4;\n\n  static const int HAVE_FUTURE_DATA = 3;\n\n  static const int HAVE_METADATA = 1;\n\n  static const int HAVE_NOTHING = 0;\n\n  static const int NETWORK_EMPTY = 0;\n\n  static const int NETWORK_IDLE = 1;\n\n  static const int NETWORK_LOADING = 2;\n\n  static const int NETWORK_NO_SOURCE = 3;\n\n  @DomName('HTMLMediaElement.autoplay')\n  @DocsEditable\n  bool autoplay;\n\n  @DomName('HTMLMediaElement.buffered')\n  @DocsEditable\n  final TimeRanges buffered;\n\n  @DomName('HTMLMediaElement.controller')\n  @DocsEditable\n  MediaController controller;\n\n  @DomName('HTMLMediaElement.controls')\n  @DocsEditable\n  bool controls;\n\n  @DomName('HTMLMediaElement.currentSrc')\n  @DocsEditable\n  final String currentSrc;\n\n  @DomName('HTMLMediaElement.currentTime')\n  @DocsEditable\n  num currentTime;\n\n  @DomName('HTMLMediaElement.defaultMuted')\n  @DocsEditable\n  bool defaultMuted;\n\n  @DomName('HTMLMediaElement.defaultPlaybackRate')\n  @DocsEditable\n  num defaultPlaybackRate;\n\n  @DomName('HTMLMediaElement.duration')\n  @DocsEditable\n  final num duration;\n\n  @DomName('HTMLMediaElement.ended')\n  @DocsEditable\n  final bool ended;\n\n  @DomName('HTMLMediaElement.error')\n  @DocsEditable\n  final MediaError error;\n\n  @DomName('HTMLMediaElement.initialTime')\n  @DocsEditable\n  final num initialTime;\n\n  @DomName('HTMLMediaElement.loop')\n  @DocsEditable\n  bool loop;\n\n  @DomName('HTMLMediaElement.mediaGroup')\n  @DocsEditable\n  String mediaGroup;\n\n  @DomName('HTMLMediaElement.muted')\n  @DocsEditable\n  bool muted;\n\n  @DomName('HTMLMediaElement.networkState')\n  @DocsEditable\n  final int networkState;\n\n  @DomName('HTMLMediaElement.paused')\n  @DocsEditable\n  final bool paused;\n\n  @DomName('HTMLMediaElement.playbackRate')\n  @DocsEditable\n  num playbackRate;\n\n  @DomName('HTMLMediaElement.played')\n  @DocsEditable\n  final TimeRanges played;\n\n  @DomName('HTMLMediaElement.preload')\n  @DocsEditable\n  String preload;\n\n  @DomName('HTMLMediaElement.readyState')\n  @DocsEditable\n  final int readyState;\n\n  @DomName('HTMLMediaElement.seekable')\n  @DocsEditable\n  final TimeRanges seekable;\n\n  @DomName('HTMLMediaElement.seeking')\n  @DocsEditable\n  final bool seeking;\n\n  @DomName('HTMLMediaElement.src')\n  @DocsEditable\n  String src;\n\n  @DomName('HTMLMediaElement.startTime')\n  @DocsEditable\n  final num startTime;\n\n  @DomName('HTMLMediaElement.textTracks')\n  @DocsEditable\n  final TextTrackList textTracks;\n\n  @DomName('HTMLMediaElement.volume')\n  @DocsEditable\n  num volume;\n\n  @JSName('webkitAudioDecodedByteCount')\n  @DomName('HTMLMediaElement.webkitAudioDecodedByteCount')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final int audioDecodedByteCount;\n\n  @JSName('webkitClosedCaptionsVisible')\n  @DomName('HTMLMediaElement.webkitClosedCaptionsVisible')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  bool closedCaptionsVisible;\n\n  @JSName('webkitHasClosedCaptions')\n  @DomName('HTMLMediaElement.webkitHasClosedCaptions')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final bool hasClosedCaptions;\n\n  @JSName('webkitPreservesPitch')\n  @DomName('HTMLMediaElement.webkitPreservesPitch')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  bool preservesPitch;\n\n  @JSName('webkitVideoDecodedByteCount')\n  @DomName('HTMLMediaElement.webkitVideoDecodedByteCount')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final int videoDecodedByteCount;\n\n  @DomName('HTMLMediaElement.addTextTrack')\n  @DocsEditable\n  TextTrack addTextTrack(String kind, [String label, String language]) native;\n\n  @DomName('HTMLMediaElement.canPlayType')\n  @DocsEditable\n  String canPlayType(String type, String keySystem) native;\n\n  @DomName('HTMLMediaElement.load')\n  @DocsEditable\n  void load() native;\n\n  @DomName('HTMLMediaElement.pause')\n  @DocsEditable\n  void pause() native;\n\n  @DomName('HTMLMediaElement.play')\n  @DocsEditable\n  void play() native;\n\n  @JSName('webkitAddKey')\n  @DomName('HTMLMediaElement.webkitAddKey')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void addKey(String keySystem, Uint8List key, [Uint8List initData, String sessionId]) native;\n\n  @JSName('webkitCancelKeyRequest')\n  @DomName('HTMLMediaElement.webkitCancelKeyRequest')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void cancelKeyRequest(String keySystem, String sessionId) native;\n\n  @JSName('webkitGenerateKeyRequest')\n  @DomName('HTMLMediaElement.webkitGenerateKeyRequest')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void generateKeyRequest(String keySystem, [Uint8List initData]) native;\n\n  @DomName('HTMLMediaElement.oncanplay')\n  @DocsEditable\n  Stream<Event> get onCanPlay => canPlayEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.oncanplaythrough')\n  @DocsEditable\n  Stream<Event> get onCanPlayThrough => canPlayThroughEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.ondurationchange')\n  @DocsEditable\n  Stream<Event> get onDurationChange => durationChangeEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onemptied')\n  @DocsEditable\n  Stream<Event> get onEmptied => emptiedEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onended')\n  @DocsEditable\n  Stream<Event> get onEnded => endedEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onloadeddata')\n  @DocsEditable\n  Stream<Event> get onLoadedData => loadedDataEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onloadedmetadata')\n  @DocsEditable\n  Stream<Event> get onLoadedMetadata => loadedMetadataEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onloadstart')\n  @DocsEditable\n  Stream<Event> get onLoadStart => loadStartEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onpause')\n  @DocsEditable\n  Stream<Event> get onPause => pauseEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onplay')\n  @DocsEditable\n  Stream<Event> get onPlay => playEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onplaying')\n  @DocsEditable\n  Stream<Event> get onPlaying => playingEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onprogress')\n  @DocsEditable\n  Stream<Event> get onProgress => progressEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onratechange')\n  @DocsEditable\n  Stream<Event> get onRateChange => rateChangeEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onseeked')\n  @DocsEditable\n  Stream<Event> get onSeeked => seekedEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onseeking')\n  @DocsEditable\n  Stream<Event> get onSeeking => seekingEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onshow')\n  @DocsEditable\n  Stream<Event> get onShow => showEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onstalled')\n  @DocsEditable\n  Stream<Event> get onStalled => stalledEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onsuspend')\n  @DocsEditable\n  Stream<Event> get onSuspend => suspendEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.ontimeupdate')\n  @DocsEditable\n  Stream<Event> get onTimeUpdate => timeUpdateEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onvolumechange')\n  @DocsEditable\n  Stream<Event> get onVolumeChange => volumeChangeEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onwaiting')\n  @DocsEditable\n  Stream<Event> get onWaiting => waitingEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onwebkitkeyadded')\n  @DocsEditable\n  Stream<MediaKeyEvent> get onKeyAdded => keyAddedEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onwebkitkeyerror')\n  @DocsEditable\n  Stream<MediaKeyEvent> get onKeyError => keyErrorEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onwebkitkeymessage')\n  @DocsEditable\n  Stream<MediaKeyEvent> get onKeyMessage => keyMessageEvent.forTarget(this);\n\n  @DomName('HTMLMediaElement.onwebkitneedkey')\n  @DocsEditable\n  Stream<MediaKeyEvent> get onNeedKey => needKeyEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MediaError')\nclass MediaError native \"MediaError\" {\n\n  static const int MEDIA_ERR_ABORTED = 1;\n\n  static const int MEDIA_ERR_DECODE = 3;\n\n  static const int MEDIA_ERR_ENCRYPTED = 5;\n\n  static const int MEDIA_ERR_NETWORK = 2;\n\n  static const int MEDIA_ERR_SRC_NOT_SUPPORTED = 4;\n\n  @DomName('MediaError.code')\n  @DocsEditable\n  final int code;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MediaKeyError')\nclass MediaKeyError native \"MediaKeyError\" {\n\n  static const int MEDIA_KEYERR_CLIENT = 2;\n\n  static const int MEDIA_KEYERR_DOMAIN = 6;\n\n  static const int MEDIA_KEYERR_HARDWARECHANGE = 5;\n\n  static const int MEDIA_KEYERR_OUTPUT = 4;\n\n  static const int MEDIA_KEYERR_SERVICE = 3;\n\n  static const int MEDIA_KEYERR_UNKNOWN = 1;\n\n  @DomName('MediaKeyError.code')\n  @DocsEditable\n  final int code;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MediaKeyEvent')\nclass MediaKeyEvent extends Event native \"MediaKeyEvent\" {\n\n  @JSName('defaultURL')\n  @DomName('MediaKeyEvent.defaultURL')\n  @DocsEditable\n  final String defaultUrl;\n\n  @DomName('MediaKeyEvent.errorCode')\n  @DocsEditable\n  final MediaKeyError errorCode;\n\n  @DomName('MediaKeyEvent.initData')\n  @DocsEditable\n  @Returns('Uint8List')\n  @Creates('Uint8List')\n  final List<int> initData;\n\n  @DomName('MediaKeyEvent.keySystem')\n  @DocsEditable\n  final String keySystem;\n\n  @DomName('MediaKeyEvent.message')\n  @DocsEditable\n  @Returns('Uint8List')\n  @Creates('Uint8List')\n  final List<int> message;\n\n  @DomName('MediaKeyEvent.sessionId')\n  @DocsEditable\n  final String sessionId;\n\n  @DomName('MediaKeyEvent.systemCode')\n  @DocsEditable\n  final int systemCode;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MediaList')\nclass MediaList native \"MediaList\" {\n\n  @DomName('MediaList.length')\n  @DocsEditable\n  final int length;\n\n  @DomName('MediaList.mediaText')\n  @DocsEditable\n  String mediaText;\n\n  @DomName('MediaList.appendMedium')\n  @DocsEditable\n  void appendMedium(String newMedium) native;\n\n  @DomName('MediaList.deleteMedium')\n  @DocsEditable\n  void deleteMedium(String oldMedium) native;\n\n  @DomName('MediaList.item')\n  @DocsEditable\n  String item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MediaQueryList')\nclass MediaQueryList native \"MediaQueryList\" {\n\n  @DomName('MediaQueryList.matches')\n  @DocsEditable\n  final bool matches;\n\n  @DomName('MediaQueryList.media')\n  @DocsEditable\n  final String media;\n\n  @DomName('MediaQueryList.addListener')\n  @DocsEditable\n  void addListener(MediaQueryListListener listener) native;\n\n  @DomName('MediaQueryList.removeListener')\n  @DocsEditable\n  void removeListener(MediaQueryListListener listener) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('MediaQueryListListener')\nabstract class MediaQueryListListener {\n\n  void queryChanged(MediaQueryList list);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MediaSource')\nclass MediaSource extends EventTarget native \"MediaSource\" {\n\n  @DomName('MediaSource.MediaSource')\n  @DocsEditable\n  factory MediaSource() {\n    return MediaSource._create_1();\n  }\n  static MediaSource _create_1() => JS('MediaSource', 'new MediaSource()');\n\n  @DomName('MediaSource.activeSourceBuffers')\n  @DocsEditable\n  final SourceBufferList activeSourceBuffers;\n\n  @DomName('MediaSource.duration')\n  @DocsEditable\n  num duration;\n\n  @DomName('MediaSource.readyState')\n  @DocsEditable\n  final String readyState;\n\n  @DomName('MediaSource.sourceBuffers')\n  @DocsEditable\n  final SourceBufferList sourceBuffers;\n\n  @JSName('addEventListener')\n  @DomName('MediaSource.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('MediaSource.addSourceBuffer')\n  @DocsEditable\n  SourceBuffer addSourceBuffer(String type) native;\n\n  @DomName('MediaSource.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event event) native;\n\n  @DomName('MediaSource.endOfStream')\n  @DocsEditable\n  void endOfStream(String error) native;\n\n  @DomName('MediaSource.isTypeSupported')\n  @DocsEditable\n  static bool isTypeSupported(String type) native;\n\n  @JSName('removeEventListener')\n  @DomName('MediaSource.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('MediaSource.removeSourceBuffer')\n  @DocsEditable\n  void removeSourceBuffer(SourceBuffer buffer) native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('MediaStream')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental\nclass MediaStream extends EventTarget native \"MediaStream\" {\n\n  @DomName('MediaStream.addtrackEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> addTrackEvent = const EventStreamProvider<Event>('addtrack');\n\n  @DomName('MediaStream.endedEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> endedEvent = const EventStreamProvider<Event>('ended');\n\n  @DomName('MediaStream.removetrackEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> removeTrackEvent = const EventStreamProvider<Event>('removetrack');\n\n  @DomName('MediaStream.MediaStream')\n  @DocsEditable\n  factory MediaStream([stream_OR_tracks]) {\n    if (!?stream_OR_tracks) {\n      return MediaStream._create_1();\n    }\n    if ((stream_OR_tracks is MediaStream || stream_OR_tracks == null)) {\n      return MediaStream._create_2(stream_OR_tracks);\n    }\n    if ((stream_OR_tracks is List<MediaStreamTrack> || stream_OR_tracks == null)) {\n      return MediaStream._create_3(stream_OR_tracks);\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  static MediaStream _create_1() => JS('MediaStream', 'new MediaStream()');\n  static MediaStream _create_2(stream_OR_tracks) => JS('MediaStream', 'new MediaStream(#)', stream_OR_tracks);\n  static MediaStream _create_3(stream_OR_tracks) => JS('MediaStream', 'new MediaStream(#)', stream_OR_tracks);\n\n  @DomName('MediaStream.ended')\n  @DocsEditable\n  final bool ended;\n\n  @DomName('MediaStream.id')\n  @DocsEditable\n  final String id;\n\n  @DomName('MediaStream.label')\n  @DocsEditable\n  final String label;\n\n  @JSName('addEventListener')\n  @DomName('MediaStream.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('MediaStream.addTrack')\n  @DocsEditable\n  void addTrack(MediaStreamTrack track) native;\n\n  @DomName('MediaStream.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event event) native;\n\n  @DomName('MediaStream.getAudioTracks')\n  @DocsEditable\n  List<MediaStreamTrack> getAudioTracks() native;\n\n  @DomName('MediaStream.getTrackById')\n  @DocsEditable\n  MediaStreamTrack getTrackById(String trackId) native;\n\n  @DomName('MediaStream.getVideoTracks')\n  @DocsEditable\n  List<MediaStreamTrack> getVideoTracks() native;\n\n  @JSName('removeEventListener')\n  @DomName('MediaStream.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('MediaStream.removeTrack')\n  @DocsEditable\n  void removeTrack(MediaStreamTrack track) native;\n\n  @DomName('MediaStream.onaddtrack')\n  @DocsEditable\n  Stream<Event> get onAddTrack => addTrackEvent.forTarget(this);\n\n  @DomName('MediaStream.onended')\n  @DocsEditable\n  Stream<Event> get onEnded => endedEvent.forTarget(this);\n\n  @DomName('MediaStream.onremovetrack')\n  @DocsEditable\n  Stream<Event> get onRemoveTrack => removeTrackEvent.forTarget(this);\n\n\n  /**\n   * Checks if the MediaStream APIs are supported on the current platform.\n   *\n   * See also:\n   *\n   * * [Navigator.getUserMedia]\n   */\n  static bool get supported =>\n    JS('bool', '''!!(#.getUserMedia || #.webkitGetUserMedia ||\n        #.mozGetUserMedia || #.msGetUserMedia)''',\n        window.navigator,\n        window.navigator,\n        window.navigator,\n        window.navigator);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MediaStreamEvent')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental\nclass MediaStreamEvent extends Event native \"MediaStreamEvent\" {\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Device.isEventTypeSupported('MediaStreamEvent');\n\n  @DomName('MediaStreamEvent.stream')\n  @DocsEditable\n  final MediaStream stream;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MediaStreamTrack')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental\nclass MediaStreamTrack extends EventTarget native \"MediaStreamTrack\" {\n\n  @DomName('MediaStreamTrack.endedEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> endedEvent = const EventStreamProvider<Event>('ended');\n\n  @DomName('MediaStreamTrack.muteEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> muteEvent = const EventStreamProvider<Event>('mute');\n\n  @DomName('MediaStreamTrack.unmuteEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> unmuteEvent = const EventStreamProvider<Event>('unmute');\n\n  @DomName('MediaStreamTrack.enabled')\n  @DocsEditable\n  bool enabled;\n\n  @DomName('MediaStreamTrack.id')\n  @DocsEditable\n  final String id;\n\n  @DomName('MediaStreamTrack.kind')\n  @DocsEditable\n  final String kind;\n\n  @DomName('MediaStreamTrack.label')\n  @DocsEditable\n  final String label;\n\n  @DomName('MediaStreamTrack.readyState')\n  @DocsEditable\n  final String readyState;\n\n  @JSName('addEventListener')\n  @DomName('MediaStreamTrack.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('MediaStreamTrack.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event event) native;\n\n  @JSName('removeEventListener')\n  @DomName('MediaStreamTrack.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('MediaStreamTrack.onended')\n  @DocsEditable\n  Stream<Event> get onEnded => endedEvent.forTarget(this);\n\n  @DomName('MediaStreamTrack.onmute')\n  @DocsEditable\n  Stream<Event> get onMute => muteEvent.forTarget(this);\n\n  @DomName('MediaStreamTrack.onunmute')\n  @DocsEditable\n  Stream<Event> get onUnmute => unmuteEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MediaStreamTrackEvent')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental\nclass MediaStreamTrackEvent extends Event native \"MediaStreamTrackEvent\" {\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Device.isEventTypeSupported('MediaStreamTrackEvent');\n\n  @DomName('MediaStreamTrackEvent.track')\n  @DocsEditable\n  final MediaStreamTrack track;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MemoryInfo')\nclass MemoryInfo native \"MemoryInfo\" {\n\n  @DomName('MemoryInfo.jsHeapSizeLimit')\n  @DocsEditable\n  final int jsHeapSizeLimit;\n\n  @DomName('MemoryInfo.totalJSHeapSize')\n  @DocsEditable\n  final int totalJSHeapSize;\n\n  @DomName('MemoryInfo.usedJSHeapSize')\n  @DocsEditable\n  final int usedJSHeapSize;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n/**\n * An HTML <menu> element.\n *\n * A <menu> element represents an unordered list of menu commands.\n *\n * See also:\n *\n *  * [Menu Element](https://developer.mozilla.org/en-US/docs/HTML/Element/menu) from MDN.\n *  * [Menu Element](http://www.w3.org/TR/html5/the-menu-element.html#the-menu-element) from the W3C.\n */\n@DomName('HTMLMenuElement')\nclass MenuElement extends Element native \"HTMLMenuElement\" {\n\n  @DomName('HTMLMenuElement.HTMLMenuElement')\n  @DocsEditable\n  factory MenuElement() => document.$dom_createElement(\"menu\");\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MessageChannel')\nclass MessageChannel native \"MessageChannel\" {\n\n  @DomName('MessageChannel.MessageChannel')\n  @DocsEditable\n  factory MessageChannel() {\n    return MessageChannel._create_1();\n  }\n  static MessageChannel _create_1() => JS('MessageChannel', 'new MessageChannel()');\n\n  @DomName('MessageChannel.port1')\n  @DocsEditable\n  final MessagePort port1;\n\n  @DomName('MessageChannel.port2')\n  @DocsEditable\n  final MessagePort port2;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('MessageEvent')\nclass MessageEvent extends Event native \"MessageEvent\" {\n  factory MessageEvent(String type,\n      {bool canBubble: false, bool cancelable: false, Object data,\n      String origin, String lastEventId,\n      Window source, List messagePorts}) {\n    if (source == null) {\n      source = window;\n    }\n    var event = document.$dom_createEvent(\"MessageEvent\");\n    event.$dom_initMessageEvent(type, canBubble, cancelable, data, origin,\n        lastEventId, source, messagePorts);\n    return event;\n  }\n\n  dynamic get data => convertNativeToDart_SerializedScriptValue(this._get_data);\n  @JSName('data')\n  @DomName('MessageEvent.data')\n  @DocsEditable\n  @annotation_Creates_SerializedScriptValue\n  @annotation_Returns_SerializedScriptValue\n  final dynamic _get_data;\n\n  @DomName('MessageEvent.lastEventId')\n  @DocsEditable\n  final String lastEventId;\n\n  @DomName('MessageEvent.origin')\n  @DocsEditable\n  final String origin;\n\n  @DomName('MessageEvent.ports')\n  @DocsEditable\n  @Creates('=List')\n  final List ports;\n\n  WindowBase get source => _convertNativeToDart_Window(this._get_source);\n  @JSName('source')\n  @DomName('MessageEvent.source')\n  @DocsEditable\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_source;\n\n  @JSName('initMessageEvent')\n  @DomName('MessageEvent.initMessageEvent')\n  @DocsEditable\n  void $dom_initMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List messagePorts) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MessagePort')\nclass MessagePort extends EventTarget native \"MessagePort\" {\n\n  @DomName('MessagePort.messageEvent')\n  @DocsEditable\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  @JSName('addEventListener')\n  @DomName('MessagePort.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('MessagePort.close')\n  @DocsEditable\n  void close() native;\n\n  @DomName('MessagePort.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @DomName('MessagePort.postMessage')\n  @DocsEditable\n  void postMessage(/*any*/ message, [List messagePorts]) {\n    if (?messagePorts) {\n      var message_1 = convertDartToNative_SerializedScriptValue(message);\n      _postMessage_1(message_1, messagePorts);\n      return;\n    }\n    var message_2 = convertDartToNative_SerializedScriptValue(message);\n    _postMessage_2(message_2);\n    return;\n  }\n  @JSName('postMessage')\n  @DomName('MessagePort.postMessage')\n  @DocsEditable\n  void _postMessage_1(message, List messagePorts) native;\n  @JSName('postMessage')\n  @DomName('MessagePort.postMessage')\n  @DocsEditable\n  void _postMessage_2(message) native;\n\n  @JSName('removeEventListener')\n  @DomName('MessagePort.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('MessagePort.start')\n  @DocsEditable\n  void start() native;\n\n  @DomName('MessagePort.onmessage')\n  @DocsEditable\n  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLMetaElement')\nclass MetaElement extends Element native \"HTMLMetaElement\" {\n\n  @DomName('HTMLMetaElement.content')\n  @DocsEditable\n  String content;\n\n  @DomName('HTMLMetaElement.httpEquiv')\n  @DocsEditable\n  String httpEquiv;\n\n  @DomName('HTMLMetaElement.name')\n  @DocsEditable\n  String name;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Metadata')\nclass Metadata native \"Metadata\" {\n\n  DateTime get modificationTime => _convertNativeToDart_DateTime(this._get_modificationTime);\n  @JSName('modificationTime')\n  @DomName('Metadata.modificationTime')\n  @DocsEditable\n  final dynamic _get_modificationTime;\n\n  @DomName('Metadata.size')\n  @DocsEditable\n  final int size;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void MetadataCallback(Metadata metadata);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLMeterElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass MeterElement extends Element native \"HTMLMeterElement\" {\n\n  @DomName('HTMLMeterElement.HTMLMeterElement')\n  @DocsEditable\n  factory MeterElement() => document.$dom_createElement(\"meter\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('meter');\n\n  @DomName('HTMLMeterElement.high')\n  @DocsEditable\n  num high;\n\n  @DomName('HTMLMeterElement.labels')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLMeterElement.low')\n  @DocsEditable\n  num low;\n\n  @DomName('HTMLMeterElement.max')\n  @DocsEditable\n  num max;\n\n  @DomName('HTMLMeterElement.min')\n  @DocsEditable\n  num min;\n\n  @DomName('HTMLMeterElement.optimum')\n  @DocsEditable\n  num optimum;\n\n  @DomName('HTMLMeterElement.value')\n  @DocsEditable\n  num value;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLModElement')\nclass ModElement extends Element native \"HTMLModElement\" {\n\n  @DomName('HTMLModElement.cite')\n  @DocsEditable\n  String cite;\n\n  @DomName('HTMLModElement.dateTime')\n  @DocsEditable\n  String dateTime;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('MouseEvent')\nclass MouseEvent extends UIEvent native \"MouseEvent\" {\n  factory MouseEvent(String type,\n      {Window view, int detail: 0, int screenX: 0, int screenY: 0,\n      int clientX: 0, int clientY: 0, int button: 0, bool canBubble: true,\n      bool cancelable: true, bool ctrlKey: false, bool altKey: false,\n      bool shiftKey: false, bool metaKey: false, EventTarget relatedTarget}) {\n\n    if (view == null) {\n      view = window;\n    }\n    var event = document.$dom_createEvent('MouseEvent');\n    event.$dom_initMouseEvent(type, canBubble, cancelable, view, detail,\n        screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey,\n        button, relatedTarget);\n    return event;\n  }\n\n  @DomName('MouseEvent.altKey')\n  @DocsEditable\n  final bool altKey;\n\n  @DomName('MouseEvent.button')\n  @DocsEditable\n  final int button;\n\n  @JSName('clientX')\n  @DomName('MouseEvent.clientX')\n  @DocsEditable\n  final int $dom_clientX;\n\n  @JSName('clientY')\n  @DomName('MouseEvent.clientY')\n  @DocsEditable\n  final int $dom_clientY;\n\n  @DomName('MouseEvent.ctrlKey')\n  @DocsEditable\n  final bool ctrlKey;\n\n  @DomName('MouseEvent.dataTransfer')\n  @DocsEditable\n  final DataTransfer dataTransfer;\n\n  @DomName('MouseEvent.fromElement')\n  @DocsEditable\n  final Node fromElement;\n\n  @DomName('MouseEvent.metaKey')\n  @DocsEditable\n  final bool metaKey;\n\n  EventTarget get relatedTarget => _convertNativeToDart_EventTarget(this._get_relatedTarget);\n  @JSName('relatedTarget')\n  @DomName('MouseEvent.relatedTarget')\n  @DocsEditable\n  @Creates('Node')\n  @Returns('EventTarget|=Object')\n  final dynamic _get_relatedTarget;\n\n  @JSName('screenX')\n  @DomName('MouseEvent.screenX')\n  @DocsEditable\n  final int $dom_screenX;\n\n  @JSName('screenY')\n  @DomName('MouseEvent.screenY')\n  @DocsEditable\n  final int $dom_screenY;\n\n  @DomName('MouseEvent.shiftKey')\n  @DocsEditable\n  final bool shiftKey;\n\n  @DomName('MouseEvent.toElement')\n  @DocsEditable\n  final Node toElement;\n\n  @JSName('webkitMovementX')\n  @DomName('MouseEvent.webkitMovementX')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final int $dom_webkitMovementX;\n\n  @JSName('webkitMovementY')\n  @DomName('MouseEvent.webkitMovementY')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final int $dom_webkitMovementY;\n\n  @DomName('MouseEvent.initMouseEvent')\n  @DocsEditable\n  void $dom_initMouseEvent(String type, bool canBubble, bool cancelable, Window view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, int button, EventTarget relatedTarget) {\n    var relatedTarget_1 = _convertDartToNative_EventTarget(relatedTarget);\n    _$dom_initMouseEvent_1(type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget_1);\n    return;\n  }\n  @JSName('initMouseEvent')\n  @DomName('MouseEvent.initMouseEvent')\n  @DocsEditable\n  void _$dom_initMouseEvent_1(type, canBubble, cancelable, Window view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) native;\n\n\n  @deprecated\n  int get clientX => client.x;\n  @deprecated\n  int get clientY => client.y;\n  @deprecated\n  int get offsetX => offset.x;\n  @deprecated\n  int get offsetY => offset.y;\n  @deprecated\n  int get movementX => movement.x;\n  @deprecated\n  int get movementY => movement.y;\n  @deprecated\n  int get screenX => screen.x;\n  @deprecated\n  int get screenY => screen.y;\n\n  @DomName('MouseEvent.clientX')\n  @DomName('MouseEvent.clientY')\n  Point get client => new Point($dom_clientX, $dom_clientY);\n\n  @DomName('MouseEvent.movementX')\n  @DomName('MouseEvent.movementY')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  Point get movement => new Point($dom_webkitMovementX, $dom_webkitMovementY);\n\n  /**\n   * The coordinates of the mouse pointer in target node coordinates.\n   *\n   * This value may vary between platforms if the target node moves\n   * after the event has fired or if the element has CSS transforms affecting\n   * it.\n   */\n  Point get offset {\n    if (JS('bool', '!!#.offsetX', this)) {\n      var x = JS('int', '#.offsetX', this);\n      var y = JS('int', '#.offsetY', this);\n      return new Point(x, y);\n    } else {\n      // Firefox does not support offsetX.\n      var target = this.target;\n      if (!(target is Element)) {\n        throw new UnsupportedError(\n            'offsetX is only supported on elements');\n      }\n      return (this.client -\n          this.target.getBoundingClientRect().topLeft).toInt();\n    }\n  }\n\n  @DomName('MouseEvent.screenX')\n  @DomName('MouseEvent.screenY')\n  Point get screen => new Point($dom_screenX, $dom_screenY);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void MutationCallback(List<MutationRecord> mutations, MutationObserver observer);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('MutationEvent')\nclass MutationEvent extends Event native \"MutationEvent\" {\n  factory MutationEvent(String type,\n      {bool canBubble: false, bool cancelable: false, Node relatedNode,\n      String prevValue, String newValue, String attrName, int attrChange: 0}) {\n\n    var event = document.$dom_createEvent('MutationEvent');\n    event.$dom_initMutationEvent(type, canBubble, cancelable, relatedNode,\n        prevValue, newValue, attrName, attrChange);\n    return event;\n  }\n\n  static const int ADDITION = 2;\n\n  static const int MODIFICATION = 1;\n\n  static const int REMOVAL = 3;\n\n  @DomName('MutationEvent.attrChange')\n  @DocsEditable\n  final int attrChange;\n\n  @DomName('MutationEvent.attrName')\n  @DocsEditable\n  final String attrName;\n\n  @DomName('MutationEvent.newValue')\n  @DocsEditable\n  final String newValue;\n\n  @DomName('MutationEvent.prevValue')\n  @DocsEditable\n  final String prevValue;\n\n  @DomName('MutationEvent.relatedNode')\n  @DocsEditable\n  final Node relatedNode;\n\n  @JSName('initMutationEvent')\n  @DomName('MutationEvent.initMutationEvent')\n  @DocsEditable\n  void $dom_initMutationEvent(String type, bool canBubble, bool cancelable, Node relatedNode, String prevValue, String newValue, String attrName, int attrChange) native;\n\n}\n\n\n\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('MutationObserver')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental\nclass MutationObserver native \"MutationObserver,WebKitMutationObserver\" {\n\n  @DomName('MutationObserver.observe')\n  @DocsEditable\n  void _observe(Node target, Map options) {\n    var options_1 = convertDartToNative_Dictionary(options);\n    __observe_1(target, options_1);\n    return;\n  }\n  @JSName('observe')\n  @DomName('MutationObserver.observe')\n  @DocsEditable\n  void __observe_1(Node target, options) native;\n\n  @DomName('MutationObserver.disconnect')\n  @DocsEditable\n  void disconnect() native;\n\n  @DomName('MutationObserver.takeRecords')\n  @DocsEditable\n  List<MutationRecord> takeRecords() native;\n\n  /**\n   * Checks to see if the mutation observer API is supported on the current\n   * platform.\n   */\n  static bool get supported {\n    return JS('bool',\n        '!!(window.MutationObserver || window.WebKitMutationObserver)');\n  }\n\n  void observe(Node target,\n               {bool childList,\n                bool attributes,\n                bool characterData,\n                bool subtree,\n                bool attributeOldValue,\n                bool characterDataOldValue,\n                List<String> attributeFilter}) {\n\n    // Parse options into map of known type.\n    var parsedOptions = _createDict();\n\n    // Override options passed in the map with named optional arguments.\n    override(key, value) {\n      if (value != null) _add(parsedOptions, key, value);\n    }\n\n    override('childList', childList);\n    override('attributes', attributes);\n    override('characterData', characterData);\n    override('subtree', subtree);\n    override('attributeOldValue', attributeOldValue);\n    override('characterDataOldValue', characterDataOldValue);\n    if (attributeFilter != null) {\n      override('attributeFilter', _fixupList(attributeFilter));\n    }\n\n    _call(target, parsedOptions);\n  }\n\n   // TODO: Change to a set when const Sets are available.\n  static final _boolKeys =\n    const {'childList': true,\n           'attributes': true,\n           'characterData': true,\n           'subtree': true,\n           'attributeOldValue': true,\n           'characterDataOldValue': true };\n\n\n  static _createDict() => JS('var', '{}');\n  static _add(m, String key, value) { JS('void', '#[#] = #', m, key, value); }\n  static _fixupList(list) => list;  // TODO: Ensure is a JavaScript Array.\n\n  // Call native function with no conversions.\n  @JSName('observe')\n  void _call(target, options) native;\n\n  factory MutationObserver(MutationCallback callback) {\n    // Dummy statement to mark types as instantiated.\n    JS('MutationObserver|MutationRecord', '0');\n\n    return JS('MutationObserver',\n        'new(window.MutationObserver||window.WebKitMutationObserver||'\n        'window.MozMutationObserver)(#)',\n        convertDartClosureToJS(callback, 2));\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MutationRecord')\nclass MutationRecord native \"MutationRecord\" {\n\n  @DomName('MutationRecord.addedNodes')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> addedNodes;\n\n  @DomName('MutationRecord.attributeName')\n  @DocsEditable\n  final String attributeName;\n\n  @DomName('MutationRecord.attributeNamespace')\n  @DocsEditable\n  final String attributeNamespace;\n\n  @DomName('MutationRecord.nextSibling')\n  @DocsEditable\n  final Node nextSibling;\n\n  @DomName('MutationRecord.oldValue')\n  @DocsEditable\n  final String oldValue;\n\n  @DomName('MutationRecord.previousSibling')\n  @DocsEditable\n  final Node previousSibling;\n\n  @DomName('MutationRecord.removedNodes')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> removedNodes;\n\n  @DomName('MutationRecord.target')\n  @DocsEditable\n  final Node target;\n\n  @DomName('MutationRecord.type')\n  @DocsEditable\n  final String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebKitNamedFlow')\nclass NamedFlow extends EventTarget native \"WebKitNamedFlow\" {\n\n  @DomName('NamedFlow.firstEmptyRegionIndex')\n  @DocsEditable\n  final int firstEmptyRegionIndex;\n\n  @DomName('NamedFlow.name')\n  @DocsEditable\n  final String name;\n\n  @DomName('NamedFlow.overset')\n  @DocsEditable\n  final bool overset;\n\n  @JSName('addEventListener')\n  @DomName('NamedFlow.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('NamedFlow.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event event) native;\n\n  @DomName('NamedFlow.getContent')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getContent() native;\n\n  @DomName('NamedFlow.getRegions')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getRegions() native;\n\n  @DomName('NamedFlow.getRegionsByContent')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getRegionsByContent(Node contentNode) native;\n\n  @JSName('removeEventListener')\n  @DomName('NamedFlow.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('Navigator')\nclass Navigator native \"Navigator\" {\n\n  @DomName('Navigator.language')\n  String get language => JS('String', '#.language || #.userLanguage', this,\n      this);\n\n  /**\n   * Gets a stream (video and or audio) from the local computer.\n   *\n   * Use [MediaStream.supported] to check if this is supported by the current\n   * platform. The arguments `audio` and `video` default to `false` (stream does\n   * not use audio or video, respectively).\n   *\n   * Simple example usage:\n   *\n   *     window.navigator.getUserMedia(audio: true, video: true).then((stream) {\n   *       var video = new VideoElement()\n   *         ..autoplay = true\n   *         ..src = Url.createObjectUrl(stream);\n   *       document.body.append(video);\n   *     });\n   *\n   * The user can also pass in Maps to the audio or video parameters to specify \n   * mandatory and optional constraints for the media stream. Not passing in a \n   * map, but passing in `true` will provide a LocalMediaStream with audio or \n   * video capabilities, but without any additional constraints. The particular\n   * constraint names for audio and video are still in flux, but as of this \n   * writing, here is an example providing more constraints.\n   *\n   *     window.navigator.getUserMedia(\n   *         audio: true, \n   *         video: {'mandatory': \n   *                    { 'minAspectRatio': 1.333, 'maxAspectRatio': 1.334 },\n   *                 'optional': \n   *                    [{ 'minFrameRate': 60 },\n   *                     { 'maxWidth': 640 }]\n   *     });\n   *\n   * See also:\n   * * [MediaStream.supported]\n   */\n  @DomName('Navigator.webkitGetUserMedia')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @Experimental\n  Future<LocalMediaStream> getUserMedia({audio: false, video: false}) {\n    var completer = new Completer<LocalMediaStream>();\n    var options = {\n      'audio': audio,\n      'video': video\n    };\n    _ensureGetUserMedia();\n    this._getUserMedia(convertDartToNative_SerializedScriptValue(options),\n      (stream) {\n        completer.complete(stream);\n      },\n      (error) {\n        completer.completeError(error);\n      });\n    return completer.future;\n  }\n\n  _ensureGetUserMedia() {\n    if (JS('bool', '!(#.getUserMedia)', this)) {\n      JS('void', '#.getUserMedia = '\n          '(#.getUserMedia || #.webkitGetUserMedia || #.mozGetUserMedia ||'\n          '#.msGetUserMedia)', this, this, this, this, this);\n    }\n  }\n\n  @JSName('getUserMedia')\n  void _getUserMedia(options, _NavigatorUserMediaSuccessCallback success,\n      _NavigatorUserMediaErrorCallback error) native;\n\n\n  @DomName('Navigator.appCodeName')\n  @DocsEditable\n  final String appCodeName;\n\n  @DomName('Navigator.appName')\n  @DocsEditable\n  final String appName;\n\n  @DomName('Navigator.appVersion')\n  @DocsEditable\n  final String appVersion;\n\n  @DomName('Navigator.cookieEnabled')\n  @DocsEditable\n  final bool cookieEnabled;\n\n  @DomName('Navigator.doNotTrack')\n  @DocsEditable\n  final String doNotTrack;\n\n  @DomName('Navigator.geolocation')\n  @DocsEditable\n  final Geolocation geolocation;\n\n  @DomName('Navigator.mimeTypes')\n  @DocsEditable\n  final DomMimeTypeArray mimeTypes;\n\n  @DomName('Navigator.onLine')\n  @DocsEditable\n  final bool onLine;\n\n  @DomName('Navigator.platform')\n  @DocsEditable\n  final String platform;\n\n  @DomName('Navigator.plugins')\n  @DocsEditable\n  final DomPluginArray plugins;\n\n  @DomName('Navigator.product')\n  @DocsEditable\n  final String product;\n\n  @DomName('Navigator.productSub')\n  @DocsEditable\n  final String productSub;\n\n  @DomName('Navigator.userAgent')\n  @DocsEditable\n  final String userAgent;\n\n  @DomName('Navigator.vendor')\n  @DocsEditable\n  final String vendor;\n\n  @DomName('Navigator.vendorSub')\n  @DocsEditable\n  final String vendorSub;\n\n  @JSName('webkitPersistentStorage')\n  @DomName('Navigator.webkitPersistentStorage')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final StorageQuota persistentStorage;\n\n  @JSName('webkitTemporaryStorage')\n  @DomName('Navigator.webkitTemporaryStorage')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final StorageQuota temporaryStorage;\n\n  @DomName('Navigator.getStorageUpdates')\n  @DocsEditable\n  void getStorageUpdates() native;\n\n  @DomName('Navigator.javaEnabled')\n  @DocsEditable\n  bool javaEnabled() native;\n\n  @DomName('Navigator.registerProtocolHandler')\n  @DocsEditable\n  void registerProtocolHandler(String scheme, String url, String title) native;\n\n  @JSName('webkitGetGamepads')\n  @DomName('Navigator.webkitGetGamepads')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  @Returns('_GamepadList')\n  @Creates('_GamepadList')\n  List<Gamepad> getGamepads() native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('NavigatorUserMediaError')\nclass NavigatorUserMediaError native \"NavigatorUserMediaError\" {\n\n  static const int PERMISSION_DENIED = 1;\n\n  @DomName('NavigatorUserMediaError.code')\n  @DocsEditable\n  final int code;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void _NavigatorUserMediaErrorCallback(NavigatorUserMediaError error);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void _NavigatorUserMediaSuccessCallback(LocalMediaStream stream);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Lazy implementation of the child nodes of an element that does not request\n * the actual child nodes of an element until strictly necessary greatly\n * improving performance for the typical cases where it is not required.\n */\nclass _ChildNodeListLazy extends ListBase<Node> {\n  final Node _this;\n\n  _ChildNodeListLazy(this._this);\n\n\n  Node get first {\n    Node result = JS('Node|Null', '#.firstChild', _this);\n    if (result == null) throw new StateError(\"No elements\");\n    return result;\n  }\n  Node get last {\n    Node result = JS('Node|Null', '#.lastChild', _this);\n    if (result == null) throw new StateError(\"No elements\");\n    return result;\n  }\n  Node get single {\n    int l = this.length;\n    if (l == 0) throw new StateError(\"No elements\");\n    if (l > 1) throw new StateError(\"More than one element\");\n    return JS('Node|Null', '#.firstChild', _this);\n  }\n\n  void add(Node value) {\n    _this.append(value);\n  }\n\n  void addAll(Iterable<Node> iterable) {\n    if (iterable is _ChildNodeListLazy) {\n      if (!identical(iterable._this, _this)) {\n        // Optimized route for copying between nodes.\n        for (var i = 0, len = iterable.length; i < len; ++i) {\n          // Should use $dom_firstChild, Bug 8886.\n          _this.append(iterable[0]);\n        }\n      }\n      return;\n    }\n    for (Node node in iterable) {\n      _this.append(node);\n    }\n  }\n\n  void insert(int index, Node node) {\n    if (index < 0 || index > length) {\n      throw new RangeError.range(index, 0, length);\n    }\n    if (index == length) {\n      _this.append(node);\n    } else {\n      _this.insertBefore(node, this[index]);\n    }\n  }\n\n  void insertAll(int index, Iterable<Node> iterable) {\n    throw new UnimplementedError();\n  }\n\n  void setAll(int index, Iterable<Node> iterable) {\n    throw new UnimplementedError();\n  }\n\n  Node removeLast() {\n    final result = last;\n    if (result != null) {\n      _this.$dom_removeChild(result);\n    }\n    return result;\n  }\n\n  Node removeAt(int index) {\n    var result = this[index];\n    if (result != null) {\n      _this.$dom_removeChild(result);\n    }\n    return result;\n  }\n\n  bool remove(Object object) {\n    if (object is! Node) return false;\n    Node node = object;\n    if (!identical(_this, node.parentNode)) return false;\n    _this.$dom_removeChild(node);\n    return true;\n  }\n\n  void _filter(bool test(Node node), bool removeMatching) {\n    // This implementation of removeWhere/retainWhere is more efficient\n    // than the default in ListBase. Child nodes can be removed in constant\n    // time.\n    Node child = _this.$dom_firstChild;\n    while (child != null) {\n      Node nextChild = child.nextSibling;\n      if (test(child) == removeMatching) {\n        _this.$dom_removeChild(child);\n      }\n      child = nextChild;\n    }\n  }\n\n  void removeWhere(bool test(Node node)) {\n    _filter(test, true);\n  }\n\n  void retainWhere(bool test(Node node)) {\n    _filter(test, false);\n  }\n\n  void clear() {\n    _this.text = '';\n  }\n\n  void operator []=(int index, Node value) {\n    _this.$dom_replaceChild(value, this[index]);\n  }\n\n  Iterator<Node> get iterator => _this.$dom_childNodes.iterator;\n\n  List<Node> toList({ bool growable: true }) =>\n      new List<Node>.from(this, growable: growable);\n  Set<Node> toSet() => new Set<Node>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  // From List<Node>:\n\n  // TODO(jacobr): this could be implemented for child node lists.\n  // The exception we throw here is misleading.\n  void sort([int compare(Node a, Node b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  // FIXME: implement these.\n  void setRange(int start, int end, Iterable<Node> iterable,\n                [int skipCount = 0]) {\n    throw new UnsupportedError(\n        \"Cannot setRange on immutable List.\");\n  }\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\n        \"Cannot removeRange on immutable List.\");\n  }\n\n  Iterable<Node> getRange(int start, int end) {\n    throw new UnimplementedError(\"NodeList.getRange\");\n  }\n\n  void replaceRange(int start, int end, Iterable<Node> iterable) {\n    throw new UnimplementedError(\"NodeList.replaceRange\");\n  }\n\n  void fillRange(int start, int end, [Node fillValue]) {\n    throw new UnimplementedError(\"NodeList.fillRange\");\n  }\n\n  List<Node> sublist(int start, [int end]) {\n    if (end == null) end == length;\n    return Lists.getRange(this, start, end, <Node>[]);\n  }\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n  // -- end List<Node> mixins.\n\n  // TODO(jacobr): benchmark whether this is more efficient or whether caching\n  // a local copy of $dom_childNodes is more efficient.\n  int get length => _this.$dom_childNodes.length;\n\n  void set length(int value) {\n    throw new UnsupportedError(\n        \"Cannot set length on immutable List.\");\n  }\n\n  Node operator[](int index) => _this.$dom_childNodes[index];\n}\n\n@DomName('Node')\nclass Node extends EventTarget native \"Node\" {\n  List<Node> get nodes {\n    return new _ChildNodeListLazy(this);\n  }\n\n  void set nodes(Iterable<Node> value) {\n    // Copy list first since we don't want liveness during iteration.\n    // TODO(jacobr): there is a better way to do this.\n    List copy = new List.from(value);\n    text = '';\n    for (Node node in copy) {\n      append(node);\n    }\n  }\n\n  /**\n   * Removes this node from the DOM.\n   */\n  @DomName('Node.removeChild')\n  void remove() {\n    // TODO(jacobr): should we throw an exception if parent is already null?\n    // TODO(vsm): Use the native remove when available.\n    if (this.parentNode != null) {\n      final Node parent = this.parentNode;\n      parentNode.$dom_removeChild(this);\n    }\n  }\n\n  /**\n   * Replaces this node with another node.\n   */\n  @DomName('Node.replaceChild')\n  Node replaceWith(Node otherNode) {\n    try {\n      final Node parent = this.parentNode;\n      parent.$dom_replaceChild(otherNode, this);\n    } catch (e) {\n\n    };\n    return this;\n  }\n\n  /**\n   * Inserts all of the nodes into this node directly before refChild.\n   *\n   * See also:\n   *\n   * * [insertBefore]\n   */\n  Node insertAllBefore(Iterable<Node> newNodes, Node refChild) {\n    if (newNodes is _ChildNodeListLazy) {\n      if (identical(newNodes._this, this)) {\n        throw new ArgumentError(newNodes);\n      }\n\n      // Optimized route for copying between nodes.\n      for (var i = 0, len = newNodes.length; i < len; ++i) {\n        // Should use $dom_firstChild, Bug 8886.\n        this.insertBefore(newNodes[0], refChild);\n      }\n    } else {\n      for (var node in newNodes) {\n        this.insertBefore(node, refChild);\n      }\n    }\n  }\n\n  // Note that this may either be the locally set model or a cached value\n  // of the inherited model. This is cached to minimize model change\n  // notifications.\n  @Creates('Null')\n  var _model;\n  bool _hasLocalModel;\n  Set<StreamController<Node>> _modelChangedStreams;\n\n  /**\n   * The data model which is inherited through the tree.\n   *\n   * Setting this will propagate the value to all descendant nodes. If the\n   * model is not set on this node then it will be inherited from ancestor\n   * nodes.\n   *\n   * Currently this does not support propagation through Shadow DOMs.\n   *\n   * [clearModel] must be used to remove the model property from this node\n   * and have the model inherit from ancestor nodes.\n   */\n  @Experimental\n  get model {\n    // If we have a change handler then we've cached the model locally.\n    if (_modelChangedStreams != null && !_modelChangedStreams.isEmpty) {\n      return _model;\n    }\n    // Otherwise start looking up the tree.\n    for (var node = this; node != null; node = node.parentNode) {\n      if (node._hasLocalModel == true) {\n        return node._model;\n      }\n    }\n    return null;\n  }\n\n  @Experimental\n  void set model(value) {\n    var changed = model != value;\n    _model = value;\n    _hasLocalModel = true;\n    _ModelTreeObserver.initialize();\n\n    if (changed) {\n      if (_modelChangedStreams != null && !_modelChangedStreams.isEmpty) {\n        _modelChangedStreams.toList().forEach((stream) => stream.add(this));\n      }\n      // Propagate new model to all descendants.\n      _ModelTreeObserver.propagateModel(this, value, false);\n    }\n  }\n\n  /**\n   * Clears the locally set model and makes this model be inherited from parent\n   * nodes.\n   */\n  @Experimental\n  void clearModel() {\n    if (_hasLocalModel == true) {\n      _hasLocalModel = false;\n\n      // Propagate new model to all descendants.\n      if (parentNode != null) {\n        _ModelTreeObserver.propagateModel(this, parentNode.model, false);\n      } else {\n        _ModelTreeObserver.propagateModel(this, null, false);\n      }\n    }\n  }\n\n  /**\n   * Get a stream of models, whenever the model changes.\n   */\n  Stream<Node> get onModelChanged {\n    if (_modelChangedStreams == null) {\n      _modelChangedStreams = new Set<StreamController<Node>>();\n    }\n    var controller;\n    controller = new StreamController(\n        onListen: () { _modelChangedStreams.add(controller); },\n        onCancel: () { _modelChangedStreams.remove(controller); });\n    return controller.stream;\n  }\n\n  /**\n   * Print out a String representation of this Node.\n   */\n  String toString() => localName == null ?\n      (nodeValue == null ? super.toString() : nodeValue) : localName;\n\n\n  static const int ATTRIBUTE_NODE = 2;\n\n  static const int CDATA_SECTION_NODE = 4;\n\n  static const int COMMENT_NODE = 8;\n\n  static const int DOCUMENT_FRAGMENT_NODE = 11;\n\n  static const int DOCUMENT_NODE = 9;\n\n  static const int DOCUMENT_TYPE_NODE = 10;\n\n  static const int ELEMENT_NODE = 1;\n\n  static const int ENTITY_NODE = 6;\n\n  static const int ENTITY_REFERENCE_NODE = 5;\n\n  static const int NOTATION_NODE = 12;\n\n  static const int PROCESSING_INSTRUCTION_NODE = 7;\n\n  static const int TEXT_NODE = 3;\n\n  @JSName('childNodes')\n  @DomName('Node.childNodes')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> $dom_childNodes;\n\n  @JSName('firstChild')\n  @DomName('Node.firstChild')\n  @DocsEditable\n  final Node $dom_firstChild;\n\n  @JSName('lastChild')\n  @DomName('Node.lastChild')\n  @DocsEditable\n  final Node $dom_lastChild;\n\n  @DomName('Node.localName')\n  @DocsEditable\n  final String localName;\n\n  @JSName('namespaceURI')\n  @DomName('Node.namespaceURI')\n  @DocsEditable\n  final String $dom_namespaceUri;\n\n  @JSName('nextSibling')\n  @DomName('Node.nextSibling')\n  @DocsEditable\n  final Node nextNode;\n\n  @DomName('Node.nodeType')\n  @DocsEditable\n  final int nodeType;\n\n  @DomName('Node.nodeValue')\n  @DocsEditable\n  final String nodeValue;\n\n  @JSName('ownerDocument')\n  @DomName('Node.ownerDocument')\n  @DocsEditable\n  final Document document;\n\n  @JSName('parentElement')\n  @DomName('Node.parentElement')\n  @DocsEditable\n  final Element parent;\n\n  @DomName('Node.parentNode')\n  @DocsEditable\n  final Node parentNode;\n\n  @JSName('previousSibling')\n  @DomName('Node.previousSibling')\n  @DocsEditable\n  final Node previousNode;\n\n  @JSName('textContent')\n  @DomName('Node.textContent')\n  @DocsEditable\n  String text;\n\n  @JSName('addEventListener')\n  @DomName('Node.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @JSName('appendChild')\n  @DomName('Node.appendChild')\n  @DocsEditable\n  Node append(Node newChild) native;\n\n  @JSName('cloneNode')\n  @DomName('Node.cloneNode')\n  @DocsEditable\n  Node clone(bool deep) native;\n\n  @DomName('Node.contains')\n  @DocsEditable\n  bool contains(Node other) native;\n\n  @DomName('Node.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event event) native;\n\n  @DomName('Node.hasChildNodes')\n  @DocsEditable\n  bool hasChildNodes() native;\n\n  @DomName('Node.insertBefore')\n  @DocsEditable\n  Node insertBefore(Node newChild, Node refChild) native;\n\n  @JSName('removeChild')\n  @DomName('Node.removeChild')\n  @DocsEditable\n  Node $dom_removeChild(Node oldChild) native;\n\n  @JSName('removeEventListener')\n  @DomName('Node.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @JSName('replaceChild')\n  @DomName('Node.replaceChild')\n  @DocsEditable\n  Node $dom_replaceChild(Node newChild, Node oldChild) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('NodeFilter')\nclass NodeFilter native \"NodeFilter\" {\n\n  static const int FILTER_ACCEPT = 1;\n\n  static const int FILTER_REJECT = 2;\n\n  static const int FILTER_SKIP = 3;\n\n  static const int SHOW_ALL = 0xFFFFFFFF;\n\n  static const int SHOW_ATTRIBUTE = 0x00000002;\n\n  static const int SHOW_CDATA_SECTION = 0x00000008;\n\n  static const int SHOW_COMMENT = 0x00000080;\n\n  static const int SHOW_DOCUMENT = 0x00000100;\n\n  static const int SHOW_DOCUMENT_FRAGMENT = 0x00000400;\n\n  static const int SHOW_DOCUMENT_TYPE = 0x00000200;\n\n  static const int SHOW_ELEMENT = 0x00000001;\n\n  static const int SHOW_ENTITY = 0x00000020;\n\n  static const int SHOW_ENTITY_REFERENCE = 0x00000010;\n\n  static const int SHOW_NOTATION = 0x00000800;\n\n  static const int SHOW_PROCESSING_INSTRUCTION = 0x00000040;\n\n  static const int SHOW_TEXT = 0x00000004;\n\n  @DomName('NodeFilter.acceptNode')\n  @DocsEditable\n  int acceptNode(Node n) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('NodeIterator')\nclass NodeIterator native \"NodeIterator\" {\n\n  @DomName('NodeIterator.expandEntityReferences')\n  @DocsEditable\n  final bool expandEntityReferences;\n\n  @DomName('NodeIterator.filter')\n  @DocsEditable\n  final NodeFilter filter;\n\n  @DomName('NodeIterator.pointerBeforeReferenceNode')\n  @DocsEditable\n  final bool pointerBeforeReferenceNode;\n\n  @DomName('NodeIterator.referenceNode')\n  @DocsEditable\n  final Node referenceNode;\n\n  @DomName('NodeIterator.root')\n  @DocsEditable\n  final Node root;\n\n  @DomName('NodeIterator.whatToShow')\n  @DocsEditable\n  final int whatToShow;\n\n  @DomName('NodeIterator.detach')\n  @DocsEditable\n  void detach() native;\n\n  @DomName('NodeIterator.nextNode')\n  @DocsEditable\n  Node nextNode() native;\n\n  @DomName('NodeIterator.previousNode')\n  @DocsEditable\n  Node previousNode() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('NodeList')\nclass NodeList implements JavaScriptIndexingBehavior, List<Node> native \"NodeList,RadioNodeList\" {\n\n  @DomName('NodeList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Node operator[](int index) => JS(\"Node\", \"#[#]\", this, index);\n\n  void operator[]=(int index, Node value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Node> mixins.\n  // Node is the element type.\n\n  // From Iterable<Node>:\n\n  Iterator<Node> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<Node>(this);\n  }\n\n  Node reduce(Node combine(Node value, Node element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, Node element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(Node element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(Node element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(Node element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<Node> where(bool f(Node element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(Node element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(Node element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(Node element)) => IterableMixinWorkaround.any(this, f);\n\n  List<Node> toList({ bool growable: true }) =>\n      new List<Node>.from(this, growable: growable);\n\n  Set<Node> toSet() => new Set<Node>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<Node> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<Node> takeWhile(bool test(Node value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<Node> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<Node> skipWhile(bool test(Node value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  Node firstWhere(bool test(Node value), { Node orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  Node lastWhere(bool test(Node value), {Node orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  Node singleWhere(bool test(Node value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  Node elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<Node>:\n\n  void add(Node value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<Node>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<Node> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(Node a, Node b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(Node element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(Node element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  Node get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  Node get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  Node get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, Node element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Node removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  Node removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(Node element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(Node element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<Node> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [Node fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<Node> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<Node> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <Node>[]);\n  }\n\n  Map<int, Node> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<Node> mixins.\n\n  @JSName('item')\n  @DomName('NodeList.item')\n  @DocsEditable\n  Node _item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Notation')\nclass Notation extends Node native \"Notation\" {\n\n  @DomName('Notation.publicId')\n  @DocsEditable\n  final String publicId;\n\n  @DomName('Notation.systemId')\n  @DocsEditable\n  final String systemId;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('Notification')\nclass Notification extends EventTarget native \"Notification\" {\n\n  factory Notification(String title, {String titleDir: null, String body: null, \n      String bodyDir: null, String tag: null, String iconUrl: null}) {\n\n    var parsedOptions = {};\n    if (titleDir != null) parsedOptions['titleDir'] = titleDir;\n    if (body != null) parsedOptions['body'] = body;\n    if (bodyDir != null) parsedOptions['bodyDir'] = bodyDir;\n    if (tag != null) parsedOptions['tag'] = tag;\n    if (iconUrl != null) parsedOptions['iconUrl'] = iconUrl;\n\n    return Notification._factoryNotification(title, parsedOptions);\n  }\n\n  @DomName('Notification.clickEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> clickEvent = const EventStreamProvider<Event>('click');\n\n  @DomName('Notification.closeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> closeEvent = const EventStreamProvider<Event>('close');\n\n  @DomName('Notification.displayEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> displayEvent = const EventStreamProvider<Event>('display');\n\n  @DomName('Notification.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('Notification.showEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> showEvent = const EventStreamProvider<Event>('show');\n\n  @DomName('Notification.Notification')\n  @DocsEditable\n  static Notification _factoryNotification(String title, [Map options]) {\n    if (?options) {\n      return Notification._create_1(title, options);\n    }\n    return Notification._create_2(title);\n  }\n  static Notification _create_1(title, options) => JS('Notification', 'new Notification(#,#)', title, options);\n  static Notification _create_2(title) => JS('Notification', 'new Notification(#)', title);\n\n  @DomName('Notification.dir')\n  @DocsEditable\n  String dir;\n\n  @DomName('Notification.permission')\n  @DocsEditable\n  final String permission;\n\n  @DomName('Notification.replaceId')\n  @DocsEditable\n  String replaceId;\n\n  @DomName('Notification.tag')\n  @DocsEditable\n  String tag;\n\n  @JSName('addEventListener')\n  @DomName('Notification.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('Notification.cancel')\n  @DocsEditable\n  void cancel() native;\n\n  @DomName('Notification.close')\n  @DocsEditable\n  void close() native;\n\n  @DomName('Notification.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @JSName('removeEventListener')\n  @DomName('Notification.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @JSName('requestPermission')\n  @DomName('Notification.requestPermission')\n  @DocsEditable\n  static void _requestPermission([_NotificationPermissionCallback callback]) native;\n\n  @JSName('requestPermission')\n  @DomName('Notification.requestPermission')\n  @DocsEditable\n  static Future<String> requestPermission() {\n    var completer = new Completer<String>();\n    _requestPermission(\n        (value) { completer.complete(value); });\n    return completer.future;\n  }\n\n  @DomName('Notification.show')\n  @DocsEditable\n  void show() native;\n\n  @DomName('Notification.onclick')\n  @DocsEditable\n  Stream<Event> get onClick => clickEvent.forTarget(this);\n\n  @DomName('Notification.onclose')\n  @DocsEditable\n  Stream<Event> get onClose => closeEvent.forTarget(this);\n\n  @DomName('Notification.ondisplay')\n  @DocsEditable\n  Stream<Event> get onDisplay => displayEvent.forTarget(this);\n\n  @DomName('Notification.onerror')\n  @DocsEditable\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  @DomName('Notification.onshow')\n  @DocsEditable\n  Stream<Event> get onShow => showEvent.forTarget(this);\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('NotificationCenter')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental\nclass NotificationCenter native \"NotificationCenter\" {\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.webkitNotifications)');\n\n  @DomName('NotificationCenter.checkPermission')\n  @DocsEditable\n  int checkPermission() native;\n\n  @JSName('createHTMLNotification')\n  @DomName('NotificationCenter.createHTMLNotification')\n  @DocsEditable\n  Notification createHtmlNotification(String url) native;\n\n  @DomName('NotificationCenter.createNotification')\n  @DocsEditable\n  Notification createNotification(String iconUrl, String title, String body) native;\n\n  @JSName('requestPermission')\n  @DomName('NotificationCenter.requestPermission')\n  @DocsEditable\n  void _requestPermission([VoidCallback callback]) native;\n\n  @JSName('requestPermission')\n  @DomName('NotificationCenter.requestPermission')\n  @DocsEditable\n  Future requestPermission() {\n    var completer = new Completer();\n    _requestPermission(\n        () { completer.complete(); });\n    return completer.future;\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void _NotificationPermissionCallback(String permission);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLOListElement')\nclass OListElement extends Element native \"HTMLOListElement\" {\n\n  @DomName('HTMLOListElement.HTMLOListElement')\n  @DocsEditable\n  factory OListElement() => document.$dom_createElement(\"ol\");\n\n  @DomName('HTMLOListElement.reversed')\n  @DocsEditable\n  bool reversed;\n\n  @DomName('HTMLOListElement.start')\n  @DocsEditable\n  int start;\n\n  @DomName('HTMLOListElement.type')\n  @DocsEditable\n  String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLObjectElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.IE)\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass ObjectElement extends Element native \"HTMLObjectElement\" {\n\n  @DomName('HTMLObjectElement.HTMLObjectElement')\n  @DocsEditable\n  factory ObjectElement() => document.$dom_createElement(\"object\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('object');\n\n  @DomName('HTMLObjectElement.code')\n  @DocsEditable\n  String code;\n\n  @DomName('HTMLObjectElement.data')\n  @DocsEditable\n  String data;\n\n  @DomName('HTMLObjectElement.form')\n  @DocsEditable\n  final FormElement form;\n\n  @DomName('HTMLObjectElement.height')\n  @DocsEditable\n  String height;\n\n  @DomName('HTMLObjectElement.name')\n  @DocsEditable\n  String name;\n\n  @DomName('HTMLObjectElement.type')\n  @DocsEditable\n  String type;\n\n  @DomName('HTMLObjectElement.useMap')\n  @DocsEditable\n  String useMap;\n\n  @DomName('HTMLObjectElement.validationMessage')\n  @DocsEditable\n  final String validationMessage;\n\n  @DomName('HTMLObjectElement.validity')\n  @DocsEditable\n  final ValidityState validity;\n\n  @DomName('HTMLObjectElement.width')\n  @DocsEditable\n  String width;\n\n  @DomName('HTMLObjectElement.willValidate')\n  @DocsEditable\n  final bool willValidate;\n\n  @DomName('HTMLObjectElement.checkValidity')\n  @DocsEditable\n  bool checkValidity() native;\n\n  @DomName('HTMLObjectElement.setCustomValidity')\n  @DocsEditable\n  void setCustomValidity(String error) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLOptGroupElement')\nclass OptGroupElement extends Element native \"HTMLOptGroupElement\" {\n\n  @DomName('HTMLOptGroupElement.HTMLOptGroupElement')\n  @DocsEditable\n  factory OptGroupElement() => document.$dom_createElement(\"optgroup\");\n\n  @DomName('HTMLOptGroupElement.disabled')\n  @DocsEditable\n  bool disabled;\n\n  @DomName('HTMLOptGroupElement.label')\n  @DocsEditable\n  String label;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLOptionElement')\nclass OptionElement extends Element native \"HTMLOptionElement\" {\n\n  @DomName('HTMLOptionElement.HTMLOptionElement')\n  @DocsEditable\n  factory OptionElement([String data, String value, bool defaultSelected, bool selected]) {\n    if (?selected) {\n      return OptionElement._create_1(data, value, defaultSelected, selected);\n    }\n    if (?defaultSelected) {\n      return OptionElement._create_2(data, value, defaultSelected);\n    }\n    if (?value) {\n      return OptionElement._create_3(data, value);\n    }\n    if (?data) {\n      return OptionElement._create_4(data);\n    }\n    return OptionElement._create_5();\n  }\n  static OptionElement _create_1(data, value, defaultSelected, selected) => JS('OptionElement', 'new Option(#,#,#,#)', data, value, defaultSelected, selected);\n  static OptionElement _create_2(data, value, defaultSelected) => JS('OptionElement', 'new Option(#,#,#)', data, value, defaultSelected);\n  static OptionElement _create_3(data, value) => JS('OptionElement', 'new Option(#,#)', data, value);\n  static OptionElement _create_4(data) => JS('OptionElement', 'new Option(#)', data);\n  static OptionElement _create_5() => JS('OptionElement', 'new Option()');\n\n  @DomName('HTMLOptionElement.defaultSelected')\n  @DocsEditable\n  bool defaultSelected;\n\n  @DomName('HTMLOptionElement.disabled')\n  @DocsEditable\n  bool disabled;\n\n  @DomName('HTMLOptionElement.form')\n  @DocsEditable\n  final FormElement form;\n\n  @DomName('HTMLOptionElement.index')\n  @DocsEditable\n  final int index;\n\n  @DomName('HTMLOptionElement.label')\n  @DocsEditable\n  String label;\n\n  @DomName('HTMLOptionElement.selected')\n  @DocsEditable\n  bool selected;\n\n  @DomName('HTMLOptionElement.value')\n  @DocsEditable\n  String value;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLOutputElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass OutputElement extends Element native \"HTMLOutputElement\" {\n\n  @DomName('HTMLOutputElement.HTMLOutputElement')\n  @DocsEditable\n  factory OutputElement() => document.$dom_createElement(\"output\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('output');\n\n  @DomName('HTMLOutputElement.defaultValue')\n  @DocsEditable\n  String defaultValue;\n\n  @DomName('HTMLOutputElement.form')\n  @DocsEditable\n  final FormElement form;\n\n  @DomName('HTMLOutputElement.htmlFor')\n  @DocsEditable\n  final DomSettableTokenList htmlFor;\n\n  @DomName('HTMLOutputElement.labels')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLOutputElement.name')\n  @DocsEditable\n  String name;\n\n  @DomName('HTMLOutputElement.type')\n  @DocsEditable\n  final String type;\n\n  @DomName('HTMLOutputElement.validationMessage')\n  @DocsEditable\n  final String validationMessage;\n\n  @DomName('HTMLOutputElement.validity')\n  @DocsEditable\n  final ValidityState validity;\n\n  @DomName('HTMLOutputElement.value')\n  @DocsEditable\n  String value;\n\n  @DomName('HTMLOutputElement.willValidate')\n  @DocsEditable\n  final bool willValidate;\n\n  @DomName('HTMLOutputElement.checkValidity')\n  @DocsEditable\n  bool checkValidity() native;\n\n  @DomName('HTMLOutputElement.setCustomValidity')\n  @DocsEditable\n  void setCustomValidity(String error) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('OverflowEvent')\nclass OverflowEvent extends Event native \"OverflowEvent\" {\n\n  static const int BOTH = 2;\n\n  static const int HORIZONTAL = 0;\n\n  static const int VERTICAL = 1;\n\n  @DomName('OverflowEvent.horizontalOverflow')\n  @DocsEditable\n  final bool horizontalOverflow;\n\n  @DomName('OverflowEvent.orient')\n  @DocsEditable\n  final int orient;\n\n  @DomName('OverflowEvent.verticalOverflow')\n  @DocsEditable\n  final bool verticalOverflow;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('PagePopupController')\nclass PagePopupController native \"PagePopupController\" {\n\n  @DomName('PagePopupController.closePopup')\n  @DocsEditable\n  void closePopup() native;\n\n  @DomName('PagePopupController.formatMonth')\n  @DocsEditable\n  String formatMonth(int year, int zeroBaseMonth) native;\n\n  @DomName('PagePopupController.formatShortMonth')\n  @DocsEditable\n  String formatShortMonth(int year, int zeroBaseMonth) native;\n\n  @DomName('PagePopupController.histogramEnumeration')\n  @DocsEditable\n  void histogramEnumeration(String name, int sample, int boundaryValue) native;\n\n  @DomName('PagePopupController.localizeNumberString')\n  @DocsEditable\n  String localizeNumberString(String numberString) native;\n\n  @DomName('PagePopupController.setValue')\n  @DocsEditable\n  void setValue(String value) native;\n\n  @DomName('PagePopupController.setValueAndClosePopup')\n  @DocsEditable\n  void setValueAndClosePopup(int numberValue, String stringValue) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('PageTransitionEvent')\nclass PageTransitionEvent extends Event native \"PageTransitionEvent\" {\n\n  @DomName('PageTransitionEvent.persisted')\n  @DocsEditable\n  final bool persisted;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLParagraphElement')\nclass ParagraphElement extends Element native \"HTMLParagraphElement\" {\n\n  @DomName('HTMLParagraphElement.HTMLParagraphElement')\n  @DocsEditable\n  factory ParagraphElement() => document.$dom_createElement(\"p\");\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLParamElement')\nclass ParamElement extends Element native \"HTMLParamElement\" {\n\n  @DomName('HTMLParamElement.HTMLParamElement')\n  @DocsEditable\n  factory ParamElement() => document.$dom_createElement(\"param\");\n\n  @DomName('HTMLParamElement.name')\n  @DocsEditable\n  String name;\n\n  @DomName('HTMLParamElement.value')\n  @DocsEditable\n  String value;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Performance')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE)\nclass Performance extends EventTarget native \"Performance\" {\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.performance)');\n\n  @DomName('Performance.memory')\n  @DocsEditable\n  final MemoryInfo memory;\n\n  @DomName('Performance.navigation')\n  @DocsEditable\n  final PerformanceNavigation navigation;\n\n  @DomName('Performance.timing')\n  @DocsEditable\n  final PerformanceTiming timing;\n\n  @DomName('Performance.now')\n  @DocsEditable\n  num now() native;\n\n  @JSName('webkitClearMarks')\n  @DomName('Performance.webkitClearMarks')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void clearMarks(String markName) native;\n\n  @JSName('webkitClearMeasures')\n  @DomName('Performance.webkitClearMeasures')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void clearMeasures(String measureName) native;\n\n  @JSName('webkitClearResourceTimings')\n  @DomName('Performance.webkitClearResourceTimings')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void clearResourceTimings() native;\n\n  @JSName('webkitGetEntries')\n  @DomName('Performance.webkitGetEntries')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  List<PerformanceEntry> getEntries() native;\n\n  @JSName('webkitGetEntriesByName')\n  @DomName('Performance.webkitGetEntriesByName')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  List<PerformanceEntry> getEntriesByName(String name, String entryType) native;\n\n  @JSName('webkitGetEntriesByType')\n  @DomName('Performance.webkitGetEntriesByType')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  List<PerformanceEntry> getEntriesByType(String entryType) native;\n\n  @JSName('webkitMark')\n  @DomName('Performance.webkitMark')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void mark(String markName) native;\n\n  @JSName('webkitMeasure')\n  @DomName('Performance.webkitMeasure')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void measure(String measureName, String startMark, String endMark) native;\n\n  @JSName('webkitSetResourceTimingBufferSize')\n  @DomName('Performance.webkitSetResourceTimingBufferSize')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void setResourceTimingBufferSize(int maxSize) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('PerformanceEntry')\nclass PerformanceEntry native \"PerformanceEntry\" {\n\n  @DomName('PerformanceEntry.duration')\n  @DocsEditable\n  final num duration;\n\n  @DomName('PerformanceEntry.entryType')\n  @DocsEditable\n  final String entryType;\n\n  @DomName('PerformanceEntry.name')\n  @DocsEditable\n  final String name;\n\n  @DomName('PerformanceEntry.startTime')\n  @DocsEditable\n  final num startTime;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('PerformanceEntryList')\nclass PerformanceEntryList native \"PerformanceEntryList\" {\n\n  @DomName('PerformanceEntryList.length')\n  @DocsEditable\n  final int length;\n\n  @DomName('PerformanceEntryList.item')\n  @DocsEditable\n  PerformanceEntry item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('PerformanceMark')\nclass PerformanceMark extends PerformanceEntry native \"PerformanceMark\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('PerformanceMeasure')\nclass PerformanceMeasure extends PerformanceEntry native \"PerformanceMeasure\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('PerformanceNavigation')\nclass PerformanceNavigation native \"PerformanceNavigation\" {\n\n  static const int TYPE_BACK_FORWARD = 2;\n\n  static const int TYPE_NAVIGATE = 0;\n\n  static const int TYPE_RELOAD = 1;\n\n  static const int TYPE_RESERVED = 255;\n\n  @DomName('PerformanceNavigation.redirectCount')\n  @DocsEditable\n  final int redirectCount;\n\n  @DomName('PerformanceNavigation.type')\n  @DocsEditable\n  final int type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('PerformanceResourceTiming')\nclass PerformanceResourceTiming extends PerformanceEntry native \"PerformanceResourceTiming\" {\n\n  @DomName('PerformanceResourceTiming.connectEnd')\n  @DocsEditable\n  final num connectEnd;\n\n  @DomName('PerformanceResourceTiming.connectStart')\n  @DocsEditable\n  final num connectStart;\n\n  @DomName('PerformanceResourceTiming.domainLookupEnd')\n  @DocsEditable\n  final num domainLookupEnd;\n\n  @DomName('PerformanceResourceTiming.domainLookupStart')\n  @DocsEditable\n  final num domainLookupStart;\n\n  @DomName('PerformanceResourceTiming.fetchStart')\n  @DocsEditable\n  final num fetchStart;\n\n  @DomName('PerformanceResourceTiming.initiatorType')\n  @DocsEditable\n  final String initiatorType;\n\n  @DomName('PerformanceResourceTiming.redirectEnd')\n  @DocsEditable\n  final num redirectEnd;\n\n  @DomName('PerformanceResourceTiming.redirectStart')\n  @DocsEditable\n  final num redirectStart;\n\n  @DomName('PerformanceResourceTiming.requestStart')\n  @DocsEditable\n  final num requestStart;\n\n  @DomName('PerformanceResourceTiming.responseEnd')\n  @DocsEditable\n  final num responseEnd;\n\n  @DomName('PerformanceResourceTiming.responseStart')\n  @DocsEditable\n  final num responseStart;\n\n  @DomName('PerformanceResourceTiming.secureConnectionStart')\n  @DocsEditable\n  final num secureConnectionStart;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('PerformanceTiming')\nclass PerformanceTiming native \"PerformanceTiming\" {\n\n  @DomName('PerformanceTiming.connectEnd')\n  @DocsEditable\n  final int connectEnd;\n\n  @DomName('PerformanceTiming.connectStart')\n  @DocsEditable\n  final int connectStart;\n\n  @DomName('PerformanceTiming.domComplete')\n  @DocsEditable\n  final int domComplete;\n\n  @DomName('PerformanceTiming.domContentLoadedEventEnd')\n  @DocsEditable\n  final int domContentLoadedEventEnd;\n\n  @DomName('PerformanceTiming.domContentLoadedEventStart')\n  @DocsEditable\n  final int domContentLoadedEventStart;\n\n  @DomName('PerformanceTiming.domInteractive')\n  @DocsEditable\n  final int domInteractive;\n\n  @DomName('PerformanceTiming.domLoading')\n  @DocsEditable\n  final int domLoading;\n\n  @DomName('PerformanceTiming.domainLookupEnd')\n  @DocsEditable\n  final int domainLookupEnd;\n\n  @DomName('PerformanceTiming.domainLookupStart')\n  @DocsEditable\n  final int domainLookupStart;\n\n  @DomName('PerformanceTiming.fetchStart')\n  @DocsEditable\n  final int fetchStart;\n\n  @DomName('PerformanceTiming.loadEventEnd')\n  @DocsEditable\n  final int loadEventEnd;\n\n  @DomName('PerformanceTiming.loadEventStart')\n  @DocsEditable\n  final int loadEventStart;\n\n  @DomName('PerformanceTiming.navigationStart')\n  @DocsEditable\n  final int navigationStart;\n\n  @DomName('PerformanceTiming.redirectEnd')\n  @DocsEditable\n  final int redirectEnd;\n\n  @DomName('PerformanceTiming.redirectStart')\n  @DocsEditable\n  final int redirectStart;\n\n  @DomName('PerformanceTiming.requestStart')\n  @DocsEditable\n  final int requestStart;\n\n  @DomName('PerformanceTiming.responseEnd')\n  @DocsEditable\n  final int responseEnd;\n\n  @DomName('PerformanceTiming.responseStart')\n  @DocsEditable\n  final int responseStart;\n\n  @DomName('PerformanceTiming.secureConnectionStart')\n  @DocsEditable\n  final int secureConnectionStart;\n\n  @DomName('PerformanceTiming.unloadEventEnd')\n  @DocsEditable\n  final int unloadEventEnd;\n\n  @DomName('PerformanceTiming.unloadEventStart')\n  @DocsEditable\n  final int unloadEventStart;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('PopStateEvent')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass PopStateEvent extends Event native \"PopStateEvent\" {\n\n  dynamic get state => convertNativeToDart_SerializedScriptValue(this._get_state);\n  @JSName('state')\n  @DomName('PopStateEvent.state')\n  @DocsEditable\n  @annotation_Creates_SerializedScriptValue\n  @annotation_Returns_SerializedScriptValue\n  final dynamic _get_state;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void _PositionCallback(Geoposition position);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('PositionError')\nclass PositionError native \"PositionError\" {\n\n  static const int PERMISSION_DENIED = 1;\n\n  static const int POSITION_UNAVAILABLE = 2;\n\n  static const int TIMEOUT = 3;\n\n  @DomName('PositionError.code')\n  @DocsEditable\n  final int code;\n\n  @DomName('PositionError.message')\n  @DocsEditable\n  final String message;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void _PositionErrorCallback(PositionError error);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLPreElement')\nclass PreElement extends Element native \"HTMLPreElement\" {\n\n  @DomName('HTMLPreElement.HTMLPreElement')\n  @DocsEditable\n  factory PreElement() => document.$dom_createElement(\"pre\");\n\n  @DomName('HTMLPreElement.wrap')\n  @DocsEditable\n  bool wrap;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('ProcessingInstruction')\nclass ProcessingInstruction extends Node native \"ProcessingInstruction\" {\n\n  @DomName('ProcessingInstruction.data')\n  @DocsEditable\n  String data;\n\n  @DomName('ProcessingInstruction.sheet')\n  @DocsEditable\n  final StyleSheet sheet;\n\n  @DomName('ProcessingInstruction.target')\n  @DocsEditable\n  final String target;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLProgressElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass ProgressElement extends Element native \"HTMLProgressElement\" {\n\n  @DomName('HTMLProgressElement.HTMLProgressElement')\n  @DocsEditable\n  factory ProgressElement() => document.$dom_createElement(\"progress\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('progress');\n\n  @DomName('HTMLProgressElement.labels')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLProgressElement.max')\n  @DocsEditable\n  num max;\n\n  @DomName('HTMLProgressElement.position')\n  @DocsEditable\n  final num position;\n\n  @DomName('HTMLProgressElement.value')\n  @DocsEditable\n  num value;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('ProgressEvent')\nclass ProgressEvent extends Event native \"ProgressEvent\" {\n\n  @DomName('ProgressEvent.lengthComputable')\n  @DocsEditable\n  final bool lengthComputable;\n\n  @DomName('ProgressEvent.loaded')\n  @DocsEditable\n  final int loaded;\n\n  @DomName('ProgressEvent.total')\n  @DocsEditable\n  final int total;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLQuoteElement')\nclass QuoteElement extends Element native \"HTMLQuoteElement\" {\n\n  @DomName('HTMLQuoteElement.cite')\n  @DocsEditable\n  String cite;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void _RtcErrorCallback(String errorInformation);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void _RtcSessionDescriptionCallback(RtcSessionDescription sdp);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void RtcStatsCallback(RtcStatsResponse response);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('Range')\nclass Range native \"Range\" {\n  factory Range() => document.$dom_createRange();\n\n\n  static const int END_TO_END = 2;\n\n  static const int END_TO_START = 3;\n\n  static const int NODE_AFTER = 1;\n\n  static const int NODE_BEFORE = 0;\n\n  static const int NODE_BEFORE_AND_AFTER = 2;\n\n  static const int NODE_INSIDE = 3;\n\n  static const int START_TO_END = 1;\n\n  static const int START_TO_START = 0;\n\n  @DomName('Range.collapsed')\n  @DocsEditable\n  final bool collapsed;\n\n  @DomName('Range.commonAncestorContainer')\n  @DocsEditable\n  final Node commonAncestorContainer;\n\n  @DomName('Range.endContainer')\n  @DocsEditable\n  final Node endContainer;\n\n  @DomName('Range.endOffset')\n  @DocsEditable\n  final int endOffset;\n\n  @DomName('Range.startContainer')\n  @DocsEditable\n  final Node startContainer;\n\n  @DomName('Range.startOffset')\n  @DocsEditable\n  final int startOffset;\n\n  @DomName('Range.cloneContents')\n  @DocsEditable\n  DocumentFragment cloneContents() native;\n\n  @DomName('Range.cloneRange')\n  @DocsEditable\n  Range cloneRange() native;\n\n  @DomName('Range.collapse')\n  @DocsEditable\n  void collapse(bool toStart) native;\n\n  @DomName('Range.compareNode')\n  @DocsEditable\n  int compareNode(Node refNode) native;\n\n  @DomName('Range.comparePoint')\n  @DocsEditable\n  int comparePoint(Node refNode, int offset) native;\n\n  @DomName('Range.createContextualFragment')\n  @DocsEditable\n  DocumentFragment createContextualFragment(String html) native;\n\n  @DomName('Range.deleteContents')\n  @DocsEditable\n  void deleteContents() native;\n\n  @DomName('Range.detach')\n  @DocsEditable\n  void detach() native;\n\n  @DomName('Range.expand')\n  @DocsEditable\n  void expand(String unit) native;\n\n  @DomName('Range.extractContents')\n  @DocsEditable\n  DocumentFragment extractContents() native;\n\n  @DomName('Range.getBoundingClientRect')\n  @DocsEditable\n  Rect getBoundingClientRect() native;\n\n  @DomName('Range.getClientRects')\n  @DocsEditable\n  @Returns('_ClientRectList')\n  @Creates('_ClientRectList')\n  List<Rect> getClientRects() native;\n\n  @DomName('Range.insertNode')\n  @DocsEditable\n  void insertNode(Node newNode) native;\n\n  @DomName('Range.intersectsNode')\n  @DocsEditable\n  bool intersectsNode(Node refNode) native;\n\n  @DomName('Range.isPointInRange')\n  @DocsEditable\n  bool isPointInRange(Node refNode, int offset) native;\n\n  @DomName('Range.selectNode')\n  @DocsEditable\n  void selectNode(Node refNode) native;\n\n  @DomName('Range.selectNodeContents')\n  @DocsEditable\n  void selectNodeContents(Node refNode) native;\n\n  @DomName('Range.setEnd')\n  @DocsEditable\n  void setEnd(Node refNode, int offset) native;\n\n  @DomName('Range.setEndAfter')\n  @DocsEditable\n  void setEndAfter(Node refNode) native;\n\n  @DomName('Range.setEndBefore')\n  @DocsEditable\n  void setEndBefore(Node refNode) native;\n\n  @DomName('Range.setStart')\n  @DocsEditable\n  void setStart(Node refNode, int offset) native;\n\n  @DomName('Range.setStartAfter')\n  @DocsEditable\n  void setStartAfter(Node refNode) native;\n\n  @DomName('Range.setStartBefore')\n  @DocsEditable\n  void setStartBefore(Node refNode) native;\n\n  @DomName('Range.surroundContents')\n  @DocsEditable\n  void surroundContents(Node newParent) native;\n\n  @DomName('Range.toString')\n  @DocsEditable\n  String toString() native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('RangeException')\nclass RangeException native \"RangeException\" {\n\n  static const int BAD_BOUNDARYPOINTS_ERR = 1;\n\n  static const int INVALID_NODE_TYPE_ERR = 2;\n\n  @DomName('RangeException.code')\n  @DocsEditable\n  final int code;\n\n  @DomName('RangeException.message')\n  @DocsEditable\n  final String message;\n\n  @DomName('RangeException.name')\n  @DocsEditable\n  final String name;\n\n  @DomName('RangeException.toString')\n  @DocsEditable\n  String toString() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void RequestAnimationFrameCallback(num highResTime);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('RTCDataChannel')\nclass RtcDataChannel extends EventTarget native \"RTCDataChannel\" {\n\n  @DomName('RTCDataChannel.closeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> closeEvent = const EventStreamProvider<Event>('close');\n\n  @DomName('RTCDataChannel.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('RTCDataChannel.messageEvent')\n  @DocsEditable\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  @DomName('RTCDataChannel.openEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> openEvent = const EventStreamProvider<Event>('open');\n\n  @DomName('RTCDataChannel.binaryType')\n  @DocsEditable\n  String binaryType;\n\n  @DomName('RTCDataChannel.bufferedAmount')\n  @DocsEditable\n  final int bufferedAmount;\n\n  @DomName('RTCDataChannel.label')\n  @DocsEditable\n  final String label;\n\n  @DomName('RTCDataChannel.readyState')\n  @DocsEditable\n  final String readyState;\n\n  @DomName('RTCDataChannel.reliable')\n  @DocsEditable\n  final bool reliable;\n\n  @JSName('addEventListener')\n  @DomName('RTCDataChannel.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('RTCDataChannel.close')\n  @DocsEditable\n  void close() native;\n\n  @DomName('RTCDataChannel.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event event) native;\n\n  @JSName('removeEventListener')\n  @DomName('RTCDataChannel.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('RTCDataChannel.send')\n  @DocsEditable\n  void send(data) native;\n\n  @DomName('RTCDataChannel.onclose')\n  @DocsEditable\n  Stream<Event> get onClose => closeEvent.forTarget(this);\n\n  @DomName('RTCDataChannel.onerror')\n  @DocsEditable\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  @DomName('RTCDataChannel.onmessage')\n  @DocsEditable\n  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);\n\n  @DomName('RTCDataChannel.onopen')\n  @DocsEditable\n  Stream<Event> get onOpen => openEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('RTCDataChannelEvent')\nclass RtcDataChannelEvent extends Event native \"RTCDataChannelEvent\" {\n\n  @DomName('RTCDataChannelEvent.channel')\n  @DocsEditable\n  final RtcDataChannel channel;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('RTCDTMFSender')\nclass RtcDtmfSender extends EventTarget native \"RTCDTMFSender\" {\n\n  @DomName('RTCDTMFSender.tonechangeEvent')\n  @DocsEditable\n  static const EventStreamProvider<RtcDtmfToneChangeEvent> toneChangeEvent = const EventStreamProvider<RtcDtmfToneChangeEvent>('tonechange');\n\n  @JSName('canInsertDTMF')\n  @DomName('RTCDTMFSender.canInsertDTMF')\n  @DocsEditable\n  final bool canInsertDtmf;\n\n  @DomName('RTCDTMFSender.duration')\n  @DocsEditable\n  final int duration;\n\n  @DomName('RTCDTMFSender.interToneGap')\n  @DocsEditable\n  final int interToneGap;\n\n  @DomName('RTCDTMFSender.toneBuffer')\n  @DocsEditable\n  final String toneBuffer;\n\n  @DomName('RTCDTMFSender.track')\n  @DocsEditable\n  final MediaStreamTrack track;\n\n  @JSName('addEventListener')\n  @DomName('RTCDTMFSender.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('RTCDTMFSender.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event event) native;\n\n  @JSName('insertDTMF')\n  @DomName('RTCDTMFSender.insertDTMF')\n  @DocsEditable\n  void insertDtmf(String tones, [int duration, int interToneGap]) native;\n\n  @JSName('removeEventListener')\n  @DomName('RTCDTMFSender.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('RTCDTMFSender.ontonechange')\n  @DocsEditable\n  Stream<RtcDtmfToneChangeEvent> get onToneChange => toneChangeEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('RTCDTMFToneChangeEvent')\nclass RtcDtmfToneChangeEvent extends Event native \"RTCDTMFToneChangeEvent\" {\n\n  @DomName('RTCDTMFToneChangeEvent.tone')\n  @DocsEditable\n  final String tone;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('RTCIceCandidate')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental\nclass RtcIceCandidate native \"RTCIceCandidate\" {\n  factory RtcIceCandidate(Map dictionary) {\n    return JS('RtcIceCandidate', 'new RTCIceCandidate(#)',\n        convertDartToNative_SerializedScriptValue(dictionary));\n  }\n\n  @DomName('RTCIceCandidate.candidate')\n  @DocsEditable\n  final String candidate;\n\n  @DomName('RTCIceCandidate.sdpMLineIndex')\n  @DocsEditable\n  final int sdpMLineIndex;\n\n  @DomName('RTCIceCandidate.sdpMid')\n  @DocsEditable\n  final String sdpMid;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('RTCIceCandidateEvent')\nclass RtcIceCandidateEvent extends Event native \"RTCIceCandidateEvent\" {\n\n  @DomName('RTCIceCandidateEvent.candidate')\n  @DocsEditable\n  final RtcIceCandidate candidate;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('RTCPeerConnection')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental\nclass RtcPeerConnection extends EventTarget native \"RTCPeerConnection\" {\n  factory RtcPeerConnection(Map rtcIceServers, [Map mediaConstraints]) {\n    var constructorName = JS('RtcPeerConnection', 'window[#]',\n        '${Device.propertyPrefix}RTCPeerConnection');\n    if (?mediaConstraints) {\n      return JS('RtcPeerConnection', 'new #(#,#)', constructorName,\n          convertDartToNative_SerializedScriptValue(rtcIceServers),\n          convertDartToNative_SerializedScriptValue(mediaConstraints));\n    } else {\n      return JS('RtcPeerConnection', 'new #(#)', constructorName,\n          convertDartToNative_SerializedScriptValue(rtcIceServers));\n    }\n  }\n\n  /**\n   * Checks if Real Time Communication (RTC) APIs are supported and enabled on\n   * the current platform.\n   */\n  static bool get supported {\n    // Currently in Firefox some of the RTC elements are defined but throw an\n    // error unless the user has specifically enabled them in their\n    // about:config. So we have to construct an element to actually test if RTC\n    // is supported at at the given time.\n    try {\n      var c = new RtcPeerConnection({\"iceServers\": [ {\"url\":\"stun:foo.com\"}]});\n      return c is RtcPeerConnection;\n    } catch (_) {}\n    return false;\n  }\n  Future<RtcSessionDescription> createOffer([Map mediaConstraints]) {\n    var completer = new Completer<RtcSessionDescription>();\n    _createOffer(\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); }, mediaConstraints);\n    return completer.future;\n  }\n\n  Future<RtcSessionDescription> createAnswer([Map mediaConstraints]) {\n    var completer = new Completer<RtcSessionDescription>();\n    _createAnswer(\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); }, mediaConstraints);\n    return completer.future;\n  }\n\n  @DomName('RTCPeerConnection.addstreamEvent')\n  @DocsEditable\n  static const EventStreamProvider<MediaStreamEvent> addStreamEvent = const EventStreamProvider<MediaStreamEvent>('addstream');\n\n  @DomName('RTCPeerConnection.datachannelEvent')\n  @DocsEditable\n  static const EventStreamProvider<RtcDataChannelEvent> dataChannelEvent = const EventStreamProvider<RtcDataChannelEvent>('datachannel');\n\n  @DomName('RTCPeerConnection.icecandidateEvent')\n  @DocsEditable\n  static const EventStreamProvider<RtcIceCandidateEvent> iceCandidateEvent = const EventStreamProvider<RtcIceCandidateEvent>('icecandidate');\n\n  @DomName('RTCPeerConnection.iceconnectionstatechangeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> iceConnectionStateChangeEvent = const EventStreamProvider<Event>('iceconnectionstatechange');\n\n  @DomName('RTCPeerConnection.negotiationneededEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> negotiationNeededEvent = const EventStreamProvider<Event>('negotiationneeded');\n\n  @DomName('RTCPeerConnection.removestreamEvent')\n  @DocsEditable\n  static const EventStreamProvider<MediaStreamEvent> removeStreamEvent = const EventStreamProvider<MediaStreamEvent>('removestream');\n\n  @DomName('RTCPeerConnection.signalingstatechangeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> signalingStateChangeEvent = const EventStreamProvider<Event>('signalingstatechange');\n\n  @DomName('RTCPeerConnection.iceConnectionState')\n  @DocsEditable\n  final String iceConnectionState;\n\n  @DomName('RTCPeerConnection.iceGatheringState')\n  @DocsEditable\n  final String iceGatheringState;\n\n  @DomName('RTCPeerConnection.localDescription')\n  @DocsEditable\n  final RtcSessionDescription localDescription;\n\n  @DomName('RTCPeerConnection.remoteDescription')\n  @DocsEditable\n  final RtcSessionDescription remoteDescription;\n\n  @DomName('RTCPeerConnection.signalingState')\n  @DocsEditable\n  final String signalingState;\n\n  @JSName('addEventListener')\n  @DomName('RTCPeerConnection.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('RTCPeerConnection.addIceCandidate')\n  @DocsEditable\n  void addIceCandidate(RtcIceCandidate candidate) native;\n\n  @DomName('RTCPeerConnection.addStream')\n  @DocsEditable\n  void addStream(MediaStream stream, [Map mediaConstraints]) {\n    if (?mediaConstraints) {\n      var mediaConstraints_1 = convertDartToNative_Dictionary(mediaConstraints);\n      _addStream_1(stream, mediaConstraints_1);\n      return;\n    }\n    _addStream_2(stream);\n    return;\n  }\n  @JSName('addStream')\n  @DomName('RTCPeerConnection.addStream')\n  @DocsEditable\n  void _addStream_1(MediaStream stream, mediaConstraints) native;\n  @JSName('addStream')\n  @DomName('RTCPeerConnection.addStream')\n  @DocsEditable\n  void _addStream_2(MediaStream stream) native;\n\n  @DomName('RTCPeerConnection.close')\n  @DocsEditable\n  void close() native;\n\n  @DomName('RTCPeerConnection.createAnswer')\n  @DocsEditable\n  void _createAnswer(_RtcSessionDescriptionCallback successCallback, [_RtcErrorCallback failureCallback, Map mediaConstraints]) {\n    if (?mediaConstraints) {\n      var mediaConstraints_1 = convertDartToNative_Dictionary(mediaConstraints);\n      __createAnswer_1(successCallback, failureCallback, mediaConstraints_1);\n      return;\n    }\n    __createAnswer_2(successCallback, failureCallback);\n    return;\n  }\n  @JSName('createAnswer')\n  @DomName('RTCPeerConnection.createAnswer')\n  @DocsEditable\n  void __createAnswer_1(_RtcSessionDescriptionCallback successCallback, _RtcErrorCallback failureCallback, mediaConstraints) native;\n  @JSName('createAnswer')\n  @DomName('RTCPeerConnection.createAnswer')\n  @DocsEditable\n  void __createAnswer_2(_RtcSessionDescriptionCallback successCallback, _RtcErrorCallback failureCallback) native;\n\n  @JSName('createDTMFSender')\n  @DomName('RTCPeerConnection.createDTMFSender')\n  @DocsEditable\n  RtcDtmfSender createDtmfSender(MediaStreamTrack track) native;\n\n  @DomName('RTCPeerConnection.createDataChannel')\n  @DocsEditable\n  RtcDataChannel createDataChannel(String label, [Map options]) {\n    if (?options) {\n      var options_1 = convertDartToNative_Dictionary(options);\n      return _createDataChannel_1(label, options_1);\n    }\n    return _createDataChannel_2(label);\n  }\n  @JSName('createDataChannel')\n  @DomName('RTCPeerConnection.createDataChannel')\n  @DocsEditable\n  RtcDataChannel _createDataChannel_1(label, options) native;\n  @JSName('createDataChannel')\n  @DomName('RTCPeerConnection.createDataChannel')\n  @DocsEditable\n  RtcDataChannel _createDataChannel_2(label) native;\n\n  @DomName('RTCPeerConnection.createOffer')\n  @DocsEditable\n  void _createOffer(_RtcSessionDescriptionCallback successCallback, [_RtcErrorCallback failureCallback, Map mediaConstraints]) {\n    if (?mediaConstraints) {\n      var mediaConstraints_1 = convertDartToNative_Dictionary(mediaConstraints);\n      __createOffer_1(successCallback, failureCallback, mediaConstraints_1);\n      return;\n    }\n    __createOffer_2(successCallback, failureCallback);\n    return;\n  }\n  @JSName('createOffer')\n  @DomName('RTCPeerConnection.createOffer')\n  @DocsEditable\n  void __createOffer_1(_RtcSessionDescriptionCallback successCallback, _RtcErrorCallback failureCallback, mediaConstraints) native;\n  @JSName('createOffer')\n  @DomName('RTCPeerConnection.createOffer')\n  @DocsEditable\n  void __createOffer_2(_RtcSessionDescriptionCallback successCallback, _RtcErrorCallback failureCallback) native;\n\n  @DomName('RTCPeerConnection.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event event) native;\n\n  @DomName('RTCPeerConnection.getLocalStreams')\n  @DocsEditable\n  List<MediaStream> getLocalStreams() native;\n\n  @DomName('RTCPeerConnection.getRemoteStreams')\n  @DocsEditable\n  List<MediaStream> getRemoteStreams() native;\n\n  @DomName('RTCPeerConnection.getStats')\n  @DocsEditable\n  void getStats(RtcStatsCallback successCallback, MediaStreamTrack selector) native;\n\n  @DomName('RTCPeerConnection.getStreamById')\n  @DocsEditable\n  MediaStream getStreamById(String streamId) native;\n\n  @JSName('removeEventListener')\n  @DomName('RTCPeerConnection.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('RTCPeerConnection.removeStream')\n  @DocsEditable\n  void removeStream(MediaStream stream) native;\n\n  @JSName('setLocalDescription')\n  @DomName('RTCPeerConnection.setLocalDescription')\n  @DocsEditable\n  void _setLocalDescription(RtcSessionDescription description, [VoidCallback successCallback, _RtcErrorCallback failureCallback]) native;\n\n  @JSName('setLocalDescription')\n  @DomName('RTCPeerConnection.setLocalDescription')\n  @DocsEditable\n  Future setLocalDescription(RtcSessionDescription description) {\n    var completer = new Completer();\n    _setLocalDescription(description,\n        () { completer.complete(); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('setRemoteDescription')\n  @DomName('RTCPeerConnection.setRemoteDescription')\n  @DocsEditable\n  void _setRemoteDescription(RtcSessionDescription description, [VoidCallback successCallback, _RtcErrorCallback failureCallback]) native;\n\n  @JSName('setRemoteDescription')\n  @DomName('RTCPeerConnection.setRemoteDescription')\n  @DocsEditable\n  Future setRemoteDescription(RtcSessionDescription description) {\n    var completer = new Completer();\n    _setRemoteDescription(description,\n        () { completer.complete(); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @DomName('RTCPeerConnection.updateIce')\n  @DocsEditable\n  void updateIce([Map configuration, Map mediaConstraints]) {\n    if (?mediaConstraints) {\n      var configuration_1 = convertDartToNative_Dictionary(configuration);\n      var mediaConstraints_2 = convertDartToNative_Dictionary(mediaConstraints);\n      _updateIce_1(configuration_1, mediaConstraints_2);\n      return;\n    }\n    if (?configuration) {\n      var configuration_3 = convertDartToNative_Dictionary(configuration);\n      _updateIce_2(configuration_3);\n      return;\n    }\n    _updateIce_3();\n    return;\n  }\n  @JSName('updateIce')\n  @DomName('RTCPeerConnection.updateIce')\n  @DocsEditable\n  void _updateIce_1(configuration, mediaConstraints) native;\n  @JSName('updateIce')\n  @DomName('RTCPeerConnection.updateIce')\n  @DocsEditable\n  void _updateIce_2(configuration) native;\n  @JSName('updateIce')\n  @DomName('RTCPeerConnection.updateIce')\n  @DocsEditable\n  void _updateIce_3() native;\n\n  @DomName('RTCPeerConnection.onaddstream')\n  @DocsEditable\n  Stream<MediaStreamEvent> get onAddStream => addStreamEvent.forTarget(this);\n\n  @DomName('RTCPeerConnection.ondatachannel')\n  @DocsEditable\n  Stream<RtcDataChannelEvent> get onDataChannel => dataChannelEvent.forTarget(this);\n\n  @DomName('RTCPeerConnection.onicecandidate')\n  @DocsEditable\n  Stream<RtcIceCandidateEvent> get onIceCandidate => iceCandidateEvent.forTarget(this);\n\n  @DomName('RTCPeerConnection.oniceconnectionstatechange')\n  @DocsEditable\n  Stream<Event> get onIceConnectionStateChange => iceConnectionStateChangeEvent.forTarget(this);\n\n  @DomName('RTCPeerConnection.onnegotiationneeded')\n  @DocsEditable\n  Stream<Event> get onNegotiationNeeded => negotiationNeededEvent.forTarget(this);\n\n  @DomName('RTCPeerConnection.onremovestream')\n  @DocsEditable\n  Stream<MediaStreamEvent> get onRemoveStream => removeStreamEvent.forTarget(this);\n\n  @DomName('RTCPeerConnection.onsignalingstatechange')\n  @DocsEditable\n  Stream<Event> get onSignalingStateChange => signalingStateChangeEvent.forTarget(this);\n\n}\n\n\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('RTCSessionDescription')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental\nclass RtcSessionDescription native \"RTCSessionDescription\" {\n  factory RtcSessionDescription(Map dictionary) {\n    return JS('RtcSessionDescription', 'new RTCSessionDescription(#)',\n        convertDartToNative_SerializedScriptValue(dictionary));\n  }\n\n  @DomName('RTCSessionDescription.sdp')\n  @DocsEditable\n  String sdp;\n\n  @DomName('RTCSessionDescription.type')\n  @DocsEditable\n  String type;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('RTCStatsReport')\nclass RtcStatsReport native \"RTCStatsReport\" {\n\n  @DomName('RTCStatsReport.id')\n  @DocsEditable\n  final String id;\n\n  @DomName('RTCStatsReport.local')\n  @DocsEditable\n  final RtcStatsReport local;\n\n  @DomName('RTCStatsReport.remote')\n  @DocsEditable\n  final RtcStatsReport remote;\n\n  DateTime get timestamp => _convertNativeToDart_DateTime(this._get_timestamp);\n  @JSName('timestamp')\n  @DomName('RTCStatsReport.timestamp')\n  @DocsEditable\n  final dynamic _get_timestamp;\n\n  @DomName('RTCStatsReport.type')\n  @DocsEditable\n  final String type;\n\n  @DomName('RTCStatsReport.names')\n  @DocsEditable\n  List<String> names() native;\n\n  @DomName('RTCStatsReport.stat')\n  @DocsEditable\n  String stat(String name) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('RTCStatsResponse')\nclass RtcStatsResponse native \"RTCStatsResponse\" {\n\n  @DomName('RTCStatsResponse.namedItem')\n  @DocsEditable\n  RtcStatsReport namedItem(String name) native;\n\n  @DomName('RTCStatsResponse.result')\n  @DocsEditable\n  List<RtcStatsReport> result() native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Screen')\nclass Screen native \"Screen\" {\n\n  @DomName('Screen.availHeight')\n  @DomName('Screen.availLeft')\n  @DomName('Screen.availTop')\n  @DomName('Screen.availWidth')\n  Rect get available => new Rect($dom_availLeft, $dom_availTop, $dom_availWidth,\n      $dom_availHeight);\n\n  @JSName('availHeight')\n  @DomName('Screen.availHeight')\n  @DocsEditable\n  final int $dom_availHeight;\n\n  @JSName('availLeft')\n  @DomName('Screen.availLeft')\n  @DocsEditable\n  final int $dom_availLeft;\n\n  @JSName('availTop')\n  @DomName('Screen.availTop')\n  @DocsEditable\n  final int $dom_availTop;\n\n  @JSName('availWidth')\n  @DomName('Screen.availWidth')\n  @DocsEditable\n  final int $dom_availWidth;\n\n  @DomName('Screen.colorDepth')\n  @DocsEditable\n  final int colorDepth;\n\n  @DomName('Screen.height')\n  @DocsEditable\n  final int height;\n\n  @DomName('Screen.pixelDepth')\n  @DocsEditable\n  final int pixelDepth;\n\n  @DomName('Screen.width')\n  @DocsEditable\n  final int width;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLScriptElement')\nclass ScriptElement extends Element native \"HTMLScriptElement\" {\n\n  @DomName('HTMLScriptElement.HTMLScriptElement')\n  @DocsEditable\n  factory ScriptElement() => document.$dom_createElement(\"script\");\n\n  @DomName('HTMLScriptElement.async')\n  @DocsEditable\n  bool async;\n\n  @DomName('HTMLScriptElement.charset')\n  @DocsEditable\n  String charset;\n\n  @DomName('HTMLScriptElement.crossOrigin')\n  @DocsEditable\n  String crossOrigin;\n\n  @DomName('HTMLScriptElement.defer')\n  @DocsEditable\n  bool defer;\n\n  @DomName('HTMLScriptElement.event')\n  @DocsEditable\n  String event;\n\n  @DomName('HTMLScriptElement.htmlFor')\n  @DocsEditable\n  String htmlFor;\n\n  @DomName('HTMLScriptElement.nonce')\n  @DocsEditable\n  String nonce;\n\n  @DomName('HTMLScriptElement.src')\n  @DocsEditable\n  String src;\n\n  @DomName('HTMLScriptElement.type')\n  @DocsEditable\n  String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('ScriptProfile')\nclass ScriptProfile native \"ScriptProfile\" {\n\n  @DomName('ScriptProfile.head')\n  @DocsEditable\n  final ScriptProfileNode head;\n\n  @DomName('ScriptProfile.idleTime')\n  @DocsEditable\n  final num idleTime;\n\n  @DomName('ScriptProfile.title')\n  @DocsEditable\n  final String title;\n\n  @DomName('ScriptProfile.uid')\n  @DocsEditable\n  final int uid;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('ScriptProfileNode')\nclass ScriptProfileNode native \"ScriptProfileNode\" {\n\n  @JSName('callUID')\n  @DomName('ScriptProfileNode.callUID')\n  @DocsEditable\n  final int callUid;\n\n  @DomName('ScriptProfileNode.functionName')\n  @DocsEditable\n  final String functionName;\n\n  @DomName('ScriptProfileNode.lineNumber')\n  @DocsEditable\n  final int lineNumber;\n\n  @DomName('ScriptProfileNode.numberOfCalls')\n  @DocsEditable\n  final int numberOfCalls;\n\n  @DomName('ScriptProfileNode.selfTime')\n  @DocsEditable\n  final num selfTime;\n\n  @DomName('ScriptProfileNode.totalTime')\n  @DocsEditable\n  final num totalTime;\n\n  @DomName('ScriptProfileNode.url')\n  @DocsEditable\n  final String url;\n\n  @DomName('ScriptProfileNode.visible')\n  @DocsEditable\n  final bool visible;\n\n  @DomName('ScriptProfileNode.children')\n  @DocsEditable\n  List<ScriptProfileNode> children() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SecurityPolicyViolationEvent')\nclass SecurityPolicyViolationEvent extends Event native \"SecurityPolicyViolationEvent\" {\n\n  @JSName('blockedURI')\n  @DomName('SecurityPolicyViolationEvent.blockedURI')\n  @DocsEditable\n  final String blockedUri;\n\n  @JSName('documentURI')\n  @DomName('SecurityPolicyViolationEvent.documentURI')\n  @DocsEditable\n  final String documentUri;\n\n  @DomName('SecurityPolicyViolationEvent.effectiveDirective')\n  @DocsEditable\n  final String effectiveDirective;\n\n  @DomName('SecurityPolicyViolationEvent.lineNumber')\n  @DocsEditable\n  final int lineNumber;\n\n  @DomName('SecurityPolicyViolationEvent.originalPolicy')\n  @DocsEditable\n  final String originalPolicy;\n\n  @DomName('SecurityPolicyViolationEvent.referrer')\n  @DocsEditable\n  final String referrer;\n\n  @DomName('SecurityPolicyViolationEvent.sourceFile')\n  @DocsEditable\n  final String sourceFile;\n\n  @DomName('SecurityPolicyViolationEvent.violatedDirective')\n  @DocsEditable\n  final String violatedDirective;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('HTMLSelectElement')\nclass SelectElement extends Element native \"HTMLSelectElement\" {\n\n  @DomName('HTMLSelectElement.HTMLSelectElement')\n  @DocsEditable\n  factory SelectElement() => document.$dom_createElement(\"select\");\n\n  @DomName('HTMLSelectElement.autofocus')\n  @DocsEditable\n  bool autofocus;\n\n  @DomName('HTMLSelectElement.disabled')\n  @DocsEditable\n  bool disabled;\n\n  @DomName('HTMLSelectElement.form')\n  @DocsEditable\n  final FormElement form;\n\n  @DomName('HTMLSelectElement.labels')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLSelectElement.length')\n  @DocsEditable\n  int length;\n\n  @DomName('HTMLSelectElement.multiple')\n  @DocsEditable\n  bool multiple;\n\n  @DomName('HTMLSelectElement.name')\n  @DocsEditable\n  String name;\n\n  @DomName('HTMLSelectElement.required')\n  @DocsEditable\n  bool required;\n\n  @DomName('HTMLSelectElement.selectedIndex')\n  @DocsEditable\n  int selectedIndex;\n\n  @DomName('HTMLSelectElement.size')\n  @DocsEditable\n  int size;\n\n  @DomName('HTMLSelectElement.type')\n  @DocsEditable\n  final String type;\n\n  @DomName('HTMLSelectElement.validationMessage')\n  @DocsEditable\n  final String validationMessage;\n\n  @DomName('HTMLSelectElement.validity')\n  @DocsEditable\n  final ValidityState validity;\n\n  @DomName('HTMLSelectElement.value')\n  @DocsEditable\n  String value;\n\n  @DomName('HTMLSelectElement.willValidate')\n  @DocsEditable\n  final bool willValidate;\n\n  @DomName('HTMLSelectElement.checkValidity')\n  @DocsEditable\n  bool checkValidity() native;\n\n  @DomName('HTMLSelectElement.item')\n  @DocsEditable\n  Node item(int index) native;\n\n  @DomName('HTMLSelectElement.namedItem')\n  @DocsEditable\n  Node namedItem(String name) native;\n\n  @DomName('HTMLSelectElement.setCustomValidity')\n  @DocsEditable\n  void setCustomValidity(String error) native;\n\n\n  // Override default options, since IE returns SelectElement itself and it\n  // does not operate as a List.\n  List<OptionElement> get options {\n    var options = this.children.where((e) => e is OptionElement).toList();\n    return new UnmodifiableListView<OptionElement>(options);\n  }\n\n  List<OptionElement> get selectedOptions {\n    // IE does not change the selected flag for single-selection items.\n    if (this.multiple) {\n      var options = this.options.where((o) => o.selected).toList();\n      return new UnmodifiableListView<OptionElement>(options);\n    } else {\n      return [this.options[this.selectedIndex]];\n    }\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLShadowElement')\n@SupportedBrowser(SupportedBrowser.CHROME, '26')\n@Experimental\nclass ShadowElement extends Element native \"HTMLShadowElement\" {\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('shadow');\n\n  @DomName('HTMLShadowElement.olderShadowRoot')\n  @DocsEditable\n  final ShadowRoot olderShadowRoot;\n\n  @DomName('HTMLShadowElement.resetStyleInheritance')\n  @DocsEditable\n  bool resetStyleInheritance;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('ShadowRoot')\n@SupportedBrowser(SupportedBrowser.CHROME, '26')\n@Experimental\nclass ShadowRoot extends DocumentFragment native \"ShadowRoot\" {\n\n  @DomName('ShadowRoot.activeElement')\n  @DocsEditable\n  final Element activeElement;\n\n  @DomName('ShadowRoot.applyAuthorStyles')\n  @DocsEditable\n  bool applyAuthorStyles;\n\n  @JSName('innerHTML')\n  @DomName('ShadowRoot.innerHTML')\n  @DocsEditable\n  String innerHtml;\n\n  @DomName('ShadowRoot.resetStyleInheritance')\n  @DocsEditable\n  bool resetStyleInheritance;\n\n  @JSName('cloneNode')\n  @DomName('ShadowRoot.cloneNode')\n  @DocsEditable\n  Node clone(bool deep) native;\n\n  @DomName('ShadowRoot.elementFromPoint')\n  @DocsEditable\n  Element elementFromPoint(int x, int y) native;\n\n  @DomName('ShadowRoot.getElementById')\n  @DocsEditable\n  Element getElementById(String elementId) native;\n\n  @DomName('ShadowRoot.getElementsByClassName')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getElementsByClassName(String className) native;\n\n  @DomName('ShadowRoot.getElementsByTagName')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getElementsByTagName(String tagName) native;\n\n  @DomName('ShadowRoot.getSelection')\n  @DocsEditable\n  DomSelection getSelection() native;\n\n  static bool get supported =>\n      JS('bool', '!!(Element.prototype.webkitCreateShadowRoot)');\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SourceBuffer')\nclass SourceBuffer native \"SourceBuffer\" {\n\n  @DomName('SourceBuffer.buffered')\n  @DocsEditable\n  final TimeRanges buffered;\n\n  @DomName('SourceBuffer.timestampOffset')\n  @DocsEditable\n  num timestampOffset;\n\n  @DomName('SourceBuffer.abort')\n  @DocsEditable\n  void abort() native;\n\n  @DomName('SourceBuffer.append')\n  @DocsEditable\n  void append(Uint8List data) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SourceBufferList')\nclass SourceBufferList extends EventTarget implements JavaScriptIndexingBehavior, List<SourceBuffer> native \"SourceBufferList\" {\n\n  @DomName('SourceBufferList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  SourceBuffer operator[](int index) => JS(\"SourceBuffer\", \"#[#]\", this, index);\n\n  void operator[]=(int index, SourceBuffer value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<SourceBuffer> mixins.\n  // SourceBuffer is the element type.\n\n  // From Iterable<SourceBuffer>:\n\n  Iterator<SourceBuffer> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<SourceBuffer>(this);\n  }\n\n  SourceBuffer reduce(SourceBuffer combine(SourceBuffer value, SourceBuffer element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, SourceBuffer element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(SourceBuffer element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(SourceBuffer element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(SourceBuffer element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<SourceBuffer> where(bool f(SourceBuffer element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(SourceBuffer element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(SourceBuffer element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(SourceBuffer element)) => IterableMixinWorkaround.any(this, f);\n\n  List<SourceBuffer> toList({ bool growable: true }) =>\n      new List<SourceBuffer>.from(this, growable: growable);\n\n  Set<SourceBuffer> toSet() => new Set<SourceBuffer>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<SourceBuffer> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<SourceBuffer> takeWhile(bool test(SourceBuffer value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<SourceBuffer> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<SourceBuffer> skipWhile(bool test(SourceBuffer value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  SourceBuffer firstWhere(bool test(SourceBuffer value), { SourceBuffer orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  SourceBuffer lastWhere(bool test(SourceBuffer value), {SourceBuffer orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  SourceBuffer singleWhere(bool test(SourceBuffer value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  SourceBuffer elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<SourceBuffer>:\n\n  void add(SourceBuffer value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<SourceBuffer> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<SourceBuffer>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<SourceBuffer> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(SourceBuffer a, SourceBuffer b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(SourceBuffer element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(SourceBuffer element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  SourceBuffer get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  SourceBuffer get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  SourceBuffer get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, SourceBuffer element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<SourceBuffer> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<SourceBuffer> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  SourceBuffer removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  SourceBuffer removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(SourceBuffer element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(SourceBuffer element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<SourceBuffer> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<SourceBuffer> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [SourceBuffer fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<SourceBuffer> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<SourceBuffer> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <SourceBuffer>[]);\n  }\n\n  Map<int, SourceBuffer> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<SourceBuffer> mixins.\n\n  @JSName('addEventListener')\n  @DomName('SourceBufferList.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('SourceBufferList.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event event) native;\n\n  @DomName('SourceBufferList.item')\n  @DocsEditable\n  SourceBuffer item(int index) native;\n\n  @JSName('removeEventListener')\n  @DomName('SourceBufferList.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLSourceElement')\nclass SourceElement extends Element native \"HTMLSourceElement\" {\n\n  @DomName('HTMLSourceElement.HTMLSourceElement')\n  @DocsEditable\n  factory SourceElement() => document.$dom_createElement(\"source\");\n\n  @DomName('HTMLSourceElement.media')\n  @DocsEditable\n  String media;\n\n  @DomName('HTMLSourceElement.src')\n  @DocsEditable\n  String src;\n\n  @DomName('HTMLSourceElement.type')\n  @DocsEditable\n  String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLSpanElement')\nclass SpanElement extends Element native \"HTMLSpanElement\" {\n\n  @DomName('HTMLSpanElement.HTMLSpanElement')\n  @DocsEditable\n  factory SpanElement() => document.$dom_createElement(\"span\");\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SpeechGrammar')\nclass SpeechGrammar native \"SpeechGrammar\" {\n\n  @DomName('SpeechGrammar.SpeechGrammar')\n  @DocsEditable\n  factory SpeechGrammar() {\n    return SpeechGrammar._create_1();\n  }\n  static SpeechGrammar _create_1() => JS('SpeechGrammar', 'new SpeechGrammar()');\n\n  @DomName('SpeechGrammar.src')\n  @DocsEditable\n  String src;\n\n  @DomName('SpeechGrammar.weight')\n  @DocsEditable\n  num weight;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SpeechGrammarList')\nclass SpeechGrammarList implements JavaScriptIndexingBehavior, List<SpeechGrammar> native \"SpeechGrammarList\" {\n\n  @DomName('SpeechGrammarList.SpeechGrammarList')\n  @DocsEditable\n  factory SpeechGrammarList() {\n    return SpeechGrammarList._create_1();\n  }\n  static SpeechGrammarList _create_1() => JS('SpeechGrammarList', 'new SpeechGrammarList()');\n\n  @DomName('SpeechGrammarList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  SpeechGrammar operator[](int index) => JS(\"SpeechGrammar\", \"#[#]\", this, index);\n\n  void operator[]=(int index, SpeechGrammar value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<SpeechGrammar> mixins.\n  // SpeechGrammar is the element type.\n\n  // From Iterable<SpeechGrammar>:\n\n  Iterator<SpeechGrammar> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<SpeechGrammar>(this);\n  }\n\n  SpeechGrammar reduce(SpeechGrammar combine(SpeechGrammar value, SpeechGrammar element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, SpeechGrammar element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(SpeechGrammar element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(SpeechGrammar element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(SpeechGrammar element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<SpeechGrammar> where(bool f(SpeechGrammar element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(SpeechGrammar element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(SpeechGrammar element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(SpeechGrammar element)) => IterableMixinWorkaround.any(this, f);\n\n  List<SpeechGrammar> toList({ bool growable: true }) =>\n      new List<SpeechGrammar>.from(this, growable: growable);\n\n  Set<SpeechGrammar> toSet() => new Set<SpeechGrammar>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<SpeechGrammar> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<SpeechGrammar> takeWhile(bool test(SpeechGrammar value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<SpeechGrammar> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<SpeechGrammar> skipWhile(bool test(SpeechGrammar value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  SpeechGrammar firstWhere(bool test(SpeechGrammar value), { SpeechGrammar orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  SpeechGrammar lastWhere(bool test(SpeechGrammar value), {SpeechGrammar orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  SpeechGrammar singleWhere(bool test(SpeechGrammar value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  SpeechGrammar elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<SpeechGrammar>:\n\n  void add(SpeechGrammar value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<SpeechGrammar> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<SpeechGrammar>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<SpeechGrammar> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(SpeechGrammar a, SpeechGrammar b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(SpeechGrammar element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(SpeechGrammar element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  SpeechGrammar get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  SpeechGrammar get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  SpeechGrammar get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, SpeechGrammar element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<SpeechGrammar> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<SpeechGrammar> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  SpeechGrammar removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  SpeechGrammar removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(SpeechGrammar element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(SpeechGrammar element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<SpeechGrammar> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<SpeechGrammar> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [SpeechGrammar fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<SpeechGrammar> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<SpeechGrammar> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <SpeechGrammar>[]);\n  }\n\n  Map<int, SpeechGrammar> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<SpeechGrammar> mixins.\n\n  @DomName('SpeechGrammarList.addFromString')\n  @DocsEditable\n  void addFromString(String string, [num weight]) native;\n\n  @DomName('SpeechGrammarList.addFromUri')\n  @DocsEditable\n  void addFromUri(String src, [num weight]) native;\n\n  @DomName('SpeechGrammarList.item')\n  @DocsEditable\n  SpeechGrammar item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SpeechInputEvent')\nclass SpeechInputEvent extends Event native \"SpeechInputEvent\" {\n\n  @DomName('SpeechInputEvent.results')\n  @DocsEditable\n  @Returns('_SpeechInputResultList')\n  @Creates('_SpeechInputResultList')\n  final List<SpeechInputResult> results;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SpeechInputResult')\nclass SpeechInputResult native \"SpeechInputResult\" {\n\n  @DomName('SpeechInputResult.confidence')\n  @DocsEditable\n  final num confidence;\n\n  @DomName('SpeechInputResult.utterance')\n  @DocsEditable\n  final String utterance;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('SpeechRecognition')\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental\nclass SpeechRecognition extends EventTarget native \"SpeechRecognition\" {\n\n  @DomName('SpeechRecognition.audioendEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> audioEndEvent = const EventStreamProvider<Event>('audioend');\n\n  @DomName('SpeechRecognition.audiostartEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> audioStartEvent = const EventStreamProvider<Event>('audiostart');\n\n  @DomName('SpeechRecognition.endEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> endEvent = const EventStreamProvider<Event>('end');\n\n  @DomName('SpeechRecognition.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<SpeechRecognitionError> errorEvent = const EventStreamProvider<SpeechRecognitionError>('error');\n\n  @DomName('SpeechRecognition.nomatchEvent')\n  @DocsEditable\n  static const EventStreamProvider<SpeechRecognitionEvent> noMatchEvent = const EventStreamProvider<SpeechRecognitionEvent>('nomatch');\n\n  @DomName('SpeechRecognition.resultEvent')\n  @DocsEditable\n  static const EventStreamProvider<SpeechRecognitionEvent> resultEvent = const EventStreamProvider<SpeechRecognitionEvent>('result');\n\n  @DomName('SpeechRecognition.soundendEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> soundEndEvent = const EventStreamProvider<Event>('soundend');\n\n  @DomName('SpeechRecognition.soundstartEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> soundStartEvent = const EventStreamProvider<Event>('soundstart');\n\n  @DomName('SpeechRecognition.speechendEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> speechEndEvent = const EventStreamProvider<Event>('speechend');\n\n  @DomName('SpeechRecognition.speechstartEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> speechStartEvent = const EventStreamProvider<Event>('speechstart');\n\n  @DomName('SpeechRecognition.startEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> startEvent = const EventStreamProvider<Event>('start');\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.SpeechRecognition || window.webkitSpeechRecognition)');\n\n  @DomName('SpeechRecognition.continuous')\n  @DocsEditable\n  bool continuous;\n\n  @DomName('SpeechRecognition.grammars')\n  @DocsEditable\n  SpeechGrammarList grammars;\n\n  @DomName('SpeechRecognition.interimResults')\n  @DocsEditable\n  bool interimResults;\n\n  @DomName('SpeechRecognition.lang')\n  @DocsEditable\n  String lang;\n\n  @DomName('SpeechRecognition.maxAlternatives')\n  @DocsEditable\n  int maxAlternatives;\n\n  @DomName('SpeechRecognition.abort')\n  @DocsEditable\n  void abort() native;\n\n  @JSName('addEventListener')\n  @DomName('SpeechRecognition.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('SpeechRecognition.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @JSName('removeEventListener')\n  @DomName('SpeechRecognition.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('SpeechRecognition.start')\n  @DocsEditable\n  void start() native;\n\n  @DomName('SpeechRecognition.stop')\n  @DocsEditable\n  void stop() native;\n\n  @DomName('SpeechRecognition.onaudioend')\n  @DocsEditable\n  Stream<Event> get onAudioEnd => audioEndEvent.forTarget(this);\n\n  @DomName('SpeechRecognition.onaudiostart')\n  @DocsEditable\n  Stream<Event> get onAudioStart => audioStartEvent.forTarget(this);\n\n  @DomName('SpeechRecognition.onend')\n  @DocsEditable\n  Stream<Event> get onEnd => endEvent.forTarget(this);\n\n  @DomName('SpeechRecognition.onerror')\n  @DocsEditable\n  Stream<SpeechRecognitionError> get onError => errorEvent.forTarget(this);\n\n  @DomName('SpeechRecognition.onnomatch')\n  @DocsEditable\n  Stream<SpeechRecognitionEvent> get onNoMatch => noMatchEvent.forTarget(this);\n\n  @DomName('SpeechRecognition.onresult')\n  @DocsEditable\n  Stream<SpeechRecognitionEvent> get onResult => resultEvent.forTarget(this);\n\n  @DomName('SpeechRecognition.onsoundend')\n  @DocsEditable\n  Stream<Event> get onSoundEnd => soundEndEvent.forTarget(this);\n\n  @DomName('SpeechRecognition.onsoundstart')\n  @DocsEditable\n  Stream<Event> get onSoundStart => soundStartEvent.forTarget(this);\n\n  @DomName('SpeechRecognition.onspeechend')\n  @DocsEditable\n  Stream<Event> get onSpeechEnd => speechEndEvent.forTarget(this);\n\n  @DomName('SpeechRecognition.onspeechstart')\n  @DocsEditable\n  Stream<Event> get onSpeechStart => speechStartEvent.forTarget(this);\n\n  @DomName('SpeechRecognition.onstart')\n  @DocsEditable\n  Stream<Event> get onStart => startEvent.forTarget(this);\n\n  factory SpeechRecognition() {\n    return JS('SpeechRecognition',\n        'new (window.SpeechRecognition || window.webkitSpeechRecognition)()');\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SpeechRecognitionAlternative')\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental\nclass SpeechRecognitionAlternative native \"SpeechRecognitionAlternative\" {\n\n  @DomName('SpeechRecognitionAlternative.confidence')\n  @DocsEditable\n  final num confidence;\n\n  @DomName('SpeechRecognitionAlternative.transcript')\n  @DocsEditable\n  final String transcript;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SpeechRecognitionError')\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental\nclass SpeechRecognitionError extends Event native \"SpeechRecognitionError\" {\n\n  @DomName('SpeechRecognitionError.error')\n  @DocsEditable\n  final String error;\n\n  @DomName('SpeechRecognitionError.message')\n  @DocsEditable\n  final String message;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SpeechRecognitionEvent')\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental\nclass SpeechRecognitionEvent extends Event native \"SpeechRecognitionEvent\" {\n\n  @DomName('SpeechRecognitionEvent.emma')\n  @DocsEditable\n  final Document emma;\n\n  @DomName('SpeechRecognitionEvent.interpretation')\n  @DocsEditable\n  final Document interpretation;\n\n  @DomName('SpeechRecognitionEvent.resultIndex')\n  @DocsEditable\n  final int resultIndex;\n\n  @DomName('SpeechRecognitionEvent.results')\n  @DocsEditable\n  @Returns('_SpeechRecognitionResultList')\n  @Creates('_SpeechRecognitionResultList')\n  final List<SpeechRecognitionResult> results;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SpeechRecognitionResult')\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental\nclass SpeechRecognitionResult native \"SpeechRecognitionResult\" {\n\n  @DomName('SpeechRecognitionResult.isFinal')\n  @DocsEditable\n  final bool isFinal;\n\n  @DomName('SpeechRecognitionResult.length')\n  @DocsEditable\n  final int length;\n\n  @DomName('SpeechRecognitionResult.item')\n  @DocsEditable\n  SpeechRecognitionAlternative item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * The type used by the\n * [Window.localStorage] and [Window.sessionStorage] properties.\n * Storage is implemented as a Map&lt;String, String>.\n *\n * To store and get values, use Dart's built-in map syntax:\n *\n *     window.localStorage['key1'] = 'val1';\n *     window.localStorage['key2'] = 'val2';\n *     window.localStorage['key3'] = 'val3';\n *     assert(window.localStorage['key3'] == 'val3');\n *\n * You can use [Map](http://api.dartlang.org/dart_core/Map.html) APIs\n * such as containsValue(), clear(), and length:\n *\n *     assert(window.localStorage.containsValue('does not exist') == false);\n *     window.localStorage.clear();\n *     assert(window.localStorage.length == 0);\n *\n * For more examples of using this API, see\n * [localstorage_test.dart](http://code.google.com/p/dart/source/browse/branches/bleeding_edge/dart/tests/html/localstorage_test.dart).\n * For details on using the Map API, see the\n * [Maps](http://www.dartlang.org/docs/library-tour/#maps-aka-dictionaries-or-hashes)\n * section of the library tour.\n */\n@DomName('Storage')\nclass Storage implements Map<String, String>\n     native \"Storage\" {\n\n  // TODO(nweiz): update this when maps support lazy iteration\n  bool containsValue(String value) => values.any((e) => e == value);\n\n  bool containsKey(String key) => $dom_getItem(key) != null;\n\n  String operator [](String key) => $dom_getItem(key);\n\n  void operator []=(String key, String value) { $dom_setItem(key, value); }\n\n  String putIfAbsent(String key, String ifAbsent()) {\n    if (!containsKey(key)) this[key] = ifAbsent();\n    return this[key];\n  }\n\n  String remove(String key) {\n    final value = this[key];\n    $dom_removeItem(key);\n    return value;\n  }\n\n  void clear() => $dom_clear();\n\n  void forEach(void f(String key, String value)) {\n    for (var i = 0; true; i++) {\n      final key = $dom_key(i);\n      if (key == null) return;\n\n      f(key, this[key]);\n    }\n  }\n\n  Iterable<String> get keys {\n    final keys = [];\n    forEach((k, v) => keys.add(k));\n    return keys;\n  }\n\n  Iterable<String> get values {\n    final values = [];\n    forEach((k, v) => values.add(v));\n    return values;\n  }\n\n  int get length => $dom_length;\n\n  bool get isEmpty => $dom_key(0) == null;\n\n  @JSName('length')\n  @DomName('Storage.length')\n  @DocsEditable\n  final int $dom_length;\n\n  @JSName('clear')\n  @DomName('Storage.clear')\n  @DocsEditable\n  void $dom_clear() native;\n\n  @JSName('getItem')\n  @DomName('Storage.getItem')\n  @DocsEditable\n  String $dom_getItem(String key) native;\n\n  @JSName('key')\n  @DomName('Storage.key')\n  @DocsEditable\n  String $dom_key(int index) native;\n\n  @JSName('removeItem')\n  @DomName('Storage.removeItem')\n  @DocsEditable\n  void $dom_removeItem(String key) native;\n\n  @JSName('setItem')\n  @DomName('Storage.setItem')\n  @DocsEditable\n  void $dom_setItem(String key, String data) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void StorageErrorCallback(DomException error);\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('StorageEvent')\nclass StorageEvent extends Event native \"StorageEvent\" {\n  factory StorageEvent(String type,\n    {bool canBubble: false, bool cancelable: false, String key, String oldValue,\n    String newValue, String url, Storage storageArea}) {\n\n    var e = document.$dom_createEvent(\"StorageEvent\");\n    e.$dom_initStorageEvent(type, canBubble, cancelable, key, oldValue,\n        newValue, url, storageArea);\n    return e;\n  }\n\n  @DomName('StorageEvent.key')\n  @DocsEditable\n  final String key;\n\n  @DomName('StorageEvent.newValue')\n  @DocsEditable\n  final String newValue;\n\n  @DomName('StorageEvent.oldValue')\n  @DocsEditable\n  final String oldValue;\n\n  @DomName('StorageEvent.storageArea')\n  @DocsEditable\n  final Storage storageArea;\n\n  @DomName('StorageEvent.url')\n  @DocsEditable\n  final String url;\n\n  @JSName('initStorageEvent')\n  @DomName('StorageEvent.initStorageEvent')\n  @DocsEditable\n  void $dom_initStorageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String keyArg, String oldValueArg, String newValueArg, String urlArg, Storage storageAreaArg) native;\n\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('StorageInfo')\nclass StorageInfo native \"StorageInfo\" {\n\n  static const int PERSISTENT = 1;\n\n  static const int TEMPORARY = 0;\n\n  @JSName('queryUsageAndQuota')\n  @DomName('StorageInfo.queryUsageAndQuota')\n  @DocsEditable\n  void _queryUsageAndQuota(int storageType, [StorageUsageCallback usageCallback, StorageErrorCallback errorCallback]) native;\n\n  @JSName('requestQuota')\n  @DomName('StorageInfo.requestQuota')\n  @DocsEditable\n  void _requestQuota(int storageType, int newQuotaInBytes, [StorageQuotaCallback quotaCallback, StorageErrorCallback errorCallback]) native;\n\n  @JSName('requestQuota')\n  @DomName('StorageInfo.requestQuota')\n  @DocsEditable\n  Future<int> requestQuota(int storageType, int newQuotaInBytes) {\n    var completer = new Completer<int>();\n    _requestQuota(storageType, newQuotaInBytes,\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  Future<StorageInfoUsage> queryUsageAndQuota(int storageType) {\n    var completer = new Completer<StorageInfoUsage>();\n    _queryUsageAndQuota(storageType,\n        (currentUsageInBytes, currentQuotaInBytes) { \n          completer.complete(new StorageInfoUsage(currentUsageInBytes, \n              currentQuotaInBytes));\n        },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n}\n\n/** \n * A simple container class for the two values that are returned from the\n * futures in requestQuota and queryUsageAndQuota.\n */\nclass StorageInfoUsage {\n  final int currentUsageInBytes;\n  final int currentQuotaInBytes;\n  const StorageInfoUsage(this.currentUsageInBytes, this.currentQuotaInBytes);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('StorageQuota')\nclass StorageQuota native \"StorageQuota\" {\n\n  @DomName('StorageQuota.queryUsageAndQuota')\n  @DocsEditable\n  void queryUsageAndQuota(StorageUsageCallback usageCallback, [StorageErrorCallback errorCallback]) native;\n\n  @DomName('StorageQuota.requestQuota')\n  @DocsEditable\n  void requestQuota(int newQuotaInBytes, [StorageQuotaCallback quotaCallback, StorageErrorCallback errorCallback]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void StorageQuotaCallback(int grantedQuotaInBytes);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void StorageUsageCallback(int currentUsageInBytes, int currentQuotaInBytes);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void _StringCallback(String data);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLStyleElement')\nclass StyleElement extends Element native \"HTMLStyleElement\" {\n\n  @DomName('HTMLStyleElement.HTMLStyleElement')\n  @DocsEditable\n  factory StyleElement() => document.$dom_createElement(\"style\");\n\n  @DomName('HTMLStyleElement.disabled')\n  @DocsEditable\n  bool disabled;\n\n  @DomName('HTMLStyleElement.media')\n  @DocsEditable\n  String media;\n\n  @DomName('HTMLStyleElement.scoped')\n  @DocsEditable\n  bool scoped;\n\n  @DomName('HTMLStyleElement.sheet')\n  @DocsEditable\n  final StyleSheet sheet;\n\n  @DomName('HTMLStyleElement.type')\n  @DocsEditable\n  String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('StyleMedia')\nclass StyleMedia native \"StyleMedia\" {\n\n  @DomName('StyleMedia.type')\n  @DocsEditable\n  final String type;\n\n  @DomName('StyleMedia.matchMedium')\n  @DocsEditable\n  bool matchMedium(String mediaquery) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('StyleSheet')\nclass StyleSheet native \"StyleSheet\" {\n\n  @DomName('StyleSheet.disabled')\n  @DocsEditable\n  bool disabled;\n\n  @DomName('StyleSheet.href')\n  @DocsEditable\n  final String href;\n\n  @DomName('StyleSheet.media')\n  @DocsEditable\n  final MediaList media;\n\n  @DomName('StyleSheet.ownerNode')\n  @DocsEditable\n  final Node ownerNode;\n\n  @DomName('StyleSheet.parentStyleSheet')\n  @DocsEditable\n  final StyleSheet parentStyleSheet;\n\n  @DomName('StyleSheet.title')\n  @DocsEditable\n  final String title;\n\n  @DomName('StyleSheet.type')\n  @DocsEditable\n  final String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLTableCaptionElement')\nclass TableCaptionElement extends Element native \"HTMLTableCaptionElement\" {\n\n  @DomName('HTMLTableCaptionElement.HTMLTableCaptionElement')\n  @DocsEditable\n  factory TableCaptionElement() => document.$dom_createElement(\"caption\");\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLTableCellElement')\nclass TableCellElement extends Element native \"HTMLTableCellElement\" {\n\n  @DomName('HTMLTableCellElement.HTMLTableCellElement')\n  @DocsEditable\n  factory TableCellElement() => document.$dom_createElement(\"td\");\n\n  @DomName('HTMLTableCellElement.cellIndex')\n  @DocsEditable\n  final int cellIndex;\n\n  @DomName('HTMLTableCellElement.colSpan')\n  @DocsEditable\n  int colSpan;\n\n  @DomName('HTMLTableCellElement.headers')\n  @DocsEditable\n  String headers;\n\n  @DomName('HTMLTableCellElement.rowSpan')\n  @DocsEditable\n  int rowSpan;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLTableColElement')\nclass TableColElement extends Element native \"HTMLTableColElement\" {\n\n  @DomName('HTMLTableColElement.HTMLTableColElement')\n  @DocsEditable\n  factory TableColElement() => document.$dom_createElement(\"col\");\n\n  @DomName('HTMLTableColElement.span')\n  @DocsEditable\n  int span;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLTableElement')\nclass TableElement extends Element native \"HTMLTableElement\" {\n\n  @DomName('HTMLTableElement.tBodies')\n  List<TableSectionElement> get tBodies =>\n  new _WrappedList<TableSectionElement>($dom_tBodies);\n\n  @DomName('HTMLTableElement.rows')\n  List<TableRowElement> get rows =>\n      new _WrappedList<TableRowElement>($dom_rows);\n\n  TableRowElement addRow() {\n    return insertRow(-1);\n  }\n\n  TableCaptionElement createCaption() => $dom_createCaption();\n  TableSectionElement createTBody() => $dom_createTBody();\n  TableSectionElement createTFoot() => $dom_createTFoot();\n  TableSectionElement createTHead() => $dom_createTHead();\n  TableRowElement insertRow(int index) => $dom_insertRow(index);\n\n  TableSectionElement $dom_createTBody() {\n    if (JS('bool', '!!#.createTBody', this)) {\n      return this._createTBody();\n    }\n    var tbody = new Element.tag('tbody');\n    this.children.add(tbody);\n    return tbody;\n  }\n\n  @JSName('createTBody')\n  TableSectionElement _createTBody() native;\n\n\n  @DomName('HTMLTableElement.HTMLTableElement')\n  @DocsEditable\n  factory TableElement() => document.$dom_createElement(\"table\");\n\n  @DomName('HTMLTableElement.border')\n  @DocsEditable\n  String border;\n\n  @DomName('HTMLTableElement.caption')\n  @DocsEditable\n  TableCaptionElement caption;\n\n  @JSName('rows')\n  @DomName('HTMLTableElement.rows')\n  @DocsEditable\n  final HtmlCollection $dom_rows;\n\n  @JSName('tBodies')\n  @DomName('HTMLTableElement.tBodies')\n  @DocsEditable\n  final HtmlCollection $dom_tBodies;\n\n  @DomName('HTMLTableElement.tFoot')\n  @DocsEditable\n  TableSectionElement tFoot;\n\n  @DomName('HTMLTableElement.tHead')\n  @DocsEditable\n  TableSectionElement tHead;\n\n  @JSName('createCaption')\n  @DomName('HTMLTableElement.createCaption')\n  @DocsEditable\n  Element $dom_createCaption() native;\n\n  @JSName('createTFoot')\n  @DomName('HTMLTableElement.createTFoot')\n  @DocsEditable\n  Element $dom_createTFoot() native;\n\n  @JSName('createTHead')\n  @DomName('HTMLTableElement.createTHead')\n  @DocsEditable\n  Element $dom_createTHead() native;\n\n  @DomName('HTMLTableElement.deleteCaption')\n  @DocsEditable\n  void deleteCaption() native;\n\n  @DomName('HTMLTableElement.deleteRow')\n  @DocsEditable\n  void deleteRow(int index) native;\n\n  @DomName('HTMLTableElement.deleteTFoot')\n  @DocsEditable\n  void deleteTFoot() native;\n\n  @DomName('HTMLTableElement.deleteTHead')\n  @DocsEditable\n  void deleteTHead() native;\n\n  @JSName('insertRow')\n  @DomName('HTMLTableElement.insertRow')\n  @DocsEditable\n  Element $dom_insertRow(int index) native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLTableRowElement')\nclass TableRowElement extends Element native \"HTMLTableRowElement\" {\n\n  @DomName('HTMLTableRowElement.cells')\n  List<TableCellElement> get cells =>\n      new _WrappedList<TableCellElement>($dom_cells);\n\n  TableCellElement addCell() {\n    return insertCell(-1);\n  }\n\n  TableCellElement insertCell(int index) => $dom_insertCell(index);\n\n\n  @DomName('HTMLTableRowElement.HTMLTableRowElement')\n  @DocsEditable\n  factory TableRowElement() => document.$dom_createElement(\"tr\");\n\n  @JSName('cells')\n  @DomName('HTMLTableRowElement.cells')\n  @DocsEditable\n  final HtmlCollection $dom_cells;\n\n  @DomName('HTMLTableRowElement.rowIndex')\n  @DocsEditable\n  final int rowIndex;\n\n  @DomName('HTMLTableRowElement.sectionRowIndex')\n  @DocsEditable\n  final int sectionRowIndex;\n\n  @DomName('HTMLTableRowElement.deleteCell')\n  @DocsEditable\n  void deleteCell(int index) native;\n\n  @JSName('insertCell')\n  @DomName('HTMLTableRowElement.insertCell')\n  @DocsEditable\n  Element $dom_insertCell(int index) native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLTableSectionElement')\nclass TableSectionElement extends Element native \"HTMLTableSectionElement\" {\n\n  @DomName('HTMLTableSectionElement.rows')\n  List<TableRowElement> get rows =>\n    new _WrappedList<TableRowElement>($dom_rows);\n\n  TableRowElement addRow() {\n    return insertRow(-1);\n  }\n\n  TableRowElement insertRow(int index) => $dom_insertRow(index);\n\n\n  @JSName('rows')\n  @DomName('HTMLTableSectionElement.rows')\n  @DocsEditable\n  final HtmlCollection $dom_rows;\n\n  @DomName('HTMLTableSectionElement.deleteRow')\n  @DocsEditable\n  void deleteRow(int index) native;\n\n  @JSName('insertRow')\n  @DomName('HTMLTableSectionElement.insertRow')\n  @DocsEditable\n  Element $dom_insertRow(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLTemplateElement')\nclass TemplateElement extends Element native \"HTMLTemplateElement\" {\n\n  @DomName('HTMLTemplateElement.content')\n  @DocsEditable\n  final DocumentFragment content;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('Text')\nclass Text extends CharacterData native \"Text\" {\n  factory Text(String data) => _TextFactoryProvider.createText(data);\n\n  @JSName('webkitInsertionParent')\n  @DomName('Text.webkitInsertionParent')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final Node insertionParent;\n\n  @DomName('Text.wholeText')\n  @DocsEditable\n  final String wholeText;\n\n  @DomName('Text.replaceWholeText')\n  @DocsEditable\n  Text replaceWholeText(String content) native;\n\n  @DomName('Text.splitText')\n  @DocsEditable\n  Text splitText(int offset) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLTextAreaElement')\nclass TextAreaElement extends Element native \"HTMLTextAreaElement\" {\n\n  @DomName('HTMLTextAreaElement.HTMLTextAreaElement')\n  @DocsEditable\n  factory TextAreaElement() => document.$dom_createElement(\"textarea\");\n\n  @DomName('HTMLTextAreaElement.autofocus')\n  @DocsEditable\n  bool autofocus;\n\n  @DomName('HTMLTextAreaElement.cols')\n  @DocsEditable\n  int cols;\n\n  @DomName('HTMLTextAreaElement.defaultValue')\n  @DocsEditable\n  String defaultValue;\n\n  @DomName('HTMLTextAreaElement.dirName')\n  @DocsEditable\n  String dirName;\n\n  @DomName('HTMLTextAreaElement.disabled')\n  @DocsEditable\n  bool disabled;\n\n  @DomName('HTMLTextAreaElement.form')\n  @DocsEditable\n  final FormElement form;\n\n  @DomName('HTMLTextAreaElement.labels')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLTextAreaElement.maxLength')\n  @DocsEditable\n  int maxLength;\n\n  @DomName('HTMLTextAreaElement.name')\n  @DocsEditable\n  String name;\n\n  @DomName('HTMLTextAreaElement.placeholder')\n  @DocsEditable\n  String placeholder;\n\n  @DomName('HTMLTextAreaElement.readOnly')\n  @DocsEditable\n  bool readOnly;\n\n  @DomName('HTMLTextAreaElement.required')\n  @DocsEditable\n  bool required;\n\n  @DomName('HTMLTextAreaElement.rows')\n  @DocsEditable\n  int rows;\n\n  @DomName('HTMLTextAreaElement.selectionDirection')\n  @DocsEditable\n  String selectionDirection;\n\n  @DomName('HTMLTextAreaElement.selectionEnd')\n  @DocsEditable\n  int selectionEnd;\n\n  @DomName('HTMLTextAreaElement.selectionStart')\n  @DocsEditable\n  int selectionStart;\n\n  @DomName('HTMLTextAreaElement.textLength')\n  @DocsEditable\n  final int textLength;\n\n  @DomName('HTMLTextAreaElement.type')\n  @DocsEditable\n  final String type;\n\n  @DomName('HTMLTextAreaElement.validationMessage')\n  @DocsEditable\n  final String validationMessage;\n\n  @DomName('HTMLTextAreaElement.validity')\n  @DocsEditable\n  final ValidityState validity;\n\n  @DomName('HTMLTextAreaElement.value')\n  @DocsEditable\n  String value;\n\n  @DomName('HTMLTextAreaElement.willValidate')\n  @DocsEditable\n  final bool willValidate;\n\n  @DomName('HTMLTextAreaElement.wrap')\n  @DocsEditable\n  String wrap;\n\n  @DomName('HTMLTextAreaElement.checkValidity')\n  @DocsEditable\n  bool checkValidity() native;\n\n  @DomName('HTMLTextAreaElement.select')\n  @DocsEditable\n  void select() native;\n\n  @DomName('HTMLTextAreaElement.setCustomValidity')\n  @DocsEditable\n  void setCustomValidity(String error) native;\n\n  @DomName('HTMLTextAreaElement.setRangeText')\n  @DocsEditable\n  void setRangeText(String replacement, [int start, int end, String selectionMode]) native;\n\n  @DomName('HTMLTextAreaElement.setSelectionRange')\n  @DocsEditable\n  void setSelectionRange(int start, int end, [String direction]) native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('TextEvent')\nclass TextEvent extends UIEvent native \"TextEvent\" {\n  factory TextEvent(String type,\n    {bool canBubble: false, bool cancelable: false, Window view, String data}) {\n    if (view == null) {\n      view = window;\n    }\n    var e = document.$dom_createEvent(\"TextEvent\");\n    e.$dom_initTextEvent(type, canBubble, cancelable, view, data);\n    return e;\n  }\n\n  @DomName('TextEvent.data')\n  @DocsEditable\n  final String data;\n\n  @JSName('initTextEvent')\n  @DomName('TextEvent.initTextEvent')\n  @DocsEditable\n  void $dom_initTextEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('TextMetrics')\nclass TextMetrics native \"TextMetrics\" {\n\n  @DomName('TextMetrics.width')\n  @DocsEditable\n  final num width;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('TextTrack')\nclass TextTrack extends EventTarget native \"TextTrack\" {\n\n  @DomName('TextTrack.cuechangeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> cueChangeEvent = const EventStreamProvider<Event>('cuechange');\n\n  @DomName('TextTrack.activeCues')\n  @DocsEditable\n  final TextTrackCueList activeCues;\n\n  @DomName('TextTrack.cues')\n  @DocsEditable\n  final TextTrackCueList cues;\n\n  @DomName('TextTrack.kind')\n  @DocsEditable\n  final String kind;\n\n  @DomName('TextTrack.label')\n  @DocsEditable\n  final String label;\n\n  @DomName('TextTrack.language')\n  @DocsEditable\n  final String language;\n\n  @DomName('TextTrack.mode')\n  @DocsEditable\n  String mode;\n\n  @DomName('TextTrack.addCue')\n  @DocsEditable\n  void addCue(TextTrackCue cue) native;\n\n  @JSName('addEventListener')\n  @DomName('TextTrack.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('TextTrack.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @DomName('TextTrack.removeCue')\n  @DocsEditable\n  void removeCue(TextTrackCue cue) native;\n\n  @JSName('removeEventListener')\n  @DomName('TextTrack.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('TextTrack.oncuechange')\n  @DocsEditable\n  Stream<Event> get onCueChange => cueChangeEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('TextTrackCue')\nclass TextTrackCue extends EventTarget native \"TextTrackCue\" {\n\n  @DomName('TextTrackCue.enterEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> enterEvent = const EventStreamProvider<Event>('enter');\n\n  @DomName('TextTrackCue.exitEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> exitEvent = const EventStreamProvider<Event>('exit');\n\n  @DomName('TextTrackCue.TextTrackCue')\n  @DocsEditable\n  factory TextTrackCue(num startTime, num endTime, String text) {\n    return TextTrackCue._create_1(startTime, endTime, text);\n  }\n  static TextTrackCue _create_1(startTime, endTime, text) => JS('TextTrackCue', 'new TextTrackCue(#,#,#)', startTime, endTime, text);\n\n  @DomName('TextTrackCue.align')\n  @DocsEditable\n  String align;\n\n  @DomName('TextTrackCue.endTime')\n  @DocsEditable\n  num endTime;\n\n  @DomName('TextTrackCue.id')\n  @DocsEditable\n  String id;\n\n  @DomName('TextTrackCue.line')\n  @DocsEditable\n  int line;\n\n  @DomName('TextTrackCue.pauseOnExit')\n  @DocsEditable\n  bool pauseOnExit;\n\n  @DomName('TextTrackCue.position')\n  @DocsEditable\n  int position;\n\n  @DomName('TextTrackCue.size')\n  @DocsEditable\n  int size;\n\n  @DomName('TextTrackCue.snapToLines')\n  @DocsEditable\n  bool snapToLines;\n\n  @DomName('TextTrackCue.startTime')\n  @DocsEditable\n  num startTime;\n\n  @DomName('TextTrackCue.text')\n  @DocsEditable\n  String text;\n\n  @DomName('TextTrackCue.track')\n  @DocsEditable\n  final TextTrack track;\n\n  @DomName('TextTrackCue.vertical')\n  @DocsEditable\n  String vertical;\n\n  @JSName('addEventListener')\n  @DomName('TextTrackCue.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('TextTrackCue.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @JSName('getCueAsHTML')\n  @DomName('TextTrackCue.getCueAsHTML')\n  @DocsEditable\n  DocumentFragment getCueAsHtml() native;\n\n  @JSName('removeEventListener')\n  @DomName('TextTrackCue.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('TextTrackCue.onenter')\n  @DocsEditable\n  Stream<Event> get onEnter => enterEvent.forTarget(this);\n\n  @DomName('TextTrackCue.onexit')\n  @DocsEditable\n  Stream<Event> get onExit => exitEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('TextTrackCueList')\nclass TextTrackCueList implements List<TextTrackCue>, JavaScriptIndexingBehavior native \"TextTrackCueList\" {\n\n  @DomName('TextTrackCueList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  TextTrackCue operator[](int index) => JS(\"TextTrackCue\", \"#[#]\", this, index);\n\n  void operator[]=(int index, TextTrackCue value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<TextTrackCue> mixins.\n  // TextTrackCue is the element type.\n\n  // From Iterable<TextTrackCue>:\n\n  Iterator<TextTrackCue> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<TextTrackCue>(this);\n  }\n\n  TextTrackCue reduce(TextTrackCue combine(TextTrackCue value, TextTrackCue element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, TextTrackCue element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(TextTrackCue element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(TextTrackCue element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(TextTrackCue element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<TextTrackCue> where(bool f(TextTrackCue element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(TextTrackCue element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(TextTrackCue element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(TextTrackCue element)) => IterableMixinWorkaround.any(this, f);\n\n  List<TextTrackCue> toList({ bool growable: true }) =>\n      new List<TextTrackCue>.from(this, growable: growable);\n\n  Set<TextTrackCue> toSet() => new Set<TextTrackCue>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<TextTrackCue> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<TextTrackCue> takeWhile(bool test(TextTrackCue value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<TextTrackCue> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<TextTrackCue> skipWhile(bool test(TextTrackCue value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  TextTrackCue firstWhere(bool test(TextTrackCue value), { TextTrackCue orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  TextTrackCue lastWhere(bool test(TextTrackCue value), {TextTrackCue orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  TextTrackCue singleWhere(bool test(TextTrackCue value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  TextTrackCue elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<TextTrackCue>:\n\n  void add(TextTrackCue value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<TextTrackCue> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<TextTrackCue>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<TextTrackCue> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(TextTrackCue a, TextTrackCue b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(TextTrackCue element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(TextTrackCue element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  TextTrackCue get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  TextTrackCue get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  TextTrackCue get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, TextTrackCue element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<TextTrackCue> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<TextTrackCue> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  TextTrackCue removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  TextTrackCue removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(TextTrackCue element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(TextTrackCue element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<TextTrackCue> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<TextTrackCue> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [TextTrackCue fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<TextTrackCue> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<TextTrackCue> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <TextTrackCue>[]);\n  }\n\n  Map<int, TextTrackCue> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<TextTrackCue> mixins.\n\n  @DomName('TextTrackCueList.getCueById')\n  @DocsEditable\n  TextTrackCue getCueById(String id) native;\n\n  @DomName('TextTrackCueList.item')\n  @DocsEditable\n  TextTrackCue item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('TextTrackList')\nclass TextTrackList extends EventTarget implements JavaScriptIndexingBehavior, List<TextTrack> native \"TextTrackList\" {\n\n  @DomName('TextTrackList.addtrackEvent')\n  @DocsEditable\n  static const EventStreamProvider<TrackEvent> addTrackEvent = const EventStreamProvider<TrackEvent>('addtrack');\n\n  @DomName('TextTrackList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  TextTrack operator[](int index) => JS(\"TextTrack\", \"#[#]\", this, index);\n\n  void operator[]=(int index, TextTrack value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<TextTrack> mixins.\n  // TextTrack is the element type.\n\n  // From Iterable<TextTrack>:\n\n  Iterator<TextTrack> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<TextTrack>(this);\n  }\n\n  TextTrack reduce(TextTrack combine(TextTrack value, TextTrack element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, TextTrack element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(TextTrack element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(TextTrack element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(TextTrack element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<TextTrack> where(bool f(TextTrack element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(TextTrack element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(TextTrack element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(TextTrack element)) => IterableMixinWorkaround.any(this, f);\n\n  List<TextTrack> toList({ bool growable: true }) =>\n      new List<TextTrack>.from(this, growable: growable);\n\n  Set<TextTrack> toSet() => new Set<TextTrack>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<TextTrack> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<TextTrack> takeWhile(bool test(TextTrack value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<TextTrack> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<TextTrack> skipWhile(bool test(TextTrack value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  TextTrack firstWhere(bool test(TextTrack value), { TextTrack orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  TextTrack lastWhere(bool test(TextTrack value), {TextTrack orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  TextTrack singleWhere(bool test(TextTrack value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  TextTrack elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<TextTrack>:\n\n  void add(TextTrack value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<TextTrack> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<TextTrack>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<TextTrack> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(TextTrack a, TextTrack b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(TextTrack element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(TextTrack element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  TextTrack get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  TextTrack get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  TextTrack get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, TextTrack element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<TextTrack> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<TextTrack> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  TextTrack removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  TextTrack removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(TextTrack element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(TextTrack element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<TextTrack> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<TextTrack> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [TextTrack fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<TextTrack> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<TextTrack> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <TextTrack>[]);\n  }\n\n  Map<int, TextTrack> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<TextTrack> mixins.\n\n  @JSName('addEventListener')\n  @DomName('TextTrackList.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('TextTrackList.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @DomName('TextTrackList.item')\n  @DocsEditable\n  TextTrack item(int index) native;\n\n  @JSName('removeEventListener')\n  @DomName('TextTrackList.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('TextTrackList.onaddtrack')\n  @DocsEditable\n  Stream<TrackEvent> get onAddTrack => addTrackEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('TimeRanges')\nclass TimeRanges native \"TimeRanges\" {\n\n  @DomName('TimeRanges.length')\n  @DocsEditable\n  final int length;\n\n  @DomName('TimeRanges.end')\n  @DocsEditable\n  num end(int index) native;\n\n  @DomName('TimeRanges.start')\n  @DocsEditable\n  num start(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void TimeoutHandler();\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLTitleElement')\nclass TitleElement extends Element native \"HTMLTitleElement\" {\n\n  @DomName('HTMLTitleElement.HTMLTitleElement')\n  @DocsEditable\n  factory TitleElement() => document.$dom_createElement(\"title\");\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Touch')\nclass Touch native \"Touch\" {\n\n  @JSName('clientX')\n  @DomName('Touch.clientX')\n  @DocsEditable\n  final int $dom_clientX;\n\n  @JSName('clientY')\n  @DomName('Touch.clientY')\n  @DocsEditable\n  final int $dom_clientY;\n\n  @DomName('Touch.identifier')\n  @DocsEditable\n  final int identifier;\n\n  @JSName('pageX')\n  @DomName('Touch.pageX')\n  @DocsEditable\n  final int $dom_pageX;\n\n  @JSName('pageY')\n  @DomName('Touch.pageY')\n  @DocsEditable\n  final int $dom_pageY;\n\n  @JSName('screenX')\n  @DomName('Touch.screenX')\n  @DocsEditable\n  final int $dom_screenX;\n\n  @JSName('screenY')\n  @DomName('Touch.screenY')\n  @DocsEditable\n  final int $dom_screenY;\n\n  EventTarget get target => _convertNativeToDart_EventTarget(this._get_target);\n  @JSName('target')\n  @DomName('Touch.target')\n  @DocsEditable\n  @Creates('Element|Document')\n  @Returns('Element|Document')\n  final dynamic _get_target;\n\n  @JSName('webkitForce')\n  @DomName('Touch.webkitForce')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final num force;\n\n  @JSName('webkitRadiusX')\n  @DomName('Touch.webkitRadiusX')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final int radiusX;\n\n  @JSName('webkitRadiusY')\n  @DomName('Touch.webkitRadiusY')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final int radiusY;\n\n  @JSName('webkitRotationAngle')\n  @DomName('Touch.webkitRotationAngle')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final num rotationAngle;\n\n\n  @DomName('Touch.clientX')\n  @DomName('Touch.clientY')\n  Point get client => new Point($dom_clientX, $dom_clientY);\n\n  @DomName('Touch.pageX')\n  @DomName('Touch.pageY')\n  Point get page => new Point($dom_pageX, $dom_pageY);\n\n  @DomName('Touch.screenX')\n  @DomName('Touch.screenY')\n  Point get screen => new Point($dom_screenX, $dom_screenY);\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('TouchEvent')\nclass TouchEvent extends UIEvent native \"TouchEvent\" {\n  factory TouchEvent(TouchList touches, TouchList targetTouches,\n      TouchList changedTouches, String type,\n      {Window view, int screenX: 0, int screenY: 0, int clientX: 0,\n      int clientY: 0, bool ctrlKey: false, bool altKey: false,\n      bool shiftKey: false, bool metaKey: false}) {\n    if (view == null) {\n      view = window;\n    }\n    var e = document.$dom_createEvent(\"TouchEvent\");\n    e.$dom_initTouchEvent(touches, targetTouches, changedTouches, type, view,\n        screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey);\n    return e;\n  }\n\n  @DomName('TouchEvent.altKey')\n  @DocsEditable\n  final bool altKey;\n\n  @DomName('TouchEvent.changedTouches')\n  @DocsEditable\n  final TouchList changedTouches;\n\n  @DomName('TouchEvent.ctrlKey')\n  @DocsEditable\n  final bool ctrlKey;\n\n  @DomName('TouchEvent.metaKey')\n  @DocsEditable\n  final bool metaKey;\n\n  @DomName('TouchEvent.shiftKey')\n  @DocsEditable\n  final bool shiftKey;\n\n  @DomName('TouchEvent.targetTouches')\n  @DocsEditable\n  final TouchList targetTouches;\n\n  @DomName('TouchEvent.touches')\n  @DocsEditable\n  final TouchList touches;\n\n  @JSName('initTouchEvent')\n  @DomName('TouchEvent.initTouchEvent')\n  @DocsEditable\n  void $dom_initTouchEvent(TouchList touches, TouchList targetTouches, TouchList changedTouches, String type, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) native;\n\n\n  /**\n   * Checks if touch events supported on the current platform.\n   *\n   * Note that touch events are only supported if the user is using a touch\n   * device.\n   */\n  static bool get supported {\n    if (JS('bool', '\"ontouchstart\" in window')) {\n      return Device.isEventTypeSupported('TouchEvent');\n    }\n    return false;\n  }\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('TouchList')\nclass TouchList implements JavaScriptIndexingBehavior, List<Touch> native \"TouchList\" {\n  /// NB: This constructor likely does not work as you might expect it to! This\n  /// constructor will simply fail (returning null) if you are not on a device\n  /// with touch enabled. See dartbug.com/8314.\n  factory TouchList() => document.$dom_createTouchList();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!document.createTouchList');\n\n  @DomName('TouchList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Touch operator[](int index) => JS(\"Touch\", \"#[#]\", this, index);\n\n  void operator[]=(int index, Touch value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Touch> mixins.\n  // Touch is the element type.\n\n  // From Iterable<Touch>:\n\n  Iterator<Touch> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<Touch>(this);\n  }\n\n  Touch reduce(Touch combine(Touch value, Touch element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, Touch element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(Touch element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(Touch element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(Touch element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<Touch> where(bool f(Touch element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(Touch element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(Touch element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(Touch element)) => IterableMixinWorkaround.any(this, f);\n\n  List<Touch> toList({ bool growable: true }) =>\n      new List<Touch>.from(this, growable: growable);\n\n  Set<Touch> toSet() => new Set<Touch>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<Touch> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<Touch> takeWhile(bool test(Touch value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<Touch> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<Touch> skipWhile(bool test(Touch value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  Touch firstWhere(bool test(Touch value), { Touch orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  Touch lastWhere(bool test(Touch value), {Touch orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  Touch singleWhere(bool test(Touch value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  Touch elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<Touch>:\n\n  void add(Touch value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<Touch> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<Touch>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<Touch> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(Touch a, Touch b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(Touch element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(Touch element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  Touch get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  Touch get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  Touch get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, Touch element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<Touch> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<Touch> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Touch removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  Touch removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(Touch element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(Touch element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<Touch> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<Touch> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [Touch fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<Touch> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<Touch> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <Touch>[]);\n  }\n\n  Map<int, Touch> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<Touch> mixins.\n\n  @DomName('TouchList.item')\n  @DocsEditable\n  Touch item(int index) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLTrackElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass TrackElement extends Element native \"HTMLTrackElement\" {\n\n  @DomName('HTMLTrackElement.HTMLTrackElement')\n  @DocsEditable\n  factory TrackElement() => document.$dom_createElement(\"track\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('track');\n\n  static const int ERROR = 3;\n\n  static const int LOADED = 2;\n\n  static const int LOADING = 1;\n\n  static const int NONE = 0;\n\n  @JSName('default')\n  @DomName('HTMLTrackElement.default')\n  @DocsEditable\n  bool defaultValue;\n\n  @DomName('HTMLTrackElement.kind')\n  @DocsEditable\n  String kind;\n\n  @DomName('HTMLTrackElement.label')\n  @DocsEditable\n  String label;\n\n  @DomName('HTMLTrackElement.readyState')\n  @DocsEditable\n  final int readyState;\n\n  @DomName('HTMLTrackElement.src')\n  @DocsEditable\n  String src;\n\n  @DomName('HTMLTrackElement.srclang')\n  @DocsEditable\n  String srclang;\n\n  @DomName('HTMLTrackElement.track')\n  @DocsEditable\n  final TextTrack track;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('TrackEvent')\nclass TrackEvent extends Event native \"TrackEvent\" {\n\n  @DomName('TrackEvent.track')\n  @DocsEditable\n  final Object track;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('TransitionEvent')\nclass TransitionEvent extends Event native \"TransitionEvent,WebKitTransitionEvent\" {\n\n  @DomName('TransitionEvent.elapsedTime')\n  @DocsEditable\n  final num elapsedTime;\n\n  @DomName('TransitionEvent.propertyName')\n  @DocsEditable\n  final String propertyName;\n\n  @DomName('TransitionEvent.pseudoElement')\n  @DocsEditable\n  final String pseudoElement;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('TreeWalker')\nclass TreeWalker native \"TreeWalker\" {\n\n  @DomName('TreeWalker.currentNode')\n  @DocsEditable\n  Node currentNode;\n\n  @DomName('TreeWalker.expandEntityReferences')\n  @DocsEditable\n  final bool expandEntityReferences;\n\n  @DomName('TreeWalker.filter')\n  @DocsEditable\n  final NodeFilter filter;\n\n  @DomName('TreeWalker.root')\n  @DocsEditable\n  final Node root;\n\n  @DomName('TreeWalker.whatToShow')\n  @DocsEditable\n  final int whatToShow;\n\n  @DomName('TreeWalker.firstChild')\n  @DocsEditable\n  Node firstChild() native;\n\n  @DomName('TreeWalker.lastChild')\n  @DocsEditable\n  Node lastChild() native;\n\n  @DomName('TreeWalker.nextNode')\n  @DocsEditable\n  Node nextNode() native;\n\n  @DomName('TreeWalker.nextSibling')\n  @DocsEditable\n  Node nextSibling() native;\n\n  @DomName('TreeWalker.parentNode')\n  @DocsEditable\n  Node parentNode() native;\n\n  @DomName('TreeWalker.previousNode')\n  @DocsEditable\n  Node previousNode() native;\n\n  @DomName('TreeWalker.previousSibling')\n  @DocsEditable\n  Node previousSibling() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('UIEvent')\nclass UIEvent extends Event native \"UIEvent\" {\n  // In JS, canBubble and cancelable are technically required parameters to\n  // init*Event. In practice, though, if they aren't provided they simply\n  // default to false (since that's Boolean(undefined)).\n  //\n  // Contrary to JS, we default canBubble and cancelable to true, since that's\n  // what people want most of the time anyway.\n  factory UIEvent(String type,\n      {Window view, int detail: 0, bool canBubble: true,\n      bool cancelable: true}) {\n    if (view == null) {\n      view = window;\n    }\n    final e = document.$dom_createEvent(\"UIEvent\");\n    e.$dom_initUIEvent(type, canBubble, cancelable, view, detail);\n    return e;\n  }\n\n  @JSName('charCode')\n  @DomName('UIEvent.charCode')\n  @DocsEditable\n  final int $dom_charCode;\n\n  @DomName('UIEvent.detail')\n  @DocsEditable\n  final int detail;\n\n  @JSName('keyCode')\n  @DomName('UIEvent.keyCode')\n  @DocsEditable\n  final int $dom_keyCode;\n\n  @JSName('layerX')\n  @DomName('UIEvent.layerX')\n  @DocsEditable\n  final int $dom_layerX;\n\n  @JSName('layerY')\n  @DomName('UIEvent.layerY')\n  @DocsEditable\n  final int $dom_layerY;\n\n  @JSName('pageX')\n  @DomName('UIEvent.pageX')\n  @DocsEditable\n  final int $dom_pageX;\n\n  @JSName('pageY')\n  @DomName('UIEvent.pageY')\n  @DocsEditable\n  final int $dom_pageY;\n\n  WindowBase get view => _convertNativeToDart_Window(this._get_view);\n  @JSName('view')\n  @DomName('UIEvent.view')\n  @DocsEditable\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_view;\n\n  @DomName('UIEvent.which')\n  @DocsEditable\n  final int which;\n\n  @JSName('initUIEvent')\n  @DomName('UIEvent.initUIEvent')\n  @DocsEditable\n  void $dom_initUIEvent(String type, bool canBubble, bool cancelable, Window view, int detail) native;\n\n\n  @deprecated\n  int get layerX => layer.x;\n  @deprecated\n  int get layerY => layer.y;\n\n  @deprecated\n  int get pageX => page.x;\n  @deprecated\n  int get pageY => page.y;\n\n  @DomName('UIEvent.layerX')\n  @DomName('UIEvent.layerY')\n  Point get layer => new Point($dom_layerX, $dom_layerY);\n\n  @DomName('UIEvent.pageX')\n  @DomName('UIEvent.pageY')\n  Point get page => new Point($dom_pageX, $dom_pageY);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLUListElement')\nclass UListElement extends Element native \"HTMLUListElement\" {\n\n  @DomName('HTMLUListElement.HTMLUListElement')\n  @DocsEditable\n  factory UListElement() => document.$dom_createElement(\"ul\");\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLUnknownElement')\nclass UnknownElement extends Element native \"HTMLUnknownElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('URL')\nclass Url native \"URL\" {\n\n  static String createObjectUrl(blob_OR_source_OR_stream) =>\n      JS('String',\n         '(self.URL || self.webkitURL).createObjectURL(#)',\n         blob_OR_source_OR_stream);\n\n  static void revokeObjectUrl(String objectUrl) =>\n      JS('void',\n         '(self.URL || self.webkitURL).revokeObjectURL(#)', objectUrl);\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('ValidityState')\nclass ValidityState native \"ValidityState\" {\n\n  @DomName('ValidityState.badInput')\n  @DocsEditable\n  final bool badInput;\n\n  @DomName('ValidityState.customError')\n  @DocsEditable\n  final bool customError;\n\n  @DomName('ValidityState.patternMismatch')\n  @DocsEditable\n  final bool patternMismatch;\n\n  @DomName('ValidityState.rangeOverflow')\n  @DocsEditable\n  final bool rangeOverflow;\n\n  @DomName('ValidityState.rangeUnderflow')\n  @DocsEditable\n  final bool rangeUnderflow;\n\n  @DomName('ValidityState.stepMismatch')\n  @DocsEditable\n  final bool stepMismatch;\n\n  @DomName('ValidityState.tooLong')\n  @DocsEditable\n  final bool tooLong;\n\n  @DomName('ValidityState.typeMismatch')\n  @DocsEditable\n  final bool typeMismatch;\n\n  @DomName('ValidityState.valid')\n  @DocsEditable\n  final bool valid;\n\n  @DomName('ValidityState.valueMissing')\n  @DocsEditable\n  final bool valueMissing;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('HTMLVideoElement')\nclass VideoElement extends MediaElement implements CanvasImageSource native \"HTMLVideoElement\" {\n\n  @DomName('HTMLVideoElement.HTMLVideoElement')\n  @DocsEditable\n  factory VideoElement() => document.$dom_createElement(\"video\");\n\n  @DomName('HTMLVideoElement.height')\n  @DocsEditable\n  int height;\n\n  @DomName('HTMLVideoElement.poster')\n  @DocsEditable\n  String poster;\n\n  @DomName('HTMLVideoElement.videoHeight')\n  @DocsEditable\n  final int videoHeight;\n\n  @DomName('HTMLVideoElement.videoWidth')\n  @DocsEditable\n  final int videoWidth;\n\n  @JSName('webkitDecodedFrameCount')\n  @DomName('HTMLVideoElement.webkitDecodedFrameCount')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final int decodedFrameCount;\n\n  @JSName('webkitDisplayingFullscreen')\n  @DomName('HTMLVideoElement.webkitDisplayingFullscreen')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final bool displayingFullscreen;\n\n  @JSName('webkitDroppedFrameCount')\n  @DomName('HTMLVideoElement.webkitDroppedFrameCount')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final int droppedFrameCount;\n\n  @JSName('webkitSupportsFullscreen')\n  @DomName('HTMLVideoElement.webkitSupportsFullscreen')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final bool supportsFullscreen;\n\n  @DomName('HTMLVideoElement.width')\n  @DocsEditable\n  int width;\n\n  @JSName('webkitEnterFullScreen')\n  @DomName('HTMLVideoElement.webkitEnterFullScreen')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void enterFullScreen() native;\n\n  @JSName('webkitEnterFullscreen')\n  @DomName('HTMLVideoElement.webkitEnterFullscreen')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void enterFullscreen() native;\n\n  @JSName('webkitExitFullScreen')\n  @DomName('HTMLVideoElement.webkitExitFullScreen')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void exitFullScreen() native;\n\n  @JSName('webkitExitFullscreen')\n  @DomName('HTMLVideoElement.webkitExitFullscreen')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  void exitFullscreen() native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void VoidCallback();\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebKitCSSFilterRule')\nclass WebKitCssFilterRule extends CssRule native \"WebKitCSSFilterRule\" {\n\n  @DomName('WebKitCSSFilterRule.style')\n  @DocsEditable\n  final CssStyleDeclaration style;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebKitCSSRegionRule')\nclass WebKitCssRegionRule extends CssRule native \"WebKitCSSRegionRule\" {\n\n  @DomName('WebKitCSSRegionRule.cssRules')\n  @DocsEditable\n  @Returns('_CssRuleList')\n  @Creates('_CssRuleList')\n  final List<CssRule> cssRules;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n/**\n * Use the WebSocket interface to connect to a WebSocket,\n * and to send and receive data on that WebSocket.\n *\n * To use a WebSocket in your web app, first create a WebSocket object,\n * passing the WebSocket URL as an argument to the constructor.\n *\n *     var webSocket = new WebSocket('ws://127.0.0.1:1337/ws');\n *\n * To send data on the WebSocket, use the [send] method.\n *\n *     if (webSocket != null && webSocket.readyState == WebSocket.OPEN) {\n *       webSocket.send(data);\n *     } else {\n *       print('WebSocket not connected, message $data not sent');\n *     }\n *\n * To receive data on the WebSocket, register a listener for message events.\n *\n *     webSocket.on.message.add((MessageEvent e) {\n *       receivedData(e.data);\n *     });\n *\n * The message event handler receives a [MessageEvent] object\n * as its sole argument.\n * You can also define open, close, and error handlers,\n * as specified by [WebSocketEvents].\n *\n * For more information, see the\n * [WebSockets](http://www.dartlang.org/docs/library-tour/#html-websockets)\n * section of the library tour and\n * [Introducing WebSockets](http://www.html5rocks.com/en/tutorials/websockets/basics/),\n * an HTML5Rocks.com tutorial.\n */\n@DomName('WebSocket')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass WebSocket extends EventTarget native \"WebSocket\" {\n\n  @DomName('WebSocket.closeEvent')\n  @DocsEditable\n  static const EventStreamProvider<CloseEvent> closeEvent = const EventStreamProvider<CloseEvent>('close');\n\n  @DomName('WebSocket.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('WebSocket.messageEvent')\n  @DocsEditable\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  @DomName('WebSocket.openEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> openEvent = const EventStreamProvider<Event>('open');\n\n  @DomName('WebSocket.WebSocket')\n  @DocsEditable\n  factory WebSocket(String url, [protocol_OR_protocols]) {\n    if ((url is String || url == null) && !?protocol_OR_protocols) {\n      return WebSocket._create_1(url);\n    }\n    if ((url is String || url == null) && (protocol_OR_protocols is List<String> || protocol_OR_protocols == null)) {\n      return WebSocket._create_2(url, protocol_OR_protocols);\n    }\n    if ((url is String || url == null) && (protocol_OR_protocols is String || protocol_OR_protocols == null)) {\n      return WebSocket._create_3(url, protocol_OR_protocols);\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  static WebSocket _create_1(url) => JS('WebSocket', 'new WebSocket(#)', url);\n  static WebSocket _create_2(url, protocol_OR_protocols) => JS('WebSocket', 'new WebSocket(#,#)', url, protocol_OR_protocols);\n  static WebSocket _create_3(url, protocol_OR_protocols) => JS('WebSocket', 'new WebSocket(#,#)', url, protocol_OR_protocols);\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', 'typeof window.WebSocket != \"undefined\"');\n\n  static const int CLOSED = 3;\n\n  static const int CLOSING = 2;\n\n  static const int CONNECTING = 0;\n\n  static const int OPEN = 1;\n\n  @JSName('URL')\n  @DomName('WebSocket.URL')\n  @DocsEditable\n  final String Url;\n\n  @DomName('WebSocket.binaryType')\n  @DocsEditable\n  String binaryType;\n\n  @DomName('WebSocket.bufferedAmount')\n  @DocsEditable\n  final int bufferedAmount;\n\n  @DomName('WebSocket.extensions')\n  @DocsEditable\n  final String extensions;\n\n  @DomName('WebSocket.protocol')\n  @DocsEditable\n  final String protocol;\n\n  @DomName('WebSocket.readyState')\n  @DocsEditable\n  final int readyState;\n\n  @DomName('WebSocket.url')\n  @DocsEditable\n  final String url;\n\n  @JSName('addEventListener')\n  @DomName('WebSocket.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('WebSocket.close')\n  @DocsEditable\n  void close([int code, String reason]) native;\n\n  @DomName('WebSocket.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @JSName('removeEventListener')\n  @DomName('WebSocket.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('WebSocket.send')\n  @DocsEditable\n  void send(data) native;\n\n  @DomName('WebSocket.onclose')\n  @DocsEditable\n  Stream<CloseEvent> get onClose => closeEvent.forTarget(this);\n\n  @DomName('WebSocket.onerror')\n  @DocsEditable\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  @DomName('WebSocket.onmessage')\n  @DocsEditable\n  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);\n\n  @DomName('WebSocket.onopen')\n  @DocsEditable\n  Stream<Event> get onOpen => openEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('WheelEvent')\nclass WheelEvent extends MouseEvent native \"WheelEvent,MouseWheelEvent,MouseScrollEvent\" {\n\n  factory WheelEvent(String type,\n      {Window view, int deltaX: 0, int deltaY: 0,\n      int detail: 0, int screenX: 0, int screenY: 0, int clientX: 0,\n      int clientY: 0, int button: 0, bool canBubble: true,\n      bool cancelable: true, bool ctrlKey: false, bool altKey: false,\n      bool shiftKey: false, bool metaKey: false, EventTarget relatedTarget}) {\n\n    if (view == null) {\n      view = window;\n    }\n    var eventType = 'WheelEvent';\n    if (Device.isFirefox) {\n      eventType = 'MouseScrollEvents';\n    }\n    final event = document.$dom_createEvent(eventType);\n    // If polyfilling, then flip these because we'll flip them back to match\n    // the W3C standard:\n    // http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html#events-WheelEvent-deltaY\n    if (JS('bool', '#.deltaY === undefined', event)) {\n      deltaX = -deltaX;\n      deltaY = -deltaY;\n    }\n    if (event._hasInitWheelEvent) {\n      var modifiers = [];\n      if (ctrlKey) {\n        modifiers.push('Control');\n      }\n      if (altKey) {\n        modifiers.push('Alt');\n      }\n      if (shiftKey) {\n        modifiers.push('Shift');\n      }\n      if (metaKey) {\n        modifiers.push('Meta');\n      }\n      event._initWheelEvent(type, canBubble, cancelable, view, detail, screenX,\n          screenY, clientX, clientY, button, relatedTarget, modifiers.join(' '),\n          deltaX, deltaY, 0, 0);\n    } else if (event._hasInitMouseScrollEvent) {\n      var axis = 0;\n      var detail = 0;\n      if (deltaX != 0 && deltaY != 0) {\n        throw UnsupportedError(\n            'Cannot modify deltaX and deltaY simultaneously');\n      }\n      if (deltaY != 0) {\n        detail = deltaY;\n        axis = JS('int', 'MouseScrollEvent.VERTICAL_AXIS');\n      } else if (deltaX != 0) {\n        detail = deltaX;\n        axis = JS('int', 'MouseScrollEvent.HORIZONTAL_AXIS');\n      }\n      event._initMouseScrollEvent(type, canBubble, cancelable, view, detail,\n          screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey,\n          metaKey, button, relatedTarget, axis);\n    } else {\n      // Fallthrough for Dartium.\n      event.$dom_initMouseEvent(type, canBubble, cancelable, view, detail,\n          screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey,\n          metaKey, button, relatedTarget);\n      event.$dom_initWebKitWheelEvent(deltaX,\n          deltaY ~/ 120, // Chrome does an auto-convert to pixels.\n          view, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey,\n          metaKey);\n    }\n\n    return event;\n  }\n\n\n  static const int DOM_DELTA_LINE = 0x01;\n\n  static const int DOM_DELTA_PAGE = 0x02;\n\n  static const int DOM_DELTA_PIXEL = 0x00;\n\n  @JSName('webkitDirectionInvertedFromDevice')\n  @DomName('WheelEvent.webkitDirectionInvertedFromDevice')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final bool directionInvertedFromDevice;\n\n  @JSName('initWebKitWheelEvent')\n  @DomName('WheelEvent.initWebKitWheelEvent')\n  @DocsEditable\n  void $dom_initWebKitWheelEvent(int wheelDeltaX, int wheelDeltaY, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) native;\n\n\n  /**\n   * The amount that is expected to scroll vertically, in units determined by\n   * [deltaMode].\n   *\n   * See also:\n   *\n   * * [WheelEvent.deltaY](http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html#events-WheelEvent-deltaY) from the W3C.\n   */\n  @DomName('WheelEvent.deltaY')\n  num get deltaY {\n    if (JS('bool', '#.deltaY !== undefined', this)) {\n      // W3C WheelEvent\n      return this._deltaY;\n    } else if (JS('bool', '#.wheelDelta !== undefined', this)) {\n      // Chrome and IE\n      return -this._wheelDelta;\n    } else if (JS('bool', '#.detail !== undefined', this)) {\n      // Firefox\n\n      // Handle DOMMouseScroll case where it uses detail and the axis to\n      // differentiate.\n      if (JS('bool', '#.axis == MouseScrollEvent.VERTICAL_AXIS', this)) {\n        var detail = this._detail;\n        // Firefox is normally the number of lines to scale (normally 3)\n        // so multiply it by 40 to get pixels to move, matching IE & WebKit.\n        if (detail.abs() < 100) {\n          return -detail * 40;\n        }\n        return -detail;\n      }\n      return 0;\n    }\n    throw new UnsupportedError(\n        'deltaY is not supported');\n  }\n\n  /**\n   * The amount that is expected to scroll horizontally, in units determined by\n   * [deltaMode].\n   *\n   * See also:\n   *\n   * * [WheelEvent.deltaX](http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html#events-WheelEvent-deltaX) from the W3C.\n   */\n  @DomName('WheelEvent.deltaX')\n  num get deltaX {\n    if (JS('bool', '#.deltaX !== undefined', this)) {\n      // W3C WheelEvent\n      return this._deltaX;\n    } else if (JS('bool', '#.wheelDeltaX !== undefined', this)) {\n      // Chrome\n      return -this._wheelDeltaX;\n    } else if (JS('bool', '#.detail !== undefined', this)) {\n      // Firefox and IE.\n      // IE will have detail set but will not set axis.\n\n      // Handle DOMMouseScroll case where it uses detail and the axis to\n      // differentiate.\n      if (JS('bool', '#.axis !== undefined && '\n        '#.axis == MouseScrollEvent.HORIZONTAL_AXIS', this, this)) {\n        var detail = this._detail;\n        // Firefox is normally the number of lines to scale (normally 3)\n        // so multiply it by 40 to get pixels to move, matching IE & WebKit.\n        if (detail < 100) {\n          return -detail * 40;\n        }\n        return -detail;\n      }\n      return 0;\n    }\n    throw new UnsupportedError(\n        'deltaX is not supported');\n  }\n\n  @DomName('WheelEvent.deltaMode')\n  int get deltaMode {\n    if (JS('bool', '!!(#.deltaMode)', this)) {\n      return JS('int', '#.deltaMode', this);\n    }\n    // If not available then we're poly-filling and doing pixel scroll.\n    return 0;\n  }\n\n  num get _deltaY => JS('num', '#.deltaY', this);\n  num get _deltaX => JS('num', '#.deltaX', this);\n  num get _wheelDelta => JS('num', '#.wheelDelta', this);\n  num get _wheelDeltaX => JS('num', '#.wheelDeltaX', this);\n  num get _detail => JS('num', '#.detail', this);\n\n  bool get _hasInitMouseScrollEvent =>\n      JS('bool', '!!(#.initMouseScrollEvent)', this);\n\n  @JSName('initMouseScrollEvent')\n  void _initMouseScrollEvent(\n      String type,\n      bool canBubble,\n      bool cancelable,\n      Window view,\n      int detail,\n      int screenX,\n      int screenY,\n      int clientX,\n      int clientY,\n      bool ctrlKey,\n      bool altKey,\n      bool shiftKey,\n      bool metaKey,\n      int button,\n      EventTarget relatedTarget,\n      int axis) native;\n\n  bool get _hasInitWheelEvent =>\n      JS('bool', '!!(#.initWheelEvent)', this);\n  @JSName('initWheelEvent')\n  void _initWheelEvent(\n      String eventType,\n      bool canBubble,\n      bool cancelable,\n      Window view,\n      int detail,\n      int screenX,\n      int screenY,\n      int clientX,\n      int clientY,\n      int button,\n      EventTarget relatedTarget,\n      String modifiersList,\n      int deltaX,\n      int deltaY,\n      int deltaZ,\n      int deltaMode) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('Window')\nclass Window extends EventTarget implements WindowBase native \"Window,DOMWindow\" {\n\n  /**\n   * Executes a [callback] after the immediate execution stack has completed.\n   *\n   * This differs from using Timer.run(callback)\n   * because Timer will run in about 4-15 milliseconds, depending on browser,\n   * depending on load. [setImmediate], in contrast, makes browser-specific\n   * changes in behavior to attempt to run immediately after the current\n   * frame unwinds, causing the future to complete after all processing has\n   * completed for the current event, but before any subsequent events.\n   */\n  void setImmediate(TimeoutHandler callback) {\n    _addMicrotaskCallback(callback);\n  }\n  /**\n   * Lookup a port by its [name].  Return null if no port is\n   * registered under [name].\n   */\n  SendPortSync lookupPort(String name) {\n    var portStr = document.documentElement.attributes['dart-port:$name'];\n    if (portStr == null) {\n      return null;\n    }\n    var port = json.parse(portStr);\n    return _deserialize(port);\n  }\n\n  /**\n   * Register a [port] on this window under the given [name].  This\n   * port may be retrieved by any isolate (or JavaScript script)\n   * running in this window.\n   */\n  void registerPort(String name, var port) {\n    var serialized = _serialize(port);\n    document.documentElement.attributes['dart-port:$name'] =\n        json.stringify(serialized);\n  }\n\n  /**\n   * Returns a Future that completes just before the window is about to repaint\n   * so the user can draw an animation frame\n   *\n   * If you need to later cancel this animation, use [requestAnimationFrame]\n   * instead.\n   *\n   * Note: The code that runs when the future completes should call\n   * [animationFrame] again for the animation to continue.\n   */\n  Future<num> get animationFrame {\n    var completer = new Completer<num>();\n    requestAnimationFrame((time) {\n      completer.complete(time);\n    });\n    return completer.future;\n  }\n\n  Document get document => JS('Document', '#.document', this);\n\n  WindowBase _open2(url, name) => JS('Window', '#.open(#,#)', this, url, name);\n\n  WindowBase _open3(url, name, options) =>\n      JS('Window', '#.open(#,#,#)', this, url, name, options);\n\n  WindowBase open(String url, String name, [String options]) {\n    if (options == null) {\n      return _DOMWindowCrossFrame._createSafe(_open2(url, name));\n    } else {\n      return _DOMWindowCrossFrame._createSafe(_open3(url, name, options));\n    }\n  }\n\n  // API level getter and setter for Location.\n  // TODO: The cross domain safe wrapper can be inserted here or folded into\n  // _LocationWrapper.\n  Location get location {\n    // Firefox work-around for Location.  The Firefox location object cannot be\n    // made to behave like a Dart object so must be wrapped.\n    var result = _location;\n    if (_isDartLocation(result)) return result;  // e.g. on Chrome.\n    if (null == _location_wrapper) {\n      _location_wrapper = new _LocationWrapper(result);\n    }\n    return _location_wrapper;\n  }\n\n  // TODO: consider forcing users to do: window.location.assign('string').\n  /**\n   * Sets the window's location, which causes the browser to navigate to the new\n   * location. [value] may be a Location object or a string.\n   */\n  void set location(value) {\n    if (value is _LocationWrapper) {\n      _location = value._ptr;\n    } else {\n      _location = value;\n    }\n  }\n\n  _LocationWrapper _location_wrapper;  // Cached wrapped Location object.\n\n  // Native getter and setter to access raw Location object.\n  dynamic get _location => JS('Location|=Object', '#.location', this);\n  void set _location(value) {\n    JS('void', '#.location = #', this, value);\n  }\n  // Prevent compiled from thinking 'location' property is available for a Dart\n  // member.\n  @JSName('location')\n  _protect_location() native;\n\n  static _isDartLocation(thing) {\n    // On Firefox the code that implements 'is Location' fails to find the patch\n    // stub on Object.prototype and throws an exception.\n    try {\n      return thing is Location;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Called to draw an animation frame and then request the window to repaint\n   * after [callback] has finished (creating the animation).\n   *\n   * Use this method only if you need to later call [cancelAnimationFrame]. If\n   * not, the preferred Dart idiom is to set animation frames by calling\n   * [animationFrame], which returns a Future.\n   *\n   * Returns a non-zero valued integer to represent the request id for this\n   * request. This value only needs to be saved if you intend to call\n   * [cancelAnimationFrame] so you can specify the particular animation to\n   * cancel.\n   *\n   * Note: The supplied [callback] needs to call [requestAnimationFrame] again\n   * for the animation to continue.\n   */\n  @DomName('DOMWindow.requestAnimationFrame')\n  int requestAnimationFrame(RequestAnimationFrameCallback callback) {\n    _ensureRequestAnimationFrame();\n    return _requestAnimationFrame(callback);\n  }\n\n  void cancelAnimationFrame(id) {\n    _ensureRequestAnimationFrame();\n    _cancelAnimationFrame(id);\n  }\n\n  @JSName('requestAnimationFrame')\n  int _requestAnimationFrame(RequestAnimationFrameCallback callback) native;\n\n  @JSName('cancelAnimationFrame')\n  void _cancelAnimationFrame(int id) native;\n\n  _ensureRequestAnimationFrame() {\n    if (JS('bool',\n           '!!(#.requestAnimationFrame && #.cancelAnimationFrame)', this, this))\n      return;\n\n    JS('void',\n       r\"\"\"\n  (function($this) {\n   var vendors = ['ms', 'moz', 'webkit', 'o'];\n   for (var i = 0; i < vendors.length && !$this.requestAnimationFrame; ++i) {\n     $this.requestAnimationFrame = $this[vendors[i] + 'RequestAnimationFrame'];\n     $this.cancelAnimationFrame =\n         $this[vendors[i]+'CancelAnimationFrame'] ||\n         $this[vendors[i]+'CancelRequestAnimationFrame'];\n   }\n   if ($this.requestAnimationFrame && $this.cancelAnimationFrame) return;\n   $this.requestAnimationFrame = function(callback) {\n      return window.setTimeout(function() {\n        callback(Date.now());\n      }, 16 /* 16ms ~= 60fps */);\n   };\n   $this.cancelAnimationFrame = function(id) { clearTimeout(id); }\n  })(#)\"\"\",\n       this);\n  }\n\n  /**\n   * Gets an instance of the Indexed DB factory to being using Indexed DB.\n   *\n   * Use [IdbFactory.supported] to check if Indexed DB is supported on the\n   * current platform.\n   */\n  @SupportedBrowser(SupportedBrowser.CHROME, '23.0')\n  @SupportedBrowser(SupportedBrowser.FIREFOX, '15.0')\n  @SupportedBrowser(SupportedBrowser.IE, '10.0')\n  @Experimental\n  IdbFactory get indexedDB =>\n      JS('IdbFactory|Null',  // If not supported, returns `null`.\n         '#.indexedDB || #.webkitIndexedDB || #.mozIndexedDB',\n         this, this, this);\n\n  @DomName('Window.console')\n  Console get console => Console.safeConsole;\n\n  /// Checks if _setImmediate is supported.\n  static bool get _supportsSetImmediate =>\n      JS('bool', '!!(window.setImmediate)');\n\n  // Set immediate implementation for IE\n  void _setImmediate(void callback()) {\n    JS('void', '#.setImmediate(#)', this, convertDartClosureToJS(callback, 0));\n  }\n\n  /**\n   * Access a sandboxed file system of the specified `size`. If `persistent` is\n   * true, the application will request permission from the user to create\n   * lasting storage. This storage cannot be freed without the user's\n   * permission. Returns a [Future] whose value stores a reference to the\n   * sandboxed file system for use. Because the file system is sandboxed,\n   * applications cannot access file systems created in other web pages.\n   */\n  Future<FileSystem> requestFileSystem(int size, {bool persistent: false}) {\n    return _requestFileSystem(persistent? 1 : 0, size);\n  }\n\n  @DomName('DOMWindow.convertPointFromNodeToPage')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  Point convertPointFromNodeToPage(Node node, Point point) {\n    var result = _convertPointFromNodeToPage(node,\n        new _DomPoint(point.x, point.y));\n    return new Point(result.x, result.y);\n  }\n\n  @DomName('DOMWindow.convertPointFromPageToNode')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  Point convertPointFromPageToNode(Node node, Point point) {\n    var result = _convertPointFromPageToNode(node,\n        new _DomPoint(point.x, point.y));\n    return new Point(result.x, result.y);\n  }\n\n  /**\n   * Checks whether [convertPointFromNodeToPage] and\n   * [convertPointFromPageToNode] are supported on the current platform.\n   */\n  static bool get supportsPointConversions => _DomPoint.supported;\n\n  @DomName('DOMWindow.DOMContentLoadedEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> contentLoadedEvent = const EventStreamProvider<Event>('DOMContentLoaded');\n\n  @DomName('DOMWindow.devicemotionEvent')\n  @DocsEditable\n  static const EventStreamProvider<DeviceMotionEvent> deviceMotionEvent = const EventStreamProvider<DeviceMotionEvent>('devicemotion');\n\n  @DomName('DOMWindow.deviceorientationEvent')\n  @DocsEditable\n  static const EventStreamProvider<DeviceOrientationEvent> deviceOrientationEvent = const EventStreamProvider<DeviceOrientationEvent>('deviceorientation');\n\n  @DomName('DOMWindow.hashchangeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> hashChangeEvent = const EventStreamProvider<Event>('hashchange');\n\n  @DomName('DOMWindow.messageEvent')\n  @DocsEditable\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  @DomName('DOMWindow.offlineEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> offlineEvent = const EventStreamProvider<Event>('offline');\n\n  @DomName('DOMWindow.onlineEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> onlineEvent = const EventStreamProvider<Event>('online');\n\n  @DomName('DOMWindow.pagehideEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> pageHideEvent = const EventStreamProvider<Event>('pagehide');\n\n  @DomName('DOMWindow.pageshowEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> pageShowEvent = const EventStreamProvider<Event>('pageshow');\n\n  @DomName('DOMWindow.popstateEvent')\n  @DocsEditable\n  static const EventStreamProvider<PopStateEvent> popStateEvent = const EventStreamProvider<PopStateEvent>('popstate');\n\n  @DomName('DOMWindow.resizeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> resizeEvent = const EventStreamProvider<Event>('resize');\n\n  @DomName('DOMWindow.storageEvent')\n  @DocsEditable\n  static const EventStreamProvider<StorageEvent> storageEvent = const EventStreamProvider<StorageEvent>('storage');\n\n  @DomName('DOMWindow.unloadEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> unloadEvent = const EventStreamProvider<Event>('unload');\n\n  @DomName('DOMWindow.webkitAnimationEndEvent')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  static const EventStreamProvider<AnimationEvent> animationEndEvent = const EventStreamProvider<AnimationEvent>('webkitAnimationEnd');\n\n  @DomName('DOMWindow.webkitAnimationIterationEvent')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  static const EventStreamProvider<AnimationEvent> animationIterationEvent = const EventStreamProvider<AnimationEvent>('webkitAnimationIteration');\n\n  @DomName('DOMWindow.webkitAnimationStartEvent')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  static const EventStreamProvider<AnimationEvent> animationStartEvent = const EventStreamProvider<AnimationEvent>('webkitAnimationStart');\n\n  static const int PERSISTENT = 1;\n\n  static const int TEMPORARY = 0;\n\n  @DomName('DOMWindow.applicationCache')\n  @DocsEditable\n  final ApplicationCache applicationCache;\n\n  @DomName('DOMWindow.closed')\n  @DocsEditable\n  final bool closed;\n\n  @DomName('DOMWindow.crypto')\n  @DocsEditable\n  final Crypto crypto;\n\n  @DomName('DOMWindow.defaultStatus')\n  @DocsEditable\n  String defaultStatus;\n\n  @DomName('DOMWindow.defaultstatus')\n  @DocsEditable\n  String defaultstatus;\n\n  @DomName('DOMWindow.devicePixelRatio')\n  @DocsEditable\n  final num devicePixelRatio;\n\n  @DomName('DOMWindow.event')\n  @DocsEditable\n  final Event event;\n\n  @DomName('DOMWindow.history')\n  @DocsEditable\n  final History history;\n\n  @DomName('DOMWindow.innerHeight')\n  @DocsEditable\n  final int innerHeight;\n\n  @DomName('DOMWindow.innerWidth')\n  @DocsEditable\n  final int innerWidth;\n\n  @DomName('DOMWindow.localStorage')\n  @DocsEditable\n  final Storage localStorage;\n\n  @DomName('DOMWindow.locationbar')\n  @DocsEditable\n  final BarInfo locationbar;\n\n  @DomName('DOMWindow.menubar')\n  @DocsEditable\n  final BarInfo menubar;\n\n  @DomName('DOMWindow.name')\n  @DocsEditable\n  String name;\n\n  @DomName('DOMWindow.navigator')\n  @DocsEditable\n  final Navigator navigator;\n\n  @DomName('DOMWindow.offscreenBuffering')\n  @DocsEditable\n  final bool offscreenBuffering;\n\n  WindowBase get opener => _convertNativeToDart_Window(this._get_opener);\n  @JSName('opener')\n  @DomName('DOMWindow.opener')\n  @DocsEditable\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_opener;\n\n  @DomName('DOMWindow.outerHeight')\n  @DocsEditable\n  final int outerHeight;\n\n  @DomName('DOMWindow.outerWidth')\n  @DocsEditable\n  final int outerWidth;\n\n  @DomName('DOMWindow.pagePopupController')\n  @DocsEditable\n  final PagePopupController pagePopupController;\n\n  @DomName('DOMWindow.pageXOffset')\n  @DocsEditable\n  final int pageXOffset;\n\n  @DomName('DOMWindow.pageYOffset')\n  @DocsEditable\n  final int pageYOffset;\n\n  WindowBase get parent => _convertNativeToDart_Window(this._get_parent);\n  @JSName('parent')\n  @DomName('DOMWindow.parent')\n  @DocsEditable\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_parent;\n\n  @DomName('DOMWindow.performance')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE)\n  final Performance performance;\n\n  @DomName('DOMWindow.personalbar')\n  @DocsEditable\n  final BarInfo personalbar;\n\n  @DomName('DOMWindow.screen')\n  @DocsEditable\n  final Screen screen;\n\n  @DomName('DOMWindow.screenLeft')\n  @DocsEditable\n  final int screenLeft;\n\n  @DomName('DOMWindow.screenTop')\n  @DocsEditable\n  final int screenTop;\n\n  @DomName('DOMWindow.screenX')\n  @DocsEditable\n  final int screenX;\n\n  @DomName('DOMWindow.screenY')\n  @DocsEditable\n  final int screenY;\n\n  @DomName('DOMWindow.scrollX')\n  @DocsEditable\n  final int scrollX;\n\n  @DomName('DOMWindow.scrollY')\n  @DocsEditable\n  final int scrollY;\n\n  @DomName('DOMWindow.scrollbars')\n  @DocsEditable\n  final BarInfo scrollbars;\n\n  WindowBase get self => _convertNativeToDart_Window(this._get_self);\n  @JSName('self')\n  @DomName('DOMWindow.self')\n  @DocsEditable\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_self;\n\n  @DomName('DOMWindow.sessionStorage')\n  @DocsEditable\n  final Storage sessionStorage;\n\n  @DomName('DOMWindow.status')\n  @DocsEditable\n  String status;\n\n  @DomName('DOMWindow.statusbar')\n  @DocsEditable\n  final BarInfo statusbar;\n\n  @DomName('DOMWindow.styleMedia')\n  @DocsEditable\n  final StyleMedia styleMedia;\n\n  @DomName('DOMWindow.toolbar')\n  @DocsEditable\n  final BarInfo toolbar;\n\n  WindowBase get top => _convertNativeToDart_Window(this._get_top);\n  @JSName('top')\n  @DomName('DOMWindow.top')\n  @DocsEditable\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_top;\n\n  @JSName('webkitNotifications')\n  @DomName('DOMWindow.webkitNotifications')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final NotificationCenter notifications;\n\n  @JSName('webkitStorageInfo')\n  @DomName('DOMWindow.webkitStorageInfo')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final StorageInfo storageInfo;\n\n  WindowBase get window => _convertNativeToDart_Window(this._get_window);\n  @JSName('window')\n  @DomName('DOMWindow.window')\n  @DocsEditable\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_window;\n\n  @JSName('addEventListener')\n  @DomName('DOMWindow.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('DOMWindow.alert')\n  @DocsEditable\n  void alert(String message) native;\n\n  @DomName('DOMWindow.atob')\n  @DocsEditable\n  String atob(String string) native;\n\n  @DomName('DOMWindow.btoa')\n  @DocsEditable\n  String btoa(String string) native;\n\n  @DomName('DOMWindow.captureEvents')\n  @DocsEditable\n  void captureEvents() native;\n\n  @JSName('clearInterval')\n  @DomName('DOMWindow.clearInterval')\n  @DocsEditable\n  void _clearInterval(int handle) native;\n\n  @JSName('clearTimeout')\n  @DomName('DOMWindow.clearTimeout')\n  @DocsEditable\n  void _clearTimeout(int handle) native;\n\n  @DomName('DOMWindow.close')\n  @DocsEditable\n  void close() native;\n\n  @DomName('DOMWindow.confirm')\n  @DocsEditable\n  bool confirm(String message) native;\n\n  @DomName('DOMWindow.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @DomName('DOMWindow.find')\n  @DocsEditable\n  bool find(String string, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog) native;\n\n  @JSName('getComputedStyle')\n  @DomName('DOMWindow.getComputedStyle')\n  @DocsEditable\n  CssStyleDeclaration $dom_getComputedStyle(Element element, String pseudoElement) native;\n\n  @JSName('getMatchedCSSRules')\n  @DomName('DOMWindow.getMatchedCSSRules')\n  @DocsEditable\n  @Returns('_CssRuleList')\n  @Creates('_CssRuleList')\n  List<CssRule> getMatchedCssRules(Element element, String pseudoElement) native;\n\n  @DomName('DOMWindow.getSelection')\n  @DocsEditable\n  DomSelection getSelection() native;\n\n  @DomName('DOMWindow.matchMedia')\n  @DocsEditable\n  MediaQueryList matchMedia(String query) native;\n\n  @DomName('DOMWindow.moveBy')\n  @DocsEditable\n  void moveBy(num x, num y) native;\n\n  @DomName('DOMWindow.moveTo')\n  @DocsEditable\n  void moveTo(num x, num y) native;\n\n  @DomName('DOMWindow.openDatabase')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  @Creates('SqlDatabase')\n  SqlDatabase openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]) native;\n\n  @DomName('DOMWindow.postMessage')\n  @DocsEditable\n  void postMessage(/*SerializedScriptValue*/ message, String targetOrigin, [List messagePorts]) {\n    if (?messagePorts) {\n      var message_1 = convertDartToNative_SerializedScriptValue(message);\n      _postMessage_1(message_1, targetOrigin, messagePorts);\n      return;\n    }\n    var message_2 = convertDartToNative_SerializedScriptValue(message);\n    _postMessage_2(message_2, targetOrigin);\n    return;\n  }\n  @JSName('postMessage')\n  @DomName('DOMWindow.postMessage')\n  @DocsEditable\n  void _postMessage_1(message, targetOrigin, List messagePorts) native;\n  @JSName('postMessage')\n  @DomName('DOMWindow.postMessage')\n  @DocsEditable\n  void _postMessage_2(message, targetOrigin) native;\n\n  @DomName('DOMWindow.print')\n  @DocsEditable\n  void print() native;\n\n  @DomName('DOMWindow.releaseEvents')\n  @DocsEditable\n  void releaseEvents() native;\n\n  @JSName('removeEventListener')\n  @DomName('DOMWindow.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('DOMWindow.resizeBy')\n  @DocsEditable\n  void resizeBy(num x, num y) native;\n\n  @DomName('DOMWindow.resizeTo')\n  @DocsEditable\n  void resizeTo(num width, num height) native;\n\n  @DomName('DOMWindow.scroll')\n  @DocsEditable\n  void scroll(int x, int y) native;\n\n  @DomName('DOMWindow.scrollBy')\n  @DocsEditable\n  void scrollBy(int x, int y) native;\n\n  @DomName('DOMWindow.scrollTo')\n  @DocsEditable\n  void scrollTo(int x, int y) native;\n\n  @JSName('setInterval')\n  @DomName('DOMWindow.setInterval')\n  @DocsEditable\n  int _setInterval(Object handler, int timeout) native;\n\n  @JSName('setTimeout')\n  @DomName('DOMWindow.setTimeout')\n  @DocsEditable\n  int _setTimeout(Object handler, int timeout) native;\n\n  @DomName('DOMWindow.showModalDialog')\n  @DocsEditable\n  Object showModalDialog(String url, [Object dialogArgs, String featureArgs]) native;\n\n  @DomName('DOMWindow.stop')\n  @DocsEditable\n  void stop() native;\n\n  @DomName('DOMWindow.toString')\n  @DocsEditable\n  String toString() native;\n\n  @JSName('webkitConvertPointFromNodeToPage')\n  @DomName('DOMWindow.webkitConvertPointFromNodeToPage')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  _DomPoint _convertPointFromNodeToPage(Node node, _DomPoint p) native;\n\n  @JSName('webkitConvertPointFromPageToNode')\n  @DomName('DOMWindow.webkitConvertPointFromPageToNode')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  _DomPoint _convertPointFromPageToNode(Node node, _DomPoint p) native;\n\n  @JSName('webkitRequestFileSystem')\n  @DomName('DOMWindow.webkitRequestFileSystem')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @Experimental\n  void __requestFileSystem(int type, int size, _FileSystemCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('webkitRequestFileSystem')\n  @DomName('DOMWindow.webkitRequestFileSystem')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @Experimental\n  Future<FileSystem> _requestFileSystem(int type, int size) {\n    var completer = new Completer<FileSystem>();\n    __requestFileSystem(type, size,\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('webkitResolveLocalFileSystemURL')\n  @DomName('DOMWindow.webkitResolveLocalFileSystemURL')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @Experimental\n  void _resolveLocalFileSystemUrl(String url, _EntryCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('webkitResolveLocalFileSystemURL')\n  @DomName('DOMWindow.webkitResolveLocalFileSystemURL')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @Experimental\n  Future<Entry> resolveLocalFileSystemUrl(String url) {\n    var completer = new Completer<Entry>();\n    _resolveLocalFileSystemUrl(url,\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @DomName('DOMWindow.onDOMContentLoaded')\n  @DocsEditable\n  Stream<Event> get onContentLoaded => contentLoadedEvent.forTarget(this);\n\n  @DomName('DOMWindow.onabort')\n  @DocsEditable\n  Stream<Event> get onAbort => Element.abortEvent.forTarget(this);\n\n  @DomName('DOMWindow.onblur')\n  @DocsEditable\n  Stream<Event> get onBlur => Element.blurEvent.forTarget(this);\n\n  @DomName('DOMWindow.onchange')\n  @DocsEditable\n  Stream<Event> get onChange => Element.changeEvent.forTarget(this);\n\n  @DomName('DOMWindow.onclick')\n  @DocsEditable\n  Stream<MouseEvent> get onClick => Element.clickEvent.forTarget(this);\n\n  @DomName('DOMWindow.oncontextmenu')\n  @DocsEditable\n  Stream<MouseEvent> get onContextMenu => Element.contextMenuEvent.forTarget(this);\n\n  @DomName('DOMWindow.ondblclick')\n  @DocsEditable\n  Stream<Event> get onDoubleClick => Element.doubleClickEvent.forTarget(this);\n\n  @DomName('DOMWindow.ondevicemotion')\n  @DocsEditable\n  Stream<DeviceMotionEvent> get onDeviceMotion => deviceMotionEvent.forTarget(this);\n\n  @DomName('DOMWindow.ondeviceorientation')\n  @DocsEditable\n  Stream<DeviceOrientationEvent> get onDeviceOrientation => deviceOrientationEvent.forTarget(this);\n\n  @DomName('DOMWindow.ondrag')\n  @DocsEditable\n  Stream<MouseEvent> get onDrag => Element.dragEvent.forTarget(this);\n\n  @DomName('DOMWindow.ondragend')\n  @DocsEditable\n  Stream<MouseEvent> get onDragEnd => Element.dragEndEvent.forTarget(this);\n\n  @DomName('DOMWindow.ondragenter')\n  @DocsEditable\n  Stream<MouseEvent> get onDragEnter => Element.dragEnterEvent.forTarget(this);\n\n  @DomName('DOMWindow.ondragleave')\n  @DocsEditable\n  Stream<MouseEvent> get onDragLeave => Element.dragLeaveEvent.forTarget(this);\n\n  @DomName('DOMWindow.ondragover')\n  @DocsEditable\n  Stream<MouseEvent> get onDragOver => Element.dragOverEvent.forTarget(this);\n\n  @DomName('DOMWindow.ondragstart')\n  @DocsEditable\n  Stream<MouseEvent> get onDragStart => Element.dragStartEvent.forTarget(this);\n\n  @DomName('DOMWindow.ondrop')\n  @DocsEditable\n  Stream<MouseEvent> get onDrop => Element.dropEvent.forTarget(this);\n\n  @DomName('DOMWindow.onerror')\n  @DocsEditable\n  Stream<Event> get onError => Element.errorEvent.forTarget(this);\n\n  @DomName('DOMWindow.onfocus')\n  @DocsEditable\n  Stream<Event> get onFocus => Element.focusEvent.forTarget(this);\n\n  @DomName('DOMWindow.onhashchange')\n  @DocsEditable\n  Stream<Event> get onHashChange => hashChangeEvent.forTarget(this);\n\n  @DomName('DOMWindow.oninput')\n  @DocsEditable\n  Stream<Event> get onInput => Element.inputEvent.forTarget(this);\n\n  @DomName('DOMWindow.oninvalid')\n  @DocsEditable\n  Stream<Event> get onInvalid => Element.invalidEvent.forTarget(this);\n\n  @DomName('DOMWindow.onkeydown')\n  @DocsEditable\n  Stream<KeyboardEvent> get onKeyDown => Element.keyDownEvent.forTarget(this);\n\n  @DomName('DOMWindow.onkeypress')\n  @DocsEditable\n  Stream<KeyboardEvent> get onKeyPress => Element.keyPressEvent.forTarget(this);\n\n  @DomName('DOMWindow.onkeyup')\n  @DocsEditable\n  Stream<KeyboardEvent> get onKeyUp => Element.keyUpEvent.forTarget(this);\n\n  @DomName('DOMWindow.onload')\n  @DocsEditable\n  Stream<Event> get onLoad => Element.loadEvent.forTarget(this);\n\n  @DomName('DOMWindow.onmessage')\n  @DocsEditable\n  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);\n\n  @DomName('DOMWindow.onmousedown')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseDown => Element.mouseDownEvent.forTarget(this);\n\n  @DomName('DOMWindow.onmousemove')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseMove => Element.mouseMoveEvent.forTarget(this);\n\n  @DomName('DOMWindow.onmouseout')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseOut => Element.mouseOutEvent.forTarget(this);\n\n  @DomName('DOMWindow.onmouseover')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseOver => Element.mouseOverEvent.forTarget(this);\n\n  @DomName('DOMWindow.onmouseup')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseUp => Element.mouseUpEvent.forTarget(this);\n\n  @DomName('DOMWindow.onmousewheel')\n  @DocsEditable\n  Stream<WheelEvent> get onMouseWheel => Element.mouseWheelEvent.forTarget(this);\n\n  @DomName('DOMWindow.onoffline')\n  @DocsEditable\n  Stream<Event> get onOffline => offlineEvent.forTarget(this);\n\n  @DomName('DOMWindow.ononline')\n  @DocsEditable\n  Stream<Event> get onOnline => onlineEvent.forTarget(this);\n\n  @DomName('DOMWindow.onpagehide')\n  @DocsEditable\n  Stream<Event> get onPageHide => pageHideEvent.forTarget(this);\n\n  @DomName('DOMWindow.onpageshow')\n  @DocsEditable\n  Stream<Event> get onPageShow => pageShowEvent.forTarget(this);\n\n  @DomName('DOMWindow.onpopstate')\n  @DocsEditable\n  Stream<PopStateEvent> get onPopState => popStateEvent.forTarget(this);\n\n  @DomName('DOMWindow.onreset')\n  @DocsEditable\n  Stream<Event> get onReset => Element.resetEvent.forTarget(this);\n\n  @DomName('DOMWindow.onresize')\n  @DocsEditable\n  Stream<Event> get onResize => resizeEvent.forTarget(this);\n\n  @DomName('DOMWindow.onscroll')\n  @DocsEditable\n  Stream<Event> get onScroll => Element.scrollEvent.forTarget(this);\n\n  @DomName('DOMWindow.onsearch')\n  @DocsEditable\n  Stream<Event> get onSearch => Element.searchEvent.forTarget(this);\n\n  @DomName('DOMWindow.onselect')\n  @DocsEditable\n  Stream<Event> get onSelect => Element.selectEvent.forTarget(this);\n\n  @DomName('DOMWindow.onstorage')\n  @DocsEditable\n  Stream<StorageEvent> get onStorage => storageEvent.forTarget(this);\n\n  @DomName('DOMWindow.onsubmit')\n  @DocsEditable\n  Stream<Event> get onSubmit => Element.submitEvent.forTarget(this);\n\n  @DomName('DOMWindow.ontouchcancel')\n  @DocsEditable\n  Stream<TouchEvent> get onTouchCancel => Element.touchCancelEvent.forTarget(this);\n\n  @DomName('DOMWindow.ontouchend')\n  @DocsEditable\n  Stream<TouchEvent> get onTouchEnd => Element.touchEndEvent.forTarget(this);\n\n  @DomName('DOMWindow.ontouchmove')\n  @DocsEditable\n  Stream<TouchEvent> get onTouchMove => Element.touchMoveEvent.forTarget(this);\n\n  @DomName('DOMWindow.ontouchstart')\n  @DocsEditable\n  Stream<TouchEvent> get onTouchStart => Element.touchStartEvent.forTarget(this);\n\n  @DomName('DOMWindow.onunload')\n  @DocsEditable\n  Stream<Event> get onUnload => unloadEvent.forTarget(this);\n\n  @DomName('DOMWindow.onwebkitAnimationEnd')\n  @DocsEditable\n  Stream<AnimationEvent> get onAnimationEnd => animationEndEvent.forTarget(this);\n\n  @DomName('DOMWindow.onwebkitAnimationIteration')\n  @DocsEditable\n  Stream<AnimationEvent> get onAnimationIteration => animationIterationEvent.forTarget(this);\n\n  @DomName('DOMWindow.onwebkitAnimationStart')\n  @DocsEditable\n  Stream<AnimationEvent> get onAnimationStart => animationStartEvent.forTarget(this);\n\n  @DomName('DOMWindow.onwebkitTransitionEnd')\n  @DocsEditable\n  Stream<TransitionEvent> get onTransitionEnd => Element.transitionEndEvent.forTarget(this);\n\n\n  @DomName('DOMWindow.beforeunloadEvent')\n  @DocsEditable\n  static const EventStreamProvider<BeforeUnloadEvent> beforeUnloadEvent =\n      const _BeforeUnloadEventStreamProvider('beforeunload');\n\n  @DomName('DOMWindow.onbeforeunload')\n  @DocsEditable\n  Stream<Event> get onBeforeUnload => beforeUnloadEvent.forTarget(this);\n}\n\n/**\n * Event object that is fired before the window is closed.\n *\n * The standard window close behavior can be prevented by setting the\n * [returnValue]. This will display a dialog to the user confirming that they\n * want to close the page.\n */\nabstract class BeforeUnloadEvent implements Event {\n  /**\n   * If set to a non-null value, a dialog will be presented to the user\n   * confirming that they want to close the page.\n   */\n  String returnValue;\n}\n\nclass _BeforeUnloadEvent extends _WrappedEvent implements BeforeUnloadEvent {\n  String _returnValue;\n\n  _BeforeUnloadEvent(Event base): super(base);\n\n  String get returnValue => _returnValue;\n\n  void set returnValue(String value) {\n    _returnValue = value;\n    // FF and IE use the value as the return value, Chrome will return this from\n    // the event callback function.\n    if (JS('bool', '(\"returnValue\" in #)', _base)) {\n      JS('void', '#.returnValue = #', _base, value);\n    }\n  }\n}\n\nclass _BeforeUnloadEventStreamProvider implements\n    EventStreamProvider<BeforeUnloadEvent> {\n  final String _eventType;\n\n  const _BeforeUnloadEventStreamProvider(this._eventType);\n\n  Stream<BeforeUnloadEvent> forTarget(EventTarget e, {bool useCapture: false}) {\n    var controller = new StreamController();\n    var stream = new _EventStream(e, _eventType, useCapture);\n    stream.listen((event) {\n      var wrapped = new _BeforeUnloadEvent(event);\n      controller.add(wrapped);\n      return wrapped.returnValue;\n    });\n\n    return controller.stream;\n  }\n\n  String getEventType(EventTarget target) {\n    return _eventType;\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Worker')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass Worker extends AbstractWorker native \"Worker\" {\n\n  @DomName('Worker.messageEvent')\n  @DocsEditable\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  @DomName('Worker.Worker')\n  @DocsEditable\n  factory Worker(String scriptUrl) {\n    return Worker._create_1(scriptUrl);\n  }\n  static Worker _create_1(scriptUrl) => JS('Worker', 'new Worker(#)', scriptUrl);\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '(typeof window.Worker != \"undefined\")');\n\n  @DomName('Worker.postMessage')\n  @DocsEditable\n  void postMessage(/*SerializedScriptValue*/ message, [List messagePorts]) native;\n\n  @DomName('Worker.terminate')\n  @DocsEditable\n  void terminate() native;\n\n  @DomName('Worker.onmessage')\n  @DocsEditable\n  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('XPathEvaluator')\nclass XPathEvaluator native \"XPathEvaluator\" {\n\n  @DomName('XPathEvaluator.XPathEvaluator')\n  @DocsEditable\n  factory XPathEvaluator() {\n    return XPathEvaluator._create_1();\n  }\n  static XPathEvaluator _create_1() => JS('XPathEvaluator', 'new XPathEvaluator()');\n\n  @DomName('XPathEvaluator.createExpression')\n  @DocsEditable\n  XPathExpression createExpression(String expression, XPathNSResolver resolver) native;\n\n  @DomName('XPathEvaluator.createNSResolver')\n  @DocsEditable\n  XPathNSResolver createNSResolver(Node nodeResolver) native;\n\n  @DomName('XPathEvaluator.evaluate')\n  @DocsEditable\n  XPathResult evaluate(String expression, Node contextNode, XPathNSResolver resolver, int type, XPathResult inResult) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('XPathException')\nclass XPathException native \"XPathException\" {\n\n  static const int INVALID_EXPRESSION_ERR = 51;\n\n  static const int TYPE_ERR = 52;\n\n  @DomName('XPathException.code')\n  @DocsEditable\n  final int code;\n\n  @DomName('XPathException.message')\n  @DocsEditable\n  final String message;\n\n  @DomName('XPathException.name')\n  @DocsEditable\n  final String name;\n\n  @DomName('XPathException.toString')\n  @DocsEditable\n  String toString() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('XPathExpression')\nclass XPathExpression native \"XPathExpression\" {\n\n  @DomName('XPathExpression.evaluate')\n  @DocsEditable\n  XPathResult evaluate(Node contextNode, int type, XPathResult inResult) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('XPathNSResolver')\nclass XPathNSResolver native \"XPathNSResolver\" {\n\n  @JSName('lookupNamespaceURI')\n  @DomName('XPathNSResolver.lookupNamespaceURI')\n  @DocsEditable\n  String lookupNamespaceUri(String prefix) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('XPathResult')\nclass XPathResult native \"XPathResult\" {\n\n  static const int ANY_TYPE = 0;\n\n  static const int ANY_UNORDERED_NODE_TYPE = 8;\n\n  static const int BOOLEAN_TYPE = 3;\n\n  static const int FIRST_ORDERED_NODE_TYPE = 9;\n\n  static const int NUMBER_TYPE = 1;\n\n  static const int ORDERED_NODE_ITERATOR_TYPE = 5;\n\n  static const int ORDERED_NODE_SNAPSHOT_TYPE = 7;\n\n  static const int STRING_TYPE = 2;\n\n  static const int UNORDERED_NODE_ITERATOR_TYPE = 4;\n\n  static const int UNORDERED_NODE_SNAPSHOT_TYPE = 6;\n\n  @DomName('XPathResult.booleanValue')\n  @DocsEditable\n  final bool booleanValue;\n\n  @DomName('XPathResult.invalidIteratorState')\n  @DocsEditable\n  final bool invalidIteratorState;\n\n  @DomName('XPathResult.numberValue')\n  @DocsEditable\n  final num numberValue;\n\n  @DomName('XPathResult.resultType')\n  @DocsEditable\n  final int resultType;\n\n  @DomName('XPathResult.singleNodeValue')\n  @DocsEditable\n  final Node singleNodeValue;\n\n  @DomName('XPathResult.snapshotLength')\n  @DocsEditable\n  final int snapshotLength;\n\n  @DomName('XPathResult.stringValue')\n  @DocsEditable\n  final String stringValue;\n\n  @DomName('XPathResult.iterateNext')\n  @DocsEditable\n  Node iterateNext() native;\n\n  @DomName('XPathResult.snapshotItem')\n  @DocsEditable\n  Node snapshotItem(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('XMLSerializer')\nclass XmlSerializer native \"XMLSerializer\" {\n\n  @DomName('XMLSerializer.XMLSerializer')\n  @DocsEditable\n  factory XmlSerializer() {\n    return XmlSerializer._create_1();\n  }\n  static XmlSerializer _create_1() => JS('XmlSerializer', 'new XMLSerializer()');\n\n  @DomName('XMLSerializer.serializeToString')\n  @DocsEditable\n  String serializeToString(Node node) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('XSLTProcessor')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass XsltProcessor native \"XSLTProcessor\" {\n\n  @DomName('XSLTProcessor.XSLTProcessor')\n  @DocsEditable\n  factory XsltProcessor() {\n    return XsltProcessor._create_1();\n  }\n  static XsltProcessor _create_1() => JS('XsltProcessor', 'new XSLTProcessor()');\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.XSLTProcessor)');\n\n  @DomName('XSLTProcessor.clearParameters')\n  @DocsEditable\n  void clearParameters() native;\n\n  @DomName('XSLTProcessor.getParameter')\n  @DocsEditable\n  String getParameter(String namespaceURI, String localName) native;\n\n  @DomName('XSLTProcessor.importStylesheet')\n  @DocsEditable\n  void importStylesheet(Node stylesheet) native;\n\n  @DomName('XSLTProcessor.removeParameter')\n  @DocsEditable\n  void removeParameter(String namespaceURI, String localName) native;\n\n  @DomName('XSLTProcessor.reset')\n  @DocsEditable\n  void reset() native;\n\n  @DomName('XSLTProcessor.setParameter')\n  @DocsEditable\n  void setParameter(String namespaceURI, String localName, String value) native;\n\n  @DomName('XSLTProcessor.transformToDocument')\n  @DocsEditable\n  Document transformToDocument(Node source) native;\n\n  @DomName('XSLTProcessor.transformToFragment')\n  @DocsEditable\n  DocumentFragment transformToFragment(Node source, Document docVal) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CSSPrimitiveValue')\nabstract class _CSSPrimitiveValue extends _CSSValue native \"CSSPrimitiveValue\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CSSValue')\nabstract class _CSSValue native \"CSSValue\" {\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('ClientRect')\nclass _ClientRect implements Rect native \"ClientRect\" {\n\n  // NOTE! All code below should be common with Rect.\n  // TODO(blois): implement with mixins when available.\n\n  String toString() {\n    return '($left, $top, $width, $height)';\n  }\n\n  bool operator ==(other) {\n    if (other is !Rect) return false;\n    return left == other.left && top == other.top && width == other.width &&\n        height == other.height;\n  }\n\n  /**\n   * Computes the intersection of this rectangle and the rectangle parameter.\n   * Returns null if there is no intersection.\n   */\n  Rect intersection(Rect rect) {\n    var x0 = max(left, rect.left);\n    var x1 = min(left + width, rect.left + rect.width);\n\n    if (x0 <= x1) {\n      var y0 = max(top, rect.top);\n      var y1 = min(top + height, rect.top + rect.height);\n\n      if (y0 <= y1) {\n        return new Rect(x0, y0, x1 - x0, y1 - y0);\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * Returns whether a rectangle intersects this rectangle.\n   */\n  bool intersects(Rect other) {\n    return (left <= other.left + other.width && other.left <= left + width &&\n        top <= other.top + other.height && other.top <= top + height);\n  }\n\n  /**\n   * Returns a new rectangle which completely contains this rectangle and the\n   * input rectangle.\n   */\n  Rect union(Rect rect) {\n    var right = max(this.left + this.width, rect.left + rect.width);\n    var bottom = max(this.top + this.height, rect.top + rect.height);\n\n    var left = min(this.left, rect.left);\n    var top = min(this.top, rect.top);\n\n    return new Rect(left, top, right - left, bottom - top);\n  }\n\n  /**\n   * Tests whether this rectangle entirely contains another rectangle.\n   */\n  bool containsRect(Rect another) {\n    return left <= another.left &&\n           left + width >= another.left + another.width &&\n           top <= another.top &&\n           top + height >= another.top + another.height;\n  }\n\n  /**\n   * Tests whether this rectangle entirely contains a point.\n   */\n  bool containsPoint(Point another) {\n    return another.x >= left &&\n           another.x <= left + width &&\n           another.y >= top &&\n           another.y <= top + height;\n  }\n\n  Rect ceil() => new Rect(left.ceil(), top.ceil(), width.ceil(), height.ceil());\n  Rect floor() => new Rect(left.floor(), top.floor(), width.floor(),\n      height.floor());\n  Rect round() => new Rect(left.round(), top.round(), width.round(),\n      height.round());\n\n  /**\n   * Truncates coordinates to integers and returns the result as a new\n   * rectangle.\n   */\n  Rect toInt() => new Rect(left.toInt(), top.toInt(), width.toInt(),\n      height.toInt());\n\n  Point get topLeft => new Point(this.left, this.top);\n  Point get bottomRight => new Point(this.left + this.width,\n      this.top + this.height);\n\n  @DomName('ClientRect.bottom')\n  @DocsEditable\n  final num bottom;\n\n  @DomName('ClientRect.height')\n  @DocsEditable\n  final num height;\n\n  @DomName('ClientRect.left')\n  @DocsEditable\n  final num left;\n\n  @DomName('ClientRect.right')\n  @DocsEditable\n  final num right;\n\n  @DomName('ClientRect.top')\n  @DocsEditable\n  final num top;\n\n  @DomName('ClientRect.width')\n  @DocsEditable\n  final num width;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('ClientRectList')\nclass _ClientRectList implements JavaScriptIndexingBehavior, List<Rect> native \"ClientRectList\" {\n\n  @DomName('ClientRectList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Rect operator[](int index) => JS(\"Rect\", \"#[#]\", this, index);\n\n  void operator[]=(int index, Rect value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Rect> mixins.\n  // Rect is the element type.\n\n  // From Iterable<Rect>:\n\n  Iterator<Rect> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<Rect>(this);\n  }\n\n  Rect reduce(Rect combine(Rect value, Rect element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, Rect element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(Rect element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(Rect element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(Rect element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<Rect> where(bool f(Rect element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(Rect element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(Rect element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(Rect element)) => IterableMixinWorkaround.any(this, f);\n\n  List<Rect> toList({ bool growable: true }) =>\n      new List<Rect>.from(this, growable: growable);\n\n  Set<Rect> toSet() => new Set<Rect>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<Rect> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<Rect> takeWhile(bool test(Rect value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<Rect> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<Rect> skipWhile(bool test(Rect value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  Rect firstWhere(bool test(Rect value), { Rect orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  Rect lastWhere(bool test(Rect value), {Rect orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  Rect singleWhere(bool test(Rect value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  Rect elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<Rect>:\n\n  void add(Rect value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<Rect> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<Rect>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<Rect> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(Rect a, Rect b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(Rect element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(Rect element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  Rect get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  Rect get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  Rect get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, Rect element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<Rect> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<Rect> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Rect removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  Rect removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(Rect element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(Rect element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<Rect> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<Rect> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [Rect fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<Rect> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<Rect> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <Rect>[]);\n  }\n\n  Map<int, Rect> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<Rect> mixins.\n\n  @DomName('ClientRectList.item')\n  @DocsEditable\n  Rect item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Counter')\nabstract class _Counter native \"Counter\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CSSRuleList')\nclass _CssRuleList implements JavaScriptIndexingBehavior, List<CssRule> native \"CSSRuleList\" {\n\n  @DomName('CSSRuleList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  CssRule operator[](int index) => JS(\"CssRule\", \"#[#]\", this, index);\n\n  void operator[]=(int index, CssRule value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<CssRule> mixins.\n  // CssRule is the element type.\n\n  // From Iterable<CssRule>:\n\n  Iterator<CssRule> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<CssRule>(this);\n  }\n\n  CssRule reduce(CssRule combine(CssRule value, CssRule element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, CssRule element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(CssRule element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(CssRule element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(CssRule element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<CssRule> where(bool f(CssRule element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(CssRule element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(CssRule element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(CssRule element)) => IterableMixinWorkaround.any(this, f);\n\n  List<CssRule> toList({ bool growable: true }) =>\n      new List<CssRule>.from(this, growable: growable);\n\n  Set<CssRule> toSet() => new Set<CssRule>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<CssRule> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<CssRule> takeWhile(bool test(CssRule value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<CssRule> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<CssRule> skipWhile(bool test(CssRule value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  CssRule firstWhere(bool test(CssRule value), { CssRule orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  CssRule lastWhere(bool test(CssRule value), {CssRule orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  CssRule singleWhere(bool test(CssRule value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  CssRule elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<CssRule>:\n\n  void add(CssRule value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<CssRule> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<CssRule>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<CssRule> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(CssRule a, CssRule b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(CssRule element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(CssRule element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  CssRule get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  CssRule get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  CssRule get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, CssRule element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<CssRule> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<CssRule> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  CssRule removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  CssRule removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(CssRule element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(CssRule element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<CssRule> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<CssRule> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [CssRule fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<CssRule> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<CssRule> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <CssRule>[]);\n  }\n\n  Map<int, CssRule> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<CssRule> mixins.\n\n  @DomName('CSSRuleList.item')\n  @DocsEditable\n  CssRule item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('CSSValueList')\nclass _CssValueList extends _CSSValue implements JavaScriptIndexingBehavior, List<_CSSValue> native \"CSSValueList\" {\n\n  @DomName('CSSValueList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  _CSSValue operator[](int index) => JS(\"_CSSValue\", \"#[#]\", this, index);\n\n  void operator[]=(int index, _CSSValue value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<_CSSValue> mixins.\n  // _CSSValue is the element type.\n\n  // From Iterable<_CSSValue>:\n\n  Iterator<_CSSValue> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<_CSSValue>(this);\n  }\n\n  _CSSValue reduce(_CSSValue combine(_CSSValue value, _CSSValue element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, _CSSValue element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(_CSSValue element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(_CSSValue element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(_CSSValue element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<_CSSValue> where(bool f(_CSSValue element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(_CSSValue element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(_CSSValue element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(_CSSValue element)) => IterableMixinWorkaround.any(this, f);\n\n  List<_CSSValue> toList({ bool growable: true }) =>\n      new List<_CSSValue>.from(this, growable: growable);\n\n  Set<_CSSValue> toSet() => new Set<_CSSValue>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<_CSSValue> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<_CSSValue> takeWhile(bool test(_CSSValue value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<_CSSValue> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<_CSSValue> skipWhile(bool test(_CSSValue value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  _CSSValue firstWhere(bool test(_CSSValue value), { _CSSValue orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  _CSSValue lastWhere(bool test(_CSSValue value), {_CSSValue orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  _CSSValue singleWhere(bool test(_CSSValue value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  _CSSValue elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<_CSSValue>:\n\n  void add(_CSSValue value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<_CSSValue> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<_CSSValue>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<_CSSValue> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(_CSSValue a, _CSSValue b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(_CSSValue element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(_CSSValue element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  _CSSValue get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  _CSSValue get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  _CSSValue get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, _CSSValue element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<_CSSValue> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<_CSSValue> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  _CSSValue removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  _CSSValue removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(_CSSValue element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(_CSSValue element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<_CSSValue> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<_CSSValue> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [_CSSValue fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<_CSSValue> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<_CSSValue> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <_CSSValue>[]);\n  }\n\n  Map<int, _CSSValue> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<_CSSValue> mixins.\n\n  @DomName('CSSValueList.item')\n  @DocsEditable\n  _CSSValue item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DOMFileSystemSync')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental\nabstract class _DOMFileSystemSync native \"DOMFileSystemSync\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DatabaseSync')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental\nabstract class _DatabaseSync native \"DatabaseSync\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DedicatedWorkerContext')\nabstract class _DedicatedWorkerContext extends _WorkerContext native \"DedicatedWorkerContext\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DirectoryEntrySync')\nabstract class _DirectoryEntrySync extends _EntrySync native \"DirectoryEntrySync\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DirectoryReaderSync')\nabstract class _DirectoryReaderSync native \"DirectoryReaderSync\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebKitPoint')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental\nclass _DomPoint native \"WebKitPoint\" {\n\n  @DomName('DOMPoint.DOMPoint')\n  @DocsEditable\n  factory _DomPoint(num x, num y) {\n    return _DomPoint._create_1(x, y);\n  }\n  static _DomPoint _create_1(x, y) => JS('_DomPoint', 'new WebKitPoint(#,#)', x, y);\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.WebKitPoint)');\n\n  @DomName('DOMPoint.x')\n  @DocsEditable\n  num x;\n\n  @DomName('DOMPoint.y')\n  @DocsEditable\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('EntryArray')\nclass _EntryArray implements JavaScriptIndexingBehavior, List<Entry> native \"EntryArray\" {\n\n  @DomName('EntryArray.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Entry operator[](int index) => JS(\"Entry\", \"#[#]\", this, index);\n\n  void operator[]=(int index, Entry value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Entry> mixins.\n  // Entry is the element type.\n\n  // From Iterable<Entry>:\n\n  Iterator<Entry> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<Entry>(this);\n  }\n\n  Entry reduce(Entry combine(Entry value, Entry element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, Entry element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(Entry element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(Entry element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(Entry element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<Entry> where(bool f(Entry element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(Entry element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(Entry element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(Entry element)) => IterableMixinWorkaround.any(this, f);\n\n  List<Entry> toList({ bool growable: true }) =>\n      new List<Entry>.from(this, growable: growable);\n\n  Set<Entry> toSet() => new Set<Entry>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<Entry> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<Entry> takeWhile(bool test(Entry value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<Entry> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<Entry> skipWhile(bool test(Entry value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  Entry firstWhere(bool test(Entry value), { Entry orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  Entry lastWhere(bool test(Entry value), {Entry orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  Entry singleWhere(bool test(Entry value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  Entry elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<Entry>:\n\n  void add(Entry value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<Entry> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<Entry>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<Entry> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(Entry a, Entry b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(Entry element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(Entry element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  Entry get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  Entry get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  Entry get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, Entry element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<Entry> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<Entry> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Entry removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  Entry removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(Entry element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(Entry element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<Entry> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<Entry> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [Entry fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<Entry> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<Entry> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <Entry>[]);\n  }\n\n  Map<int, Entry> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<Entry> mixins.\n\n  @DomName('EntryArray.item')\n  @DocsEditable\n  Entry item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('EntryArraySync')\nclass _EntryArraySync implements JavaScriptIndexingBehavior, List<_EntrySync> native \"EntryArraySync\" {\n\n  @DomName('EntryArraySync.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  _EntrySync operator[](int index) => JS(\"_EntrySync\", \"#[#]\", this, index);\n\n  void operator[]=(int index, _EntrySync value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<_EntrySync> mixins.\n  // _EntrySync is the element type.\n\n  // From Iterable<_EntrySync>:\n\n  Iterator<_EntrySync> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<_EntrySync>(this);\n  }\n\n  _EntrySync reduce(_EntrySync combine(_EntrySync value, _EntrySync element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, _EntrySync element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(_EntrySync element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(_EntrySync element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(_EntrySync element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<_EntrySync> where(bool f(_EntrySync element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(_EntrySync element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(_EntrySync element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(_EntrySync element)) => IterableMixinWorkaround.any(this, f);\n\n  List<_EntrySync> toList({ bool growable: true }) =>\n      new List<_EntrySync>.from(this, growable: growable);\n\n  Set<_EntrySync> toSet() => new Set<_EntrySync>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<_EntrySync> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<_EntrySync> takeWhile(bool test(_EntrySync value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<_EntrySync> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<_EntrySync> skipWhile(bool test(_EntrySync value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  _EntrySync firstWhere(bool test(_EntrySync value), { _EntrySync orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  _EntrySync lastWhere(bool test(_EntrySync value), {_EntrySync orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  _EntrySync singleWhere(bool test(_EntrySync value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  _EntrySync elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<_EntrySync>:\n\n  void add(_EntrySync value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<_EntrySync> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<_EntrySync>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<_EntrySync> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(_EntrySync a, _EntrySync b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(_EntrySync element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(_EntrySync element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  _EntrySync get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  _EntrySync get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  _EntrySync get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, _EntrySync element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<_EntrySync> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<_EntrySync> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  _EntrySync removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  _EntrySync removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(_EntrySync element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(_EntrySync element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<_EntrySync> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<_EntrySync> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [_EntrySync fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<_EntrySync> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<_EntrySync> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <_EntrySync>[]);\n  }\n\n  Map<int, _EntrySync> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<_EntrySync> mixins.\n\n  @DomName('EntryArraySync.item')\n  @DocsEditable\n  _EntrySync item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('EntrySync')\nabstract class _EntrySync native \"EntrySync\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('FileEntrySync')\nabstract class _FileEntrySync extends _EntrySync native \"FileEntrySync\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('FileReaderSync')\nabstract class _FileReaderSync native \"FileReaderSync\" {\n\n  @DomName('FileReaderSync.FileReaderSync')\n  @DocsEditable\n  factory _FileReaderSync() {\n    return _FileReaderSync._create_1();\n  }\n  static _FileReaderSync _create_1() => JS('_FileReaderSync', 'new FileReaderSync()');\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('FileWriterSync')\nabstract class _FileWriterSync native \"FileWriterSync\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('GamepadList')\nclass _GamepadList implements JavaScriptIndexingBehavior, List<Gamepad> native \"GamepadList\" {\n\n  @DomName('GamepadList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Gamepad operator[](int index) => JS(\"Gamepad\", \"#[#]\", this, index);\n\n  void operator[]=(int index, Gamepad value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Gamepad> mixins.\n  // Gamepad is the element type.\n\n  // From Iterable<Gamepad>:\n\n  Iterator<Gamepad> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<Gamepad>(this);\n  }\n\n  Gamepad reduce(Gamepad combine(Gamepad value, Gamepad element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, Gamepad element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(Gamepad element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(Gamepad element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(Gamepad element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<Gamepad> where(bool f(Gamepad element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(Gamepad element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(Gamepad element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(Gamepad element)) => IterableMixinWorkaround.any(this, f);\n\n  List<Gamepad> toList({ bool growable: true }) =>\n      new List<Gamepad>.from(this, growable: growable);\n\n  Set<Gamepad> toSet() => new Set<Gamepad>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<Gamepad> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<Gamepad> takeWhile(bool test(Gamepad value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<Gamepad> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<Gamepad> skipWhile(bool test(Gamepad value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  Gamepad firstWhere(bool test(Gamepad value), { Gamepad orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  Gamepad lastWhere(bool test(Gamepad value), {Gamepad orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  Gamepad singleWhere(bool test(Gamepad value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  Gamepad elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<Gamepad>:\n\n  void add(Gamepad value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<Gamepad> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<Gamepad>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<Gamepad> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(Gamepad a, Gamepad b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(Gamepad element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(Gamepad element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  Gamepad get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  Gamepad get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  Gamepad get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, Gamepad element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<Gamepad> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<Gamepad> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Gamepad removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  Gamepad removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(Gamepad element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(Gamepad element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<Gamepad> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<Gamepad> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [Gamepad fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<Gamepad> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<Gamepad> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <Gamepad>[]);\n  }\n\n  Map<int, Gamepad> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<Gamepad> mixins.\n\n  @DomName('GamepadList.item')\n  @DocsEditable\n  Gamepad item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLAppletElement')\nabstract class _HTMLAppletElement extends Element native \"HTMLAppletElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLBaseFontElement')\nabstract class _HTMLBaseFontElement extends Element native \"HTMLBaseFontElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLDirectoryElement')\nabstract class _HTMLDirectoryElement extends Element native \"HTMLDirectoryElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLFontElement')\nabstract class _HTMLFontElement extends Element native \"HTMLFontElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLFrameElement')\nabstract class _HTMLFrameElement extends Element native \"HTMLFrameElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLFrameSetElement')\nabstract class _HTMLFrameSetElement extends Element native \"HTMLFrameSetElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('HTMLMarqueeElement')\nabstract class _HTMLMarqueeElement extends Element native \"HTMLMarqueeElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('NamedNodeMap')\nclass _NamedNodeMap implements JavaScriptIndexingBehavior, List<Node> native \"NamedNodeMap\" {\n\n  @DomName('NamedNodeMap.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Node operator[](int index) => JS(\"Node\", \"#[#]\", this, index);\n\n  void operator[]=(int index, Node value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Node> mixins.\n  // Node is the element type.\n\n  // From Iterable<Node>:\n\n  Iterator<Node> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<Node>(this);\n  }\n\n  Node reduce(Node combine(Node value, Node element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, Node element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(Node element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(Node element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(Node element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<Node> where(bool f(Node element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(Node element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(Node element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(Node element)) => IterableMixinWorkaround.any(this, f);\n\n  List<Node> toList({ bool growable: true }) =>\n      new List<Node>.from(this, growable: growable);\n\n  Set<Node> toSet() => new Set<Node>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<Node> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<Node> takeWhile(bool test(Node value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<Node> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<Node> skipWhile(bool test(Node value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  Node firstWhere(bool test(Node value), { Node orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  Node lastWhere(bool test(Node value), {Node orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  Node singleWhere(bool test(Node value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  Node elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<Node>:\n\n  void add(Node value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<Node>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<Node> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(Node a, Node b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(Node element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(Node element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  Node get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  Node get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  Node get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, Node element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Node removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  Node removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(Node element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(Node element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<Node> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [Node fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<Node> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<Node> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <Node>[]);\n  }\n\n  Map<int, Node> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<Node> mixins.\n\n  @DomName('NamedNodeMap.getNamedItem')\n  @DocsEditable\n  Node getNamedItem(String name) native;\n\n  @DomName('NamedNodeMap.getNamedItemNS')\n  @DocsEditable\n  Node getNamedItemNS(String namespaceURI, String localName) native;\n\n  @DomName('NamedNodeMap.item')\n  @DocsEditable\n  Node item(int index) native;\n\n  @DomName('NamedNodeMap.removeNamedItem')\n  @DocsEditable\n  Node removeNamedItem(String name) native;\n\n  @DomName('NamedNodeMap.removeNamedItemNS')\n  @DocsEditable\n  Node removeNamedItemNS(String namespaceURI, String localName) native;\n\n  @DomName('NamedNodeMap.setNamedItem')\n  @DocsEditable\n  Node setNamedItem(Node node) native;\n\n  @DomName('NamedNodeMap.setNamedItemNS')\n  @DocsEditable\n  Node setNamedItemNS(Node node) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('RGBColor')\nabstract class _RGBColor native \"RGBColor\" {\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n// Omit RadioNodeList for dart2js.  The Dart Form and FieldSet APIs don't\n// currently expose an API the returns RadioNodeList.  The only use of a\n// RadioNodeList is to get the selected value and it will be cleaner to\n// introduce a different API for that purpose.\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Rect')\nabstract class _Rect native \"Rect\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SharedWorker')\nabstract class _SharedWorker extends AbstractWorker native \"SharedWorker\" {\n\n  @DomName('SharedWorker.SharedWorker')\n  @DocsEditable\n  factory _SharedWorker(String scriptURL, [String name]) {\n    if (?name) {\n      return _SharedWorker._create_1(scriptURL, name);\n    }\n    return _SharedWorker._create_2(scriptURL);\n  }\n  static _SharedWorker _create_1(scriptURL, name) => JS('_SharedWorker', 'new SharedWorker(#,#)', scriptURL, name);\n  static _SharedWorker _create_2(scriptURL) => JS('_SharedWorker', 'new SharedWorker(#)', scriptURL);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SharedWorkerContext')\nabstract class _SharedWorkerContext extends _WorkerContext native \"SharedWorkerContext\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SpeechInputResultList')\nclass _SpeechInputResultList implements JavaScriptIndexingBehavior, List<SpeechInputResult> native \"SpeechInputResultList\" {\n\n  @DomName('SpeechInputResultList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  SpeechInputResult operator[](int index) => JS(\"SpeechInputResult\", \"#[#]\", this, index);\n\n  void operator[]=(int index, SpeechInputResult value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<SpeechInputResult> mixins.\n  // SpeechInputResult is the element type.\n\n  // From Iterable<SpeechInputResult>:\n\n  Iterator<SpeechInputResult> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<SpeechInputResult>(this);\n  }\n\n  SpeechInputResult reduce(SpeechInputResult combine(SpeechInputResult value, SpeechInputResult element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, SpeechInputResult element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(SpeechInputResult element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(SpeechInputResult element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(SpeechInputResult element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<SpeechInputResult> where(bool f(SpeechInputResult element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(SpeechInputResult element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(SpeechInputResult element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(SpeechInputResult element)) => IterableMixinWorkaround.any(this, f);\n\n  List<SpeechInputResult> toList({ bool growable: true }) =>\n      new List<SpeechInputResult>.from(this, growable: growable);\n\n  Set<SpeechInputResult> toSet() => new Set<SpeechInputResult>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<SpeechInputResult> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<SpeechInputResult> takeWhile(bool test(SpeechInputResult value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<SpeechInputResult> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<SpeechInputResult> skipWhile(bool test(SpeechInputResult value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  SpeechInputResult firstWhere(bool test(SpeechInputResult value), { SpeechInputResult orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  SpeechInputResult lastWhere(bool test(SpeechInputResult value), {SpeechInputResult orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  SpeechInputResult singleWhere(bool test(SpeechInputResult value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  SpeechInputResult elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<SpeechInputResult>:\n\n  void add(SpeechInputResult value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<SpeechInputResult> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<SpeechInputResult>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<SpeechInputResult> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(SpeechInputResult a, SpeechInputResult b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(SpeechInputResult element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(SpeechInputResult element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  SpeechInputResult get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  SpeechInputResult get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  SpeechInputResult get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, SpeechInputResult element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<SpeechInputResult> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<SpeechInputResult> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  SpeechInputResult removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  SpeechInputResult removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(SpeechInputResult element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(SpeechInputResult element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<SpeechInputResult> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<SpeechInputResult> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [SpeechInputResult fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<SpeechInputResult> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<SpeechInputResult> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <SpeechInputResult>[]);\n  }\n\n  Map<int, SpeechInputResult> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<SpeechInputResult> mixins.\n\n  @DomName('SpeechInputResultList.item')\n  @DocsEditable\n  SpeechInputResult item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SpeechRecognitionResultList')\nclass _SpeechRecognitionResultList implements JavaScriptIndexingBehavior, List<SpeechRecognitionResult> native \"SpeechRecognitionResultList\" {\n\n  @DomName('SpeechRecognitionResultList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  SpeechRecognitionResult operator[](int index) => JS(\"SpeechRecognitionResult\", \"#[#]\", this, index);\n\n  void operator[]=(int index, SpeechRecognitionResult value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<SpeechRecognitionResult> mixins.\n  // SpeechRecognitionResult is the element type.\n\n  // From Iterable<SpeechRecognitionResult>:\n\n  Iterator<SpeechRecognitionResult> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<SpeechRecognitionResult>(this);\n  }\n\n  SpeechRecognitionResult reduce(SpeechRecognitionResult combine(SpeechRecognitionResult value, SpeechRecognitionResult element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, SpeechRecognitionResult element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(SpeechRecognitionResult element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(SpeechRecognitionResult element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(SpeechRecognitionResult element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<SpeechRecognitionResult> where(bool f(SpeechRecognitionResult element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(SpeechRecognitionResult element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(SpeechRecognitionResult element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(SpeechRecognitionResult element)) => IterableMixinWorkaround.any(this, f);\n\n  List<SpeechRecognitionResult> toList({ bool growable: true }) =>\n      new List<SpeechRecognitionResult>.from(this, growable: growable);\n\n  Set<SpeechRecognitionResult> toSet() => new Set<SpeechRecognitionResult>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<SpeechRecognitionResult> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<SpeechRecognitionResult> takeWhile(bool test(SpeechRecognitionResult value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<SpeechRecognitionResult> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<SpeechRecognitionResult> skipWhile(bool test(SpeechRecognitionResult value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  SpeechRecognitionResult firstWhere(bool test(SpeechRecognitionResult value), { SpeechRecognitionResult orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  SpeechRecognitionResult lastWhere(bool test(SpeechRecognitionResult value), {SpeechRecognitionResult orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  SpeechRecognitionResult singleWhere(bool test(SpeechRecognitionResult value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  SpeechRecognitionResult elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<SpeechRecognitionResult>:\n\n  void add(SpeechRecognitionResult value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<SpeechRecognitionResult> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<SpeechRecognitionResult>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<SpeechRecognitionResult> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(SpeechRecognitionResult a, SpeechRecognitionResult b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(SpeechRecognitionResult element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(SpeechRecognitionResult element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  SpeechRecognitionResult get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  SpeechRecognitionResult get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  SpeechRecognitionResult get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, SpeechRecognitionResult element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<SpeechRecognitionResult> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<SpeechRecognitionResult> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  SpeechRecognitionResult removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  SpeechRecognitionResult removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(SpeechRecognitionResult element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(SpeechRecognitionResult element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<SpeechRecognitionResult> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<SpeechRecognitionResult> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [SpeechRecognitionResult fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<SpeechRecognitionResult> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<SpeechRecognitionResult> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <SpeechRecognitionResult>[]);\n  }\n\n  Map<int, SpeechRecognitionResult> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<SpeechRecognitionResult> mixins.\n\n  @DomName('SpeechRecognitionResultList.item')\n  @DocsEditable\n  SpeechRecognitionResult item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('StyleSheetList')\nclass _StyleSheetList implements JavaScriptIndexingBehavior, List<StyleSheet> native \"StyleSheetList\" {\n\n  @DomName('StyleSheetList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  StyleSheet operator[](int index) => JS(\"StyleSheet\", \"#[#]\", this, index);\n\n  void operator[]=(int index, StyleSheet value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<StyleSheet> mixins.\n  // StyleSheet is the element type.\n\n  // From Iterable<StyleSheet>:\n\n  Iterator<StyleSheet> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<StyleSheet>(this);\n  }\n\n  StyleSheet reduce(StyleSheet combine(StyleSheet value, StyleSheet element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, StyleSheet element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(StyleSheet element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(StyleSheet element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(StyleSheet element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<StyleSheet> where(bool f(StyleSheet element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(StyleSheet element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(StyleSheet element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(StyleSheet element)) => IterableMixinWorkaround.any(this, f);\n\n  List<StyleSheet> toList({ bool growable: true }) =>\n      new List<StyleSheet>.from(this, growable: growable);\n\n  Set<StyleSheet> toSet() => new Set<StyleSheet>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<StyleSheet> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<StyleSheet> takeWhile(bool test(StyleSheet value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<StyleSheet> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<StyleSheet> skipWhile(bool test(StyleSheet value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  StyleSheet firstWhere(bool test(StyleSheet value), { StyleSheet orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  StyleSheet lastWhere(bool test(StyleSheet value), {StyleSheet orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  StyleSheet singleWhere(bool test(StyleSheet value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  StyleSheet elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<StyleSheet>:\n\n  void add(StyleSheet value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<StyleSheet> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<StyleSheet>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<StyleSheet> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(StyleSheet a, StyleSheet b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(StyleSheet element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(StyleSheet element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  StyleSheet get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  StyleSheet get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  StyleSheet get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, StyleSheet element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<StyleSheet> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<StyleSheet> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  StyleSheet removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  StyleSheet removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(StyleSheet element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(StyleSheet element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<StyleSheet> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<StyleSheet> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [StyleSheet fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<StyleSheet> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<StyleSheet> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <StyleSheet>[]);\n  }\n\n  Map<int, StyleSheet> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<StyleSheet> mixins.\n\n  @DomName('StyleSheetList.item')\n  @DocsEditable\n  StyleSheet item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebKitCSSFilterValue')\nabstract class _WebKitCSSFilterValue extends _CssValueList native \"WebKitCSSFilterValue\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebKitCSSMatrix')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental\nabstract class _WebKitCSSMatrix native \"WebKitCSSMatrix\" {\n\n  @DomName('WebKitCSSMatrix.WebKitCSSMatrix')\n  @DocsEditable\n  factory _WebKitCSSMatrix([String cssValue]) {\n    if (?cssValue) {\n      return _WebKitCSSMatrix._create_1(cssValue);\n    }\n    return _WebKitCSSMatrix._create_2();\n  }\n  static _WebKitCSSMatrix _create_1(cssValue) => JS('_WebKitCSSMatrix', 'new WebKitCSSMatrix(#)', cssValue);\n  static _WebKitCSSMatrix _create_2() => JS('_WebKitCSSMatrix', 'new WebKitCSSMatrix()');\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebKitCSSMixFunctionValue')\nabstract class _WebKitCSSMixFunctionValue extends _CssValueList native \"WebKitCSSMixFunctionValue\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebKitCSSTransformValue')\nabstract class _WebKitCSSTransformValue extends _CssValueList native \"WebKitCSSTransformValue\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WorkerContext')\nabstract class _WorkerContext extends EventTarget native \"WorkerContext\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WorkerLocation')\nabstract class _WorkerLocation native \"WorkerLocation\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WorkerNavigator')\nabstract class _WorkerNavigator native \"WorkerNavigator\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nabstract class _AttributeMap implements Map<String, String> {\n  final Element _element;\n\n  _AttributeMap(this._element);\n\n  bool containsValue(String value) {\n    for (var v in this.values) {\n      if (value == v) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  String putIfAbsent(String key, String ifAbsent()) {\n    if (!containsKey(key)) {\n      this[key] = ifAbsent();\n    }\n    return this[key];\n  }\n\n  void clear() {\n    for (var key in keys) {\n      remove(key);\n    }\n  }\n\n  void forEach(void f(String key, String value)) {\n    for (var key in keys) {\n      var value = this[key];\n      f(key, value);\n    }\n  }\n\n  Iterable<String> get keys {\n    // TODO: generate a lazy collection instead.\n    var attributes = _element.$dom_attributes;\n    var keys = new List<String>();\n    for (int i = 0, len = attributes.length; i < len; i++) {\n      if (_matches(attributes[i])) {\n        keys.add(attributes[i].localName);\n      }\n    }\n    return keys;\n  }\n\n  Iterable<String> get values {\n    // TODO: generate a lazy collection instead.\n    var attributes = _element.$dom_attributes;\n    var values = new List<String>();\n    for (int i = 0, len = attributes.length; i < len; i++) {\n      if (_matches(attributes[i])) {\n        values.add(attributes[i].value);\n      }\n    }\n    return values;\n  }\n\n  /**\n   * Returns true if there is no {key, value} pair in the map.\n   */\n  bool get isEmpty {\n    return length == 0;\n  }\n\n  /**\n   * Checks to see if the node should be included in this map.\n   */\n  bool _matches(Node node);\n}\n\n/**\n * Wrapper to expose [Element.attributes] as a typed map.\n */\nclass _ElementAttributeMap extends _AttributeMap {\n\n  _ElementAttributeMap(Element element): super(element);\n\n  bool containsKey(String key) {\n    return _element.$dom_hasAttribute(key);\n  }\n\n  String operator [](String key) {\n    return _element.$dom_getAttribute(key);\n  }\n\n  void operator []=(String key, String value) {\n    _element.$dom_setAttribute(key, value);\n  }\n\n  String remove(String key) {\n    String value = _element.$dom_getAttribute(key);\n    _element.$dom_removeAttribute(key);\n    return value;\n  }\n\n  /**\n   * The number of {key, value} pairs in the map.\n   */\n  int get length {\n    return keys.length;\n  }\n\n  bool _matches(Node node) => node.$dom_namespaceUri == null;\n}\n\n/**\n * Wrapper to expose namespaced attributes as a typed map.\n */\nclass _NamespacedAttributeMap extends _AttributeMap {\n\n  final String _namespace;\n\n  _NamespacedAttributeMap(Element element, this._namespace): super(element);\n\n  bool containsKey(String key) {\n    return _element.$dom_hasAttributeNS(_namespace, key);\n  }\n\n  String operator [](String key) {\n    return _element.$dom_getAttributeNS(_namespace, key);\n  }\n\n  void operator []=(String key, String value) {\n    _element.$dom_setAttributeNS(_namespace, key, value);\n  }\n\n  String remove(String key) {\n    String value = this[key];\n    _element.$dom_removeAttributeNS(_namespace, key);\n    return value;\n  }\n\n  /**\n   * The number of {key, value} pairs in the map.\n   */\n  int get length {\n    return keys.length;\n  }\n\n  bool _matches(Node node) => node.$dom_namespaceUri == _namespace;\n}\n\n\n/**\n * Provides a Map abstraction on top of data-* attributes, similar to the\n * dataSet in the old DOM.\n */\nclass _DataAttributeMap implements Map<String, String> {\n\n  final Map<String, String> $dom_attributes;\n\n  _DataAttributeMap(this.$dom_attributes);\n\n  // interface Map\n\n  // TODO: Use lazy iterator when it is available on Map.\n  bool containsValue(String value) => values.any((v) => v == value);\n\n  bool containsKey(String key) => $dom_attributes.containsKey(_attr(key));\n\n  String operator [](String key) => $dom_attributes[_attr(key)];\n\n  void operator []=(String key, String value) {\n    $dom_attributes[_attr(key)] = value;\n  }\n\n  String putIfAbsent(String key, String ifAbsent()) =>\n    $dom_attributes.putIfAbsent(_attr(key), ifAbsent);\n\n  String remove(String key) => $dom_attributes.remove(_attr(key));\n\n  void clear() {\n    // Needs to operate on a snapshot since we are mutating the collection.\n    for (String key in keys) {\n      remove(key);\n    }\n  }\n\n  void forEach(void f(String key, String value)) {\n    $dom_attributes.forEach((String key, String value) {\n      if (_matches(key)) {\n        f(_strip(key), value);\n      }\n    });\n  }\n\n  Iterable<String> get keys {\n    final keys = new List<String>();\n    $dom_attributes.forEach((String key, String value) {\n      if (_matches(key)) {\n        keys.add(_strip(key));\n      }\n    });\n    return keys;\n  }\n\n  Iterable<String> get values {\n    final values = new List<String>();\n    $dom_attributes.forEach((String key, String value) {\n      if (_matches(key)) {\n        values.add(value);\n      }\n    });\n    return values;\n  }\n\n  int get length => keys.length;\n\n  // TODO: Use lazy iterator when it is available on Map.\n  bool get isEmpty => length == 0;\n\n  // Helpers.\n  String _attr(String key) => 'data-$key';\n  bool _matches(String key) => key.startsWith('data-');\n  String _strip(String key) => key.substring(5);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * An object that can be drawn to a [CanvasRenderingContext2D] object with\n * [CanvasRenderingContext2D.drawImage],\n * [CanvasRenderingContext2D.drawImageRect],\n * [CanvasRenderingContext2D.drawImageScaled], or\n * [CanvasRenderingContext2D.drawImageScaledFromSource].\n *\n * If the CanvasImageSource is an [ImageElement] then the element's image is\n * used. If the [ImageElement] is an animated image, then the poster frame is\n * used. If there is no poster frame, then the first frame of animation is used.\n *\n * If the CanvasImageSource is a [VideoElement] then the frame at the current\n * playback position is used as the image.\n *\n * If the CanvasImageSource is a [CanvasElement] then the element's bitmap is\n * used.\n *\n * ** Note: ** Currently, all versions of Internet Explorer do not support\n * drawing a VideoElement to a canvas. Also, you may experience problems drawing\n * a video to a canvas in Firefox if the source of the video is a data URL.\n *\n * See also:\n *\n *  * [CanvasImageSource](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#image-sources-for-2d-rendering-contexts)\n * from the WHATWG.\n *  * [drawImage](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage)\n * from the WHATWG.\n */\nabstract class CanvasImageSource {}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * An object representing the top-level context object for web scripting.\n *\n * In a web browser, a [Window] object represents the actual browser window.\n * In a multi-tabbed browser, each tab has its own [Window] object. A [Window]\n * is the container that displays a [Document]'s content. All web scripting\n * happens within the context of a [Window] object.\n *\n * **Note:** This class represents any window, whereas [Window] is\n * used to access the properties and content of the current window.\n *\n * See also:\n *\n * * [DOM Window](https://developer.mozilla.org/en-US/docs/DOM/window) from MDN.\n * * [Window](http://www.w3.org/TR/Window/) from the W3C.\n */\nabstract class WindowBase {\n  // Fields.\n\n  /**\n   * The current location of this window.\n   *\n   *     Location currentLocation = window.location;\n   *     print(currentLocation.href); // 'http://www.example.com:80/'\n   */\n  LocationBase get location;\n  HistoryBase get history;\n\n  /**\n   * Indicates whether this window has been closed.\n   *\n   *     print(window.closed); // 'false'\n   *     window.close();\n   *     print(window.closed); // 'true'\n   */\n  bool get closed;\n\n  /**\n   * A reference to the window that opened this one.\n   *\n   *     Window thisWindow = window;\n   *     WindowBase otherWindow = thisWindow.open('http://www.example.com/', 'foo');\n   *     print(otherWindow.opener == thisWindow); // 'true'\n   */\n  WindowBase get opener;\n\n  /**\n   * A reference to the parent of this window.\n   *\n   * If this [WindowBase] has no parent, [parent] will return a reference to\n   * the [WindowBase] itself.\n   *\n   *     IFrameElement myIFrame = new IFrameElement();\n   *     window.document.body.elements.add(myIFrame);\n   *     print(myIframe.contentWindow.parent == window) // 'true'\n   *\n   *     print(window.parent == window) // 'true'\n   */\n  WindowBase get parent;\n\n  /**\n   * A reference to the topmost window in the window hierarchy.\n   *\n   * If this [WindowBase] is the topmost [WindowBase], [top] will return a\n   * reference to the [WindowBase] itself.\n   *\n   *     // Add an IFrame to the current window.\n   *     IFrameElement myIFrame = new IFrameElement();\n   *     window.document.body.elements.add(myIFrame);\n   *\n   *     // Add an IFrame inside of the other IFrame.\n   *     IFrameElement innerIFrame = new IFrameElement();\n   *     myIFrame.elements.add(innerIFrame);\n   *\n   *     print(myIframe.contentWindow.top == window) // 'true'\n   *     print(innerIFrame.contentWindow.top == window) // 'true'\n   *\n   *     print(window.top == window) // 'true'\n   */\n  WindowBase get top;\n\n  // Methods.\n  /**\n   * Closes the window.\n   *\n   * This method should only succeed if the [WindowBase] object is\n   * **script-closeable** and the window calling [close] is allowed to navigate\n   * the window.\n   *\n   * A window is script-closeable if it is either a window\n   * that was opened by another window, or if it is a window with only one\n   * document in its history.\n   *\n   * A window might not be allowed to navigate, and therefore close, another\n   * window due to browser security features.\n   *\n   *     var other = window.open('http://www.example.com', 'foo');\n   *     // Closes other window, as it is script-closeable.\n   *     other.close();\n   *     print(other.closed()); // 'true'\n   *\n   *     window.location('http://www.mysite.com', 'foo');\n   *     // Does not close this window, as the history has changed.\n   *     window.close();\n   *     print(window.closed()); // 'false'\n   *\n   * See also:\n   *\n   * * [Window close discussion](http://www.w3.org/TR/html5/browsers.html#dom-window-close) from the W3C\n   */\n  void close();\n  void postMessage(var message, String targetOrigin, [List messagePorts]);\n}\n\nabstract class LocationBase {\n  void set href(String val);\n}\n\nabstract class HistoryBase {\n  void back();\n  void forward();\n  void go(int distance);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nabstract class CssClassSet implements Set<String> {\n\n  String toString() {\n    return readClasses().join(' ');\n  }\n\n  /**\n   * Adds the class [value] to the element if it is not on it, removes it if it\n   * is.\n   */\n  bool toggle(String value) {\n    Set<String> s = readClasses();\n    bool result = false;\n    if (s.contains(value)) {\n      s.remove(value);\n    } else {\n      s.add(value);\n      result = true;\n    }\n    writeClasses(s);\n    return result;\n  }\n\n  /**\n   * Returns [:true:] if classes cannot be added or removed from this\n   * [:CssClassSet:].\n   */\n  bool get frozen => false;\n\n  // interface Iterable - BEGIN\n  Iterator<String> get iterator => readClasses().iterator;\n  // interface Iterable - END\n\n  // interface Collection - BEGIN\n  void forEach(void f(String element)) {\n    readClasses().forEach(f);\n  }\n\n  String join([String separator = \"\"]) => readClasses().join(separator);\n\n  Iterable map(f(String element)) => readClasses().map(f);\n\n  Iterable<String> where(bool f(String element)) => readClasses().where(f);\n\n  Iterable expand(Iterable f(String element)) => readClasses().expand(f);\n\n  bool every(bool f(String element)) => readClasses().every(f);\n\n  bool any(bool f(String element)) => readClasses().any(f);\n\n  bool get isEmpty => readClasses().isEmpty;\n\n  int get length => readClasses().length;\n\n  String reduce(String combine(String value, String element)) {\n    return readClasses().reduce(combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n      dynamic combine(dynamic previousValue, String element)) {\n    return readClasses().fold(initialValue, combine);\n  }\n  // interface Collection - END\n\n  // interface Set - BEGIN\n  /**\n   * Determine if this element contains the class [value].\n   *\n   * This is the Dart equivalent of jQuery's\n   * [hasClass](http://api.jquery.com/hasClass/).\n   */\n  bool contains(String value) => readClasses().contains(value);\n\n  /**\n   * Add the class [value] to element.\n   *\n   * This is the Dart equivalent of jQuery's\n   * [addClass](http://api.jquery.com/addClass/).\n   */\n  void add(String value) {\n    // TODO - figure out if we need to do any validation here\n    // or if the browser natively does enough.\n    _modify((s) => s.add(value));\n  }\n\n  /**\n   * Remove the class [value] from element, and return true on successful\n   * removal.\n   *\n   * This is the Dart equivalent of jQuery's\n   * [removeClass](http://api.jquery.com/removeClass/).\n   */\n  bool remove(Object value) {\n    if (value is! String) return false;\n    Set<String> s = readClasses();\n    bool result = s.remove(value);\n    writeClasses(s);\n    return result;\n  }\n\n  /**\n   * Add all classes specified in [iterable] to element.\n   *\n   * This is the Dart equivalent of jQuery's\n   * [addClass](http://api.jquery.com/addClass/).\n   */\n  void addAll(Iterable<String> iterable) {\n    // TODO - see comment above about validation.\n    _modify((s) => s.addAll(iterable));\n  }\n\n  /**\n   * Remove all classes specified in [iterable] from element.\n   *\n   * This is the Dart equivalent of jQuery's\n   * [removeClass](http://api.jquery.com/removeClass/).\n   */\n  void removeAll(Iterable<String> iterable) {\n    _modify((s) => s.removeAll(iterable));\n  }\n\n  /**\n   * Toggles all classes specified in [iterable] on element.\n   *\n   * Iterate through [iterable]'s items, and add it if it is not on it, or\n   * remove it if it is. This is the Dart equivalent of jQuery's\n   * [toggleClass](http://api.jquery.com/toggleClass/).\n   */\n  void toggleAll(Iterable<String> iterable) {\n    iterable.forEach(toggle);\n  }\n\n  void retainAll(Iterable<String> iterable) {\n    _modify((s) => s.retainAll(iterable));\n  }\n\n  void removeWhere(bool test(String name)) {\n    _modify((s) => s.removeWhere(test));\n  }\n\n  void retainWhere(bool test(String name)) {\n    _modify((s) => s.retainWhere(test));\n  }\n\n  bool containsAll(Iterable<String> collection) =>\n    readClasses().containsAll(collection);\n\n  Set<String> intersection(Set<String> other) =>\n    readClasses().intersection(other);\n\n  Set<String> union(Set<String> other) =>\n    readClasses().union(other);\n\n  Set<String> difference(Set<String> other) =>\n    readClasses().difference(other);\n\n  String get first => readClasses().first;\n  String get last => readClasses().last;\n  String get single => readClasses().single;\n  List<String> toList({ bool growable: true }) =>\n      readClasses().toList(growable: growable);\n  Set<String> toSet() => readClasses().toSet();\n  Iterable<String> take(int n) => readClasses().take(n);\n  Iterable<String> takeWhile(bool test(String value)) =>\n      readClasses().takeWhile(test);\n  Iterable<String> skip(int n) => readClasses().skip(n);\n  Iterable<String> skipWhile(bool test(String value)) =>\n      readClasses().skipWhile(test);\n  String firstWhere(bool test(String value), { String orElse() }) =>\n      readClasses().firstWhere(test, orElse: orElse);\n  String lastWhere(bool test(String value), {String orElse()}) =>\n      readClasses().lastWhere(test, orElse: orElse);\n  String singleWhere(bool test(String value)) =>\n      readClasses().singleWhere(test);\n  String elementAt(int index) => readClasses().elementAt(index);\n\n  void clear() {\n    _modify((s) => s.clear());\n  }\n  // interface Set - END\n\n  /**\n   * Helper method used to modify the set of css classes on this element.\n   *\n   *   f - callback with:\n   *   s - a Set of all the css class name currently on this element.\n   *\n   *   After f returns, the modified set is written to the\n   *       className property of this element.\n   */\n  void _modify( f(Set<String> s)) {\n    Set<String> s = readClasses();\n    f(s);\n    writeClasses(s);\n  }\n\n  /**\n   * Read the class names from the Element class property,\n   * and put them into a set (duplicates are discarded).\n   * This is intended to be overridden by specific implementations.\n   */\n  Set<String> readClasses();\n\n  /**\n   * Join all the elements of a set into one string and write\n   * back to the element.\n   * This is intended to be overridden by specific implementations.\n   */\n  void writeClasses(Set<String> s);\n}\n// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\ntypedef EventListener(Event event);\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Adapter for exposing DOM events as Dart streams.\n */\nclass _EventStream<T extends Event> extends Stream<T> {\n  final EventTarget _target;\n  final String _eventType;\n  final bool _useCapture;\n\n  _EventStream(this._target, this._eventType, this._useCapture);\n\n  // DOM events are inherently multi-subscribers.\n  Stream<T> asBroadcastStream() => this;\n  bool get isBroadcast => true;\n\n  StreamSubscription<T> listen(void onData(T event),\n      { void onError(error),\n        void onDone(),\n        bool cancelOnError}) {\n\n    return new _EventStreamSubscription<T>(\n        this._target, this._eventType, onData, this._useCapture);\n  }\n}\n\nclass _EventStreamSubscription<T extends Event> extends StreamSubscription<T> {\n  int _pauseCount = 0;\n  EventTarget _target;\n  final String _eventType;\n  var _onData;\n  final bool _useCapture;\n\n  _EventStreamSubscription(this._target, this._eventType, this._onData,\n      this._useCapture) {\n    _tryResume();\n  }\n\n  void cancel() {\n    if (_canceled) return;\n\n    _unlisten();\n    // Clear out the target to indicate this is complete.\n    _target = null;\n    _onData = null;\n  }\n\n  bool get _canceled => _target == null;\n\n  void onData(void handleData(T event)) {\n    if (_canceled) {\n      throw new StateError(\"Subscription has been canceled.\");\n    }\n    // Remove current event listener.\n    _unlisten();\n\n    _onData = handleData;\n    _tryResume();\n  }\n\n  /// Has no effect.\n  void onError(void handleError(error)) {}\n\n  /// Has no effect.\n  void onDone(void handleDone()) {}\n\n  void pause([Future resumeSignal]) {\n    if (_canceled) return;\n    ++_pauseCount;\n    _unlisten();\n\n    if (resumeSignal != null) {\n      resumeSignal.whenComplete(resume);\n    }\n  }\n\n  bool get _paused => _pauseCount > 0;\n\n  void resume() {\n    if (_canceled || !_paused) return;\n    --_pauseCount;\n    _tryResume();\n  }\n\n  void _tryResume() {\n    if (_onData != null && !_paused) {\n      _target.$dom_addEventListener(_eventType, _onData, _useCapture);\n    }\n  }\n\n  void _unlisten() {\n    if (_onData != null) {\n      _target.$dom_removeEventListener(_eventType, _onData, _useCapture);\n    }\n  }\n\n  Future asFuture([var futureValue]) {\n    // We just need a future that will never succeed or fail.\n    Completer completer = new Completer();\n    return completer.future;\n  }\n}\n\n\n/**\n * A factory to expose DOM events as Streams.\n */\nclass EventStreamProvider<T extends Event> {\n  final String _eventType;\n\n  const EventStreamProvider(this._eventType);\n\n  /**\n   * Gets a [Stream] for this event type, on the specified target.\n   *\n   * This may be used to capture DOM events:\n   *\n   *     Element.keyDownEvent.forTarget(element, useCapture: true).listen(...);\n   *\n   * Or for listening to an event which will bubble through the DOM tree:\n   *\n   *     MediaElement.pauseEvent.forTarget(document.body).listen(...);\n   *\n   * See also:\n   *\n   * [addEventListener](http://docs.webplatform.org/wiki/dom/methods/addEventListener)\n   */\n  Stream<T> forTarget(EventTarget e, {bool useCapture: false}) {\n    return new _EventStream(e, _eventType, useCapture);\n  }\n\n  /**\n   * Gets the type of the event which this would listen for on the specified\n   * event target.\n   *\n   * The target is necessary because some browsers may use different event names\n   * for the same purpose and the target allows differentiating browser support.\n   */\n  String getEventType(EventTarget target) {\n    return _eventType;\n  }\n}\n\n/**\n * A factory to expose DOM events as streams, where the DOM event name has to\n * be determined on the fly (for example, mouse wheel events).\n */\nclass _CustomEventStreamProvider<T extends Event>\n    implements EventStreamProvider<T> {\n\n  final _eventTypeGetter;\n  const _CustomEventStreamProvider(this._eventTypeGetter);\n\n  Stream<T> forTarget(EventTarget e, {bool useCapture: false}) {\n    return new _EventStream(e, _eventTypeGetter(e), useCapture);\n  }\n\n  String getEventType(EventTarget target) {\n    return _eventTypeGetter(target);\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Internal class that does the actual calculations to determine keyCode and\n * charCode for keydown, keypress, and keyup events for all browsers.\n */\nclass _KeyboardEventHandler extends EventStreamProvider<KeyEvent> {\n  // This code inspired by Closure's KeyHandling library.\n  // http://closure-library.googlecode.com/svn/docs/closure_goog_events_keyhandler.js.source.html\n\n  /**\n   * The set of keys that have been pressed down without seeing their\n   * corresponding keyup event.\n   */\n  final List<KeyboardEvent> _keyDownList = <KeyboardEvent>[];\n\n  /** The type of KeyEvent we are tracking (keyup, keydown, keypress). */\n  final String _type;\n\n  /** The element we are watching for events to happen on. */\n  final EventTarget _target;\n\n  // The distance to shift from upper case alphabet Roman letters to lower case.\n  static final int _ROMAN_ALPHABET_OFFSET = \"a\".codeUnits[0] - \"A\".codeUnits[0];\n\n  /** Controller to produce KeyEvents for the stream. */\n  final StreamController _controller = new StreamController();\n\n  static const _EVENT_TYPE = 'KeyEvent';\n\n  /**\n   * An enumeration of key identifiers currently part of the W3C draft for DOM3\n   * and their mappings to keyCodes.\n   * http://www.w3.org/TR/DOM-Level-3-Events/keyset.html#KeySet-Set\n   */\n  static const Map<String, int> _keyIdentifier = const {\n    'Up': KeyCode.UP,\n    'Down': KeyCode.DOWN,\n    'Left': KeyCode.LEFT,\n    'Right': KeyCode.RIGHT,\n    'Enter': KeyCode.ENTER,\n    'F1': KeyCode.F1,\n    'F2': KeyCode.F2,\n    'F3': KeyCode.F3,\n    'F4': KeyCode.F4,\n    'F5': KeyCode.F5,\n    'F6': KeyCode.F6,\n    'F7': KeyCode.F7,\n    'F8': KeyCode.F8,\n    'F9': KeyCode.F9,\n    'F10': KeyCode.F10,\n    'F11': KeyCode.F11,\n    'F12': KeyCode.F12,\n    'U+007F': KeyCode.DELETE,\n    'Home': KeyCode.HOME,\n    'End': KeyCode.END,\n    'PageUp': KeyCode.PAGE_UP,\n    'PageDown': KeyCode.PAGE_DOWN,\n    'Insert': KeyCode.INSERT\n  };\n\n  /** Return a stream for KeyEvents for the specified target. */\n  Stream<KeyEvent> forTarget(EventTarget e, {bool useCapture: false}) {\n    return new _KeyboardEventHandler.initializeAllEventListeners(\n        _type, e).stream;\n  }\n\n  /**\n   * Accessor to the stream associated with a particular KeyboardEvent\n   * EventTarget.\n   *\n   * [forTarget] must be called to initialize this stream to listen to a\n   * particular EventTarget.\n   */\n  Stream<KeyEvent> get stream {\n    if(_target != null) {\n      return _controller.stream;\n    } else {\n      throw new StateError(\"Not initialized. Call forTarget to access a stream \"\n          \"initialized with a particular EventTarget.\");\n    }\n  }\n\n  /**\n   * General constructor, performs basic initialization for our improved\n   * KeyboardEvent controller.\n   */\n  _KeyboardEventHandler(this._type) :\n    _target = null, super(_EVENT_TYPE) {\n  }\n\n  /**\n   * Hook up all event listeners under the covers so we can estimate keycodes\n   * and charcodes when they are not provided.\n   */\n  _KeyboardEventHandler.initializeAllEventListeners(this._type, this._target) : \n    super(_EVENT_TYPE) {\n    Element.keyDownEvent.forTarget(_target, useCapture: true).listen(\n        processKeyDown);\n    Element.keyPressEvent.forTarget(_target, useCapture: true).listen(\n        processKeyPress);\n    Element.keyUpEvent.forTarget(_target, useCapture: true).listen(\n        processKeyUp);\n  }\n\n  /**\n   * Notify all callback listeners that a KeyEvent of the relevant type has\n   * occurred.\n   */\n  bool _dispatch(KeyEvent event) {\n    if (event.type == _type)\n      _controller.add(event);\n  }\n\n  /** Determine if caps lock is one of the currently depressed keys. */\n  bool get _capsLockOn =>\n      _keyDownList.any((var element) => element.keyCode == KeyCode.CAPS_LOCK);\n\n  /**\n   * Given the previously recorded keydown key codes, see if we can determine\n   * the keycode of this keypress [event]. (Generally browsers only provide\n   * charCode information for keypress events, but with a little\n   * reverse-engineering, we can also determine the keyCode.) Returns\n   * KeyCode.UNKNOWN if the keycode could not be determined.\n   */\n  int _determineKeyCodeForKeypress(KeyboardEvent event) {\n    // Note: This function is a work in progress. We'll expand this function\n    // once we get more information about other keyboards.\n    for (var prevEvent in _keyDownList) {\n      if (prevEvent._shadowCharCode == event.charCode) {\n        return prevEvent.keyCode;\n      }\n      if ((event.shiftKey || _capsLockOn) && event.charCode >= \"A\".codeUnits[0]\n          && event.charCode <= \"Z\".codeUnits[0] && event.charCode +\n          _ROMAN_ALPHABET_OFFSET == prevEvent._shadowCharCode) {\n        return prevEvent.keyCode;\n      }\n    }\n    return KeyCode.UNKNOWN;\n  }\n\n  /**\n   * Given the charater code returned from a keyDown [event], try to ascertain\n   * and return the corresponding charCode for the character that was pressed.\n   * This information is not shown to the user, but used to help polyfill\n   * keypress events.\n   */\n  int _findCharCodeKeyDown(KeyboardEvent event) {\n    if (event.keyLocation == 3) { // Numpad keys.\n      switch (event.keyCode) {\n        case KeyCode.NUM_ZERO:\n          // Even though this function returns _charCodes_, for some cases the\n          // KeyCode == the charCode we want, in which case we use the keycode\n          // constant for readability.\n          return KeyCode.ZERO;\n        case KeyCode.NUM_ONE:\n          return KeyCode.ONE;\n        case KeyCode.NUM_TWO:\n          return KeyCode.TWO;\n        case KeyCode.NUM_THREE:\n          return KeyCode.THREE;\n        case KeyCode.NUM_FOUR:\n          return KeyCode.FOUR;\n        case KeyCode.NUM_FIVE:\n          return KeyCode.FIVE;\n        case KeyCode.NUM_SIX:\n          return KeyCode.SIX;\n        case KeyCode.NUM_SEVEN:\n          return KeyCode.SEVEN;\n        case KeyCode.NUM_EIGHT:\n          return KeyCode.EIGHT;\n        case KeyCode.NUM_NINE:\n          return KeyCode.NINE;\n        case KeyCode.NUM_MULTIPLY:\n          return 42; // Char code for *\n        case KeyCode.NUM_PLUS:\n          return 43; // +\n        case KeyCode.NUM_MINUS:\n          return 45; // -\n        case KeyCode.NUM_PERIOD:\n          return 46; // .\n        case KeyCode.NUM_DIVISION:\n          return 47; // /\n      }\n    } else if (event.keyCode >= 65 && event.keyCode <= 90) {\n      // Set the \"char code\" for key down as the lower case letter. Again, this\n      // will not show up for the user, but will be helpful in estimating\n      // keyCode locations and other information during the keyPress event.\n      return event.keyCode + _ROMAN_ALPHABET_OFFSET;\n    }\n    switch(event.keyCode) {\n      case KeyCode.SEMICOLON:\n        return KeyCode.FF_SEMICOLON;\n      case KeyCode.EQUALS:\n        return KeyCode.FF_EQUALS;\n      case KeyCode.COMMA:\n        return 44; // Ascii value for ,\n      case KeyCode.DASH:\n        return 45; // -\n      case KeyCode.PERIOD:\n        return 46; // .\n      case KeyCode.SLASH:\n        return 47; // /\n      case KeyCode.APOSTROPHE:\n        return 96; // `\n      case KeyCode.OPEN_SQUARE_BRACKET:\n        return 91; // [\n      case KeyCode.BACKSLASH:\n        return 92; // \\\n      case KeyCode.CLOSE_SQUARE_BRACKET:\n        return 93; // ]\n      case KeyCode.SINGLE_QUOTE:\n        return 39; // '\n    }\n    return event.keyCode;\n  }\n\n  /**\n   * Returns true if the key fires a keypress event in the current browser.\n   */\n  bool _firesKeyPressEvent(KeyEvent event) {\n    if (!Device.isIE && !Device.isWebKit) {\n      return true;\n    }\n\n    if (Device.userAgent.contains('Mac') && event.altKey) {\n      return KeyCode.isCharacterKey(event.keyCode);\n    }\n\n    // Alt but not AltGr which is represented as Alt+Ctrl.\n    if (event.altKey && !event.ctrlKey) {\n      return false;\n    }\n\n    // Saves Ctrl or Alt + key for IE and WebKit, which won't fire keypress.\n    if (!event.shiftKey &&\n        (_keyDownList.last.keyCode == KeyCode.CTRL ||\n         _keyDownList.last.keyCode == KeyCode.ALT ||\n         Device.userAgent.contains('Mac') &&\n         _keyDownList.last.keyCode == KeyCode.META)) {\n      return false;\n    }\n\n    // Some keys with Ctrl/Shift do not issue keypress in WebKit.\n    if (Device.isWebKit && event.ctrlKey && event.shiftKey && (\n        event.keyCode == KeyCode.BACKSLASH ||\n        event.keyCode == KeyCode.OPEN_SQUARE_BRACKET ||\n        event.keyCode == KeyCode.CLOSE_SQUARE_BRACKET ||\n        event.keyCode == KeyCode.TILDE ||\n        event.keyCode == KeyCode.SEMICOLON || event.keyCode == KeyCode.DASH ||\n        event.keyCode == KeyCode.EQUALS || event.keyCode == KeyCode.COMMA ||\n        event.keyCode == KeyCode.PERIOD || event.keyCode == KeyCode.SLASH ||\n        event.keyCode == KeyCode.APOSTROPHE ||\n        event.keyCode == KeyCode.SINGLE_QUOTE)) {\n      return false;\n    }\n\n    switch (event.keyCode) {\n      case KeyCode.ENTER:\n        // IE9 does not fire keypress on ENTER.\n        return !Device.isIE;\n      case KeyCode.ESC:\n        return !Device.isWebKit;\n    }\n\n    return KeyCode.isCharacterKey(event.keyCode);\n  }\n\n  /**\n   * Normalize the keycodes to the IE KeyCodes (this is what Chrome, IE, and\n   * Opera all use).\n   */\n  int _normalizeKeyCodes(KeyboardEvent event) {\n    // Note: This may change once we get input about non-US keyboards.\n    if (Device.isFirefox) {\n      switch(event.keyCode) {\n        case KeyCode.FF_EQUALS:\n          return KeyCode.EQUALS;\n        case KeyCode.FF_SEMICOLON:\n          return KeyCode.SEMICOLON;\n        case KeyCode.MAC_FF_META:\n          return KeyCode.META;\n        case KeyCode.WIN_KEY_FF_LINUX:\n          return KeyCode.WIN_KEY;\n      }\n    }\n    return event.keyCode;\n  }\n\n  /** Handle keydown events. */\n  void processKeyDown(KeyboardEvent e) {\n    // Ctrl-Tab and Alt-Tab can cause the focus to be moved to another window\n    // before we've caught a key-up event.  If the last-key was one of these\n    // we reset the state.\n    if (_keyDownList.length > 0 &&\n        (_keyDownList.last.keyCode == KeyCode.CTRL && !e.ctrlKey ||\n         _keyDownList.last.keyCode == KeyCode.ALT && !e.altKey ||\n         Device.userAgent.contains('Mac') &&\n         _keyDownList.last.keyCode == KeyCode.META && !e.metaKey)) {\n      _keyDownList.clear();\n    }\n\n    var event = new KeyEvent(e);\n    event._shadowKeyCode = _normalizeKeyCodes(event);\n    // Technically a \"keydown\" event doesn't have a charCode. This is\n    // calculated nonetheless to provide us with more information in giving\n    // as much information as possible on keypress about keycode and also\n    // charCode.\n    event._shadowCharCode = _findCharCodeKeyDown(event);\n    if (_keyDownList.length > 0 && event.keyCode != _keyDownList.last.keyCode &&\n        !_firesKeyPressEvent(event)) {\n      // Some browsers have quirks not firing keypress events where all other\n      // browsers do. This makes them more consistent.\n      processKeyPress(event);\n    }\n    _keyDownList.add(event);\n    _dispatch(event);\n  }\n\n  /** Handle keypress events. */\n  void processKeyPress(KeyboardEvent event) {\n    var e = new KeyEvent(event);\n    // IE reports the character code in the keyCode field for keypress events.\n    // There are two exceptions however, Enter and Escape.\n    if (Device.isIE) {\n      if (e.keyCode == KeyCode.ENTER || e.keyCode == KeyCode.ESC) {\n        e._shadowCharCode = 0;\n      } else {\n        e._shadowCharCode = e.keyCode;\n      }\n    } else if (Device.isOpera) {\n      // Opera reports the character code in the keyCode field.\n      e._shadowCharCode = KeyCode.isCharacterKey(e.keyCode) ? e.keyCode : 0;\n    }\n    // Now we guestimate about what the keycode is that was actually\n    // pressed, given previous keydown information.\n    e._shadowKeyCode = _determineKeyCodeForKeypress(e);\n\n    // Correct the key value for certain browser-specific quirks.\n    if (e._shadowKeyIdentifier != null &&\n        _keyIdentifier.containsKey(e._shadowKeyIdentifier)) {\n      // This is needed for Safari Windows because it currently doesn't give a\n      // keyCode/which for non printable keys.\n      e._shadowKeyCode = _keyIdentifier[e._shadowKeyIdentifier];\n    }\n    e._shadowAltKey = _keyDownList.any((var element) => element.altKey);\n    _dispatch(e);\n  }\n\n  /** Handle keyup events. */\n  void processKeyUp(KeyboardEvent event) {\n    var e = new KeyEvent(event);\n    KeyboardEvent toRemove = null;\n    for (var key in _keyDownList) {\n      if (key.keyCode == e.keyCode) {\n        toRemove = key;\n      }\n    }\n    if (toRemove != null) {\n      _keyDownList.removeWhere((element) => element == toRemove);\n    } else if (_keyDownList.length > 0) {\n      // This happens when we've reached some international keyboard case we\n      // haven't accounted for or we haven't correctly eliminated all browser\n      // inconsistencies. Filing bugs on when this is reached is welcome!\n      _keyDownList.removeLast();\n    }\n    _dispatch(e);\n  }\n}\n\n\n/**\n * Records KeyboardEvents that occur on a particular element, and provides a\n * stream of outgoing KeyEvents with cross-browser consistent keyCode and\n * charCode values despite the fact that a multitude of browsers that have\n * varying keyboard default behavior.\n *\n * Example usage:\n *\n *     KeyboardEventStream.onKeyDown(document.body).listen(\n *         keydownHandlerTest);\n *\n * This class is very much a work in progress, and we'd love to get information\n * on how we can make this class work with as many international keyboards as\n * possible. Bugs welcome!\n */\nclass KeyboardEventStream {\n\n  /** Named constructor to produce a stream for onKeyPress events. */\n  static Stream<KeyEvent> onKeyPress(EventTarget target) =>\n      new _KeyboardEventHandler('keypress').forTarget(target);\n\n  /** Named constructor to produce a stream for onKeyUp events. */\n  static Stream<KeyEvent> onKeyUp(EventTarget target) =>\n      new _KeyboardEventHandler('keyup').forTarget(target);\n\n  /** Named constructor to produce a stream for onKeyDown events. */\n  static Stream<KeyEvent> onKeyDown(EventTarget target) =>\n    new _KeyboardEventHandler('keydown').forTarget(target);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Defines the keycode values for keys that are returned by\n * KeyboardEvent.keyCode.\n *\n * Important note: There is substantial divergence in how different browsers\n * handle keycodes and their variants in different locales/keyboard layouts. We\n * provide these constants to help make code processing keys more readable.\n */\nabstract class KeyCode {\n  // These constant names were borrowed from Closure's Keycode enumeration\n  // class.\n  // http://closure-library.googlecode.com/svn/docs/closure_goog_events_keycodes.js.source.html\n  static const int WIN_KEY_FF_LINUX = 0;\n  static const int MAC_ENTER = 3;\n  static const int BACKSPACE = 8;\n  static const int TAB = 9;\n  /** NUM_CENTER is also NUMLOCK for FF and Safari on Mac. */\n  static const int NUM_CENTER = 12;\n  static const int ENTER = 13;\n  static const int SHIFT = 16;\n  static const int CTRL = 17;\n  static const int ALT = 18;\n  static const int PAUSE = 19;\n  static const int CAPS_LOCK = 20;\n  static const int ESC = 27;\n  static const int SPACE = 32;\n  static const int PAGE_UP = 33;\n  static const int PAGE_DOWN = 34;\n  static const int END = 35;\n  static const int HOME = 36;\n  static const int LEFT = 37;\n  static const int UP = 38;\n  static const int RIGHT = 39;\n  static const int DOWN = 40;\n  static const int NUM_NORTH_EAST = 33;\n  static const int NUM_SOUTH_EAST = 34;\n  static const int NUM_SOUTH_WEST = 35;\n  static const int NUM_NORTH_WEST = 36;\n  static const int NUM_WEST = 37;\n  static const int NUM_NORTH = 38;\n  static const int NUM_EAST = 39;\n  static const int NUM_SOUTH = 40;\n  static const int PRINT_SCREEN = 44;\n  static const int INSERT = 45;\n  static const int NUM_INSERT = 45;\n  static const int DELETE = 46;\n  static const int NUM_DELETE = 46;\n  static const int ZERO = 48;\n  static const int ONE = 49;\n  static const int TWO = 50;\n  static const int THREE = 51;\n  static const int FOUR = 52;\n  static const int FIVE = 53;\n  static const int SIX = 54;\n  static const int SEVEN = 55;\n  static const int EIGHT = 56;\n  static const int NINE = 57;\n  static const int FF_SEMICOLON = 59;\n  static const int FF_EQUALS = 61;\n  /**\n   * CAUTION: The question mark is for US-keyboard layouts. It varies\n   * for other locales and keyboard layouts.\n   */\n  static const int QUESTION_MARK = 63;\n  static const int A = 65;\n  static const int B = 66;\n  static const int C = 67;\n  static const int D = 68;\n  static const int E = 69;\n  static const int F = 70;\n  static const int G = 71;\n  static const int H = 72;\n  static const int I = 73;\n  static const int J = 74;\n  static const int K = 75;\n  static const int L = 76;\n  static const int M = 77;\n  static const int N = 78;\n  static const int O = 79;\n  static const int P = 80;\n  static const int Q = 81;\n  static const int R = 82;\n  static const int S = 83;\n  static const int T = 84;\n  static const int U = 85;\n  static const int V = 86;\n  static const int W = 87;\n  static const int X = 88;\n  static const int Y = 89;\n  static const int Z = 90;\n  static const int META = 91;\n  static const int WIN_KEY_LEFT = 91;\n  static const int WIN_KEY_RIGHT = 92;\n  static const int CONTEXT_MENU = 93;\n  static const int NUM_ZERO = 96;\n  static const int NUM_ONE = 97;\n  static const int NUM_TWO = 98;\n  static const int NUM_THREE = 99;\n  static const int NUM_FOUR = 100;\n  static const int NUM_FIVE = 101;\n  static const int NUM_SIX = 102;\n  static const int NUM_SEVEN = 103;\n  static const int NUM_EIGHT = 104;\n  static const int NUM_NINE = 105;\n  static const int NUM_MULTIPLY = 106;\n  static const int NUM_PLUS = 107;\n  static const int NUM_MINUS = 109;\n  static const int NUM_PERIOD = 110;\n  static const int NUM_DIVISION = 111;\n  static const int F1 = 112;\n  static const int F2 = 113;\n  static const int F3 = 114;\n  static const int F4 = 115;\n  static const int F5 = 116;\n  static const int F6 = 117;\n  static const int F7 = 118;\n  static const int F8 = 119;\n  static const int F9 = 120;\n  static const int F10 = 121;\n  static const int F11 = 122;\n  static const int F12 = 123;\n  static const int NUMLOCK = 144;\n  static const int SCROLL_LOCK = 145;\n\n  // OS-specific media keys like volume controls and browser controls.\n  static const int FIRST_MEDIA_KEY = 166;\n  static const int LAST_MEDIA_KEY = 183;\n\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int SEMICOLON = 186;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int DASH = 189;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int EQUALS = 187;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int COMMA = 188;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int PERIOD = 190;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int SLASH = 191;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int APOSTROPHE = 192;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int TILDE = 192;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int SINGLE_QUOTE = 222;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int OPEN_SQUARE_BRACKET = 219;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int BACKSLASH = 220;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int CLOSE_SQUARE_BRACKET = 221;\n  static const int WIN_KEY = 224;\n  static const int MAC_FF_META = 224;\n  static const int WIN_IME = 229;\n\n  /** A sentinel value if the keycode could not be determined. */\n  static const int UNKNOWN = -1;\n\n  /**\n   * Returns true if the keyCode produces a (US keyboard) character.\n   * Note: This does not (yet) cover characters on non-US keyboards (Russian,\n   * Hebrew, etc.).\n   */\n  static bool isCharacterKey(int keyCode) {\n    if ((keyCode >= ZERO && keyCode <= NINE) ||\n        (keyCode >= NUM_ZERO && keyCode <= NUM_MULTIPLY) ||\n        (keyCode >= A && keyCode <= Z)) {\n      return true;\n    }\n\n    // Safari sends zero key code for non-latin characters.\n    if (Device.isWebKit && keyCode == 0) {\n      return true;\n    }\n\n    return (keyCode == SPACE || keyCode == QUESTION_MARK || keyCode == NUM_PLUS\n        || keyCode == NUM_MINUS || keyCode == NUM_PERIOD ||\n        keyCode == NUM_DIVISION || keyCode == SEMICOLON ||\n        keyCode == FF_SEMICOLON || keyCode == DASH || keyCode == EQUALS ||\n        keyCode == FF_EQUALS || keyCode == COMMA || keyCode == PERIOD ||\n        keyCode == SLASH || keyCode == APOSTROPHE || keyCode == SINGLE_QUOTE ||\n        keyCode == OPEN_SQUARE_BRACKET || keyCode == BACKSLASH ||\n        keyCode == CLOSE_SQUARE_BRACKET);\n  }\n}\n// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Defines the standard key locations returned by\n * KeyboardEvent.getKeyLocation.\n */\nabstract class KeyLocation {\n\n  /**\n   * The event key is not distinguished as the left or right version\n   * of the key, and did not originate from the numeric keypad (or did not\n   * originate with a virtual key corresponding to the numeric keypad).\n   */\n  static const int STANDARD = 0;\n\n  /**\n   * The event key is in the left key location.\n   */\n  static const int LEFT = 1;\n\n  /**\n   * The event key is in the right key location.\n   */\n  static const int RIGHT = 2;\n\n  /**\n   * The event key originated on the numeric keypad or with a virtual key\n   * corresponding to the numeric keypad.\n   */\n  static const int NUMPAD = 3;\n\n  /**\n   * The event key originated on a mobile device, either on a physical\n   * keypad or a virtual keyboard.\n   */\n  static const int MOBILE = 4;\n\n  /**\n   * The event key originated on a game controller or a joystick on a mobile\n   * device.\n   */\n  static const int JOYSTICK = 5;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Defines the standard keyboard identifier names for keys that are returned\n * by KeyEvent.getKeyboardIdentifier when the key does not have a direct\n * unicode mapping.\n */\nabstract class KeyName {\n\n  /** The Accept (Commit, OK) key */\n  static const String ACCEPT = \"Accept\";\n\n  /** The Add key */\n  static const String ADD = \"Add\";\n\n  /** The Again key */\n  static const String AGAIN = \"Again\";\n\n  /** The All Candidates key */\n  static const String ALL_CANDIDATES = \"AllCandidates\";\n\n  /** The Alphanumeric key */\n  static const String ALPHANUMERIC = \"Alphanumeric\";\n\n  /** The Alt (Menu) key */\n  static const String ALT = \"Alt\";\n\n  /** The Alt-Graph key */\n  static const String ALT_GRAPH = \"AltGraph\";\n\n  /** The Application key */\n  static const String APPS = \"Apps\";\n\n  /** The ATTN key */\n  static const String ATTN = \"Attn\";\n\n  /** The Browser Back key */\n  static const String BROWSER_BACK = \"BrowserBack\";\n\n  /** The Browser Favorites key */\n  static const String BROWSER_FAVORTIES = \"BrowserFavorites\";\n\n  /** The Browser Forward key */\n  static const String BROWSER_FORWARD = \"BrowserForward\";\n\n  /** The Browser Home key */\n  static const String BROWSER_NAME = \"BrowserHome\";\n\n  /** The Browser Refresh key */\n  static const String BROWSER_REFRESH = \"BrowserRefresh\";\n\n  /** The Browser Search key */\n  static const String BROWSER_SEARCH = \"BrowserSearch\";\n\n  /** The Browser Stop key */\n  static const String BROWSER_STOP = \"BrowserStop\";\n\n  /** The Camera key */\n  static const String CAMERA = \"Camera\";\n\n  /** The Caps Lock (Capital) key */\n  static const String CAPS_LOCK = \"CapsLock\";\n\n  /** The Clear key */\n  static const String CLEAR = \"Clear\";\n\n  /** The Code Input key */\n  static const String CODE_INPUT = \"CodeInput\";\n\n  /** The Compose key */\n  static const String COMPOSE = \"Compose\";\n\n  /** The Control (Ctrl) key */\n  static const String CONTROL = \"Control\";\n\n  /** The Crsel key */\n  static const String CRSEL = \"Crsel\";\n\n  /** The Convert key */\n  static const String CONVERT = \"Convert\";\n\n  /** The Copy key */\n  static const String COPY = \"Copy\";\n\n  /** The Cut key */\n  static const String CUT = \"Cut\";\n\n  /** The Decimal key */\n  static const String DECIMAL = \"Decimal\";\n\n  /** The Divide key */\n  static const String DIVIDE = \"Divide\";\n\n  /** The Down Arrow key */\n  static const String DOWN = \"Down\";\n\n  /** The diagonal Down-Left Arrow key */\n  static const String DOWN_LEFT = \"DownLeft\";\n\n  /** The diagonal Down-Right Arrow key */\n  static const String DOWN_RIGHT = \"DownRight\";\n\n  /** The Eject key */\n  static const String EJECT = \"Eject\";\n\n  /** The End key */\n  static const String END = \"End\";\n\n  /**\n   * The Enter key. Note: This key value must also be used for the Return\n   *  (Macintosh numpad) key\n   */\n  static const String ENTER = \"Enter\";\n\n  /** The Erase EOF key */\n  static const String ERASE_EOF= \"EraseEof\";\n\n  /** The Execute key */\n  static const String EXECUTE = \"Execute\";\n\n  /** The Exsel key */\n  static const String EXSEL = \"Exsel\";\n\n  /** The Function switch key */\n  static const String FN = \"Fn\";\n\n  /** The F1 key */\n  static const String F1 = \"F1\";\n\n  /** The F2 key */\n  static const String F2 = \"F2\";\n\n  /** The F3 key */\n  static const String F3 = \"F3\";\n\n  /** The F4 key */\n  static const String F4 = \"F4\";\n\n  /** The F5 key */\n  static const String F5 = \"F5\";\n\n  /** The F6 key */\n  static const String F6 = \"F6\";\n\n  /** The F7 key */\n  static const String F7 = \"F7\";\n\n  /** The F8 key */\n  static const String F8 = \"F8\";\n\n  /** The F9 key */\n  static const String F9 = \"F9\";\n\n  /** The F10 key */\n  static const String F10 = \"F10\";\n\n  /** The F11 key */\n  static const String F11 = \"F11\";\n\n  /** The F12 key */\n  static const String F12 = \"F12\";\n\n  /** The F13 key */\n  static const String F13 = \"F13\";\n\n  /** The F14 key */\n  static const String F14 = \"F14\";\n\n  /** The F15 key */\n  static const String F15 = \"F15\";\n\n  /** The F16 key */\n  static const String F16 = \"F16\";\n\n  /** The F17 key */\n  static const String F17 = \"F17\";\n\n  /** The F18 key */\n  static const String F18 = \"F18\";\n\n  /** The F19 key */\n  static const String F19 = \"F19\";\n\n  /** The F20 key */\n  static const String F20 = \"F20\";\n\n  /** The F21 key */\n  static const String F21 = \"F21\";\n\n  /** The F22 key */\n  static const String F22 = \"F22\";\n\n  /** The F23 key */\n  static const String F23 = \"F23\";\n\n  /** The F24 key */\n  static const String F24 = \"F24\";\n\n  /** The Final Mode (Final) key used on some asian keyboards */\n  static const String FINAL_MODE = \"FinalMode\";\n\n  /** The Find key */\n  static const String FIND = \"Find\";\n\n  /** The Full-Width Characters key */\n  static const String FULL_WIDTH = \"FullWidth\";\n\n  /** The Half-Width Characters key */\n  static const String HALF_WIDTH = \"HalfWidth\";\n\n  /** The Hangul (Korean characters) Mode key */\n  static const String HANGUL_MODE = \"HangulMode\";\n\n  /** The Hanja (Korean characters) Mode key */\n  static const String HANJA_MODE = \"HanjaMode\";\n\n  /** The Help key */\n  static const String HELP = \"Help\";\n\n  /** The Hiragana (Japanese Kana characters) key */\n  static const String HIRAGANA = \"Hiragana\";\n\n  /** The Home key */\n  static const String HOME = \"Home\";\n\n  /** The Insert (Ins) key */\n  static const String INSERT = \"Insert\";\n\n  /** The Japanese-Hiragana key */\n  static const String JAPANESE_HIRAGANA = \"JapaneseHiragana\";\n\n  /** The Japanese-Katakana key */\n  static const String JAPANESE_KATAKANA = \"JapaneseKatakana\";\n\n  /** The Japanese-Romaji key */\n  static const String JAPANESE_ROMAJI = \"JapaneseRomaji\";\n\n  /** The Junja Mode key */\n  static const String JUNJA_MODE = \"JunjaMode\";\n\n  /** The Kana Mode (Kana Lock) key */\n  static const String KANA_MODE = \"KanaMode\";\n\n  /**\n   * The Kanji (Japanese name for ideographic characters of Chinese origin)\n   * Mode key\n   */\n  static const String KANJI_MODE = \"KanjiMode\";\n\n  /** The Katakana (Japanese Kana characters) key */\n  static const String KATAKANA = \"Katakana\";\n\n  /** The Start Application One key */\n  static const String LAUNCH_APPLICATION_1 = \"LaunchApplication1\";\n\n  /** The Start Application Two key */\n  static const String LAUNCH_APPLICATION_2 = \"LaunchApplication2\";\n\n  /** The Start Mail key */\n  static const String LAUNCH_MAIL = \"LaunchMail\";\n\n  /** The Left Arrow key */\n  static const String LEFT = \"Left\";\n\n  /** The Menu key */\n  static const String MENU = \"Menu\";\n\n  /**\n   * The Meta key. Note: This key value shall be also used for the Apple\n   * Command key\n   */\n  static const String META = \"Meta\";\n\n  /** The Media Next Track key */\n  static const String MEDIA_NEXT_TRACK = \"MediaNextTrack\";\n\n  /** The Media Play Pause key */\n  static const String MEDIA_PAUSE_PLAY = \"MediaPlayPause\";\n\n  /** The Media Previous Track key */\n  static const String MEDIA_PREVIOUS_TRACK = \"MediaPreviousTrack\";\n\n  /** The Media Stop key */\n  static const String MEDIA_STOP = \"MediaStop\";\n\n  /** The Mode Change key */\n  static const String MODE_CHANGE = \"ModeChange\";\n\n  /** The Next Candidate function key */\n  static const String NEXT_CANDIDATE = \"NextCandidate\";\n\n  /** The Nonconvert (Don't Convert) key */\n  static const String NON_CONVERT = \"Nonconvert\";\n\n  /** The Number Lock key */\n  static const String NUM_LOCK = \"NumLock\";\n\n  /** The Page Down (Next) key */\n  static const String PAGE_DOWN = \"PageDown\";\n\n  /** The Page Up key */\n  static const String PAGE_UP = \"PageUp\";\n\n  /** The Paste key */\n  static const String PASTE = \"Paste\";\n\n  /** The Pause key */\n  static const String PAUSE = \"Pause\";\n\n  /** The Play key */\n  static const String PLAY = \"Play\";\n\n  /**\n   * The Power key. Note: Some devices may not expose this key to the\n   * operating environment\n   */\n  static const String POWER = \"Power\";\n\n  /** The Previous Candidate function key */\n  static const String PREVIOUS_CANDIDATE = \"PreviousCandidate\";\n\n  /** The Print Screen (PrintScrn, SnapShot) key */\n  static const String PRINT_SCREEN = \"PrintScreen\";\n\n  /** The Process key */\n  static const String PROCESS = \"Process\";\n\n  /** The Props key */\n  static const String PROPS = \"Props\";\n\n  /** The Right Arrow key */\n  static const String RIGHT = \"Right\";\n\n  /** The Roman Characters function key */\n  static const String ROMAN_CHARACTERS = \"RomanCharacters\";\n\n  /** The Scroll Lock key */\n  static const String SCROLL = \"Scroll\";\n\n  /** The Select key */\n  static const String SELECT = \"Select\";\n\n  /** The Select Media key */\n  static const String SELECT_MEDIA = \"SelectMedia\";\n\n  /** The Separator key */\n  static const String SEPARATOR = \"Separator\";\n\n  /** The Shift key */\n  static const String SHIFT = \"Shift\";\n\n  /** The Soft1 key */\n  static const String SOFT_1 = \"Soft1\";\n\n  /** The Soft2 key */\n  static const String SOFT_2 = \"Soft2\";\n\n  /** The Soft3 key */\n  static const String SOFT_3 = \"Soft3\";\n\n  /** The Soft4 key */\n  static const String SOFT_4 = \"Soft4\";\n\n  /** The Stop key */\n  static const String STOP = \"Stop\";\n\n  /** The Subtract key */\n  static const String SUBTRACT = \"Subtract\";\n\n  /** The Symbol Lock key */\n  static const String SYMBOL_LOCK = \"SymbolLock\";\n\n  /** The Up Arrow key */\n  static const String UP = \"Up\";\n\n  /** The diagonal Up-Left Arrow key */\n  static const String UP_LEFT = \"UpLeft\";\n\n  /** The diagonal Up-Right Arrow key */\n  static const String UP_RIGHT = \"UpRight\";\n\n  /** The Undo key */\n  static const String UNDO = \"Undo\";\n\n  /** The Volume Down key */\n  static const String VOLUME_DOWN = \"VolumeDown\";\n\n  /** The Volume Mute key */\n  static const String VOLUMN_MUTE = \"VolumeMute\";\n\n  /** The Volume Up key */\n  static const String VOLUMN_UP = \"VolumeUp\";\n\n  /** The Windows Logo key */\n  static const String WIN = \"Win\";\n\n  /** The Zoom key */\n  static const String ZOOM = \"Zoom\";\n\n  /**\n   * The Backspace (Back) key. Note: This key value shall be also used for the\n   * key labeled 'delete' MacOS keyboards when not modified by the 'Fn' key\n   */\n  static const String BACKSPACE = \"Backspace\";\n\n  /** The Horizontal Tabulation (Tab) key */\n  static const String TAB = \"Tab\";\n\n  /** The Cancel key */\n  static const String CANCEL = \"Cancel\";\n\n  /** The Escape (Esc) key */\n  static const String ESC = \"Esc\";\n\n  /** The Space (Spacebar) key:   */\n  static const String SPACEBAR = \"Spacebar\";\n\n  /**\n   * The Delete (Del) Key. Note: This key value shall be also used for the key\n   * labeled 'delete' MacOS keyboards when modified by the 'Fn' key\n   */\n  static const String DEL = \"Del\";\n\n  /** The Combining Grave Accent (Greek Varia, Dead Grave) key */\n  static const String DEAD_GRAVE = \"DeadGrave\";\n\n  /**\n   * The Combining Acute Accent (Stress Mark, Greek Oxia, Tonos, Dead Eacute)\n   * key\n   */\n  static const String DEAD_EACUTE = \"DeadEacute\";\n\n  /** The Combining Circumflex Accent (Hat, Dead Circumflex) key */\n  static const String DEAD_CIRCUMFLEX = \"DeadCircumflex\";\n\n  /** The Combining Tilde (Dead Tilde) key */\n  static const String DEAD_TILDE = \"DeadTilde\";\n\n  /** The Combining Macron (Long, Dead Macron) key */\n  static const String DEAD_MACRON = \"DeadMacron\";\n\n  /** The Combining Breve (Short, Dead Breve) key */\n  static const String DEAD_BREVE = \"DeadBreve\";\n\n  /** The Combining Dot Above (Derivative, Dead Above Dot) key */\n  static const String DEAD_ABOVE_DOT = \"DeadAboveDot\";\n\n  /**\n   * The Combining Diaeresis (Double Dot Abode, Umlaut, Greek Dialytika,\n   * Double Derivative, Dead Diaeresis) key\n   */\n  static const String DEAD_UMLAUT = \"DeadUmlaut\";\n\n  /** The Combining Ring Above (Dead Above Ring) key */\n  static const String DEAD_ABOVE_RING = \"DeadAboveRing\";\n\n  /** The Combining Double Acute Accent (Dead Doubleacute) key */\n  static const String DEAD_DOUBLEACUTE = \"DeadDoubleacute\";\n\n  /** The Combining Caron (Hacek, V Above, Dead Caron) key */\n  static const String DEAD_CARON = \"DeadCaron\";\n\n  /** The Combining Cedilla (Dead Cedilla) key */\n  static const String DEAD_CEDILLA = \"DeadCedilla\";\n\n  /** The Combining Ogonek (Nasal Hook, Dead Ogonek) key */\n  static const String DEAD_OGONEK = \"DeadOgonek\";\n\n  /**\n   * The Combining Greek Ypogegrammeni (Greek Non-Spacing Iota Below, Iota\n   * Subscript, Dead Iota) key\n   */\n  static const String DEAD_IOTA = \"DeadIota\";\n\n  /**\n   * The Combining Katakana-Hiragana Voiced Sound Mark (Dead Voiced Sound) key\n   */\n  static const String DEAD_VOICED_SOUND = \"DeadVoicedSound\";\n\n  /**\n   * The Combining Katakana-Hiragana Semi-Voiced Sound Mark (Dead Semivoiced\n   * Sound) key\n   */\n  static const String DEC_SEMIVOICED_SOUND= \"DeadSemivoicedSound\";\n\n  /**\n   * Key value used when an implementation is unable to identify another key\n   * value, due to either hardware, platform, or software constraints\n   */\n  static const String UNIDENTIFIED = \"Unidentified\";\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nclass _ModelTreeObserver {\n  static bool _initialized = false;\n\n  /**\n   * Start an observer watching the document for tree changes to automatically\n   * propagate model changes.\n   *\n   * Currently this does not support propagation through Shadow DOMs.\n   */\n  static void initialize() {\n    if (!_initialized) {\n      _initialized = true;\n\n      if (MutationObserver.supported) {\n        var observer = new MutationObserver(_processTreeChange);\n        observer.observe(document, childList: true, subtree: true);\n      } else {\n        document.on['DOMNodeInserted'].listen(_handleNodeInserted);\n        document.on['DOMNodeRemoved'].listen(_handleNodeRemoved);\n      }\n    }\n  }\n\n  static void _processTreeChange(List<MutationRecord> mutations,\n      MutationObserver observer) {\n    for (var record in mutations) {\n      for (var node in record.addedNodes) {\n        // When nodes enter the document we need to make sure that all of the\n        // models are properly propagated through the entire sub-tree.\n        propagateModel(node, _calculatedModel(node), true);\n      }\n      for (var node in record.removedNodes) {\n        propagateModel(node, _calculatedModel(node), false);\n      }\n    }\n  }\n\n  static void _handleNodeInserted(MutationEvent e) {\n    var node = e.target;\n    window.setImmediate(() {\n      propagateModel(node, _calculatedModel(node), true);\n    });\n  }\n\n  static void _handleNodeRemoved(MutationEvent e) {\n    var node = e.target;\n    window.setImmediate(() {\n      propagateModel(node, _calculatedModel(node), false);\n    });\n  }\n\n  /**\n   * Figures out what the model should be for a node, avoiding any cached\n   * model values.\n   */\n  static _calculatedModel(node) {\n    if (node._hasLocalModel == true) {\n      return node._model;\n    } else if (node.parentNode != null) {\n      return node.parentNode._model;\n    }\n    return null;\n  }\n\n  /**\n   * Pushes model changes down through the tree.\n   *\n   * Set fullTree to true if the state of the tree is unknown and model changes\n   * should be propagated through the entire tree.\n   */\n  static void propagateModel(Node node, model, bool fullTree) {\n    // Calling into user code with the != call could generate exceptions.\n    // Catch and report them a global exceptions.\n    try {\n      if (node._hasLocalModel != true && node._model != model &&\n          node._modelChangedStreams != null &&\n          !node._modelChangedStreams.isEmpty) {\n        node._model = model;\n        node._modelChangedStreams.toList()\n          .forEach((controller) => controller.add(node));\n      }\n    } catch (e, s) {\n      new Future.error(e, s);\n    }\n    for (var child = node.$dom_firstChild; child != null;\n        child = child.nextNode) {\n      if (child._hasLocalModel != true) {\n        propagateModel(child, model, fullTree);\n      } else if (fullTree) {\n        propagateModel(child, child._model, true);\n      }\n    }\n  }\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * A utility class for representing two-dimensional positions.\n */\nclass Point {\n  final num x;\n  final num y;\n\n  const Point([num x = 0, num y = 0]): x = x, y = y;\n\n  String toString() => '($x, $y)';\n\n  bool operator ==(other) {\n    if (other is !Point) return false;\n    return x == other.x && y == other.y;\n  }\n\n  Point operator +(Point other) {\n    return new Point(x + other.x, y + other.y);\n  }\n\n  Point operator -(Point other) {\n    return new Point(x - other.x, y - other.y);\n  }\n\n  Point operator *(num factor) {\n    return new Point(x * factor, y * factor);\n  }\n\n  /**\n   * Returns the distance between two points.\n   */\n  double distanceTo(Point other) {\n    var dx = x - other.x;\n    var dy = y - other.y;\n    return sqrt(dx * dx + dy * dy);\n  }\n\n  /**\n   * Returns the squared distance between two points.\n   *\n   * Squared distances can be used for comparisons when the actual value is not\n   * required.\n   */\n  num squaredDistanceTo(Point other) {\n    var dx = x - other.x;\n    var dy = y - other.y;\n    return dx * dx + dy * dy;\n  }\n\n  Point ceil() => new Point(x.ceil(), y.ceil());\n  Point floor() => new Point(x.floor(), y.floor());\n  Point round() => new Point(x.round(), y.round());\n\n  /**\n   * Truncates x and y to integers and returns the result as a new point.\n   */\n  Point toInt() => new Point(x.toInt(), y.toInt());\n}\n// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Contains the set of standard values returned by HTMLDocument.getReadyState.\n */\nabstract class ReadyState {\n  /**\n   * Indicates the document is still loading and parsing.\n   */\n  static const String LOADING = \"loading\";\n\n  /**\n   * Indicates the document is finished parsing but is still loading\n   * subresources.\n   */\n  static const String INTERACTIVE = \"interactive\";\n\n  /**\n   * Indicates the document and all subresources have been loaded.\n   */\n  static const String COMPLETE = \"complete\";\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * A class for representing two-dimensional rectangles.\n */\nclass Rect {\n  final num left;\n  final num top;\n  final num width;\n  final num height;\n\n  const Rect(this.left, this.top, this.width, this.height);\n\n  factory Rect.fromPoints(Point a, Point b) {\n    var left;\n    var width;\n    if (a.x < b.x) {\n      left = a.x;\n      width = b.x - left;\n    } else {\n      left = b.x;\n      width = a.x - left;\n    }\n    var top;\n    var height;\n    if (a.y < b.y) {\n      top = a.y;\n      height = b.y - top;\n    } else {\n      top = b.y;\n      height = a.y - top;\n    }\n\n    return new Rect(left, top, width, height);\n  }\n\n  num get right => left + width;\n  num get bottom => top + height;\n\n  // NOTE! All code below should be common with Rect.\n  // TODO: implement with mixins when available.\n\n  String toString() {\n    return '($left, $top, $width, $height)';\n  }\n\n  bool operator ==(other) {\n    if (other is !Rect) return false;\n    return left == other.left && top == other.top && width == other.width &&\n        height == other.height;\n  }\n\n  /**\n   * Computes the intersection of this rectangle and the rectangle parameter.\n   * Returns null if there is no intersection.\n   */\n  Rect intersection(Rect rect) {\n    var x0 = max(left, rect.left);\n    var x1 = min(left + width, rect.left + rect.width);\n\n    if (x0 <= x1) {\n      var y0 = max(top, rect.top);\n      var y1 = min(top + height, rect.top + rect.height);\n\n      if (y0 <= y1) {\n        return new Rect(x0, y0, x1 - x0, y1 - y0);\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * Returns whether a rectangle intersects this rectangle.\n   */\n  bool intersects(Rect other) {\n    return (left <= other.left + other.width && other.left <= left + width &&\n        top <= other.top + other.height && other.top <= top + height);\n  }\n\n  /**\n   * Returns a new rectangle which completely contains this rectangle and the\n   * input rectangle.\n   */\n  Rect union(Rect rect) {\n    var right = max(this.left + this.width, rect.left + rect.width);\n    var bottom = max(this.top + this.height, rect.top + rect.height);\n\n    var left = min(this.left, rect.left);\n    var top = min(this.top, rect.top);\n\n    return new Rect(left, top, right - left, bottom - top);\n  }\n\n  /**\n   * Tests whether this rectangle entirely contains another rectangle.\n   */\n  bool containsRect(Rect another) {\n    return left <= another.left &&\n           left + width >= another.left + another.width &&\n           top <= another.top &&\n           top + height >= another.top + another.height;\n  }\n\n  /**\n   * Tests whether this rectangle entirely contains a point.\n   */\n  bool containsPoint(Point another) {\n    return another.x >= left &&\n           another.x <= left + width &&\n           another.y >= top &&\n           another.y <= top + height;\n  }\n\n  Rect ceil() => new Rect(left.ceil(), top.ceil(), width.ceil(), height.ceil());\n  Rect floor() => new Rect(left.floor(), top.floor(), width.floor(),\n      height.floor());\n  Rect round() => new Rect(left.round(), top.round(), width.round(),\n      height.round());\n\n  /**\n   * Truncates coordinates to integers and returns the result as a new\n   * rectangle.\n   */\n  Rect toInt() => new Rect(left.toInt(), top.toInt(), width.toInt(),\n      height.toInt());\n\n  Point get topLeft => new Point(this.left, this.top);\n  Point get bottomRight => new Point(this.left + this.width,\n      this.top + this.height);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nclass _HttpRequestUtils {\n\n  // Helper for factory HttpRequest.get\n  static HttpRequest get(String url,\n                            onComplete(HttpRequest request),\n                            bool withCredentials) {\n    final request = new HttpRequest();\n    request.open('GET', url, async: true);\n\n    request.withCredentials = withCredentials;\n\n    request.onReadyStateChange.listen((e) {\n      if (request.readyState == HttpRequest.DONE) {\n        onComplete(request);\n      }\n    });\n\n    request.send();\n\n    return request;\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n_serialize(var message) {\n  return new _JsSerializer().traverse(message);\n}\n\nclass _JsSerializer extends _Serializer {\n\n  visitSendPortSync(SendPortSync x) {\n    if (x is _JsSendPortSync) return visitJsSendPortSync(x);\n    if (x is _LocalSendPortSync) return visitLocalSendPortSync(x);\n    if (x is _RemoteSendPortSync) return visitRemoteSendPortSync(x);\n    throw \"Unknown port type $x\";\n  }\n\n  visitJsSendPortSync(_JsSendPortSync x) {\n    return [ 'sendport', 'nativejs', x._id ];\n  }\n\n  visitLocalSendPortSync(_LocalSendPortSync x) {\n    return [ 'sendport', 'dart',\n             ReceivePortSync._isolateId, x._receivePort._portId ];\n  }\n\n  visitSendPort(SendPort x) {\n    throw new UnimplementedError('Asynchronous send port not yet implemented.');\n  }\n\n  visitRemoteSendPortSync(_RemoteSendPortSync x) {\n    return [ 'sendport', 'dart', x._isolateId, x._portId ];\n  }\n}\n\n_deserialize(var message) {\n  return new _JsDeserializer().deserialize(message);\n}\n\n\nclass _JsDeserializer extends _Deserializer {\n\n  static const _UNSPECIFIED = const Object();\n\n  deserializeSendPort(List x) {\n    String tag = x[1];\n    switch (tag) {\n      case 'nativejs':\n        num id = x[2];\n        return new _JsSendPortSync(id);\n      case 'dart':\n        num isolateId = x[2];\n        num portId = x[3];\n        return ReceivePortSync._lookup(isolateId, portId);\n      default:\n        throw 'Illegal SendPortSync type: $tag';\n    }\n  }\n}\n\n// The receiver is JS.\nclass _JsSendPortSync implements SendPortSync {\n\n  final num _id;\n  _JsSendPortSync(this._id);\n\n  callSync(var message) {\n    var serialized = _serialize(message);\n    var result = _callPortSync(_id, serialized);\n    return _deserialize(result);\n  }\n\n  bool operator==(var other) {\n    return (other is _JsSendPortSync) && (_id == other._id);\n  }\n\n  int get hashCode => _id;\n}\n\n// TODO(vsm): Differentiate between Dart2Js and Dartium isolates.\n// The receiver is a different Dart isolate, compiled to JS.\nclass _RemoteSendPortSync implements SendPortSync {\n\n  int _isolateId;\n  int _portId;\n  _RemoteSendPortSync(this._isolateId, this._portId);\n\n  callSync(var message) {\n    var serialized = _serialize(message);\n    var result = _call(_isolateId, _portId, serialized);\n    return _deserialize(result);\n  }\n\n  static _call(int isolateId, int portId, var message) {\n    var target = 'dart-port-$isolateId-$portId';\n    // TODO(vsm): Make this re-entrant.\n    // TODO(vsm): Set this up set once, on the first call.\n    var source = '$target-result';\n    var result = null;\n    window.on[source].first.then((Event e) {\n      result = json.parse(_getPortSyncEventData(e));\n    });\n    _dispatchEvent(target, [source, message]);\n    return result;\n  }\n\n  bool operator==(var other) {\n    return (other is _RemoteSendPortSync) && (_isolateId == other._isolateId)\n      && (_portId == other._portId);\n  }\n\n  int get hashCode => _isolateId >> 16 + _portId;\n}\n\n// The receiver is in the same Dart isolate, compiled to JS.\nclass _LocalSendPortSync implements SendPortSync {\n\n  ReceivePortSync _receivePort;\n\n  _LocalSendPortSync._internal(this._receivePort);\n\n  callSync(var message) {\n    // TODO(vsm): Do a more efficient deep copy.\n    var copy = _deserialize(_serialize(message));\n    var result = _receivePort._callback(copy);\n    return _deserialize(_serialize(result));\n  }\n\n  bool operator==(var other) {\n    return (other is _LocalSendPortSync)\n      && (_receivePort == other._receivePort);\n  }\n\n  int get hashCode => _receivePort.hashCode;\n}\n\n// TODO(vsm): Move this to dart:isolate.  This will take some\n// refactoring as there are dependences here on the DOM.  Users\n// interact with this class (or interface if we change it) directly -\n// new ReceivePortSync.  I think most of the DOM logic could be\n// delayed until the corresponding SendPort is registered on the\n// window.\n\n// A Dart ReceivePortSync (tagged 'dart' when serialized) is\n// identifiable / resolvable by the combination of its isolateid and\n// portid.  When a corresponding SendPort is used within the same\n// isolate, the _portMap below can be used to obtain the\n// ReceivePortSync directly.  Across isolates (or from JS), an\n// EventListener can be used to communicate with the port indirectly.\nclass ReceivePortSync {\n\n  static Map<int, ReceivePortSync> _portMap;\n  static int _portIdCount;\n  static int _cachedIsolateId;\n\n  num _portId;\n  Function _callback;\n  StreamSubscription _portSubscription;\n\n  ReceivePortSync() {\n    if (_portIdCount == null) {\n      _portIdCount = 0;\n      _portMap = new Map<int, ReceivePortSync>();\n    }\n    _portId = _portIdCount++;\n    _portMap[_portId] = this;\n  }\n\n  static int get _isolateId {\n    // TODO(vsm): Make this coherent with existing isolate code.\n    if (_cachedIsolateId == null) {\n      _cachedIsolateId = _getNewIsolateId();\n    }\n    return _cachedIsolateId;\n  }\n\n  static String _getListenerName(isolateId, portId) =>\n      'dart-port-$isolateId-$portId';\n  String get _listenerName => _getListenerName(_isolateId, _portId);\n\n  void receive(callback(var message)) {\n    _callback = callback;\n    if (_portSubscription == null) {\n      _portSubscription = window.on[_listenerName].listen((Event e) {\n        var data = json.parse(_getPortSyncEventData(e));\n        var replyTo = data[0];\n        var message = _deserialize(data[1]);\n        var result = _callback(message);\n        _dispatchEvent(replyTo, _serialize(result));\n      });\n    }\n  }\n\n  void close() {\n    _portMap.remove(_portId);\n    if (_portSubscription != null) _portSubscription.cancel();\n  }\n\n  SendPortSync toSendPort() {\n    return new _LocalSendPortSync._internal(this);\n  }\n\n  static SendPortSync _lookup(int isolateId, int portId) {\n    if (isolateId == _isolateId) {\n      return _portMap[portId].toSendPort();\n    } else {\n      return new _RemoteSendPortSync(isolateId, portId);\n    }\n  }\n}\n\nget _isolateId => ReceivePortSync._isolateId;\n\nvoid _dispatchEvent(String receiver, var message) {\n  var event = new CustomEvent(receiver, canBubble: false, cancelable:false,\n    detail: json.stringify(message));\n  window.dispatchEvent(event);\n}\n\nString _getPortSyncEventData(CustomEvent event) => event.detail;\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\ntypedef void _MicrotaskCallback();\n\n/**\n * This class attempts to invoke a callback as soon as the current event stack\n * unwinds, but before the browser repaints.\n */\nabstract class _MicrotaskScheduler {\n  bool _nextMicrotaskFrameScheduled = false;\n  final _MicrotaskCallback _callback;\n\n  _MicrotaskScheduler(this._callback);\n\n  /**\n   * Creates the best possible microtask scheduler for the current platform.\n   */\n  factory _MicrotaskScheduler.best(_MicrotaskCallback callback) {\n    if (Window._supportsSetImmediate) {\n      return new _SetImmediateScheduler(callback);\n    } else if (MutationObserver.supported) {\n      return new _MutationObserverScheduler(callback);\n    }\n    return new _PostMessageScheduler(callback);\n  }\n\n  /**\n   * Schedules a microtask callback if one has not been scheduled already.\n   */\n  void maybeSchedule() {\n    if (this._nextMicrotaskFrameScheduled) {\n      return;\n    }\n    this._nextMicrotaskFrameScheduled = true;\n    this._schedule();\n  }\n\n  /**\n   * Does the actual scheduling of the callback.\n   */\n  void _schedule();\n\n  /**\n   * Handles the microtask callback and forwards it if necessary.\n   */\n  void _onCallback() {\n    // Ignore spurious messages.\n    if (!_nextMicrotaskFrameScheduled) {\n      return;\n    }\n    _nextMicrotaskFrameScheduled = false;\n    this._callback();\n  }\n}\n\n/**\n * Scheduler which uses window.postMessage to schedule events.\n */\nclass _PostMessageScheduler extends _MicrotaskScheduler {\n  const _MICROTASK_MESSAGE = \"DART-MICROTASK\";\n\n  _PostMessageScheduler(_MicrotaskCallback callback): super(callback) {\n      // Messages from other windows do not cause a security risk as\n      // all we care about is that _handleMessage is called\n      // after the current event loop is unwound and calling the function is\n      // a noop when zero requests are pending.\n      window.onMessage.listen(this._handleMessage);\n  }\n\n  void _schedule() {\n    window.postMessage(_MICROTASK_MESSAGE, \"*\");\n  }\n\n  void _handleMessage(e) {\n    this._onCallback();\n  }\n}\n\n/**\n * Scheduler which uses a MutationObserver to schedule events.\n */\nclass _MutationObserverScheduler extends _MicrotaskScheduler {\n  MutationObserver _observer;\n  Element _dummy;\n\n  _MutationObserverScheduler(_MicrotaskCallback callback): super(callback) {\n    // Mutation events get fired as soon as the current event stack is unwound\n    // so we just make a dummy event and listen for that.\n    _observer = new MutationObserver(this._handleMutation);\n    _dummy = new DivElement();\n    _observer.observe(_dummy, attributes: true);\n  }\n\n  void _schedule() {\n    // Toggle it to trigger the mutation event.\n    _dummy.hidden = !_dummy.hidden;\n  }\n\n  _handleMutation(List<MutationRecord> mutations, MutationObserver observer) {\n    this._onCallback();\n  }\n}\n\n/**\n * Scheduler which uses window.setImmediate to schedule events.\n */\nclass _SetImmediateScheduler extends _MicrotaskScheduler {\n  _SetImmediateScheduler(_MicrotaskCallback callback): super(callback);\n\n  void _schedule() {\n    window._setImmediate(_handleImmediate);\n  }\n\n  void _handleImmediate() {\n    this._onCallback();\n  }\n}\n\nList<TimeoutHandler> _pendingMicrotasks;\n_MicrotaskScheduler _microtaskScheduler = null;\n\nvoid _maybeScheduleMicrotaskFrame() {\n  if (_microtaskScheduler == null) {\n    _microtaskScheduler =\n      new _MicrotaskScheduler.best(_completeMicrotasks);\n  }\n  _microtaskScheduler.maybeSchedule();\n}\n\n/**\n * Registers a [callback] which is called after the current execution stack\n * unwinds.\n */\nvoid _addMicrotaskCallback(TimeoutHandler callback) {\n  if (_pendingMicrotasks == null) {\n    _pendingMicrotasks = <TimeoutHandler>[];\n    _maybeScheduleMicrotaskFrame();\n  }\n  _pendingMicrotasks.add(callback);\n}\n\n\n/**\n * Complete all pending microtasks.\n */\nvoid _completeMicrotasks() {\n  var callbacks = _pendingMicrotasks;\n  _pendingMicrotasks = null;\n  for (var callback in callbacks) {\n    callback();\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Patch file for the dart:isolate library.\n\n\n/********************************************************\n  Inserted from lib/isolate/serialization.dart\n ********************************************************/\n\nclass _MessageTraverserVisitedMap {\n\n  operator[](var object) => null;\n  void operator[]=(var object, var info) { }\n\n  void reset() { }\n  void cleanup() { }\n\n}\n\n/** Abstract visitor for dart objects that can be sent as isolate messages. */\nabstract class _MessageTraverser {\n\n  _MessageTraverserVisitedMap _visited;\n  _MessageTraverser() : _visited = new _MessageTraverserVisitedMap();\n\n  /** Visitor's entry point. */\n  traverse(var x) {\n    if (isPrimitive(x)) return visitPrimitive(x);\n    _visited.reset();\n    var result;\n    try {\n      result = _dispatch(x);\n    } finally {\n      _visited.cleanup();\n    }\n    return result;\n  }\n\n  _dispatch(var x) {\n    if (isPrimitive(x)) return visitPrimitive(x);\n    if (x is List) return visitList(x);\n    if (x is Map) return visitMap(x);\n    if (x is SendPort) return visitSendPort(x);\n    if (x is SendPortSync) return visitSendPortSync(x);\n\n    // Overridable fallback.\n    return visitObject(x);\n  }\n\n  visitPrimitive(x);\n  visitList(List x);\n  visitMap(Map x);\n  visitSendPort(SendPort x);\n  visitSendPortSync(SendPortSync x);\n\n  visitObject(Object x) {\n    // TODO(floitsch): make this a real exception. (which one)?\n    throw \"Message serialization: Illegal value $x passed\";\n  }\n\n  static bool isPrimitive(x) {\n    return (x == null) || (x is String) || (x is num) || (x is bool);\n  }\n}\n\n\n/** Visitor that serializes a message as a JSON array. */\nabstract class _Serializer extends _MessageTraverser {\n  int _nextFreeRefId = 0;\n\n  visitPrimitive(x) => x;\n\n  visitList(List list) {\n    int copyId = _visited[list];\n    if (copyId != null) return ['ref', copyId];\n\n    int id = _nextFreeRefId++;\n    _visited[list] = id;\n    var jsArray = _serializeList(list);\n    // TODO(floitsch): we are losing the generic type.\n    return ['list', id, jsArray];\n  }\n\n  visitMap(Map map) {\n    int copyId = _visited[map];\n    if (copyId != null) return ['ref', copyId];\n\n    int id = _nextFreeRefId++;\n    _visited[map] = id;\n    var keys = _serializeList(map.keys.toList());\n    var values = _serializeList(map.values.toList());\n    // TODO(floitsch): we are losing the generic type.\n    return ['map', id, keys, values];\n  }\n\n  _serializeList(List list) {\n    int len = list.length;\n    var result = new List(len);\n    for (int i = 0; i < len; i++) {\n      result[i] = _dispatch(list[i]);\n    }\n    return result;\n  }\n}\n\n/** Deserializes arrays created with [_Serializer]. */\nabstract class _Deserializer {\n  Map<int, dynamic> _deserialized;\n\n  _Deserializer();\n\n  static bool isPrimitive(x) {\n    return (x == null) || (x is String) || (x is num) || (x is bool);\n  }\n\n  deserialize(x) {\n    if (isPrimitive(x)) return x;\n    // TODO(floitsch): this should be new HashMap<int, dynamic>()\n    _deserialized = new HashMap();\n    return _deserializeHelper(x);\n  }\n\n  _deserializeHelper(x) {\n    if (isPrimitive(x)) return x;\n    assert(x is List);\n    switch (x[0]) {\n      case 'ref': return _deserializeRef(x);\n      case 'list': return _deserializeList(x);\n      case 'map': return _deserializeMap(x);\n      case 'sendport': return deserializeSendPort(x);\n      default: return deserializeObject(x);\n    }\n  }\n\n  _deserializeRef(List x) {\n    int id = x[1];\n    var result = _deserialized[id];\n    assert(result != null);\n    return result;\n  }\n\n  List _deserializeList(List x) {\n    int id = x[1];\n    // We rely on the fact that Dart-lists are directly mapped to Js-arrays.\n    List dartList = x[2];\n    _deserialized[id] = dartList;\n    int len = dartList.length;\n    for (int i = 0; i < len; i++) {\n      dartList[i] = _deserializeHelper(dartList[i]);\n    }\n    return dartList;\n  }\n\n  Map _deserializeMap(List x) {\n    Map result = new Map();\n    int id = x[1];\n    _deserialized[id] = result;\n    List keys = x[2];\n    List values = x[3];\n    int len = keys.length;\n    assert(len == values.length);\n    for (int i = 0; i < len; i++) {\n      var key = _deserializeHelper(keys[i]);\n      var value = _deserializeHelper(values[i]);\n      result[key] = value;\n    }\n    return result;\n  }\n\n  deserializeSendPort(List x);\n\n  deserializeObject(List x) {\n    // TODO(floitsch): Use real exception (which one?).\n    throw \"Unexpected serialized object\";\n  }\n}\n\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Helper class to implement custom events which wrap DOM events.\n */\nclass _WrappedEvent implements Event {\n  final Event wrapped;\n  _WrappedEvent(this.wrapped);\n\n  bool get bubbles => wrapped.bubbles;\n\n  bool get cancelBubble => wrapped.bubbles;\n  void set cancelBubble(bool value) {\n    wrapped.cancelBubble = value;\n  }\n\n  bool get cancelable => wrapped.cancelable;\n\n  DataTransfer get clipboardData => wrapped.clipboardData;\n\n  EventTarget get currentTarget => wrapped.currentTarget;\n\n  bool get defaultPrevented => wrapped.defaultPrevented;\n\n  int get eventPhase => wrapped.eventPhase;\n\n  EventTarget get target => wrapped.target;\n\n  int get timeStamp => wrapped.timeStamp;\n\n  String get type => wrapped.type;\n\n  void $dom_initEvent(String eventTypeArg, bool canBubbleArg,\n      bool cancelableArg) {\n    throw new UnsupportedError(\n        'Cannot initialize this Event.');\n  }\n\n  void preventDefault() {\n    wrapped.preventDefault();\n  }\n\n  void stopImmediatePropagation() {\n    wrapped.stopImmediatePropagation();\n  }\n\n  void stopPropagation() {\n    wrapped.stopPropagation();\n  }\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * A list which just wraps another list, for either intercepting list calls or\n * retyping the list (for example, from List<A> to List<B> where B extends A).\n */\nclass _WrappedList<E> implements List<E> {\n  final List _list;\n\n  _WrappedList(this._list);\n\n  // Iterable APIs\n\n  Iterator<E> get iterator => new _WrappedIterator(_list.iterator);\n\n  Iterable map(f(E element)) => _list.map(f);\n\n  Iterable<E> where(bool f(E element)) => _list.where(f);\n\n  Iterable expand(Iterable f(E element)) => _list.expand(f);\n\n  bool contains(E element) => _list.contains(element);\n\n  void forEach(void f(E element)) { _list.forEach(f); }\n\n  E reduce(E combine(E value, E element)) =>\n      _list.reduce(combine);\n\n  dynamic fold(initialValue, combine(previousValue, E element)) =>\n      _list.fold(initialValue, combine);\n\n  bool every(bool f(E element)) => _list.every(f);\n\n  String join([String separator = \"\"]) => _list.join(separator);\n\n  bool any(bool f(E element)) => _list.any(f);\n\n  List<E> toList({ bool growable: true }) =>\n      new List.from(_list, growable: growable);\n\n  Set<E> toSet() => _list.toSet();\n\n  int get length => _list.length;\n\n  bool get isEmpty => _list.isEmpty;\n\n  Iterable<E> take(int n) => _list.take(n);\n\n  Iterable<E> takeWhile(bool test(E value)) => _list.takeWhile(test);\n\n  Iterable<E> skip(int n) => _list.skip(n);\n\n  Iterable<E> skipWhile(bool test(E value)) => _list.skipWhile(test);\n\n  E get first => _list.first;\n\n  E get last => _list.last;\n\n  E get single => _list.single;\n\n  E firstWhere(bool test(E value), { E orElse() }) =>\n      _list.firstWhere(test, orElse: orElse);\n\n  E lastWhere(bool test(E value), {E orElse()}) =>\n      _list.lastWhere(test, orElse: orElse);\n\n  E singleWhere(bool test(E value)) => _list.singleWhere(test);\n\n  E elementAt(int index) => _list.elementAt(index);\n\n  // Collection APIs\n\n  void add(E element) { _list.add(element); }\n\n  void addAll(Iterable<E> elements) { _list.addAll(elements); }\n\n  void remove(Object element) { _list.remove(element); }\n\n  void removeWhere(bool test(E element)) { _list.removeWhere(test); }\n\n  void retainWhere(bool test(E element)) { _list.retainWhere(test); }\n\n  void clear() { _list.clear(); }\n\n  // List APIs\n\n  E operator [](int index) => _list[index];\n\n  void operator []=(int index, E value) { _list[index] = value; }\n\n  void set length(int newLength) { _list.length = newLength; }\n\n  Iterable<E> get reversed => _list.reversed;\n\n  void sort([int compare(E a, E b)]) { _list.sort(compare); }\n\n  int indexOf(E element, [int start = 0]) => _list.indexOf(element, start);\n\n  int lastIndexOf(E element, [int start]) => _list.lastIndexOf(element, start);\n\n  void insert(int index, E element) => _list.insert(index, element);\n\n  void insertAll(int index, Iterable<E> iterable) =>\n      _list.insertAll(index, iterable);\n\n  void setAll(int index, Iterable<E> iterable) =>\n      _list.setAll(index, iterable);\n\n  E removeAt(int index) => _list.removeAt(index);\n\n  E removeLast() => _list.removeLast();\n\n  List<E> sublist(int start, [int end]) => _list.sublist(start, end);\n\n  Iterable<E> getRange(int start, int end) => _list.getRange(start, end);\n\n  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) {\n    _list.setRange(start, end, iterable, skipCount);\n  }\n\n  void removeRange(int start, int end) { _list.removeRange(start, end); }\n\n  void replaceRange(int start, int end, Iterable<E> iterable) {\n    _list.replaceRange(start, end, iterable);\n  }\n\n  void fillRange(int start, int end, [E fillValue]) {\n    _list.fillRange(start, end, fillValue);\n  }\n\n  Map<int, E> asMap() => _list.asMap();\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n}\n\n/**\n * Iterator wrapper for _WrappedList.\n */\nclass _WrappedIterator<E> implements Iterator<E> {\n  Iterator _iterator;\n\n  _WrappedIterator(this._iterator);\n\n  bool moveNext() {\n    return _iterator.moveNext();\n  }\n\n  E get current => _iterator.current;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nclass _CssStyleDeclarationFactoryProvider {\n  static CssStyleDeclaration createCssStyleDeclaration_css(String css) {\n    final style = new Element.tag('div').style;\n    style.cssText = css;\n    return style;\n  }\n\n  static CssStyleDeclaration createCssStyleDeclaration() {\n    return new CssStyleDeclaration.css('');\n  }\n}\n\nclass _DocumentFragmentFactoryProvider {\n  @DomName('Document.createDocumentFragment')\n  static DocumentFragment createDocumentFragment() =>\n      document.createDocumentFragment();\n\n  static DocumentFragment createDocumentFragment_html(String html) {\n    final fragment = new DocumentFragment();\n    fragment.innerHtml = html;\n    return fragment;\n  }\n\n  // TODO(nweiz): enable this when XML is ported.\n  // factory DocumentFragment.xml(String xml) {\n  //   final fragment = new DocumentFragment();\n  //   final e = new XMLElement.tag(\"xml\");\n  //   e.innerHtml = xml;\n  //\n  //   // Copy list first since we don't want liveness during iteration.\n  //   final List nodes = new List.from(e.nodes);\n  //   fragment.nodes.addAll(nodes);\n  //   return fragment;\n  // }\n\n  static DocumentFragment createDocumentFragment_svg(String svgContent) {\n    final fragment = new DocumentFragment();\n    final e = new svg.SvgSvgElement();\n    e.innerHtml = svgContent;\n\n    // Copy list first since we don't want liveness during iteration.\n    final List nodes = new List.from(e.nodes);\n    fragment.nodes.addAll(nodes);\n    return fragment;\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n// Conversions for Window.  These check if the window is the local\n// window, and if it's not, wraps or unwraps it with a secure wrapper.\n// We need to test for EventTarget here as well as it's a base type.\n// We omit an unwrapper for Window as no methods take a non-local\n// window as a parameter.\n\n\nDateTime _convertNativeToDart_DateTime(date) {\n  var millisSinceEpoch = JS('int', '#.getTime()', date);\n  return new DateTime.fromMillisecondsSinceEpoch(millisSinceEpoch, isUtc: true);\n}\n\n_convertDartToNative_DateTime(DateTime date) {\n  return JS('', 'new Date(#)', date.millisecondsSinceEpoch);\n}\n\nWindowBase _convertNativeToDart_Window(win) {\n  return _DOMWindowCrossFrame._createSafe(win);\n}\n\nEventTarget _convertNativeToDart_EventTarget(e) {\n  if (e == null) {\n    return null;\n  }\n  // Assume it's a Window if it contains the setInterval property.  It may be\n  // from a different frame - without a patched prototype - so we cannot\n  // rely on Dart type checking.\n  if (JS('bool', r'\"setInterval\" in #', e))\n    return _DOMWindowCrossFrame._createSafe(e);\n  else\n    return e;\n}\n\nEventTarget _convertDartToNative_EventTarget(e) {\n  if (e is _DOMWindowCrossFrame) {\n    return e._window;\n  } else {\n    return e;\n  }\n}\n\n// Conversions for ImageData\n//\n// On Firefox, the returned ImageData is a plain object.\n\nclass _TypedImageData implements ImageData {\n  final Uint8ClampedList data;\n  final int height;\n  final int width;\n\n  _TypedImageData(this.data, this.height, this.width);\n}\n\nImageData _convertNativeToDart_ImageData(nativeImageData) {\n\n  // None of the native getters that return ImageData have the type ImageData\n  // since that is incorrect for FireFox (which returns a plain Object).  So we\n  // need something that tells the compiler that the ImageData class has been\n  // instantiated.\n  // TODO(sra): Remove this when all the ImageData returning APIs have been\n  // annotated as returning the union ImageData + Object.\n  JS('ImageData', '0');\n\n  if (nativeImageData is ImageData) return nativeImageData;\n\n  // On Firefox the above test fails because imagedata is a plain object.\n  // So we create a _TypedImageData.\n\n  return new _TypedImageData(\n      JS('var', '#.data', nativeImageData),\n      JS('var', '#.height', nativeImageData),\n      JS('var', '#.width', nativeImageData));\n}\n\n// We can get rid of this conversion if _TypedImageData implements the fields\n// with native names.\n_convertDartToNative_ImageData(ImageData imageData) {\n  if (imageData is _TypedImageData) {\n    return JS('', '{data: #, height: #, width: #}',\n        imageData.data, imageData.height, imageData.width);\n  }\n  return imageData;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n// TODO(vsm): Unify with Dartium version.\nclass _DOMWindowCrossFrame implements WindowBase {\n  // Private window.  Note, this is a window in another frame, so it\n  // cannot be typed as \"Window\" as its prototype is not patched\n  // properly.  Its fields and methods can only be accessed via JavaScript.\n  final _window;\n\n  // Fields.\n  HistoryBase get history =>\n    _HistoryCrossFrame._createSafe(JS('HistoryBase', '#.history', _window));\n  LocationBase get location =>\n    _LocationCrossFrame._createSafe(JS('LocationBase', '#.location', _window));\n\n  // TODO(vsm): Add frames to navigate subframes.  See 2312.\n\n  bool get closed => JS('bool', '#.closed', _window);\n\n  WindowBase get opener => _createSafe(JS('WindowBase', '#.opener', _window));\n\n  WindowBase get parent => _createSafe(JS('WindowBase', '#.parent', _window));\n\n  WindowBase get top => _createSafe(JS('WindowBase', '#.top', _window));\n\n  // Methods.\n  void close() => JS('void', '#.close()', _window);\n\n  void postMessage(var message, String targetOrigin, [List messagePorts = null]) {\n    if (messagePorts == null) {\n      JS('void', '#.postMessage(#,#)', _window, message, targetOrigin);\n    } else {\n      JS('void', '#.postMessage(#,#,#)', _window, message, targetOrigin, messagePorts);\n    }\n  }\n\n  // Implementation support.\n  _DOMWindowCrossFrame(this._window);\n\n  static WindowBase _createSafe(w) {\n    if (identical(w, window)) {\n      return w;\n    } else {\n      // TODO(vsm): Cache or implement equality.\n      return new _DOMWindowCrossFrame(w);\n    }\n  }\n}\n\nclass _LocationCrossFrame implements LocationBase {\n  // Private location.  Note, this is a location object in another frame, so it\n  // cannot be typed as \"Location\" as its prototype is not patched\n  // properly.  Its fields and methods can only be accessed via JavaScript.\n  var _location;\n\n  void set href(String val) => _setHref(_location, val);\n  static void _setHref(location, val) {\n    JS('void', '#.href = #', location, val);\n  }\n\n  // Implementation support.\n  _LocationCrossFrame(this._location);\n\n  static LocationBase _createSafe(location) {\n    if (identical(location, window.location)) {\n      return location;\n    } else {\n      // TODO(vsm): Cache or implement equality.\n      return new _LocationCrossFrame(location);\n    }\n  }\n}\n\nclass _HistoryCrossFrame implements HistoryBase {\n  // Private history.  Note, this is a history object in another frame, so it\n  // cannot be typed as \"History\" as its prototype is not patched\n  // properly.  Its fields and methods can only be accessed via JavaScript.\n  var _history;\n\n  void back() => JS('void', '#.back()', _history);\n\n  void forward() => JS('void', '#.forward()', _history);\n\n  void go(int distance) => JS('void', '#.go(#)', _history, distance);\n\n  // Implementation support.\n  _HistoryCrossFrame(this._history);\n\n  static HistoryBase _createSafe(h) {\n    if (identical(h, window.history)) {\n      return h;\n    } else {\n      // TODO(vsm): Cache or implement equality.\n      return new _HistoryCrossFrame(h);\n    }\n  }\n}\n/**\n * A custom KeyboardEvent that attempts to eliminate cross-browser\n * inconsistencies, and also provide both keyCode and charCode information\n * for all key events (when such information can be determined).\n *\n * KeyEvent tries to provide a higher level, more polished keyboard event\n * information on top of the \"raw\" [KeyboardEvent].\n *\n * This class is very much a work in progress, and we'd love to get information\n * on how we can make this class work with as many international keyboards as\n * possible. Bugs welcome!\n */\nclass KeyEvent extends _WrappedEvent implements KeyboardEvent {\n  /** The parent KeyboardEvent that this KeyEvent is wrapping and \"fixing\". */\n  KeyboardEvent _parent;\n\n  /** The \"fixed\" value of whether the alt key is being pressed. */\n  bool _shadowAltKey;\n\n  /** Caculated value of what the estimated charCode is for this event. */\n  int _shadowCharCode;\n\n  /** Caculated value of what the estimated keyCode is for this event. */\n  int _shadowKeyCode;\n\n  /** Caculated value of what the estimated keyCode is for this event. */\n  int get keyCode => _shadowKeyCode;\n\n  /** Caculated value of what the estimated charCode is for this event. */\n  int get charCode => this.type == 'keypress' ? _shadowCharCode : 0;\n\n  /** Caculated value of whether the alt key is pressed is for this event. */\n  bool get altKey => _shadowAltKey;\n\n  /** Caculated value of what the estimated keyCode is for this event. */\n  int get which => keyCode;\n\n  /** Accessor to the underlying keyCode value is the parent event. */\n  int get _realKeyCode => JS('int', '#.keyCode', _parent);\n\n  /** Accessor to the underlying charCode value is the parent event. */\n  int get _realCharCode => JS('int', '#.charCode', _parent);\n\n  /** Accessor to the underlying altKey value is the parent event. */\n  bool get _realAltKey => JS('int', '#.altKey', _parent);\n\n  /** Construct a KeyEvent with [parent] as the event we're emulating. */\n  KeyEvent(KeyboardEvent parent): super(parent) {\n    _parent = parent;\n    _shadowAltKey = _realAltKey;\n    _shadowCharCode = _realCharCode;\n    _shadowKeyCode = _realKeyCode;\n  }\n\n  // TODO(efortuna): If KeyEvent is sufficiently successful that we want to make\n  // it the default keyboard event handling, move these methods over to Element.\n  /** Accessor to provide a stream of KeyEvents on the desired target. */\n  static EventStreamProvider<KeyEvent> keyDownEvent =\n    new _KeyboardEventHandler('keydown');\n  /** Accessor to provide a stream of KeyEvents on the desired target. */\n  static EventStreamProvider<KeyEvent> keyUpEvent =\n    new _KeyboardEventHandler('keyup');\n  /** Accessor to provide a stream of KeyEvents on the desired target. */\n  static EventStreamProvider<KeyEvent> keyPressEvent =\n    new _KeyboardEventHandler('keypress');\n\n  /** True if the altGraphKey is pressed during this event. */\n  bool get altGraphKey => _parent.altGraphKey;\n  /** Accessor to the clipboardData available for this event. */\n  DataTransfer get clipboardData => _parent.clipboardData;\n  /** True if the ctrl key is pressed during this event. */\n  bool get ctrlKey => _parent.ctrlKey;\n  int get detail => _parent.detail;\n  /**\n   * Accessor to the part of the keyboard that the key was pressed from (one of\n   * KeyLocation.STANDARD, KeyLocation.RIGHT, KeyLocation.LEFT,\n   * KeyLocation.NUMPAD, KeyLocation.MOBILE, KeyLocation.JOYSTICK).\n   */\n  int get keyLocation => _parent.keyLocation;\n  Point get layer => _parent.layer;\n  /** True if the Meta (or Mac command) key is pressed during this event. */\n  bool get metaKey => _parent.metaKey;\n  Point get page => _parent.page;\n  /** True if the shift key was pressed during this event. */\n  bool get shiftKey => _parent.shiftKey;\n  Window get view => _parent.view;\n  void $dom_initUIEvent(String type, bool canBubble, bool cancelable,\n      Window view, int detail) {\n    throw new UnsupportedError(\"Cannot initialize a UI Event from a KeyEvent.\");\n  }\n  String get _shadowKeyIdentifier => JS('String', '#.keyIdentifier', _parent);\n\n  int get $dom_charCode => charCode;\n  int get $dom_keyCode => keyCode;\n  String get $dom_keyIdentifier {\n    throw new UnsupportedError(\"keyIdentifier is unsupported.\");\n  }\n  void $dom_initKeyboardEvent(String type, bool canBubble, bool cancelable,\n      Window view, String keyIdentifier, int keyLocation, bool ctrlKey,\n      bool altKey, bool shiftKey, bool metaKey,\n      bool altGraphKey) {\n    throw new UnsupportedError(\n        \"Cannot initialize a KeyboardEvent from a KeyEvent.\");\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nclass _TextFactoryProvider {\n  static Text createText(String data) =>\n      JS('Text', 'document.createTextNode(#)', data);\n}\n// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n// On Firefox 11, the object obtained from 'window.location' is very strange.\n// It can't be monkey-patched and seems immune to putting methods on\n// Object.prototype.  We are forced to wrap the object.\n\nclass _LocationWrapper implements Location {\n\n  final _ptr;  // Opaque reference to real location.\n\n  _LocationWrapper(this._ptr);\n\n  // TODO(sra): Replace all the _set and _get calls with 'JS' forms.\n\n  // final List<String> ancestorOrigins;\n  List<String> get ancestorOrigins => _get(_ptr, 'ancestorOrigins');\n\n  // String hash;\n  String get hash => _get(_ptr, 'hash');\n  void set hash(String value) {\n    _set(_ptr, 'hash', value);\n  }\n\n  // String host;\n  String get host => _get(_ptr, 'host');\n  void set host(String value) {\n    _set(_ptr, 'host', value);\n  }\n\n  // String hostname;\n  String get hostname => _get(_ptr, 'hostname');\n  void set hostname(String value) {\n    _set(_ptr, 'hostname', value);\n  }\n\n  // String href;\n  String get href => _get(_ptr, 'href');\n  void set href(String value) {\n    _set(_ptr, 'href', value);\n  }\n\n  // final String origin;\n  String get origin => _get(_ptr, 'origin');\n\n  // String pathname;\n  String get pathname => _get(_ptr, 'pathname');\n  void set pathname(String value) {\n    _set(_ptr, 'pathname', value);\n  }\n\n  // String port;\n  String get port => _get(_ptr, 'port');\n  void set port(String value) {\n    _set(_ptr, 'port', value);\n  }\n\n  // String protocol;\n  String get protocol => _get(_ptr, 'protocol');\n  void set protocol(String value) {\n    _set(_ptr, 'protocol', value);\n  }\n\n  // String search;\n  String get search => _get(_ptr, 'search');\n  void set search(String value) {\n    _set(_ptr, 'search', value);\n  }\n\n  void assign(String url) => JS('void', '#.assign(#)', _ptr, url);\n\n  void reload() => JS('void', '#.reload()', _ptr);\n\n  void replace(String url) => JS('void', '#.replace(#)', _ptr, url);\n\n  String toString() => JS('String', '#.toString()', _ptr);\n\n\n  static _get(p, m) => JS('var', '#[#]', p, m);\n  static _set(p, m, v) => JS('void', '#[#] = #', p, m, v);\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nclass Platform {\n  static final supportsTypedData = JS('bool', '!!(window.ArrayBuffer)');\n}\n// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n// Iterator for arrays with fixed size.\nclass FixedSizeListIterator<T> implements Iterator<T> {\n  final List<T> _array;\n  final int _length;  // Cache array length for faster access.\n  int _position;\n  T _current;\n  \n  FixedSizeListIterator(List<T> array)\n      : _array = array,\n        _position = -1,\n        _length = array.length;\n\n  bool moveNext() {\n    int nextPosition = _position + 1;\n    if (nextPosition < _length) {\n      _current = _array[nextPosition];\n      _position = nextPosition;\n      return true;\n    }\n    _current = null;\n    _position = _length;\n    return false;\n  }\n\n  T get current => _current;\n}\n\n// Iterator for arrays with variable size.\nclass _VariableSizeListIterator<T> implements Iterator<T> {\n  final List<T> _array;\n  int _position;\n  T _current;\n\n  _VariableSizeListIterator(List<T> array)\n      : _array = array,\n        _position = -1;\n\n  bool moveNext() {\n    int nextPosition = _position + 1;\n    if (nextPosition < _array.length) {\n      _current = _array[nextPosition];\n      _position = nextPosition;\n      return true;\n    }\n    _current = null;\n    _position = _array.length;\n    return false;\n  }\n\n  T get current => _current;\n}\n","sdk/lib/html/html_common/conversions.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n// Conversions for IDBKey.\n//\n// Per http://www.w3.org/TR/IndexedDB/#key-construct\n//\n// \"A value is said to be a valid key if it is one of the following types: Array\n// JavaScript objects [ECMA-262], DOMString [WEBIDL], Date [ECMA-262] or float\n// [WEBIDL]. However Arrays are only valid keys if every item in the array is\n// defined and is a valid key (i.e. sparse arrays can not be valid keys) and if\n// the Array doesn't directly or indirectly contain itself. Any non-numeric\n// properties are ignored, and thus does not affect whether the Array is a valid\n// key. Additionally, if the value is of type float, it is only a valid key if\n// it is not NaN, and if the value is of type Date it is only a valid key if its\n// [[PrimitiveValue]] internal property, as defined by [ECMA-262], is not NaN.\"\n\n// What is required is to ensure that an Lists in the key are actually\n// JavaScript arrays, and any Dates are JavaScript Dates.\n\n// Conversions for Window.  These check if the window is the local\n// window, and if it's not, wraps or unwraps it with a secure wrapper.\n// We need to test for EventTarget here as well as it's a base type.\n// We omit an unwrapper for Window as no methods take a non-local\n// window as a parameter.\n\npart of html_common;\n\n\n/// Converts a JavaScript object with properties into a Dart Map.\n/// Not suitable for nested objects.\nMap convertNativeToDart_Dictionary(object) {\n  if (object == null) return null;\n  var dict = {};\n  for (final key in JS('=List', 'Object.getOwnPropertyNames(#)', object)) {\n    dict[key] = JS('var', '#[#]', object, key);\n  }\n  return dict;\n}\n\n/// Converts a flat Dart map into a JavaScript object with properties.\nconvertDartToNative_Dictionary(Map dict) {\n  if (dict == null) return null;\n  var object = JS('var', '{}');\n  dict.forEach((String key, value) {\n      JS('void', '#[#] = #', object, key, value);\n    });\n  return object;\n}\n\n\n/**\n * Ensures that the input is a JavaScript Array.\n *\n * Creates a new JavaScript array if necessary, otherwise returns the original.\n */\nList convertDartToNative_StringArray(List<String> input) {\n  // TODO(sra).  Implement this.\n  return input;\n}\n\n\n// -----------------------------------------------------------------------------\n\n/// Converts a Dart value into a JavaScript SerializedScriptValue.\nconvertDartToNative_SerializedScriptValue(value) {\n  return _convertDartToNative_PrepareForStructuredClone(value);\n}\n\n/// Since the source object may be viewed via a JavaScript event listener the\n/// original may not be modified.\nconvertNativeToDart_SerializedScriptValue(object) {\n  return convertNativeToDart_AcceptStructuredClone(object, mustCopy: true);\n}\n\n\n/**\n * Converts a Dart value into a JavaScript SerializedScriptValue.  Returns the\n * original input or a functional 'copy'.  Does not mutate the original.\n *\n * The main transformation is the translation of Dart Maps are converted to\n * JavaScript Objects.\n *\n * The algorithm is essentially a dry-run of the structured clone algorithm\n * described at\n * http://www.whatwg.org/specs/web-apps/current-work/multipage/common-dom-interfaces.html#structured-clone\n * https://www.khronos.org/registry/typedarray/specs/latest/#9\n *\n * Since the result of this function is expected to be passed only to JavaScript\n * operations that perform the structured clone algorithm which does not mutate\n * its output, the result may share structure with the input [value].\n */\n_convertDartToNative_PrepareForStructuredClone(value) {\n\n  // TODO(sra): Replace slots with identity hash table.\n  var values = [];\n  var copies = [];  // initially 'null', 'true' during initial DFS, then a copy.\n\n  int findSlot(value) {\n    int length = values.length;\n    for (int i = 0; i < length; i++) {\n      if (identical(values[i], value)) return i;\n    }\n    values.add(value);\n    copies.add(null);\n    return length;\n  }\n  readSlot(int i) => copies[i];\n  writeSlot(int i, x) { copies[i] = x; }\n  cleanupSlots() {}  // Will be needed if we mark objects with a property.\n\n  // Returns the input, or a clone of the input.\n  walk(e) {\n    if (e == null) return e;\n    if (e is bool) return e;\n    if (e is num) return e;\n    if (e is String) return e;\n    if (e is DateTime) {\n      // TODO(sra).\n      throw new UnimplementedError('structured clone of DateTime');\n    }\n    if (e is RegExp) {\n      // TODO(sra).\n      throw new UnimplementedError('structured clone of RegExp');\n    }\n\n    // The browser's internal structured cloning algorithm will copy certain\n    // types of object, but it will copy only its own implementations and not\n    // just any Dart implementations of the interface.\n\n    // TODO(sra): The JavaScript objects suitable for direct cloning by the\n    // structured clone algorithm could be tagged with an private interface.\n\n    if (e is File) return e;\n    if (e is Blob) return e;\n    if (e is FileList) return e;\n\n    // TODO(sra): Firefox: How to convert _TypedImageData on the other end?\n    if (e is ImageData) return e;\n    if (e is ByteBuffer) return e;\n\n    if (e is TypedData) return e;\n\n    if (e is Map) {\n      var slot = findSlot(e);\n      var copy = readSlot(slot);\n      if (copy != null) return copy;\n      copy = JS('var', '{}');\n      writeSlot(slot, copy);\n      e.forEach((key, value) {\n          JS('void', '#[#] = #', copy, key, walk(value));\n        });\n      return copy;\n    }\n\n    if (e is List) {\n      // Since a JavaScript Array is an instance of Dart List it is possible to\n      // avoid making a copy of the list if there is no need to copy anything\n      // reachable from the array.  We defer creating a new array until a cycle\n      // is detected or a subgraph was copied.\n      int length = e.length;\n      var slot = findSlot(e);\n      var copy = readSlot(slot);\n      if (copy != null) {\n        if (true == copy) {  // Cycle, so commit to making a copy.\n          copy = JS('=List', 'new Array(#)', length);\n          writeSlot(slot, copy);\n        }\n        return copy;\n      }\n\n      int i = 0;\n\n      if (isJavaScriptArray(e) &&\n          // We have to copy immutable lists, otherwise the structured clone\n          // algorithm will copy the .immutable$list marker property, making the\n          // list immutable when received!\n          !isImmutableJavaScriptArray(e)) {\n        writeSlot(slot, true);  // Deferred copy.\n        for ( ; i < length; i++) {\n          var element = e[i];\n          var elementCopy = walk(element);\n          if (!identical(elementCopy, element)) {\n            copy = readSlot(slot);   // Cyclic reference may have created it.\n            if (true == copy) {\n              copy = JS('=List', 'new Array(#)', length);\n              writeSlot(slot, copy);\n            }\n            for (int j = 0; j < i; j++) {\n              copy[j] = e[j];\n            }\n            copy[i] = elementCopy;\n            i++;\n            break;\n          }\n        }\n        if (copy == null) {\n          copy = e;\n          writeSlot(slot, copy);\n        }\n      } else {\n        // Not a JavaScript Array.  We are forced to make a copy.\n        copy = JS('=List', 'new Array(#)', length);\n        writeSlot(slot, copy);\n      }\n\n      for ( ; i < length; i++) {\n        copy[i] = walk(e[i]);\n      }\n      return copy;\n    }\n\n    throw new UnimplementedError('structured clone of other type');\n  }\n\n  var copy = walk(value);\n  cleanupSlots();\n  return copy;\n}\n\n/**\n * Converts a native value into a Dart object.\n *\n * If [mustCopy] is [:false:], may return the original input.  May mutate the\n * original input (but will be idempotent if mutation occurs).  It is assumed\n * that this conversion happens on native serializable script values such values\n * from native DOM calls.\n *\n * [object] is the result of a structured clone operation.\n *\n * If necessary, JavaScript Dates are converted into Dart Dates.\n *\n * If [mustCopy] is [:true:], the entire object is copied and the original input\n * is not mutated.  This should be the case where Dart and JavaScript code can\n * access the value, for example, via multiple event listeners for\n * MessageEvents.  Mutating the object to make it more 'Dart-like' would corrupt\n * the value as seen from the JavaScript listeners.\n */\nconvertNativeToDart_AcceptStructuredClone(object, {mustCopy = false}) {\n\n  // TODO(sra): Replace slots with identity hash table that works on non-dart\n  // objects.\n  var values = [];\n  var copies = [];\n\n  int findSlot(value) {\n    int length = values.length;\n    for (int i = 0; i < length; i++) {\n      if (identical(values[i], value)) return i;\n    }\n    values.add(value);\n    copies.add(null);\n    return length;\n  }\n  readSlot(int i) => copies[i];\n  writeSlot(int i, x) { copies[i] = x; }\n\n  walk(e) {\n    if (e == null) return e;\n    if (e is bool) return e;\n    if (e is num) return e;\n    if (e is String) return e;\n\n    if (isJavaScriptDate(e)) {\n      // TODO(sra).\n      throw new UnimplementedError('structured clone of DateTime');\n    }\n\n    if (isJavaScriptRegExp(e)) {\n      // TODO(sra).\n      throw new UnimplementedError('structured clone of RegExp');\n    }\n\n    if (isJavaScriptSimpleObject(e)) {\n      // TODO(sra): If mustCopy is false, swizzle the prototype for one of a Map\n      // implementation that uses the properies as storage.\n      var slot = findSlot(e);\n      var copy = readSlot(slot);\n      if (copy != null) return copy;\n      copy = {};\n\n      writeSlot(slot, copy);\n      for (final key in JS('=List', 'Object.keys(#)', e)) {\n        copy[key] = walk(JS('var', '#[#]', e, key));\n      }\n      return copy;\n    }\n\n    if (isJavaScriptArray(e)) {\n      var slot = findSlot(e);\n      var copy = readSlot(slot);\n      if (copy != null) return copy;\n\n      int length = e.length;\n      // Since a JavaScript Array is an instance of Dart List, we can modify it\n      // in-place unless we must copy.\n      copy = mustCopy ? JS('=List', 'new Array(#)', length) : e;\n      writeSlot(slot, copy);\n\n      for (int i = 0; i < length; i++) {\n        copy[i] = walk(e[i]);\n      }\n      return copy;\n    }\n\n    // Assume anything else is already a valid Dart object, either by having\n    // already been processed, or e.g. a clonable native class.\n    return e;\n  }\n\n  var copy = walk(object);\n  return copy;\n}\n\n\nbool isJavaScriptDate(value) => JS('bool', '# instanceof Date', value);\nbool isJavaScriptRegExp(value) => JS('bool', '# instanceof RegExp', value);\nbool isJavaScriptArray(value) => JS('bool', '# instanceof Array', value);\nbool isJavaScriptSimpleObject(value) =>\n    JS('bool', 'Object.getPrototypeOf(#) === Object.prototype', value);\nbool isImmutableJavaScriptArray(value) =>\n    JS('bool', r'!!(#.immutable$list)', value);\n\n\n\nconst String _serializedScriptValue =\n    'num|String|bool|'\n    '=List|=Object|'\n    'Blob|File|ByteBuffer|TypedData'\n    // TODO(sra): Add Date, RegExp.\n    ;\nconst annotation_Creates_SerializedScriptValue =\n    const Creates(_serializedScriptValue);\nconst annotation_Returns_SerializedScriptValue =\n    const Returns(_serializedScriptValue);\n","sdk/lib/html/html_common/device.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of html_common;\n\n/**\n * Utils for device detection.\n */\nclass Device {\n  static bool _isOpera;\n  static bool _isIE;\n  static bool _isFirefox;\n  static bool _isWebKit;\n  static String _cachedCssPrefix;\n  static String _cachedPropertyPrefix;\n\n  /**\n   * Gets the browser's user agent. Using this function allows tests to inject\n   * the user agent.\n * Returns the user agent.\n   */\n  static String get userAgent => window.navigator.userAgent;\n\n  /**\n   * Determines if the current device is running Opera.\n   */\n  static bool get isOpera {\n    if (_isOpera == null) {\n      _isOpera = userAgent.contains(\"Opera\", 0);\n    }\n    return _isOpera;\n  }\n\n  /**\n   * Determines if the current device is running Internet Explorer.\n   */\n  static bool get isIE {\n    if (_isIE == null) {\n      _isIE = !isOpera && userAgent.contains(\"MSIE\", 0);\n    }\n    return _isIE;\n  }\n\n  /**\n   * Determines if the current device is running Firefox.\n   */\n  static bool get isFirefox {\n    if (_isFirefox == null) {\n      _isFirefox = userAgent.contains(\"Firefox\", 0);\n    }\n    return _isFirefox;\n  }\n\n  /**\n   * Determines if the current device is running WebKit.\n   */\n  static bool get isWebKit {\n    if (_isWebKit == null) {\n      _isWebKit = !isOpera && userAgent.contains(\"WebKit\", 0);\n    }\n    return _isWebKit;\n  }\n\n  /**\n   * Gets the CSS property prefix for the current platform.\n   */\n  static String get cssPrefix {\n    if (_cachedCssPrefix == null) {\n      if (isFirefox) {\n        _cachedCssPrefix = '-moz-';\n      } else if (isIE) {\n        _cachedCssPrefix = '-ms-';\n      } else if (isOpera) {\n        _cachedCssPrefix = '-o-';\n      } else {\n        _cachedCssPrefix = '-webkit-';\n      }\n    }\n    return _cachedCssPrefix;\n  }\n\n  /**\n   * Prefix as used for JS property names.\n   */\n  static String get propertyPrefix {\n    if (_cachedPropertyPrefix == null) {\n      if (isFirefox) {\n        _cachedPropertyPrefix = 'moz';\n      } else if (isIE) {\n        _cachedPropertyPrefix = 'ms';\n      } else if (isOpera) {\n        _cachedPropertyPrefix = 'o';\n      } else {\n        _cachedPropertyPrefix = 'webkit';\n      }\n    }\n    return _cachedPropertyPrefix;\n  }\n\n  /**\n   * Checks to see if the event class is supported by the current platform.\n   */\n  static bool isEventTypeSupported(String eventType) {\n    // Browsers throw for unsupported event names.\n    try {\n      var e = document.$dom_createEvent(eventType);\n      return e is Event;\n    } catch (_) { }\n    return false;\n  }\n}\n","sdk/lib/html/html_common/filtered_element_list.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of html_common;\n\n/**\n * An indexable collection of a node's descendants in the document tree,\n * filtered so that only elements are in the collection.\n */\nclass FilteredElementList extends ListBase<Element> {\n  final Node _node;\n  final List<Node> _childNodes;\n\n  /**\n   * Creates a collection of the elements that descend from a node.\n   *\n   * Example usage:\n   *\n   *     var filteredElements = new FilteredElementList(query(\"#container\"));\n   *     // filteredElements is [a, b, c].\n   */\n  FilteredElementList(Node node): _childNodes = node.nodes, _node = node;\n\n  // We can't memoize this, since it's possible that children will be messed\n  // with externally to this class.\n  //\n  // TODO(nweiz): we don't always need to create a new list. For example\n  // forEach, every, any, ... could directly work on the _childNodes.\n  List<Element> get _filtered =>\n    new List<Element>.from(_childNodes.where((n) => n is Element));\n\n  void forEach(void f(Element element)) {\n    _filtered.forEach(f);\n  }\n\n  void operator []=(int index, Element value) {\n    this[index].replaceWith(value);\n  }\n\n  void set length(int newLength) {\n    final len = this.length;\n    if (newLength >= len) {\n      return;\n    } else if (newLength < 0) {\n      throw new ArgumentError(\"Invalid list length\");\n    }\n\n    removeRange(newLength, len);\n  }\n\n  String join([String separator = \"\"]) => _filtered.join(separator);\n\n  void add(Element value) {\n    _childNodes.add(value);\n  }\n\n  void addAll(Iterable<Element> iterable) {\n    for (Element element in iterable) {\n      add(element);\n    }\n  }\n\n  bool contains(Element element) {\n    return element is Element && _childNodes.contains(element);\n  }\n\n  Iterable<Element> get reversed => _filtered.reversed;\n\n  void sort([int compare(Element a, Element b)]) {\n    throw new UnsupportedError('TODO(jacobr): should we impl?');\n  }\n\n  void setRange(int start, int end, Iterable<Element> iterable,\n                [int skipCount = 0]) {\n    throw new UnimplementedError();\n  }\n\n  void fillRange(int start, int end, [Element fillValue]) {\n    throw new UnimplementedError();\n  }\n\n  void replaceRange(int start, int end, Iterable<Element> iterable) {\n    throw new UnimplementedError();\n  }\n\n  void removeRange(int start, int end) {\n    _filtered.sublist(start, end).forEach((el) => el.remove());\n  }\n\n  void clear() {\n    // Currently, ElementList#clear clears even non-element nodes, so we follow\n    // that behavior.\n    _childNodes.clear();\n  }\n\n  Element removeLast() {\n    final result = this.last;\n    if (result != null) {\n      result.remove();\n    }\n    return result;\n  }\n\n  Iterable map(f(Element element)) => _filtered.map(f);\n  Iterable<Element> where(bool f(Element element)) => _filtered.where(f);\n  Iterable expand(Iterable f(Element element)) => _filtered.expand(f);\n\n  void insert(int index, Element value) {\n    _childNodes.insert(index, value);\n  }\n\n  void insertAll(int index, Iterable<Element> iterable) {\n    _childNodes.insertAll(index, iterable);\n  }\n\n  Element removeAt(int index) {\n    final result = this[index];\n    result.remove();\n    return result;\n  }\n\n  bool remove(Object element) {\n    if (element is! Element) return false;\n    for (int i = 0; i < length; i++) {\n      Element indexElement = this[i];\n      if (identical(indexElement, element)) {\n        indexElement.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n\n\n  Element reduce(Element combine(Element value, Element element)) {\n    return _filtered.reduce(combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n      dynamic combine(dynamic previousValue, Element element)) {\n    return _filtered.fold(initialValue, combine);\n  }\n\n  bool every(bool f(Element element)) => _filtered.every(f);\n  bool any(bool f(Element element)) => _filtered.any(f);\n  List<Element> toList({ bool growable: true }) =>\n      new List<Element>.from(this, growable: growable);\n  Set<Element> toSet() => new Set<Element>.from(this);\n  Element firstWhere(bool test(Element value), {Element orElse()}) {\n    return _filtered.firstWhere(test, orElse: orElse);\n  }\n\n  Element lastWhere(bool test(Element value), {Element orElse()}) {\n    return _filtered.lastWhere(test, orElse: orElse);\n  }\n\n  Element singleWhere(bool test(Element value)) {\n    return _filtered.singleWhere(test);\n  }\n\n  Element elementAt(int index) {\n    return this[index];\n  }\n\n  bool get isEmpty => _filtered.isEmpty;\n  int get length => _filtered.length;\n  Element operator [](int index) => _filtered[index];\n  Iterator<Element> get iterator => _filtered.iterator;\n  List<Element> sublist(int start, [int end]) =>\n    _filtered.sublist(start, end);\n  Iterable<Element> getRange(int start, int end) =>\n    _filtered.getRange(start, end);\n  int indexOf(Element element, [int start = 0]) =>\n    _filtered.indexOf(element, start);\n\n  int lastIndexOf(Element element, [int start = null]) {\n    if (start == null) start = length - 1;\n    return _filtered.lastIndexOf(element, start);\n  }\n\n  List<Element> take(int n) {\n    return IterableMixinWorkaround.takeList(this, n);\n  }\n\n  Iterable<Element> takeWhile(bool test(Element value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  List<Element> skip(int n) {\n    return IterableMixinWorkaround.skipList(this, n);\n  }\n\n  Iterable<Element> skipWhile(bool test(Element value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  Element get first => _filtered.first;\n\n  Element get last => _filtered.last;\n\n  Element get single => _filtered.single;\n\n  Element min([int compare(Element a, Element b)]) => _filtered.min(compare);\n\n  Element max([int compare(Element a, Element b)]) => _filtered.max(compare);\n\n  Map<int, Element> asMap() {\n    return IterableMixinWorkaround.asMapList(this);\n  }\n}\n","sdk/lib/html/html_common/html_common.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary html_common;\n\nimport 'dart:collection';\nimport 'dart:html';\n\nimport 'metadata.dart';\nexport 'metadata.dart';\n\npart 'device.dart';\npart 'filtered_element_list.dart';\npart 'lists.dart';\n\n// For annotating deprecated APIs.\n// TODO: remove once @deprecated is added to dart core.\nconst deprecated = 0;\n","sdk/lib/html/html_common/html_common_dart2js.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary html_common;\n\nimport 'dart:collection';\nimport 'dart:html';\nimport 'dart:typed_data';\nimport 'dart:_js_helper' show Creates, Returns;\nimport 'dart:_foreign_helper' show JS;\n\nimport 'metadata.dart';\nexport 'metadata.dart';\n\npart 'conversions.dart';\npart 'device.dart';\npart 'filtered_element_list.dart';\npart 'lists.dart';\n\n// For annotating deprecated APIs.\n// TODO: remove once @deprecated is added to dart core.\nconst deprecated = 0;\n","sdk/lib/html/html_common/lists.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of html_common;\n\nclass Lists {\n\n  /**\n   * Returns the index in the array [a] of the given [element], starting\n   * the search at index [startIndex] to [endIndex] (exclusive).\n   * Returns -1 if [element] is not found.\n   */\n  static int indexOf(List a,\n                     Object element,\n                     int startIndex,\n                     int endIndex) {\n    if (startIndex >= a.length) {\n      return -1;\n    }\n    if (startIndex < 0) {\n      startIndex = 0;\n    }\n    for (int i = startIndex; i < endIndex; i++) {\n      if (a[i] == element) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the last index in the array [a] of the given [element], starting\n   * the search at index [startIndex] to 0.\n   * Returns -1 if [element] is not found.\n   */\n  static int lastIndexOf(List a, Object element, int startIndex) {\n    if (startIndex < 0) {\n      return -1;\n    }\n    if (startIndex >= a.length) {\n      startIndex = a.length - 1;\n    }\n    for (int i = startIndex; i >= 0; i--) {\n      if (a[i] == element) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns a sub list copy of this list, from [start] to\n   * [end] ([end] not inclusive).\n   * Returns an empty list if [length] is 0.\n   * It is an error if indices are not valid for the list, or\n   * if [end] is before [start].\n   */\n  static List getRange(List a, int start, int end, List accumulator) {\n    if (start < 0) throw new RangeError.value(start);\n    if (end < start) throw new RangeError.value(end);\n    if (end > a.length) throw new RangeError.value(end);\n    for (int i = start; i < end; i++) {\n      accumulator.add(a[i]);\n    }\n    return accumulator;\n  }\n}\n","sdk/lib/html/html_common/metadata.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary metadata;\n\n/**\n * An annotation used to mark a feature as only being supported by a subset\n * of the browsers that Dart supports by default.\n *\n * If an API is not annotated with [SupportedBrowser] then it is assumed to\n * work on all browsers Dart supports.\n */\nclass SupportedBrowser {\n  static const String CHROME = \"Chrome\";\n  static const String FIREFOX = \"Firefox\";\n  static const String IE = \"Internet Explorer\";\n  static const String OPERA = \"Opera\";\n  static const String SAFARI = \"Safari\";\n\n  /// The name of the browser.\n  final String browserName;\n  /// The minimum version of the browser that supports the feature, or null\n  /// if supported on all versions.\n  final String minimumVersion;\n\n  const SupportedBrowser(this.browserName, [this.minimumVersion]);\n}\n\n\n/**\n * An annotation used to mark an API as being experimental.\n *\n * An API is considered to be experimental if it is still going through the\n * process of stabilizing and is subject to change or removal.\n *\n * See also:\n *\n * * [W3C recommendation](http://en.wikipedia.org/wiki/W3C_recommendation)\n */\nclass Experimental {}\n\n\n/**\n * Metadata that specifies the DOM name associated with the element.\n *\n * This is used for API generation.\n *\n * [name] should be formatted as `interface.member`.\n */\nclass DomName {\n  final String name;\n  const DomName(this.name);\n}\n\n\n/// Metadata that specifies that that member is editable through generated\n/// files.\nclass DocsEditable {}\n","sdk/lib/indexed_db/dart2js/indexed_db_dart2js.dart":"library dart.dom.indexed_db;\n\nimport 'dart:async';\nimport 'dart:html';\nimport 'dart:html_common';\nimport 'dart:typed_data';\nimport 'dart:_js_helper' show Creates, Returns, JSName, Null;\nimport 'dart:_foreign_helper' show JS;\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// DO NOT EDIT - unless you are editing documentation as per:\n// https://code.google.com/p/dart/wiki/ContributingHTMLDocumentation\n// Auto-generated dart:svg library.\n\n\n\n\n\nclass _KeyRangeFactoryProvider {\n\n  static KeyRange createKeyRange_only(/*Key*/ value) =>\n      _only(_class(), _translateKey(value));\n\n  static KeyRange createKeyRange_lowerBound(\n      /*Key*/ bound, [bool open = false]) =>\n      _lowerBound(_class(), _translateKey(bound), open);\n\n  static KeyRange createKeyRange_upperBound(\n      /*Key*/ bound, [bool open = false]) =>\n      _upperBound(_class(), _translateKey(bound), open);\n\n  static KeyRange createKeyRange_bound(/*Key*/ lower, /*Key*/ upper,\n      [bool lowerOpen = false, bool upperOpen = false]) =>\n      _bound(_class(), _translateKey(lower), _translateKey(upper),\n             lowerOpen, upperOpen);\n\n  static var _cachedClass;\n\n  static _class() {\n    if (_cachedClass != null) return _cachedClass;\n    return _cachedClass = _uncachedClass();\n  }\n\n  static _uncachedClass() =>\n    JS('var',\n       '''window.webkitIDBKeyRange || window.mozIDBKeyRange ||\n          window.msIDBKeyRange || window.IDBKeyRange''');\n\n  static _translateKey(idbkey) => idbkey;  // TODO: fixme.\n\n  static KeyRange _only(cls, value) =>\n       JS('KeyRange', '#.only(#)', cls, value);\n\n  static KeyRange _lowerBound(cls, bound, open) =>\n       JS('KeyRange', '#.lowerBound(#, #)', cls, bound, open);\n\n  static KeyRange _upperBound(cls, bound, open) =>\n       JS('KeyRange', '#.upperBound(#, #)', cls, bound, open);\n\n  static KeyRange _bound(cls, lower, upper, lowerOpen, upperOpen) =>\n       JS('KeyRange', '#.bound(#, #, #, #)',\n          cls, lower, upper, lowerOpen, upperOpen);\n}\n\n// Conversions for IDBKey.\n//\n// Per http://www.w3.org/TR/IndexedDB/#key-construct\n//\n// \"A value is said to be a valid key if it is one of the following types: Array\n// JavaScript objects [ECMA-262], DOMString [WEBIDL], Date [ECMA-262] or float\n// [WEBIDL]. However Arrays are only valid keys if every item in the array is\n// defined and is a valid key (i.e. sparse arrays can not be valid keys) and if\n// the Array doesn't directly or indirectly contain itself. Any non-numeric\n// properties are ignored, and thus does not affect whether the Array is a valid\n// key. Additionally, if the value is of type float, it is only a valid key if\n// it is not NaN, and if the value is of type Date it is only a valid key if its\n// [[PrimitiveValue]] internal property, as defined by [ECMA-262], is not NaN.\"\n\n// What is required is to ensure that an Lists in the key are actually\n// JavaScript arrays, and any Dates are JavaScript Dates.\n\n\n/**\n * Converts a native IDBKey into a Dart object.\n *\n * May return the original input.  May mutate the original input (but will be\n * idempotent if mutation occurs).  It is assumed that this conversion happens\n * on native IDBKeys on all paths that return IDBKeys from native DOM calls.\n *\n * If necessary, JavaScript Dates are converted into Dart Dates.\n */\n_convertNativeToDart_IDBKey(nativeKey) {\n  containsDate(object) {\n    if (isJavaScriptDate(object)) return true;\n    if (object is List) {\n      for (int i = 0; i < object.length; i++) {\n        if (containsDate(object[i])) return true;\n      }\n    }\n    return false;  // number, string.\n  }\n  if (containsDate(nativeKey)) {\n    throw new UnimplementedError('Key containing DateTime');\n  }\n  // TODO: Cache conversion somewhere?\n  return nativeKey;\n}\n\n/**\n * Converts a Dart object into a valid IDBKey.\n *\n * May return the original input.  Does not mutate input.\n *\n * If necessary, [dartKey] may be copied to ensure all lists are converted into\n * JavaScript Arrays and Dart Dates into JavaScript Dates.\n */\n_convertDartToNative_IDBKey(dartKey) {\n  // TODO: Implement.\n  return dartKey;\n}\n\n\n\n/// May modify original.  If so, action is idempotent.\n_convertNativeToDart_IDBAny(object) {\n  return convertNativeToDart_AcceptStructuredClone(object, mustCopy: false);\n}\n\n\nconst String _idbKey = '=List|=Object|num|String';  // TODO(sra): Add DateTime.\nconst _annotation_Creates_IDBKey = const Creates(_idbKey);\nconst _annotation_Returns_IDBKey = const Returns(_idbKey);\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('IDBCursor')\nclass Cursor native \"IDBCursor\" {\n  @DomName('IDBCursor.delete')\n  Future delete() {\n   try {\n      return _completeRequest($dom_delete());\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBCursor.value')\n  Future update(value) {\n   try {\n      return _completeRequest($dom_update(value));\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  \n  @DomName('IDBCursor.direction')\n  @DocsEditable\n  final String direction;\n\n  @DomName('IDBCursor.key')\n  @DocsEditable\n  @_annotation_Creates_IDBKey\n  @_annotation_Returns_IDBKey\n  final Object key;\n\n  @DomName('IDBCursor.primaryKey')\n  @DocsEditable\n  final Object primaryKey;\n\n  @DomName('IDBCursor.source')\n  @DocsEditable\n  final dynamic source;\n\n  @DomName('IDBCursor.advance')\n  @DocsEditable\n  void advance(int count) native;\n\n  @JSName('delete')\n  @DomName('IDBCursor.delete')\n  @DocsEditable\n  Request $dom_delete() native;\n\n  @JSName('continue')\n  @DomName('IDBCursor.continue')\n  @DocsEditable\n  void next([Object key]) native;\n\n  @DomName('IDBCursor.update')\n  @DocsEditable\n  Request $dom_update(/*any*/ value) {\n    var value_1 = convertDartToNative_SerializedScriptValue(value);\n    return _$dom_update_1(value_1);\n  }\n  @JSName('update')\n  @DomName('IDBCursor.update')\n  @DocsEditable\n  Request _$dom_update_1(value) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('IDBCursorWithValue')\nclass CursorWithValue extends Cursor native \"IDBCursorWithValue\" {\n\n  dynamic get value => _convertNativeToDart_IDBAny(this._get_value);\n  @JSName('value')\n  @DomName('IDBCursorWithValue.value')\n  @DocsEditable\n  @annotation_Creates_SerializedScriptValue\n  @annotation_Returns_SerializedScriptValue\n  final dynamic _get_value;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('IDBDatabase')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX, '15')\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@Experimental\nclass Database extends EventTarget native \"IDBDatabase\" {\n  @DomName('IDBDatabase.createObjectStore')\n  @DocsEditable\n  ObjectStore createObjectStore(String name,\n      {String keyPath, bool autoIncrement}) {\n    var options = {};\n    if (keyPath != null) {\n      options['keyPath'] = keyPath;\n    }\n    if (autoIncrement != null) {\n      options['autoIncrement'] = autoIncrement;\n    }\n\n    return $dom_createObjectStore(name, options);\n  }\n\n  Transaction transaction(storeName_OR_storeNames, String mode) {\n    if (mode != 'readonly' && mode != 'readwrite') {\n      throw new ArgumentError(mode);\n    }\n\n    // TODO(sra): Ensure storeName_OR_storeNames is a string or List<String>,\n    // and copy to JavaScript array if necessary.\n\n    // Try and create a transaction with a string mode.  Browsers that expect a\n    // numeric mode tend to convert the string into a number.  This fails\n    // silently, resulting in zero ('readonly').\n    return _transaction(storeName_OR_storeNames, mode);\n  }\n\n  @JSName('transaction')\n  Transaction _transaction(stores, mode) native;\n\n\n  @DomName('IDBDatabase.abortEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> abortEvent = const EventStreamProvider<Event>('abort');\n\n  @DomName('IDBDatabase.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('IDBDatabase.versionchangeEvent')\n  @DocsEditable\n  static const EventStreamProvider<VersionChangeEvent> versionChangeEvent = const EventStreamProvider<VersionChangeEvent>('versionchange');\n\n  @DomName('IDBDatabase.name')\n  @DocsEditable\n  final String name;\n\n  @DomName('IDBDatabase.objectStoreNames')\n  @DocsEditable\n  @Returns('DomStringList')\n  @Creates('DomStringList')\n  final List<String> objectStoreNames;\n\n  @DomName('IDBDatabase.version')\n  @DocsEditable\n  final dynamic version;\n\n  @JSName('addEventListener')\n  @DomName('IDBDatabase.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('IDBDatabase.close')\n  @DocsEditable\n  void close() native;\n\n  @DomName('IDBDatabase.createObjectStore')\n  @DocsEditable\n  ObjectStore $dom_createObjectStore(String name, [Map options]) {\n    if (?options) {\n      var options_1 = convertDartToNative_Dictionary(options);\n      return _$dom_createObjectStore_1(name, options_1);\n    }\n    return _$dom_createObjectStore_2(name);\n  }\n  @JSName('createObjectStore')\n  @DomName('IDBDatabase.createObjectStore')\n  @DocsEditable\n  ObjectStore _$dom_createObjectStore_1(name, options) native;\n  @JSName('createObjectStore')\n  @DomName('IDBDatabase.createObjectStore')\n  @DocsEditable\n  ObjectStore _$dom_createObjectStore_2(name) native;\n\n  @DomName('IDBDatabase.deleteObjectStore')\n  @DocsEditable\n  void deleteObjectStore(String name) native;\n\n  @DomName('IDBDatabase.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @JSName('removeEventListener')\n  @DomName('IDBDatabase.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('IDBDatabase.onabort')\n  @DocsEditable\n  Stream<Event> get onAbort => abortEvent.forTarget(this);\n\n  @DomName('IDBDatabase.onerror')\n  @DocsEditable\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  @DomName('IDBDatabase.onversionchange')\n  @DocsEditable\n  Stream<VersionChangeEvent> get onVersionChange => versionChangeEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('IDBFactory')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX, '15')\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@Experimental\nclass IdbFactory native \"IDBFactory\" {\n  /**\n   * Checks to see if Indexed DB is supported on the current platform.\n   */\n  static bool get supported {\n    return JS('bool',\n        '!!(window.indexedDB || '\n        'window.webkitIndexedDB || '\n        'window.mozIndexedDB)');\n  }\n\n  @DomName('IDBFactory.open')\n  Future<Database> open(String name,\n      {int version, void onUpgradeNeeded(VersionChangeEvent),\n      void onBlocked(Event)}) {\n    if ((version == null) != (onUpgradeNeeded == null)) {\n      return new Future.error(new ArgumentError(\n          'version and onUpgradeNeeded must be specified together'));\n    }\n    try {\n      var request;\n      if (version != null) {\n        request = $dom_open(name, version);\n      } else {\n        request = $dom_open(name);\n      }\n\n      if (onUpgradeNeeded != null) {\n        request.onUpgradeNeeded.listen(onUpgradeNeeded);\n      }\n      if (onBlocked != null) {\n        request.onBlocked.listen(onBlocked);\n      }\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBFactory.deleteDatabase')\n  Future<IdbFactory> deleteDatabase(String name,\n      {void onBlocked(Event)}) {\n    try {\n      var request = $dom_deleteDatabase(name);\n\n      if (onBlocked != null) {\n        request.onBlocked.listen(onBlocked);\n      }\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBFactory.getDatabaseNames')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @Experimental\n  Future<List<String>> getDatabaseNames() {\n    try {\n      var request = $dom_webkitGetDatabaseNames();\n\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  /**\n   * Checks to see if getDatabaseNames is supported by the current platform.\n   */\n  bool get supportsDatabaseNames {\n    return supported && JS('bool',\n        '!!(#.getDatabaseNames || #.webkitGetDatabaseNames)', this, this);\n  }\n\n\n  @DomName('IDBFactory.cmp')\n  @DocsEditable\n  int cmp(Object first, Object second) native;\n\n  @JSName('deleteDatabase')\n  @DomName('IDBFactory.deleteDatabase')\n  @DocsEditable\n  OpenDBRequest $dom_deleteDatabase(String name) native;\n\n  @JSName('open')\n  @DomName('IDBFactory.open')\n  @DocsEditable\n  @Returns('Request')\n  @Creates('Request')\n  @Creates('Database')\n  OpenDBRequest $dom_open(String name, [int version]) native;\n\n  @JSName('webkitGetDatabaseNames')\n  @DomName('IDBFactory.webkitGetDatabaseNames')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  @Returns('Request')\n  @Creates('Request')\n  @Creates('DomStringList')\n  Request $dom_webkitGetDatabaseNames() native;\n\n}\n\n\n/**\n * Ties a request to a completer, so the completer is completed when it succeeds\n * and errors out when the request errors.\n */\nFuture _completeRequest(Request request) {\n  var completer = new Completer();\n  // TODO: make sure that completer.complete is synchronous as transactions\n  // may be committed if the result is not processed immediately.\n  request.onSuccess.listen((e) {\n    completer.complete(request.result);\n  });\n  request.onError.listen((e) {\n    completer.completeError(e);\n  });\n  return completer.future;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('IDBIndex')\nclass Index native \"IDBIndex\" {\n  @DomName('IDBIndex.count')\n  Future<int> count([key_OR_range]) {\n   try {\n      var request;\n      if (key_OR_range != null) {\n        request = $dom_count(key_OR_range);\n      } else {\n        request = $dom_count();\n      }\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBIndex.get')\n  Future get(key) {\n    try {\n      var request = $dom_get(key);\n\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBIndex.getKey')\n  Future getKey(key) {\n    try {\n      var request = $dom_getKey(key);\n\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  /**\n   * Creates a stream of cursors over the records in this object store.\n   *\n   * See also:\n   *\n   * * [ObjectStore.openCursor]\n   */\n  Stream<CursorWithValue> openCursor({key, KeyRange range, String direction,\n      bool autoAdvance}) {\n    var key_OR_range = null;\n    if (key != null) {\n      if (range != null) {\n        throw new ArgumentError('Cannot specify both key and range.');\n      }\n      key_OR_range = key;\n    } else {\n      key_OR_range = range;\n    }\n    var request;\n    if (direction == null) {\n      request = $dom_openCursor(key_OR_range);\n    } else {\n      request = $dom_openCursor(key_OR_range, direction);\n    }\n    return ObjectStore._cursorStreamFromResult(request, autoAdvance);\n  }\n\n  /**\n   * Creates a stream of cursors over the records in this object store.\n   *\n   * See also:\n   *\n   * * [ObjectStore.openCursor]\n   */\n  Stream<Cursor> openKeyCursor({key, KeyRange range, String direction,\n      bool autoAdvance}) {\n    var key_OR_range = null;\n    if (key != null) {\n      if (range != null) {\n        throw new ArgumentError('Cannot specify both key and range.');\n      }\n      key_OR_range = key;\n    } else {\n      key_OR_range = range;\n    }\n    var request;\n    if (direction == null) {\n      request = $dom_openKeyCursor(key_OR_range);\n    } else {\n      request = $dom_openKeyCursor(key_OR_range, direction);\n    }\n    return ObjectStore._cursorStreamFromResult(request, autoAdvance);\n  }\n\n  \n  @DomName('IDBIndex.keyPath')\n  @DocsEditable\n  final dynamic keyPath;\n\n  @DomName('IDBIndex.multiEntry')\n  @DocsEditable\n  final bool multiEntry;\n\n  @DomName('IDBIndex.name')\n  @DocsEditable\n  final String name;\n\n  @DomName('IDBIndex.objectStore')\n  @DocsEditable\n  final ObjectStore objectStore;\n\n  @DomName('IDBIndex.unique')\n  @DocsEditable\n  final bool unique;\n\n  @JSName('count')\n  @DomName('IDBIndex.count')\n  @DocsEditable\n  Request $dom_count([key_OR_range]) native;\n\n  @JSName('get')\n  @DomName('IDBIndex.get')\n  @DocsEditable\n  @Returns('Request')\n  @Creates('Request')\n  @annotation_Creates_SerializedScriptValue\n  Request $dom_get(key) native;\n\n  @JSName('getKey')\n  @DomName('IDBIndex.getKey')\n  @DocsEditable\n  @Returns('Request')\n  @Creates('Request')\n  @annotation_Creates_SerializedScriptValue\n  @Creates('ObjectStore')\n  Request $dom_getKey(key) native;\n\n  @JSName('openCursor')\n  @DomName('IDBIndex.openCursor')\n  @DocsEditable\n  @Returns('Request')\n  @Creates('Request')\n  @Creates('Cursor')\n  Request $dom_openCursor([key_OR_range, String direction]) native;\n\n  @JSName('openKeyCursor')\n  @DomName('IDBIndex.openKeyCursor')\n  @DocsEditable\n  @Returns('Request')\n  @Creates('Request')\n  @Creates('Cursor')\n  Request $dom_openKeyCursor([key_OR_range, String direction]) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('IDBKeyRange')\nclass KeyRange native \"IDBKeyRange\" {\n  @DomName('IDBKeyRange.only')\n  factory KeyRange.only(/*Key*/ value) =>\n      _KeyRangeFactoryProvider.createKeyRange_only(value);\n\n  @DomName('IDBKeyRange.lowerBound')\n  factory KeyRange.lowerBound(/*Key*/ bound, [bool open = false]) =>\n      _KeyRangeFactoryProvider.createKeyRange_lowerBound(bound, open);\n\n  @DomName('IDBKeyRange.upperBound')\n  factory KeyRange.upperBound(/*Key*/ bound, [bool open = false]) =>\n      _KeyRangeFactoryProvider.createKeyRange_upperBound(bound, open);\n\n  @DomName('KeyRange.bound')\n  factory KeyRange.bound(/*Key*/ lower, /*Key*/ upper,\n                            [bool lowerOpen = false, bool upperOpen = false]) =>\n      _KeyRangeFactoryProvider.createKeyRange_bound(\n          lower, upper, lowerOpen, upperOpen);\n\n\n  @DomName('IDBKeyRange.lower')\n  @DocsEditable\n  final Object lower;\n\n  @DomName('IDBKeyRange.lowerOpen')\n  @DocsEditable\n  final bool lowerOpen;\n\n  @DomName('IDBKeyRange.upper')\n  @DocsEditable\n  final Object upper;\n\n  @DomName('IDBKeyRange.upperOpen')\n  @DocsEditable\n  final bool upperOpen;\n\n  @JSName('bound')\n  @DomName('IDBKeyRange.bound')\n  @DocsEditable\n  static KeyRange bound_(Object lower, Object upper, [bool lowerOpen, bool upperOpen]) native;\n\n  @JSName('lowerBound')\n  @DomName('IDBKeyRange.lowerBound')\n  @DocsEditable\n  static KeyRange lowerBound_(Object bound, [bool open]) native;\n\n  @JSName('only')\n  @DomName('IDBKeyRange.only')\n  @DocsEditable\n  static KeyRange only_(Object value) native;\n\n  @JSName('upperBound')\n  @DomName('IDBKeyRange.upperBound')\n  @DocsEditable\n  static KeyRange upperBound_(Object bound, [bool open]) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('IDBObjectStore')\nclass ObjectStore native \"IDBObjectStore\" {\n\n  @DomName('IDBObjectStore.add')\n  Future add(value, [key]) {\n    try {\n      var request;\n      if (key != null) {\n        request = $dom_add(value, key);\n      } else {\n        request = $dom_add(value);\n      }\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBObjectStore.clear')\n  Future clear() {\n    try {\n      return _completeRequest($dom_clear());\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBObjectStore.delete')\n  Future delete(key_OR_keyRange){\n    try {\n      return _completeRequest($dom_delete(key_OR_keyRange));\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBObjectStore.count')\n  Future<int> count([key_OR_range]) {\n   try {\n      var request;\n      if (key_OR_range != null) {\n        request = $dom_count(key_OR_range);\n      } else {\n        request = $dom_count();\n      }\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBObjectStore.put')\n  Future put(value, [key]) {\n    try {\n      var request;\n      if (key != null) {\n        request = $dom_put(value, key);\n      } else {\n        request = $dom_put(value);\n      }\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBObjectStore.get')\n  Future getObject(key) {\n    try {\n      var request = $dom_get(key);\n\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  /**\n   * Creates a stream of cursors over the records in this object store.\n   *\n   * **The stream must be manually advanced by calling [Cursor.next] after\n   * each item or by specifying autoAdvance to be true.**\n   *\n   *     var cursors = objectStore.openCursor().listen(\n   *       (cursor) {\n   *         // ...some processing with the cursor\n   *         cursor.next(); // advance onto the next cursor.\n   *       },\n   *       onDone: () {\n   *         // called when there are no more cursors.\n   *         print('all done!');\n   *       });\n   *\n   * Asynchronous operations which are not related to the current transaction\n   * will cause the transaction to automatically be committed-- all processing\n   * must be done synchronously unless they are additional async requests to\n   * the current transaction.\n   */\n  @DomName('IDBObjectStore.openCursor')\n  Stream<CursorWithValue> openCursor({key, KeyRange range, String direction,\n      bool autoAdvance}) {\n    var key_OR_range = null;\n    if (key != null) {\n      if (range != null) {\n        throw new ArgumentError('Cannot specify both key and range.');\n      }\n      key_OR_range = key;\n    } else {\n      key_OR_range = range;\n    }\n\n    // TODO: try/catch this and return a stream with an immediate error.\n    var request;\n    if (direction == null) {\n      request = $dom_openCursor(key_OR_range);\n    } else {\n      request = $dom_openCursor(key_OR_range, direction);\n    }\n    return _cursorStreamFromResult(request, autoAdvance);\n  }\n\n  @DomName('IDBObjectStore.createIndex')\n  Index createIndex(String name, keyPath, {bool unique, bool multiEntry}) {\n    var options = {};\n    if (unique != null) {\n      options['unique'] = unique;\n    }\n    if (multiEntry != null) {\n      options['multiEntry'] = multiEntry;\n    }\n\n    return $dom_createIndex(name, keyPath, options);\n  }\n\n\n  @DomName('IDBObjectStore.autoIncrement')\n  @DocsEditable\n  final bool autoIncrement;\n\n  @DomName('IDBObjectStore.indexNames')\n  @DocsEditable\n  @Returns('DomStringList')\n  @Creates('DomStringList')\n  final List<String> indexNames;\n\n  @DomName('IDBObjectStore.keyPath')\n  @DocsEditable\n  final dynamic keyPath;\n\n  @DomName('IDBObjectStore.name')\n  @DocsEditable\n  final String name;\n\n  @DomName('IDBObjectStore.transaction')\n  @DocsEditable\n  final Transaction transaction;\n\n  @DomName('IDBObjectStore.add')\n  @DocsEditable\n  @Returns('Request')\n  @Creates('Request')\n  @_annotation_Creates_IDBKey\n  Request $dom_add(/*any*/ value, [/*any*/ key]) {\n    if (?key) {\n      var value_1 = convertDartToNative_SerializedScriptValue(value);\n      var key_2 = convertDartToNative_SerializedScriptValue(key);\n      return _$dom_add_1(value_1, key_2);\n    }\n    var value_3 = convertDartToNative_SerializedScriptValue(value);\n    return _$dom_add_2(value_3);\n  }\n  @JSName('add')\n  @DomName('IDBObjectStore.add')\n  @DocsEditable\n  @Returns('Request')\n  @Creates('Request')\n  @_annotation_Creates_IDBKey\n  Request _$dom_add_1(value, key) native;\n  @JSName('add')\n  @DomName('IDBObjectStore.add')\n  @DocsEditable\n  @Returns('Request')\n  @Creates('Request')\n  @_annotation_Creates_IDBKey\n  Request _$dom_add_2(value) native;\n\n  @JSName('clear')\n  @DomName('IDBObjectStore.clear')\n  @DocsEditable\n  Request $dom_clear() native;\n\n  @JSName('count')\n  @DomName('IDBObjectStore.count')\n  @DocsEditable\n  Request $dom_count([key_OR_range]) native;\n\n  @DomName('IDBObjectStore.createIndex')\n  @DocsEditable\n  Index $dom_createIndex(String name, keyPath, [Map options]) {\n    if ((keyPath is List<String> || keyPath == null) && !?options) {\n      List keyPath_1 = convertDartToNative_StringArray(keyPath);\n      return _$dom_createIndex_1(name, keyPath_1);\n    }\n    if ((keyPath is List<String> || keyPath == null)) {\n      List keyPath_2 = convertDartToNative_StringArray(keyPath);\n      var options_3 = convertDartToNative_Dictionary(options);\n      return _$dom_createIndex_2(name, keyPath_2, options_3);\n    }\n    if ((keyPath is String || keyPath == null) && !?options) {\n      return _$dom_createIndex_3(name, keyPath);\n    }\n    if ((keyPath is String || keyPath == null)) {\n      var options_4 = convertDartToNative_Dictionary(options);\n      return _$dom_createIndex_4(name, keyPath, options_4);\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  @JSName('createIndex')\n  @DomName('IDBObjectStore.createIndex')\n  @DocsEditable\n  Index _$dom_createIndex_1(name, List keyPath) native;\n  @JSName('createIndex')\n  @DomName('IDBObjectStore.createIndex')\n  @DocsEditable\n  Index _$dom_createIndex_2(name, List keyPath, options) native;\n  @JSName('createIndex')\n  @DomName('IDBObjectStore.createIndex')\n  @DocsEditable\n  Index _$dom_createIndex_3(name, String keyPath) native;\n  @JSName('createIndex')\n  @DomName('IDBObjectStore.createIndex')\n  @DocsEditable\n  Index _$dom_createIndex_4(name, String keyPath, options) native;\n\n  @JSName('delete')\n  @DomName('IDBObjectStore.delete')\n  @DocsEditable\n  Request $dom_delete(key_OR_keyRange) native;\n\n  @DomName('IDBObjectStore.deleteIndex')\n  @DocsEditable\n  void deleteIndex(String name) native;\n\n  @JSName('get')\n  @DomName('IDBObjectStore.get')\n  @DocsEditable\n  @Returns('Request')\n  @Creates('Request')\n  @annotation_Creates_SerializedScriptValue\n  Request $dom_get(key) native;\n\n  @DomName('IDBObjectStore.index')\n  @DocsEditable\n  Index index(String name) native;\n\n  @JSName('openCursor')\n  @DomName('IDBObjectStore.openCursor')\n  @DocsEditable\n  @Returns('Request')\n  @Creates('Request')\n  @Creates('Cursor')\n  Request $dom_openCursor([key_OR_range, String direction]) native;\n\n  @DomName('IDBObjectStore.put')\n  @DocsEditable\n  @Returns('Request')\n  @Creates('Request')\n  @_annotation_Creates_IDBKey\n  Request $dom_put(/*any*/ value, [/*any*/ key]) {\n    if (?key) {\n      var value_1 = convertDartToNative_SerializedScriptValue(value);\n      var key_2 = convertDartToNative_SerializedScriptValue(key);\n      return _$dom_put_1(value_1, key_2);\n    }\n    var value_3 = convertDartToNative_SerializedScriptValue(value);\n    return _$dom_put_2(value_3);\n  }\n  @JSName('put')\n  @DomName('IDBObjectStore.put')\n  @DocsEditable\n  @Returns('Request')\n  @Creates('Request')\n  @_annotation_Creates_IDBKey\n  Request _$dom_put_1(value, key) native;\n  @JSName('put')\n  @DomName('IDBObjectStore.put')\n  @DocsEditable\n  @Returns('Request')\n  @Creates('Request')\n  @_annotation_Creates_IDBKey\n  Request _$dom_put_2(value) native;\n\n\n  /**\n   * Helper for iterating over cursors in a request.\n   */\n  static Stream<Cursor> _cursorStreamFromResult(Request request,\n      bool autoAdvance) {\n    // TODO: need to guarantee that the controller provides the values\n    // immediately as waiting until the next tick will cause the transaction to\n    // close.\n    var controller = new StreamController();\n\n    request.onError.listen((e) {\n      //TODO: Report stacktrace once issue 4061 is resolved.\n      controller.addError(e);\n    });\n\n    request.onSuccess.listen((e) {\n      Cursor cursor = request.result;\n      if (cursor == null) {\n        controller.close();\n      } else {\n        controller.add(cursor);\n        if (autoAdvance == true && controller.hasListener) {\n          cursor.next();\n        }\n      }\n    });\n    return controller.stream;\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('IDBOpenDBRequest')\nclass OpenDBRequest extends Request implements EventTarget native \"IDBOpenDBRequest\" {\n\n  @DomName('IDBOpenDBRequest.blockedEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> blockedEvent = const EventStreamProvider<Event>('blocked');\n\n  @DomName('IDBOpenDBRequest.upgradeneededEvent')\n  @DocsEditable\n  static const EventStreamProvider<VersionChangeEvent> upgradeNeededEvent = const EventStreamProvider<VersionChangeEvent>('upgradeneeded');\n\n  @DomName('IDBOpenDBRequest.onblocked')\n  @DocsEditable\n  Stream<Event> get onBlocked => blockedEvent.forTarget(this);\n\n  @DomName('IDBOpenDBRequest.onupgradeneeded')\n  @DocsEditable\n  Stream<VersionChangeEvent> get onUpgradeNeeded => upgradeNeededEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('IDBRequest')\nclass Request extends EventTarget native \"IDBRequest\" {\n\n  @DomName('IDBRequest.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('IDBRequest.successEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> successEvent = const EventStreamProvider<Event>('success');\n\n  @DomName('IDBRequest.error')\n  @DocsEditable\n  final DomError error;\n\n  @DomName('IDBRequest.readyState')\n  @DocsEditable\n  final String readyState;\n\n  dynamic get result => _convertNativeToDart_IDBAny(this._get_result);\n  @JSName('result')\n  @DomName('IDBRequest.result')\n  @DocsEditable\n  @Creates('Null')\n  final dynamic _get_result;\n\n  @DomName('IDBRequest.source')\n  @DocsEditable\n  @Creates('Null')\n  final dynamic source;\n\n  @DomName('IDBRequest.transaction')\n  @DocsEditable\n  final Transaction transaction;\n\n  @JSName('webkitErrorMessage')\n  @DomName('IDBRequest.webkitErrorMessage')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final String errorMessage;\n\n  @JSName('addEventListener')\n  @DomName('IDBRequest.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('IDBRequest.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @JSName('removeEventListener')\n  @DomName('IDBRequest.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('IDBRequest.onerror')\n  @DocsEditable\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  @DomName('IDBRequest.onsuccess')\n  @DocsEditable\n  Stream<Event> get onSuccess => successEvent.forTarget(this);\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('IDBTransaction')\nclass Transaction extends EventTarget native \"IDBTransaction\" {\n\n  /**\n   * Provides a Future which will be completed once the transaction has\n   * completed.\n   *\n   * The future will error if an error occurrs on the transaction or if the\n   * transaction is aborted.\n   */\n  Future<Database> get completed {\n    var completer = new Completer<Database>();\n\n    this.onComplete.first.then((_) {\n      completer.complete(db);\n    });\n\n    this.onError.first.then((e) {\n      completer.completeError(e);\n    });\n\n    this.onAbort.first.then((e) {\n      completer.completeError(e);\n    });\n\n    return completer.future;\n  }\n\n\n  @DomName('IDBTransaction.abortEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> abortEvent = const EventStreamProvider<Event>('abort');\n\n  @DomName('IDBTransaction.completeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> completeEvent = const EventStreamProvider<Event>('complete');\n\n  @DomName('IDBTransaction.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('IDBTransaction.db')\n  @DocsEditable\n  final Database db;\n\n  @DomName('IDBTransaction.error')\n  @DocsEditable\n  final DomError error;\n\n  @DomName('IDBTransaction.mode')\n  @DocsEditable\n  final String mode;\n\n  @JSName('webkitErrorMessage')\n  @DomName('IDBTransaction.webkitErrorMessage')\n  @DocsEditable\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental\n  final String errorMessage;\n\n  @DomName('IDBTransaction.abort')\n  @DocsEditable\n  void abort() native;\n\n  @JSName('addEventListener')\n  @DomName('IDBTransaction.addEventListener')\n  @DocsEditable\n  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('IDBTransaction.dispatchEvent')\n  @DocsEditable\n  bool dispatchEvent(Event evt) native;\n\n  @DomName('IDBTransaction.objectStore')\n  @DocsEditable\n  ObjectStore objectStore(String name) native;\n\n  @JSName('removeEventListener')\n  @DomName('IDBTransaction.removeEventListener')\n  @DocsEditable\n  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('IDBTransaction.onabort')\n  @DocsEditable\n  Stream<Event> get onAbort => abortEvent.forTarget(this);\n\n  @DomName('IDBTransaction.oncomplete')\n  @DocsEditable\n  Stream<Event> get onComplete => completeEvent.forTarget(this);\n\n  @DomName('IDBTransaction.onerror')\n  @DocsEditable\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('IDBVersionChangeEvent')\nclass VersionChangeEvent extends Event native \"IDBVersionChangeEvent\" {\n\n  @DomName('IDBVersionChangeEvent.newVersion')\n  @DocsEditable\n  final dynamic newVersion;\n\n  @DomName('IDBVersionChangeEvent.oldVersion')\n  @DocsEditable\n  final dynamic oldVersion;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('IDBAny')\nabstract class _IDBAny native \"IDBAny\" {\n}\n","sdk/lib/io/base64.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass _Base64 {\n  static const List<String> _encodingTable = const [\n      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n      'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd',\n      'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',\n      't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7',\n      '8', '9', '+', '/'];\n\n  /**\n   * Base64 transfer encoding for MIME (RFC 2045)\n   */\n  static String _encode(List<int> data) {\n    List<String> characters = new List<String>();\n    int i;\n    for (i = 0; i + 3 <= data.length; i += 3) {\n      int value = 0;\n      value |= data[i + 2];\n      value |= data[i + 1] << 8;\n      value |= data[i] << 16;\n      for (int j = 0; j < 4; j++) {\n        int index = (value >> ((3 - j) * 6)) & ((1 << 6) - 1);\n        characters.add(_encodingTable[index]);\n      }\n    }\n    // Remainders.\n    if (i + 2 == data.length) {\n      int value = 0;\n      value |= data[i + 1] << 8;\n      value |= data[i] << 16;\n      for (int j = 0; j < 3; j++) {\n        int index = (value >> ((3 - j) * 6)) & ((1 << 6) - 1);\n        characters.add(_encodingTable[index]);\n      }\n      characters.add(\"=\");\n    } else if (i + 1 == data.length) {\n      int value = 0;\n      value |= data[i] << 16;\n      for (int j = 0; j < 2; j++) {\n        int index = (value >> ((3 - j) * 6)) & ((1 << 6) - 1);\n        characters.add(_encodingTable[index]);\n      }\n      characters.add(\"=\");\n      characters.add(\"=\");\n    }\n    StringBuffer output = new StringBuffer();\n    for (i = 0; i < characters.length; i++) {\n      if (i > 0 && i % 76 == 0) {\n        output.write(\"\\r\\n\");\n      }\n      output.write(characters[i]);\n    }\n    return output.toString();\n  }\n\n\n  /**\n   * Base64 transfer decoding for MIME (RFC 2045).\n   */\n  static List<int> _decode(String data) {\n    List<int> result = new List<int>();\n    int padCount = 0;\n    int charCount = 0;\n    int value = 0;\n    for (int i = 0; i < data.length; i++) {\n      int char = data.codeUnitAt(i);\n      if (65 <= char && char <= 90) {  // \"A\" - \"Z\".\n        value = (value << 6) | char - 65;\n        charCount++;\n      } else if (97 <= char && char <= 122) { // \"a\" - \"z\".\n        value = (value << 6) | char - 97 + 26;\n        charCount++;\n      } else if (48 <= char && char <= 57) {  // \"0\" - \"9\".\n        value = (value << 6) | char - 48 + 52;\n        charCount++;\n      } else if (char == 43) {  // \"+\".\n        value = (value << 6) | 62;\n        charCount++;\n      } else if (char == 47) {  // \"/\".\n        value = (value << 6) | 63;\n        charCount++;\n      } else if (char == 61) {  // \"=\".\n        value = (value << 6);\n        charCount++;\n        padCount++;\n      }\n      if (charCount == 4) {\n        result.add((value & 0xFF0000) >> 16);\n        if (padCount < 2) {\n          result.add((value & 0xFF00) >> 8);\n        }\n        if (padCount == 0) {\n          result.add(value & 0xFF);\n        }\n        charCount = 0;\n        value = 0;\n      }\n    }\n    return result;\n  }\n}\n","sdk/lib/io/buffer_list.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * Utility class that can fast concatenate [List<int>]s of bytes. Use\n * [readBytes] to get the final buffer.\n */\nclass _BufferList {\n  const int _INIT_SIZE = 1 * 1024;\n\n  _BufferList() {\n    clear();\n  }\n\n  int pow2roundup(int x) {\n    --x;\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    return x + 1;\n  }\n\n  /**\n   * Adds a new buffer to the list.\n   */\n  void add(List<int> buffer) {\n    int bufferLength = buffer.length;\n    int required = _length + bufferLength;\n    if (_buffer == null) {\n      int size = pow2roundup(required);\n      if (size < _INIT_SIZE) size = _INIT_SIZE;\n      _buffer = new Uint8List(size);\n    } else if (_buffer.length < required) {\n      // This will give is a list in the range of 2-4 times larger than\n      // required.\n      int size = pow2roundup(required) * 2;\n      Uint8List newBuffer = new Uint8List(size);\n      newBuffer.setRange(0, _buffer.length, _buffer);\n      _buffer = newBuffer;\n    }\n    assert(_buffer.length >= required);\n    if (buffer is Uint8List) {\n      _buffer.setRange(_length, required, buffer);\n    } else {\n      for (int i = 0; i < bufferLength; i++) {\n        _buffer[_length + i] = buffer[i];\n      }\n    }\n    _length = required;\n  }\n\n  /**\n   * Same as [add].\n   */\n  void write(List<int> buffer) {\n    add(buffer);\n  }\n\n  /**\n   * Read all the bytes from the buffer list. If it's empty, an empty list\n   * is returned. A call to [readBytes] will clear the buffer.\n   */\n  List<int> readBytes() {\n    if (_buffer == null) return new Uint8List(0);\n    var buffer = new Uint8List.view(_buffer.buffer, 0, _length);\n    clear();\n    return buffer;\n  }\n\n  /**\n   * Returns the total number of bytes in the buffer.\n   */\n  int get length => _length;\n\n  /**\n   * Returns whether the buffer list is empty.\n   */\n  bool get isEmpty => _length == 0;\n\n  /**\n   * Clears the content of the buffer list.\n   */\n  void clear() {\n    _length = 0;\n    _buffer = null;\n  }\n\n  int _length;  // Total number of bytes in the buffer.\n  Uint8List _buffer;  // Internal buffer.\n}\n","sdk/lib/io/common.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n// Constants used when working with native ports.\nconst int _SUCCESS_RESPONSE = 0;\nconst int _ILLEGAL_ARGUMENT_RESPONSE = 1;\nconst int _OSERROR_RESPONSE = 2;\nconst int _FILE_CLOSED_RESPONSE = 3;\n\nconst int _ERROR_RESPONSE_ERROR_TYPE = 0;\nconst int _OSERROR_RESPONSE_ERROR_CODE = 1;\nconst int _OSERROR_RESPONSE_MESSAGE = 2;\n\n/**\n  * An [OSError] object holds information about an error from the\n  * operating system.\n  */\nclass OSError implements Error {\n  /** Constant used to indicate that no OS error code is available. */\n  static const int noErrorCode = -1;\n\n  /** Creates an OSError object from a message and an errorCode. */\n  const OSError([String this.message = \"\", int this.errorCode = noErrorCode]);\n\n  /** Converts an OSError object to a string representation. */\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    sb.write(\"OS Error\");\n    if (!message.isEmpty) {\n      sb.write(\": \");\n      sb.write(message);\n      if (errorCode != noErrorCode) {\n        sb.write(\", errno = \");\n        sb.write(errorCode.toString());\n      }\n    } else if (errorCode != noErrorCode) {\n      sb.write(\": errno = \");\n      sb.write(errorCode.toString());\n    }\n    return sb.toString();\n  }\n\n  /**\n    * Error message supplied by the operating system. null if no message is\n    * associated with the error.\n    */\n  final String message;\n\n  /**\n    * Error code supplied by the operating system. Will have the value\n    * [noErrorCode] if there is no error code associated with the error.\n    */\n  final int errorCode;\n}\n\n\n// Object for holding a buffer and an offset.\nclass _BufferAndStart {\n  _BufferAndStart(List this.buffer, int this.start);\n  List buffer;\n  int start;\n}\n\n// Ensure that the input List can be serialized through a native port.\n// Only builtin Lists can be serialized through. If user-defined Lists\n// get here, the contents is copied to a Uint8List. This has the added\n// benefit that it is faster to access from the C code as well.\n_BufferAndStart _ensureFastAndSerializableBuffer(\n    List buffer, int start, int end) {\n  if (buffer is Uint8List ||\n      buffer is Int8List ||\n      buffer is Uint16List ||\n      buffer is Int16List ||\n      buffer is Uint32List ||\n      buffer is Int32List ||\n      buffer is Uint64List ||\n      buffer is Int64List ||\n      buffer is ByteData ||\n      buffer is Float32List ||\n      buffer is Float64List ||\n      _BufferUtils._isBuiltinList(buffer)) {\n    return new _BufferAndStart(buffer, start);\n  }\n  int length = end - start;\n  var newBuffer = new Uint8List(length);\n  int j = start;\n  for (int i = 0; i < length; i++) {\n    int value = buffer[j];\n    if (value is! int) {\n      throw new ArgumentError(\"List element is not an integer at index $j\");\n    }\n    newBuffer[i] = value;\n    j++;\n  }\n  return new _BufferAndStart(newBuffer, 0);\n}\n\n\n// TODO(ager): The only reason for the class here is that\n// we cannot patch a top-level function.\nclass _BufferUtils {\n  // Check if a List is a builtin VM List type. Returns true\n  // if the List is a builtin VM List type and false if it is\n  // a user defined List type.\n  external static bool _isBuiltinList(List buffer);\n}\n\nclass _IOCrypto {\n  external static Uint8List getRandomBytes(int count);\n}\n","sdk/lib/io/data_transformer.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * Private helper-class to handle native filters.\n */\nabstract class _Filter {\n  /**\n   * Call to process a chunk of data. A call to [process] should only be made\n   * when [processed] returns [null].\n   */\n  void process(List<int> data);\n\n  /**\n   * Get a chunk of processed data. When there are no more data available,\n   * [processed] will return [null]. Set [flush] to [false] for non-final\n   * calls to improve performance of some filters.\n   */\n  List<int> processed({bool flush: true});\n\n  /**\n   * Mark the filter as closed. Always call this method for any filter created\n   * to avoid leaking resources. [end] can be called at any time, but any\n   * successive calls to [process] or [processed] will fail.\n   */\n  void end();\n\n  external static _Filter newZLibDeflateFilter(bool gzip, int level);\n  external static _Filter newZLibInflateFilter();\n}\n\n\nclass _FilterTransformer extends StreamEventTransformer<List<int>, List<int>> {\n  final _Filter _filter;\n  bool _closed = false;\n  bool _empty = true;\n\n  _FilterTransformer(_Filter this._filter);\n\n  void handleData(List<int> data, EventSink<List<int>> sink) {\n    if (_closed) return;\n    try {\n      _empty = false;\n      _filter.process(data);\n      var out;\n      while ((out = _filter.processed(flush: false)) != null) {\n        sink.add(out);\n      }\n    } catch (e, s) {\n      _closed = true;\n      // TODO(floitsch): we are losing the stack trace.\n      sink.addError(e);\n      sink.close();\n    }\n  }\n\n  void handleDone(EventSink<List<int>> sink) {\n    if (_closed) return;\n    if (_empty) _filter.process(const []);\n    try {\n      var out;\n      while ((out = _filter.processed()) != null) {\n        sink.add(out);\n      }\n    } catch (e, s) {\n      // TODO(floitsch): we are losing the stack trace.\n      sink.addError(e);\n      _closed = true;\n    }\n    if (!_closed) _filter.end();\n    _closed = true;\n    sink.close();\n  }\n}\n\n\n/**\n * ZLibDeflater class used to deflate a stream of bytes, using zlib.\n */\nclass ZLibDeflater extends _FilterTransformer {\n  ZLibDeflater({bool gzip: true, int level: 6})\n      : super(_Filter.newZLibDeflateFilter(gzip, level));\n}\n\n\n/**\n * ZLibInflater class used to inflate a stream of bytes, using zlib.\n */\nclass ZLibInflater extends _FilterTransformer {\n  ZLibInflater() : super(_Filter.newZLibInflateFilter());\n}\n\n","sdk/lib/io/directory.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * [Directory] objects are used for working with directories.\n */\nabstract class Directory extends FileSystemEntity {\n  /**\n   * Creates a directory object. The path is either an absolute path,\n   * or it is a relative path which is interpreted relative to the directory\n   * in which the Dart VM was started.\n   */\n  factory Directory(String path) => new _Directory(path);\n\n  /**\n   * Creates a directory object from a Path object. The path is either\n   * an absolute path, or it is a relative path which is interpreted\n   * relative to the directory in which the Dart VM was started.\n   */\n  factory Directory.fromPath(Path path) => new _Directory.fromPath(path);\n\n  /**\n   * Creates a directory object pointing to the current working\n   * directory.\n   */\n  factory Directory.current() => new _Directory.current();\n\n  /**\n   * Check whether a directory with this name already exists. Returns\n   * a [:Future<bool>:] that completes with the result.\n   */\n  Future<bool> exists();\n\n  /**\n   * Synchronously check whether a directory with this name already exists.\n   */\n  bool existsSync();\n\n  /**\n   * Creates the directory with this name.\n   *\n   * If [recursive] is false, only the last directory in the path is\n   * created. If [recursive] is true, all non-existing path components\n   * are created. If the directory already exists nothing is done.\n   *\n   * Returns a [:Future<Directory>:] that completes with this\n   * directory once it has been created. If the directory cannot be\n   * created the future completes with an exception.\n   */\n  Future<Directory> create({recursive: false});\n\n  /**\n   * Synchronously creates the directory with this name.\n   *\n   * If [recursive] is false, only the last directory in the path is\n   * created. If [recursive] is true, all non-existing path components\n   * are created. If the directory already exists nothing is done.\n   *\n   * If the directory cannot be created an exception is thrown.\n   */\n  void createSync({recursive: false});\n\n  /**\n   * Creates a temporary directory with a name based on the current\n   * path.  The path is used as a template, and additional\n   * characters are appended to it to make a unique temporary\n   * directory name.  If the path is the empty string, a default\n   * system temp directory and name are used for the template.\n   *\n   * Returns a [:Future<Directory>:] that completes with the newly\n   * created temporary directory.\n   */\n  Future<Directory> createTemp();\n\n  /**\n   * Synchronously creates a temporary directory with a name based on the\n   * current path. The path is used as a template, and additional\n   * characters are appended to it to make a unique temporary directory name.\n   * If the path is the empty string, a default system temp directory and name\n   * are used for the template. Returns the newly created temporary directory.\n   */\n  Directory createTempSync();\n\n  /**\n   * Deletes this directory.\n   *\n   * If [recursive] is false, the directory must be empty.  Only directories\n   * and links to directories will be deleted.\n   *\n   * If [recursive] is true, this directory and all sub-directories\n   * and files in the directories are deleted. Links are not followed\n   * when deleting recursively. Only the link is deleted, not its target.\n   *\n   * If [recursive] is true, the target is deleted even if it is a file, or\n   * a link to a file, not only if it is a directory.  This behavior allows\n   * [delete] to be used to unconditionally delete any file system object.\n   *\n   * Returns a [:Future<Directory>:] that completes with this\n   * directory when the deletion is done. If the directory cannot be\n   * deleted, the future completes with an exception.\n   */\n  Future<Directory> delete({recursive: false});\n\n  /**\n   * Synchronously deletes this directory.\n   *\n   * If [recursive] is false, the directory must be empty.\n   *\n   * If [recursive] is true, this directory and all sub-directories\n   * and files in the directories are deleted. Links are not followed\n   * when deleting recursively. Only the link is deleted, not its target.\n   *\n   * If [recursive] is true, the target is deleted even if it is a file, or\n   * a link to a file, not only if it is a directory.  This behavior allows\n   * [delete] to be used to unconditionally delete any file system object.\n   *\n   * Throws an exception if the directory cannot be deleted.\n   */\n  void deleteSync({recursive: false});\n\n  /**\n   * Renames this directory. Returns a [:Future<Directory>:] that completes\n   * with a [Directory] instance for the renamed directory.\n   *\n   * If newPath identifies an existing directory, that directory is\n   * replaced. If newPath identifies an existing file, the operation\n   * fails and the future completes with an exception.\n   */\n  Future<Directory> rename(String newPath);\n\n  /**\n   * Synchronously renames this directory. Returns a [Directory]\n   * instance for the renamed directory.\n   *\n   * If newPath identifies an existing directory, that directory is\n   * replaced. If newPath identifies an existing file the operation\n   * fails and an exception is thrown.\n   */\n  Directory renameSync(String newPath);\n\n  /**\n   * Lists the sub-directories and files of this [Directory].\n   * Optionally recurses into sub-directories.\n   *\n   * If [followLinks] is false, then any symbolic links found\n   * are reported as [Link] objects, rather than as directories or files,\n   * and are not recursed into.\n   *\n   * If [followLinks] is true, then working links are reported as\n   * directories or files, depending on\n   * their type, and links to directories are recursed into.\n   * Broken links are reported as [Link] objects.\n   * If a symbolic link makes a loop in the file system, then a recursive\n   * listing will not follow a link twice in the\n   * same recursive descent, but will report it as a [Link]\n   * the second time it is seen.\n   *\n   * The result is a stream of [FileSystemEntity] objects\n   * for the directories, files, and links.\n   */\n  Stream<FileSystemEntity> list({bool recursive: false,\n                                 bool followLinks: true});\n\n  /**\n   * Lists the sub-directories and files of this [Directory].\n   * Optionally recurses into sub-directories.\n   *\n   * If [followLinks] is false, then any symbolic links found\n   * are reported as [Link] objects, rather than as directories or files,\n   * and are not recursed into.\n   *\n   * If [followLinks] is true, then working links are reported as\n   * directories or files, depending on\n   * their type, and links to directories are recursed into.\n   * Broken links are reported as [Link] objects.\n   * If a link makes a loop in the file system, then a recursive\n   * listing will not follow a link twice in the\n   * same recursive descent, but will report it as a [Link]\n   * the second time it is seen.\n   *\n   * Returns a [List] containing [FileSystemEntity] objects for the\n   * directories, files, and links.\n   */\n  List<FileSystemEntity> listSync({bool recursive: false,\n                                   bool followLinks: true});\n\n  /**\n   * Returns a human readable string for this Directory instance.\n   */\n  String toString();\n\n  /**\n   * Gets the path of this directory.\n   */\n  final String path;\n}\n\n\nclass DirectoryIOException implements Exception {\n  const DirectoryIOException([String this.message = \"\",\n                              String this.path = \"\",\n                              OSError this.osError = null]);\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    sb.write(\"DirectoryIOException\");\n    if (!message.isEmpty) {\n      sb.write(\": $message\");\n      if (path != null) {\n        sb.write(\", path = $path\");\n      }\n      if (osError != null) {\n        sb.write(\" ($osError)\");\n      }\n    } else if (osError != null) {\n      sb.write(\": $osError\");\n      if (path != null) {\n        sb.write(\", path = $path\");\n      }\n    }\n    return sb.toString();\n  }\n  final String message;\n  final String path;\n  final OSError osError;\n}\n","sdk/lib/io/directory_impl.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass _Directory implements Directory {\n  static const CREATE_REQUEST = 0;\n  static const DELETE_REQUEST = 1;\n  static const EXISTS_REQUEST = 2;\n  static const CREATE_TEMP_REQUEST = 3;\n  static const LIST_REQUEST = 4;\n  static const RENAME_REQUEST = 5;\n\n  static const SUCCESS_RESPONSE = 0;\n  static const ILLEGAL_ARGUMENT_RESPONSE = 1;\n  static const OSERROR_RESPONSE = 2;\n\n  _Directory(String this._path);\n  _Directory.fromPath(Path path) : this(path.toNativePath());\n  _Directory.current() : this(_current());\n\n  external static String _current();\n  external static _createTemp(String template);\n  external static int _exists(String path);\n  external static _create(String path);\n  external static _delete(String path, bool recursive);\n  external static _rename(String path, String newPath);\n  external static List _list(String path, bool recursive, bool followLinks);\n  external static SendPort _newServicePort();\n\n  Future<bool> exists() {\n    _ensureDirectoryService();\n    List request = new List(2);\n    request[0] = EXISTS_REQUEST;\n    request[1] = _path;\n    return _directoryService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionOrErrorFromResponse(response, \"Exists failed\");\n      }\n      return response == 1;\n    });\n  }\n\n  bool existsSync() {\n    if (_path is !String) {\n      throw new ArgumentError();\n    }\n    var result = _exists(_path);\n    if (result is OSError) {\n      throw new DirectoryIOException(\"Exists failed\", _path, result);\n    }\n    return (result == 1);\n  }\n\n  // Compute the index of the first directory in the list that exists. If\n  // none of the directories exist dirsToCreate.length is returned.\n  Future<int> _computeExistingIndex(List dirsToCreate) {\n    var future;\n    var notFound = dirsToCreate.length;\n    for (var i = 0; i < dirsToCreate.length; i++) {\n      if (future == null) {\n        future = dirsToCreate[i].exists().then((e) => e ? i : notFound);\n      } else {\n        future = future.then((index) {\n          if (index != notFound) {\n            return new Future.value(index);\n          }\n          return dirsToCreate[i].exists().then((e) => e ? i : notFound);\n        });\n      }\n    }\n    if (future == null) {\n      return new Future.value(notFound);\n    } else {\n      return future;\n    }\n  }\n\n  Future<Directory> createRecursively() {\n    if (_path is !String) {\n      throw new ArgumentError();\n    }\n    var path = new Path(_path);\n    var dirsToCreate = [];\n    var terminator = path.isAbsolute ? '/' : '';\n    while (path.toString() != terminator) {\n      dirsToCreate.add(new Directory.fromPath(path));\n      path = path.directoryPath;\n    }\n    return _computeExistingIndex(dirsToCreate).then((index) {\n      var future;\n      for (var i = index - 1; i >= 0 ; i--) {\n        if (future == null) {\n          future = dirsToCreate[i].create();\n        } else {\n          future = future.then((_) {\n            return dirsToCreate[i].create();\n          });\n        }\n      }\n      if (future == null) {\n        return new Future.value(this);\n      } else {\n        return future.then((_) => this);\n      }\n    });\n  }\n\n  Future<Directory> create({recursive: false}) {\n    if (recursive) return createRecursively();\n    _ensureDirectoryService();\n    List request = new List(2);\n    request[0] = CREATE_REQUEST;\n    request[1] = _path;\n    return _directoryService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionOrErrorFromResponse(response, \"Creation failed\");\n      }\n      return this;\n    });\n  }\n\n  void createRecursivelySync() {\n    var path = new Path(_path);\n    var dirsToCreate = [];\n    var terminator = path.isAbsolute ? '/' : '';\n    while (path.toString() != terminator) {\n      var dir = new Directory.fromPath(path);\n      if (dir.existsSync()) break;\n      dirsToCreate.add(dir);\n      path = path.directoryPath;\n    }\n    for (var i = dirsToCreate.length - 1; i >= 0; i--) {\n      dirsToCreate[i].createSync();\n    }\n  }\n\n  void createSync({recursive: false}) {\n    if (_path is !String) {\n      throw new ArgumentError();\n    }\n    if (recursive) return createRecursivelySync();\n    var result = _create(_path);\n    if (result is OSError) {\n      throw new DirectoryIOException(\"Creation failed\", _path, result);\n    }\n  }\n\n  Future<Directory> createTemp() {\n    _ensureDirectoryService();\n    List request = new List(2);\n    request[0] = CREATE_TEMP_REQUEST;\n    request[1] = _path;\n    return _directoryService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionOrErrorFromResponse(response,\n                                      \"Creation of temporary directory failed\");\n      }\n      return new Directory(response);\n    });\n  }\n\n  Directory createTempSync() {\n    if (_path is !String) {\n      throw new ArgumentError();\n    }\n    var result = _createTemp(path);\n    if (result is OSError) {\n      throw new DirectoryIOException(\"Creation of temporary directory failed\",\n                                     _path,\n                                     result);\n    }\n    return new Directory(result);\n  }\n\n  Future<Directory> _deleteHelper(bool recursive, String errorMsg) {\n  }\n\n  Future<Directory> delete({recursive: false}) {\n    _ensureDirectoryService();\n    List request = new List(3);\n    request[0] = DELETE_REQUEST;\n    request[1] = _path;\n    request[2] = recursive;\n    return _directoryService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionOrErrorFromResponse(response, \"Deletion failed\");\n      }\n      return this;\n    });\n  }\n\n  void deleteSync({recursive: false}) {\n    if (_path is !String) {\n      throw new ArgumentError();\n    }\n    var result = _delete(_path, recursive);\n    if (result is OSError) {\n      throw new DirectoryIOException(\"Deletion failed\", _path, result);\n    }\n  }\n\n  Future<Directory> rename(String newPath) {\n    _ensureDirectoryService();\n    List request = new List(3);\n    request[0] = RENAME_REQUEST;\n    request[1] = _path;\n    request[2] = newPath;\n    return _directoryService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionOrErrorFromResponse(response, \"Rename failed\");\n      }\n      return new Directory(newPath);\n    });\n  }\n\n  Directory renameSync(String newPath) {\n    if (_path is !String || newPath is !String) {\n      throw new ArgumentError();\n    }\n    var result = _rename(_path, newPath);\n    if (result is OSError) {\n      throw new DirectoryIOException(\"Rename failed\", _path, result);\n    }\n    return new Directory(newPath);\n  }\n\n  Stream<FileSystemEntity> list({bool recursive: false,\n                                 bool followLinks: true}) {\n    const int LIST_FILE = 0;\n    const int LIST_DIRECTORY = 1;\n    const int LIST_LINK = 2;\n    const int LIST_ERROR = 3;\n    const int LIST_DONE = 4;\n\n    const int RESPONSE_TYPE = 0;\n    const int RESPONSE_PATH = 1;\n    const int RESPONSE_COMPLETE = 1;\n    const int RESPONSE_ERROR = 2;\n\n    var controller = new StreamController<FileSystemEntity>();\n\n    List request = [ _Directory.LIST_REQUEST, path, recursive, followLinks ];\n    ReceivePort responsePort = new ReceivePort();\n    // Use a separate directory service port for each listing as\n    // listing operations on the same directory can run in parallel.\n    _Directory._newServicePort().send(request, responsePort.toSendPort());\n    responsePort.receive((message, replyTo) {\n      if (message is !List || message[RESPONSE_TYPE] is !int) {\n        responsePort.close();\n        controller.addError(new DirectoryIOException(\"Internal error\"));\n        return;\n      }\n      switch (message[RESPONSE_TYPE]) {\n        case LIST_FILE:\n          controller.add(new File(message[RESPONSE_PATH]));\n          break;\n        case LIST_DIRECTORY:\n          controller.add(new Directory(message[RESPONSE_PATH]));\n          break;\n        case LIST_LINK:\n          controller.add(new Link(message[RESPONSE_PATH]));\n          break;\n        case LIST_ERROR:\n          var errorType =\n              message[RESPONSE_ERROR][_ERROR_RESPONSE_ERROR_TYPE];\n          if (errorType == _ILLEGAL_ARGUMENT_RESPONSE) {\n            controller.addError(new ArgumentError());\n          } else if (errorType == _OSERROR_RESPONSE) {\n            var responseError = message[RESPONSE_ERROR];\n            var err = new OSError(\n                responseError[_OSERROR_RESPONSE_MESSAGE],\n                responseError[_OSERROR_RESPONSE_ERROR_CODE]);\n            var errorPath = message[RESPONSE_PATH];\n            if (errorPath == null) errorPath = path;\n            controller.addError(\n                new DirectoryIOException(\"Directory listing failed\",\n                                         errorPath,\n                                         err));\n          } else {\n            controller.addError(new DirectoryIOException(\"Internal error\"));\n          }\n          break;\n        case LIST_DONE:\n          responsePort.close();\n          controller.close();\n          break;\n      }\n    });\n\n    return controller.stream;\n  }\n\n  List listSync({bool recursive: false, bool followLinks: true}) {\n    if (_path is! String || recursive is! bool) {\n      throw new ArgumentError();\n    }\n    return _list(_path, recursive, followLinks);\n  }\n\n  String get path => _path;\n\n  String toString() => \"Directory: '$path'\";\n\n  bool _isErrorResponse(response) {\n    return response is List && response[0] != _SUCCESS_RESPONSE;\n  }\n\n  _exceptionOrErrorFromResponse(response, String message) {\n    assert(_isErrorResponse(response));\n    switch (response[_ERROR_RESPONSE_ERROR_TYPE]) {\n      case _ILLEGAL_ARGUMENT_RESPONSE:\n        return new ArgumentError();\n      case _OSERROR_RESPONSE:\n        var err = new OSError(response[_OSERROR_RESPONSE_MESSAGE],\n                              response[_OSERROR_RESPONSE_ERROR_CODE]);\n        return new DirectoryIOException(message, _path, err);\n      default:\n        return new Exception(\"Unknown error\");\n    }\n  }\n\n  void _ensureDirectoryService() {\n    if (_directoryService == null) {\n      _directoryService = _newServicePort();\n    }\n  }\n\n  final String _path;\n  SendPort _directoryService;\n}\n","sdk/lib/io/eventhandler.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass _EventHandler {\n  external static void _start();\n  external static _sendData(Object sender, ReceivePort receivePort, int data);\n}\n","sdk/lib/io/file.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * FileMode describes the modes in which a file can be opened.\n */\nclass FileMode {\n  static const READ = const FileMode._internal(0);\n  static const WRITE = const FileMode._internal(1);\n  static const APPEND = const FileMode._internal(2);\n  const FileMode._internal(int this._mode);\n  final int _mode;\n}\n\nconst READ = FileMode.READ;\nconst WRITE = FileMode.WRITE;\nconst APPEND = FileMode.APPEND;\n\n/**\n * [File] objects are references to files.\n *\n * If [path] is a symbolic link, rather than a file, then\n * the methods of [File] operate on the ultimate target of the\n * link, except for File.delete and File.deleteSync, which operate on\n * the link.\n *\n * To operate on the underlying file data there are two options:\n *\n *  * Use streaming: read the contents of the file from the [Stream]\n *    this.[openRead]() and write to the file by writing to the [IOSink]\n *    this.[openWrite]().\n *  * Open the file for random access operations using [open].\n */\nabstract class File extends FileSystemEntity {\n  /**\n   * Create a File object.\n   */\n  factory File(String path) => new _File(path);\n\n  /**\n   * Create a File object from a Path object.\n   */\n  factory File.fromPath(Path path) => new _File.fromPath(path);\n\n  /**\n   * Check if the file exists. Returns a\n   * [:Future<bool>:] that completes when the answer is known.\n   */\n  Future<bool> exists();\n\n  /**\n   * Synchronously check if the file exists.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  bool existsSync();\n\n  /**\n   * Create the file. Returns a [:Future<File>:] that completes with\n   * the file when it has been created.\n   *\n   * Existing files are left untouched by [create]. Calling [create] on an\n   * existing file might fail if there are restrictive permissions on\n   * the file.\n   */\n  Future<File> create();\n\n  /**\n   * Synchronously create the file. Existing files are left untouched\n   * by [createSync]. Calling [createSync] on an existing file might fail\n   * if there are restrictive permissions on the file.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  void createSync();\n\n  /**\n   * Delete the file. Returns a [:Future<File>:] that completes with\n   * the file when it has been deleted. Only a file or a link to a file\n   * can be deleted with this method, not a directory or a broken link.\n   */\n  Future<File> delete();\n\n  /**\n   * Synchronously delete the file. Only a file or a link to a file\n   * can be deleted with this method, not a directory or a broken link.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  void deleteSync();\n\n  /**\n   * Get a [Directory] object for the directory containing this\n   * file. Returns a [:Future<Directory>:] that completes with the\n   * directory.\n   */\n  Future<Directory> directory();\n\n  /**\n   * Synchronously get a [Directory] object for the directory containing\n   * this file.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  Directory directorySync();\n\n  /**\n   * Get the length of the file. Returns a [:Future<int>:] that\n   * completes with the length in bytes.\n   */\n  Future<int> length();\n\n  /**\n   * Synchronously get the length of the file.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  int lengthSync();\n\n  /**\n   * Get the last-modified time of the file. Returns a\n   * [:Future<DateTime>:] that completes with a [DateTime] object for the\n   * modification date.\n   */\n  Future<DateTime> lastModified();\n\n  /**\n   * Get the last-modified time of the file. Throws an exception\n   * if the file does not exist.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  DateTime lastModifiedSync();\n\n  /**\n   * Open the file for random access operations. Returns a\n   * [:Future<RandomAccessFile>:] that completes with the opened\n   * random access file. [RandomAccessFile]s must be closed using the\n   * [RandomAccessFile.close] method.\n   *\n   * Files can be opened in three modes:\n   *\n   * [FileMode.READ]: open the file for reading.\n   *\n   * [FileMode.WRITE]: open the file for both reading and writing and\n   * truncate the file to length zero. If the file does not exist the\n   * file is created.\n   *\n   * [FileMode.APPEND]: same as [FileMode.WRITE] except that the file is\n   * not truncated.\n   */\n  Future<RandomAccessFile> open({FileMode mode: FileMode.READ});\n\n  /**\n   * Synchronously open the file for random access operations. The\n   * result is a [RandomAccessFile] on which random access operations\n   * can be performed. Opened [RandomAccessFile]s must be closed using\n   * the [RandomAccessFile.close] method.\n   *\n   * See [open] for information on the [mode] argument.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  RandomAccessFile openSync({FileMode mode: FileMode.READ});\n\n  /**\n   * Get the canonical full path corresponding to the file path.\n   * Returns a [:Future<String>:] that completes with the path.\n   */\n  Future<String> fullPath();\n\n  /**\n   * Synchronously get the canonical full path corresponding to the file path.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  String fullPathSync();\n\n  /**\n   * Create a new independent [Stream](../dart_async/Stream.html) for the\n   * contents of this file.\n   *\n   * In order to make sure that system resources are freed, the stream\n   * must be read to completion or the subscription on the stream must\n   * be cancelled.\n   */\n  Stream<List<int>> openRead();\n\n  /**\n   * Creates a new independent [IOSink] for the file. The\n   * [IOSink] must be closed when no longer used, to free\n   * system resources.\n   *\n   * An [IOSink] for a file can be opened in two modes:\n   *\n   * * [FileMode.WRITE]: truncates the file to length zero.\n   * * [FileMode.APPEND]: sets the initial write position to the end\n   *   of the file.\n   *\n   *  When writing strings through the returned [IOSink] the encoding\n   *  specified using [encoding] will be used. The returned [IOSink]\n   *  has an [:encoding:] property which can be changed after the\n   *  [IOSink] has been created.\n   */\n  IOSink openWrite({FileMode mode: FileMode.WRITE,\n                    Encoding encoding: Encoding.UTF_8});\n\n  /**\n   * Read the entire file contents as a list of bytes. Returns a\n   * [:Future<List<int>>:] that completes with the list of bytes that\n   * is the contents of the file.\n   */\n  Future<List<int>> readAsBytes();\n\n  /**\n   * Synchronously read the entire file contents as a list of bytes.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  List<int> readAsBytesSync();\n\n  /**\n   * Read the entire file contents as a string using the given\n   * [Encoding].\n   *\n   * Returns a [:Future<String>:] that completes with the string once\n   * the file contents has been read.\n   */\n  Future<String> readAsString({Encoding encoding: Encoding.UTF_8});\n\n  /**\n   * Synchronously read the entire file contents as a string using the\n   * given [Encoding].\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  String readAsStringSync({Encoding encoding: Encoding.UTF_8});\n\n  /**\n   * Read the entire file contents as lines of text using the given\n   * [Encoding].\n   *\n   * Returns a [:Future<List<String>>:] that completes with the lines\n   * once the file contents has been read.\n   */\n  Future<List<String>> readAsLines({Encoding encoding: Encoding.UTF_8});\n\n  /**\n   * Synchronously read the entire file contents as lines of text\n   * using the given [Encoding].\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  List<String> readAsLinesSync({Encoding encoding: Encoding.UTF_8});\n\n  /**\n   * Write a list of bytes to a file.\n   *\n   * Opens the file, writes the list of bytes to it, and closes the file.\n   * Returns a [:Future<File>:] that completes with this [File] object once\n   * the entire operation has completed.\n   *\n   * By default [writeAsBytes] creates the file for writing and truncates the\n   * file if it already exists. In order to append the bytes to an existing\n   * file, pass [FileMode.APPEND] as the optional mode parameter.\n   */\n  Future<File> writeAsBytes(List<int> bytes, {FileMode mode: FileMode.WRITE});\n\n  /**\n   * Synchronously write a list of bytes to a file.\n   *\n   * Opens the file, writes the list of bytes to it and closes the file.\n   *\n   * By default [writeAsBytesSync] creates the file for writing and truncates\n   * the file if it already exists. In order to append the bytes to an existing\n   * file, pass [FileMode.APPEND] as the optional mode parameter.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  void writeAsBytesSync(List<int> bytes, {FileMode mode: FileMode.WRITE});\n\n  /**\n   * Write a string to a file.\n   *\n   * Opens the file, writes the string in the given encoding, and closes the\n   * file. Returns a [:Future<File>:] that completes with this [File] object\n   * once the entire operation has completed.\n   *\n   * By default [writeAsString] creates the file for writing and truncates the\n   * file if it already exists. In order to append the bytes to an existing\n   * file, pass [FileMode.APPEND] as the optional mode parameter.\n   */\n  Future<File> writeAsString(String contents,\n                             {FileMode mode: FileMode.WRITE,\n                              Encoding encoding: Encoding.UTF_8});\n\n  /**\n   * Synchronously write a string to a file.\n   *\n   * Opens the file, writes the string in the given encoding, and closes the\n   * file.\n   *\n   * By default [writeAsStringSync] creates the file for writing and\n   * truncates the file if it already exists. In order to append the bytes\n   * to an existing file, pass [FileMode.APPEND] as the optional mode\n   * parameter.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  void writeAsStringSync(String contents,\n                         {FileMode mode: FileMode.WRITE,\n                          Encoding encoding: Encoding.UTF_8});\n\n  /**\n   * Get the path of the file.\n   */\n  String get path;\n}\n\n\n/**\n * [RandomAccessFile] provides random access to the data in a\n * file. [RandomAccessFile] objects are obtained by calling the\n * [:open:] method on a [File] object.\n */\nabstract class RandomAccessFile {\n  /**\n   * Closes the file. Returns a [:Future<RandomAccessFile>:] that\n   * completes with this RandomAccessFile when it has been closed.\n   */\n  Future<RandomAccessFile> close();\n\n  /**\n   * Synchronously closes the file.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  void closeSync();\n\n  /**\n   * Reads a byte from the file. Returns a [:Future<int>:] that\n   * completes with the byte, or with -1 if end-of-file has been reached.\n   */\n  Future<int> readByte();\n\n  /**\n   * Synchronously reads a single byte from the file. If end-of-file\n   * has been reached -1 is returned.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  int readByteSync();\n\n  /**\n   * Reads [bytes] bytes from a file and returns the result as a list of bytes.\n   */\n  Future<List<int>> read(int bytes);\n\n  /**\n   * Synchronously reads a maximum of [bytes] bytes from a file and\n   * returns the result in a list of bytes.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  List<int> readSync(int bytes);\n\n  /**\n   * Reads into an existing List<int> from the file. If [start] is present, the\n   * bytes will be filled into [buffer] from at index [start], otherwise index\n   * 0. If [end] is present, the [end] - [start] bytes will be read into\n   * [buffer], otherwise up to [buffer.length]. If [end] == [start] nothing\n   * happends.\n   *\n   * Returns a [:Future<int>:] that completes with the number of bytes read.\n   */\n  Future<int> readInto(List<int> buffer, [int start, int end]);\n\n  /**\n   * Synchronously reads into an existing List<int> from the file. If [start] is\n   * present, the bytes will be filled into [buffer] from at index [start],\n   * otherwise index 0.  If [end] is present, the [end] - [start] bytes will be\n   * read into [buffer], otherwise up to [buffer.length]. If [end] == [start]\n   * nothing happends.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  int readIntoSync(List<int> buffer, [int start, int end]);\n\n  /**\n   * Writes a single byte to the file. Returns a\n   * [:Future<RandomAccessFile>:] that completes with this\n   * RandomAccessFile when the write completes.\n   */\n  Future<RandomAccessFile> writeByte(int value);\n\n  /**\n   * Synchronously writes a single byte to the file. Returns the\n   * number of bytes successfully written.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  int writeByteSync(int value);\n\n  /**\n   * Writes from a [List<int>] to the file. It will read the buffer from index\n   * [start] to index [end]. If [start] is omitted, it'll start from index 0.\n   * If [end] is omitted, it will write to end of [buffer].\n   *\n   * Returns a [:Future<RandomAccessFile>:] that completes with this\n   * [RandomAccessFile] when the write completes.\n   */\n  Future<RandomAccessFile> writeFrom(List<int> buffer, [int start, int end]);\n\n  /**\n   * Synchronously writes from a [List<int>] to the file. It will read the\n   * buffer from index [start] to index [end]. If [start] is omitted, it'll\n   * start from index 0. If [end] is omitted, it will write to the end of\n   * [buffer].\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  void writeFromSync(List<int> buffer, [int start, int end]);\n\n  /**\n   * Writes a string to the file using the given [Encoding]. Returns a\n   * [:Future<RandomAccessFile>:] that completes with this\n   * RandomAccessFile when the write completes.\n   */\n  Future<RandomAccessFile> writeString(String string,\n                                       {Encoding encoding: Encoding.UTF_8});\n\n  /**\n   * Synchronously writes a single string to the file using the given\n   * [Encoding].\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  void writeStringSync(String string,\n                       {Encoding encoding: Encoding.UTF_8});\n\n  /**\n   * Gets the current byte position in the file. Returns a\n   * [:Future<int>:] that completes with the position.\n   */\n  Future<int> position();\n\n  /**\n   * Synchronously gets the current byte position in the file.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  int positionSync();\n\n  /**\n   * Sets the byte position in the file. Returns a\n   * [:Future<RandomAccessFile>:] that completes with this\n   * RandomAccessFile when the position has been set.\n   */\n  Future<RandomAccessFile> setPosition(int position);\n\n  /**\n   * Synchronously sets the byte position in the file.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  void setPositionSync(int position);\n\n  /**\n   * Truncates (or extends) the file to [length] bytes. Returns a\n   * [:Future<RandomAccessFile>:] that completes with this\n   * RandomAccessFile when the truncation has been performed.\n   */\n  Future<RandomAccessFile> truncate(int length);\n\n  /**\n   * Synchronously truncates (or extends) the file to [length] bytes.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  void truncateSync(int length);\n\n  /**\n   * Gets the length of the file. Returns a [:Future<int>:] that\n   * completes with the length in bytes.\n   */\n  Future<int> length();\n\n  /**\n   * Synchronously gets the length of the file.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  int lengthSync();\n\n  /**\n   * Flushes the contents of the file to disk. Returns a\n   * [:Future<RandomAccessFile>:] that completes with this\n   * RandomAccessFile when the flush operation completes.\n   */\n  Future<RandomAccessFile> flush();\n\n  /**\n   * Synchronously flushes the contents of the file to disk.\n   *\n   * Throws a [FileIOException] if the operation fails.\n   */\n  void flushSync();\n\n  /**\n   * Returns a human-readable string for this RandomAccessFile instance.\n   */\n  String toString();\n\n  /**\n   * Gets the path of the file underlying this RandomAccessFile.\n   */\n  String get path;\n}\n\n\nclass FileIOException implements Exception {\n  const FileIOException([String this.message = \"\",\n                         OSError this.osError = null]);\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    sb.write(\"FileIOException\");\n    if (!message.isEmpty) {\n      sb.write(\": $message\");\n      if (osError != null) {\n        sb.write(\" ($osError)\");\n      }\n    } else if (osError != null) {\n      sb.write(\": osError\");\n    }\n    return sb.toString();\n  }\n  final String message;\n  final OSError osError;\n}\n","sdk/lib/io/file_impl.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n// Read the file in blocks of size 64k.\nconst int _BLOCK_SIZE = 64 * 1024;\n\n\nclass _FileStream extends Stream<List<int>> {\n  // Stream controller.\n  StreamController<List<int>> _controller;\n\n  // Information about the underlying file.\n  String _path;\n  RandomAccessFile _openedFile;\n  int _position;\n\n  // Has the stream been paused or unsubscribed?\n  bool _paused = false;\n  bool _unsubscribed = false;\n\n  // Is there a read currently in progress?\n  bool _readInProgress = false;\n\n  // Block read but not yet send because stream is paused.\n  List<int> _currentBlock;\n\n  _FileStream(String this._path) : _position = 0 {\n    _setupController();\n  }\n\n  _FileStream.forStdin() : _position = 0 {\n    _setupController();\n  }\n\n  StreamSubscription<List<int>> listen(void onData(List<int> event),\n                                       {void onError(error),\n                                        void onDone(),\n                                        bool cancelOnError}) {\n    return _controller.stream.listen(onData,\n                                     onError: onError,\n                                     onDone: onDone,\n                                     cancelOnError: cancelOnError);\n  }\n\n  void _setupController() {\n    _controller = new StreamController<List<int>>(\n        onListen: _start,\n        onPause: () => _paused = true,\n        onResume: _resume,\n        onCancel: () {\n          _unsubscribed = true;\n          _closeFile();\n        });\n  }\n\n  Future _closeFile() {\n    Future closeFuture;\n    if (_openedFile != null) {\n      Future closeFuture = _openedFile.close();\n      _openedFile = null;\n      return closeFuture;\n    } else {\n      return new Future.value();\n    }\n  }\n\n  void _readBlock() {\n    // Don't start a new read if one is already in progress.\n    if (_readInProgress) return;\n    _readInProgress = true;\n    _openedFile.length()\n      .then((length) {\n        if (_position >= length) {\n          _readInProgress = false;\n          if (!_unsubscribed) {\n            _closeFile().then((_) { _controller.close(); });\n            _unsubscribed = true;\n          }\n          return null;\n        } else {\n          return _openedFile.read(_BLOCK_SIZE);\n        }\n      })\n      .then((block) {\n        _readInProgress = false;\n        if (block == null || _unsubscribed) {\n          return;\n        }\n        _position += block.length;\n        if (_paused) {\n          _currentBlock = block;\n        } else {\n          _controller.add(block);\n          _readBlock();\n        }\n      })\n      .catchError((e) {\n        if (!_unsubscribed) {\n          _controller.addError(e);\n          _closeFile().then((_) { _controller.close(); });\n          _unsubscribed = true;\n        }\n      });\n  }\n\n  void _start() {\n    Future<RandomAccessFile> openFuture;\n    if (_path != null) {\n      openFuture = new File(_path).open(mode: FileMode.READ);\n    } else {\n      openFuture = new Future.value(_File._openStdioSync(0));\n    }\n    openFuture\n      .then((RandomAccessFile opened) {\n        _openedFile = opened;\n        _readBlock();\n      })\n      .catchError((e) {\n        _controller.addError(e);\n        _controller.close();\n      });\n  }\n\n  void _resume() {\n    _paused = false;\n    if (_currentBlock != null) {\n      _controller.add(_currentBlock);\n      _currentBlock = null;\n    }\n    // Resume reading unless we are already done.\n    if (_openedFile != null) _readBlock();\n  }\n}\n\nclass _FileStreamConsumer extends StreamConsumer<List<int>> {\n  File _file;\n  Future<RandomAccessFile> _openFuture;\n  StreamSubscription _subscription;\n\n  _FileStreamConsumer(File this._file, FileMode mode) {\n    _openFuture = _file.open(mode: mode);\n  }\n\n  _FileStreamConsumer.fromStdio(int fd) {\n    assert(1 <= fd && fd <= 2);\n    _openFuture = new Future.value(_File._openStdioSync(fd));\n  }\n\n  Future<File> addStream(Stream<List<int>> stream) {\n    Completer<File> completer = new Completer<File>();\n    _openFuture\n      .then((openedFile) {\n        _subscription = stream.listen(\n          (d) {\n            _subscription.pause();\n            openedFile.writeFrom(d, 0, d.length)\n              .then((_) => _subscription.resume())\n              .catchError((e) {\n                openedFile.close();\n                completer.completeError(e);\n              });\n          },\n          onDone: () {\n            completer.complete(_file);\n          },\n          onError: (e) {\n            openedFile.close();\n            completer.completeError(e);\n          },\n          cancelOnError: true);\n      })\n      .catchError((e) {\n        completer.completeError(e);\n      });\n    return completer.future;\n  }\n\n  Future<File> close() {\n    return _openFuture.then((openedFile) => openedFile.close());\n  }\n}\n\n\nconst int _EXISTS_REQUEST = 0;\nconst int _CREATE_REQUEST = 1;\nconst int _DELETE_REQUEST = 2;\nconst int _OPEN_REQUEST = 3;\nconst int _FULL_PATH_REQUEST = 4;\nconst int _DIRECTORY_REQUEST = 5;\nconst int _CLOSE_REQUEST = 6;\nconst int _POSITION_REQUEST = 7;\nconst int _SET_POSITION_REQUEST = 8;\nconst int _TRUNCATE_REQUEST = 9;\nconst int _LENGTH_REQUEST = 10;\nconst int _LENGTH_FROM_PATH_REQUEST = 11;\nconst int _LAST_MODIFIED_REQUEST = 12;\nconst int _FLUSH_REQUEST = 13;\nconst int _READ_BYTE_REQUEST = 14;\nconst int _WRITE_BYTE_REQUEST = 15;\nconst int _READ_REQUEST = 16;\nconst int _READ_LIST_REQUEST = 17;\nconst int _WRITE_LIST_REQUEST = 18;\nconst int _CREATE_LINK_REQUEST = 19;\nconst int _DELETE_LINK_REQUEST = 20;\n\n// Base class for _File and _RandomAccessFile with shared functions.\nclass _FileBase {\n  bool _isErrorResponse(response) {\n    return response is List && response[0] != _SUCCESS_RESPONSE;\n  }\n\n  _exceptionFromResponse(response, String message) {\n    assert(_isErrorResponse(response));\n    switch (response[_ERROR_RESPONSE_ERROR_TYPE]) {\n      case _ILLEGAL_ARGUMENT_RESPONSE:\n        return new ArgumentError();\n      case _OSERROR_RESPONSE:\n        var err = new OSError(response[_OSERROR_RESPONSE_MESSAGE],\n                              response[_OSERROR_RESPONSE_ERROR_CODE]);\n        return new FileIOException(message, err);\n      case _FILE_CLOSED_RESPONSE:\n        return new FileIOException(\"File closed\");\n      default:\n        return new Exception(\"Unknown error\");\n    }\n  }\n}\n\n// TODO(ager): The only reason for this class is that the patching\n// mechanism doesn't seem to like patching a private top level\n// function.\nclass _FileUtils {\n  external static SendPort _newServicePort();\n}\n\n// Class for encapsulating the native implementation of files.\nclass _File extends _FileBase implements File {\n  // Constructor for file.\n  _File(String this._path) {\n    if (_path is! String) {\n      throw new ArgumentError('${Error.safeToString(_path)} '\n                              'is not a String');\n    }\n  }\n\n  // Constructor from Path for file.\n  _File.fromPath(Path path) : this(path.toNativePath());\n\n  Future<bool> exists() {\n    _ensureFileService();\n    List request = new List(2);\n    request[0] = _EXISTS_REQUEST;\n    request[1] = _path;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"Cannot open file '$_path'\");\n      }\n      return response;\n    });\n  }\n\n  external static _exists(String path);\n\n  bool existsSync() {\n    var result = _exists(_path);\n    throwIfError(result, \"Cannot check existence of file '$_path'\");\n    return result;\n  }\n\n  Future<File> create() {\n    _ensureFileService();\n    List request = new List(2);\n    request[0] = _CREATE_REQUEST;\n    request[1] = _path;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"Cannot create file '$_path'\");\n      }\n      return this;\n    });\n  }\n\n  external static _create(String path);\n\n  external static _createLink(String path, String target);\n\n  external static _linkTarget(String path);\n\n  void createSync() {\n    var result = _create(_path);\n    throwIfError(result, \"Cannot create file '$_path'\");\n  }\n\n  Future<File> delete() {\n    _ensureFileService();\n    List request = new List(2);\n    request[0] = _DELETE_REQUEST;\n    request[1] = _path;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"Cannot delete file '$_path'\");\n      }\n      return this;\n    });\n  }\n\n  external static _delete(String path);\n\n  external static _deleteLink(String path);\n\n  void deleteSync() {\n    var result = _delete(_path);\n    throwIfError(result, \"Cannot delete file '$_path'\");\n  }\n\n  Future<Directory> directory() {\n    _ensureFileService();\n    List request = new List(2);\n    request[0] = _DIRECTORY_REQUEST;\n    request[1] = _path;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"Cannot retrieve directory for \"\n                                     \"file '$_path'\");\n      }\n      return new Directory(response);\n    });\n  }\n\n  external static _directory(String path);\n\n  Directory directorySync() {\n    var result = _directory(path);\n    throwIfError(result, \"Cannot retrieve directory for file '$_path'\");\n    return new Directory(result);\n  }\n\n  Future<RandomAccessFile> open({FileMode mode: FileMode.READ}) {\n    _ensureFileService();\n    Completer<RandomAccessFile> completer = new Completer<RandomAccessFile>();\n    if (mode != FileMode.READ &&\n        mode != FileMode.WRITE &&\n        mode != FileMode.APPEND) {\n      Timer.run(() {\n        completer.completeError(new ArgumentError());\n      });\n      return completer.future;\n    }\n    List request = new List(3);\n    request[0] = _OPEN_REQUEST;\n    request[1] = _path;\n    request[2] = mode._mode;  // Direct int value for serialization.\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"Cannot open file '$_path'\");\n      }\n      return new _RandomAccessFile(response, _path);\n    });\n  }\n\n  Future<int> length() {\n    _ensureFileService();\n    List request = new List(2);\n    request[0] = _LENGTH_FROM_PATH_REQUEST;\n    request[1] = _path;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"Cannot retrieve length of \"\n                                     \"file '$_path'\");\n      }\n      return response;\n    });\n  }\n\n\n  external static _lengthFromPath(String path);\n\n  int lengthSync() {\n    var result = _lengthFromPath(_path);\n    throwIfError(result, \"Cannot retrieve length of file '$_path'\");\n    return result;\n  }\n\n  Future<DateTime> lastModified() {\n    _ensureFileService();\n    List request = new List(2);\n    request[0] = _LAST_MODIFIED_REQUEST;\n    request[1] = _path;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"Cannot retrieve modification time \"\n                                     \"for file '$_path'\");\n      }\n      return new DateTime.fromMillisecondsSinceEpoch(response);\n    });\n  }\n\n  external static _lastModified(String path);\n\n  DateTime lastModifiedSync() {\n    var ms = _lastModified(path);\n    throwIfError(ms, \"Cannot retrieve modification time for file '$_path'\");\n    return new DateTime.fromMillisecondsSinceEpoch(ms);\n  }\n\n  external static _open(String path, int mode);\n\n  RandomAccessFile openSync({FileMode mode: FileMode.READ}) {\n    if (mode != FileMode.READ &&\n        mode != FileMode.WRITE &&\n        mode != FileMode.APPEND) {\n      throw new FileIOException(\"Unknown file mode. Use FileMode.READ, \"\n                                \"FileMode.WRITE or FileMode.APPEND.\");\n    }\n    var id = _open(_path, mode._mode);\n    throwIfError(id, \"Cannot open file '$_path'\");\n    return new _RandomAccessFile(id, _path);\n  }\n\n  external static int _openStdio(int fd);\n\n  static RandomAccessFile _openStdioSync(int fd) {\n    var id = _openStdio(fd);\n    if (id == 0) {\n      throw new FileIOException(\"Cannot open stdio file for: $fd\");\n    }\n    return new _RandomAccessFile(id, \"\");\n  }\n\n  Future<String> fullPath() {\n    _ensureFileService();\n    List request = new List(2);\n    request[0] = _FULL_PATH_REQUEST;\n    request[1] = _path;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"Cannot retrieve full path\"\n                                     \" for '$_path'\");\n      }\n      return response;\n    });\n  }\n\n  external static _fullPath(String path);\n\n  String fullPathSync() {\n    var result = _fullPath(_path);\n    throwIfError(result, \"Cannot retrieve full path for file '$_path'\");\n    return result;\n  }\n\n  Stream<List<int>> openRead() {\n    return new _FileStream(_path);\n  }\n\n  IOSink openWrite({FileMode mode: FileMode.WRITE,\n                    Encoding encoding: Encoding.UTF_8}) {\n    if (mode != FileMode.WRITE &&\n        mode != FileMode.APPEND) {\n      throw new FileIOException(\n          \"Wrong FileMode. Use FileMode.WRITE or FileMode.APPEND\");\n    }\n    var consumer = new _FileStreamConsumer(this, mode);\n    return new IOSink(consumer, encoding: encoding);\n  }\n\n  Future<List<int>> readAsBytes() {\n    _ensureFileService();\n    Completer<List<int>> completer = new Completer<List<int>>();\n    var chunks = new _BufferList();\n    openRead().listen(\n      (d) => chunks.add(d),\n      onDone: () {\n        var result = chunks.readBytes();\n        completer.complete(result);\n      },\n      onError: (e) {\n        completer.completeError(e);\n      },\n      cancelOnError: true);\n    return completer.future;\n  }\n\n  List<int> readAsBytesSync() {\n    var opened = openSync();\n    var chunks = new _BufferList();\n    var data;\n    while ((data = opened.readSync(_BLOCK_SIZE)).length > 0) {\n      chunks.add(data);\n    }\n    opened.closeSync();\n    return chunks.readBytes();\n  }\n\n  Future<String> readAsString({Encoding encoding: Encoding.UTF_8}) {\n    _ensureFileService();\n    return readAsBytes().then((bytes) {\n      return _decodeString(bytes, encoding);\n    });\n  }\n\n  String readAsStringSync({Encoding encoding: Encoding.UTF_8}) {\n    List<int> bytes = readAsBytesSync();\n    return _decodeString(bytes, encoding);\n  }\n\n  static List<String> _decodeLines(List<int> bytes, Encoding encoding) {\n    if (bytes.length == 0) return [];\n    var list = [];\n    var controller = new StreamController();\n    controller.stream\n        .transform(new StringDecoder(encoding))\n        .transform(new LineTransformer())\n        .listen((line) => list.add(line));\n    controller.add(bytes);\n    controller.close();\n    return list;\n  }\n\n  Future<List<String>> readAsLines({Encoding encoding: Encoding.UTF_8}) {\n    _ensureFileService();\n    Completer<List<String>> completer = new Completer<List<String>>();\n    return readAsBytes().then((bytes) {\n      return _decodeLines(bytes, encoding);\n    });\n  }\n\n  List<String> readAsLinesSync({Encoding encoding: Encoding.UTF_8}) {\n    return _decodeLines(readAsBytesSync(), encoding);\n  }\n\n  Future<File> writeAsBytes(List<int> bytes,\n                            {FileMode mode: FileMode.WRITE}) {\n    try {\n      IOSink sink = openWrite(mode: mode);\n      sink.add(bytes);\n      sink.close();\n      return sink.done.then((_) => this);;\n    } catch (e) {\n      return new Future.error(e);\n    }\n  }\n\n  void writeAsBytesSync(List<int> bytes, {FileMode mode: FileMode.WRITE}) {\n    RandomAccessFile opened = openSync(mode: mode);\n    opened.writeFromSync(bytes, 0, bytes.length);\n    opened.closeSync();\n  }\n\n  Future<File> writeAsString(String contents,\n                             {FileMode mode: FileMode.WRITE,\n                              Encoding encoding: Encoding.UTF_8}) {\n    try {\n      return writeAsBytes(_encodeString(contents, encoding), mode: mode);\n    } catch (e) {\n      var completer = new Completer();\n      Timer.run(() => completer.completeError(e));\n      return completer.future;\n    }\n  }\n\n  void writeAsStringSync(String contents,\n                         {FileMode mode: FileMode.WRITE,\n                          Encoding encoding: Encoding.UTF_8}) {\n    writeAsBytesSync(_encodeString(contents, encoding), mode: mode);\n  }\n\n  String get path => _path;\n\n  String toString() => \"File: '$path'\";\n\n  void _ensureFileService() {\n    if (_fileService == null) {\n      _fileService = _FileUtils._newServicePort();\n    }\n  }\n\n  static throwIfError(Object result, String msg) {\n    if (result is OSError) {\n      throw new FileIOException(msg, result);\n    }\n  }\n\n  final String _path;\n\n  SendPort _fileService;\n}\n\n\nclass _RandomAccessFile extends _FileBase implements RandomAccessFile {\n  _RandomAccessFile(int this._id, String this._path);\n\n  Future<RandomAccessFile> close() {\n    Completer<RandomAccessFile> completer = new Completer<RandomAccessFile>();\n    if (closed) return _completeWithClosedException(completer);\n    _ensureFileService();\n    List request = new List(2);\n    request[0] = _CLOSE_REQUEST;\n    request[1] = _id;\n    // Set the id_ to 0 (NULL) to ensure the no more async requests\n    // can be issued for this file.\n    _id = 0;\n    return _fileService.call(request).then((result) {\n      if (result != -1) {\n        _id = result;\n        return this;\n      } else {\n        throw new FileIOException(\"Cannot close file '$_path'\");\n      }\n    });\n  }\n\n  external static int _close(int id);\n\n  void closeSync() {\n    _checkNotClosed();\n    var id = _close(_id);\n    if (id == -1) {\n      throw new FileIOException(\"Cannot close file '$_path'\");\n    }\n    _id = id;\n  }\n\n  Future<int> readByte() {\n    _ensureFileService();\n    Completer<int> completer = new Completer<int>();\n    if (closed) return _completeWithClosedException(completer);\n    List request = new List(2);\n    request[0] = _READ_BYTE_REQUEST;\n    request[1] = _id;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"readByte failed for file '$_path'\");\n      }\n      return response;\n    });\n  }\n\n  external static _readByte(int id);\n\n  int readByteSync() {\n    _checkNotClosed();\n    var result = _readByte(_id);\n    if (result is OSError) {\n      throw new FileIOException(\"readByte failed for file '$_path'\", result);\n    }\n    return result;\n  }\n\n  Future<List<int>> read(int bytes) {\n    _ensureFileService();\n    Completer<List<int>> completer = new Completer<List<int>>();\n    if (bytes is !int) {\n      // Complete asynchronously so the user has a chance to setup\n      // handlers without getting exceptions when registering the\n      // then handler.\n      Timer.run(() {\n        completer.completeError(new FileIOException(\n            \"Invalid arguments to read for file '$_path'\"));\n      });\n      return completer.future;\n    };\n    if (closed) return _completeWithClosedException(completer);\n    List request = new List(3);\n    request[0] = _READ_REQUEST;\n    request[1] = _id;\n    request[2] = bytes;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"read failed for file '$_path'\");\n      }\n      return response[1];\n    });\n  }\n\n  external static _read(int id, int bytes);\n\n  List<int> readSync(int bytes) {\n    _checkNotClosed();\n    if (bytes is !int) {\n      throw new FileIOException(\n          \"Invalid arguments to readSync for file '$_path'\");\n    }\n    var result = _read(_id, bytes);\n    if (result is OSError) {\n      throw new FileIOException(\"readSync failed for file '$_path'\",\n                                result);\n    }\n    return result;\n  }\n\n  Future<int> readInto(List<int> buffer, [int start, int end]) {\n    _ensureFileService();\n    if (buffer is !List ||\n        (start != null && start is !int) ||\n        (end != null && end is !int)) {\n      return new Future.error(new FileIOException(\n          \"Invalid arguments to readInto for file '$_path'\"));\n    };\n    Completer<int> completer = new Completer<int>();\n    if (closed) return _completeWithClosedException(completer);\n    List request = new List(3);\n    if (start == null) start = 0;\n    if (end == null) end = buffer.length;\n    request[0] = _READ_LIST_REQUEST;\n    request[1] = _id;\n    request[2] = end - start;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"readInto failed for file '$_path'\");\n      }\n      var read = response[1];\n      var data = response[2];\n      buffer.setRange(start, start + read, data);\n      return read;\n    });\n  }\n\n  static void _checkReadWriteListArguments(int length, int start, int end) {\n    if (start < 0) throw new RangeError.value(start);\n    if (end < start) throw new RangeError.value(end);\n    if (end > length) {\n      throw new RangeError.value(end);\n    }\n  }\n\n  external static _readInto(int id, List<int> buffer, int start, int end);\n\n  int readIntoSync(List<int> buffer, [int start, int end]) {\n    _checkNotClosed();\n    if (buffer is !List ||\n        (start != null && start is !int) ||\n        (end != null && end is !int)) {\n      throw new FileIOException(\n          \"Invalid arguments to readInto for file '$_path'\");\n    }\n    if (start == null) start = 0;\n    if (end == null) end = buffer.length;\n    if (end == start) return 0;\n    _checkReadWriteListArguments(buffer.length, start, end);\n    var result = _readInto(_id, buffer, start, end);\n    if (result is OSError) {\n      throw new FileIOException(\"readInto failed for file '$_path'\",\n                                result);\n    }\n    return result;\n  }\n\n  Future<RandomAccessFile> writeByte(int value) {\n    _ensureFileService();\n    Completer<RandomAccessFile> completer = new Completer<RandomAccessFile>();\n    if (value is !int) {\n      // Complete asynchronously so the user has a chance to setup\n      // handlers without getting exceptions when registering the\n      // then handler.\n      Timer.run(() {\n          completer.completeError(new FileIOException(\n              \"Invalid argument to writeByte for file '$_path'\"));\n      });\n      return completer.future;\n    }\n    if (closed) return _completeWithClosedException(completer);\n    List request = new List(3);\n    request[0] = _WRITE_BYTE_REQUEST;\n    request[1] = _id;\n    request[2] = value;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"writeByte failed for file '$_path'\");\n      }\n      return this;\n    });\n  }\n\n  external static _writeByte(int id, int value);\n\n  int writeByteSync(int value) {\n    _checkNotClosed();\n    if (value is !int) {\n      throw new FileIOException(\n          \"Invalid argument to writeByte for file '$_path'\");\n    }\n    var result = _writeByte(_id, value);\n    if (result is OSError) {\n      throw new FileIOException(\"writeByte failed for file '$_path'\",\n                                result);\n    }\n    return result;\n  }\n\n  Future<RandomAccessFile> writeFrom(List<int> buffer, [int start, int end]) {\n    _ensureFileService();\n    if ((buffer is !List && buffer is !ByteData) ||\n        (start != null && start is !int) ||\n        (end != null && end is !int)) {\n      return new Future.error(new FileIOException(\n          \"Invalid arguments to writeFrom for file '$_path'\"));\n    }\n    Completer<RandomAccessFile> completer = new Completer<RandomAccessFile>();\n\n    if (closed) return _completeWithClosedException(completer);\n\n    _BufferAndStart result;\n    try {\n      result = _ensureFastAndSerializableBuffer(buffer, start, end);\n    } catch (e) {\n      return new Future.error(e);\n    }\n\n    List request = new List(5);\n    request[0] = _WRITE_LIST_REQUEST;\n    request[1] = _id;\n    request[2] = result.buffer;\n    request[3] = result.start;\n    request[4] = end - (start - result.start);\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"writeFrom failed for file '$_path'\");\n      }\n      return this;\n    });\n  }\n\n  external static _writeFrom(int id, List<int> buffer, int start, int end);\n\n  void writeFromSync(List<int> buffer, [int start, int end]) {\n    _checkNotClosed();\n    if (buffer is !List ||\n        (start != null && start is !int) ||\n        (end != null && end is !int)) {\n      throw new FileIOException(\n          \"Invalid arguments to writeFrom for file '$_path'\");\n    }\n    if (start == null) start = 0;\n    if (end == null) end = buffer.length;\n    if (end == start) return;\n    _checkReadWriteListArguments(buffer.length, start, end);\n    _BufferAndStart bufferAndStart =\n        _ensureFastAndSerializableBuffer(buffer, start, end);\n    var result = _writeFrom(_id,\n                            bufferAndStart.buffer,\n                            bufferAndStart.start,\n                            end - (start - bufferAndStart.start));\n    if (result is OSError) {\n      throw new FileIOException(\"writeFrom failed for file '$_path'\", result);\n    }\n  }\n\n  Future<RandomAccessFile> writeString(String string,\n                                       {Encoding encoding: Encoding.UTF_8}) {\n    if (encoding is! Encoding) {\n      var completer = new Completer();\n      Timer.run(() {\n        completer.completeError(new FileIOException(\n            \"Invalid encoding in writeString: $encoding\"));\n      });\n      return completer.future;\n    }\n    var data = _encodeString(string, encoding);\n    return writeFrom(data, 0, data.length);\n  }\n\n  void writeStringSync(String string, {Encoding encoding: Encoding.UTF_8}) {\n    if (encoding is! Encoding) {\n      throw new FileIOException(\n          \"Invalid encoding in writeStringSync: $encoding\");\n    }\n    var data = _encodeString(string, encoding);\n    writeFromSync(data, 0, data.length);\n  }\n\n  Future<int> position() {\n    _ensureFileService();\n    Completer<int> completer = new Completer<int>();\n    if (closed) return _completeWithClosedException(completer);\n    List request = new List(2);\n    request[0] = _POSITION_REQUEST;\n    request[1] = _id;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"position failed for file '$_path'\");\n      }\n      return response;\n    });\n  }\n\n  external static _position(int id);\n\n  int positionSync() {\n    _checkNotClosed();\n    var result = _position(_id);\n    if (result is OSError) {\n      throw new FileIOException(\"position failed for file '$_path'\", result);\n    }\n    return result;\n  }\n\n  Future<RandomAccessFile> setPosition(int position) {\n    _ensureFileService();\n    Completer<RandomAccessFile> completer = new Completer<RandomAccessFile>();\n    if (closed) return _completeWithClosedException(completer);\n    List request = new List(3);\n    request[0] = _SET_POSITION_REQUEST;\n    request[1] = _id;\n    request[2] = position;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"setPosition failed for file '$_path'\");\n      }\n      return this;\n    });\n  }\n\n  external static _setPosition(int id, int position);\n\n  void setPositionSync(int position) {\n    _checkNotClosed();\n    var result = _setPosition(_id, position);\n    if (result is OSError) {\n      throw new FileIOException(\"setPosition failed for file '$_path'\", result);\n    }\n  }\n\n  Future<RandomAccessFile> truncate(int length) {\n    _ensureFileService();\n    Completer<RandomAccessFile> completer = new Completer<RandomAccessFile>();\n    if (closed) return _completeWithClosedException(completer);\n    List request = new List(3);\n    request[0] = _TRUNCATE_REQUEST;\n    request[1] = _id;\n    request[2] = length;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"truncate failed for file '$_path'\");\n      }\n      return this;\n    });\n  }\n\n  external static _truncate(int id, int length);\n\n  void truncateSync(int length) {\n    _checkNotClosed();\n    var result = _truncate(_id, length);\n    if (result is OSError) {\n      throw new FileIOException(\"truncate failed for file '$_path'\", result);\n    }\n  }\n\n  Future<int> length() {\n    _ensureFileService();\n    Completer<int> completer = new Completer<int>();\n    if (closed) return _completeWithClosedException(completer);\n    List request = new List(2);\n    request[0] = _LENGTH_REQUEST;\n    request[1] = _id;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"length failed for file '$_path'\");\n      }\n      return response;\n    });\n  }\n\n  external static _length(int id);\n\n  int lengthSync() {\n    _checkNotClosed();\n    var result = _length(_id);\n    if (result is OSError) {\n      throw new FileIOException(\"length failed for file '$_path'\", result);\n    }\n    return result;\n  }\n\n  Future<RandomAccessFile> flush() {\n    _ensureFileService();\n    Completer<RandomAccessFile> completer = new Completer<RandomAccessFile>();\n    if (closed) return _completeWithClosedException(completer);\n    List request = new List(2);\n    request[0] = _FLUSH_REQUEST;\n    request[1] = _id;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"flush failed for file '$_path'\");\n      }\n      return this;\n    });\n  }\n\n  external static _flush(int id);\n\n  void flushSync() {\n    _checkNotClosed();\n    var result = _flush(_id);\n    if (result is OSError) {\n      throw new FileIOException(\"flush failed for file '$_path'\", result);\n    }\n  }\n\n  String get path => _path;\n\n  void _ensureFileService() {\n    if (_fileService == null) {\n      _fileService = _FileUtils._newServicePort();\n    }\n  }\n\n  bool get closed => _id == 0;\n\n  void _checkNotClosed() {\n    if (closed) {\n      throw new FileIOException(\"File closed '$_path'\");\n    }\n  }\n\n  Future _completeWithClosedException(Completer completer) {\n    Timer.run(() {\n      completer.completeError(\n          new FileIOException(\"File closed '$_path'\"));\n    });\n    return completer.future;\n  }\n\n  final String _path;\n  int _id;\n\n  SendPort _fileService;\n}\n","sdk/lib/io/file_system_entity.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass FileSystemEntityType {\n  static const FILE = const FileSystemEntityType._internal(0);\n  static const DIRECTORY = const FileSystemEntityType._internal(1);\n  static const LINK = const FileSystemEntityType._internal(2);\n  static const NOT_FOUND = const FileSystemEntityType._internal(3);\n  static const _typeList = const [FileSystemEntityType.FILE,\n                                  FileSystemEntityType.DIRECTORY,\n                                  FileSystemEntityType.LINK,\n                                  FileSystemEntityType.NOT_FOUND];\n  const FileSystemEntityType._internal(int this._type);\n\n  static FileSystemEntityType _lookup(int type) => _typeList[type];\n  String toString() => const ['FILE', 'DIRECTORY', 'LINK', 'NOT_FOUND'][_type];\n\n  final int _type;\n}\n\n/**\n * A [FileSystemEntity] is a common super class for [File] and\n * [Directory] objects.\n *\n * [FileSystemEntity] objects are returned from directory listing\n * operations. To determine if a FileSystemEntity is a [File] or a\n * [Directory], perform a type check:\n *\n *     if (entity is File) (entity as File).readAsStringSync();\n */\nabstract class FileSystemEntity {\n  String get path;\n\n  external static int _getType(String path, bool followLinks);\n  external static bool _identical(String path1, String path2);\n\n  static int _getTypeSync(String path, bool followLinks) {\n    var result = _getType(path, followLinks);\n    _throwIfError(result, 'Error getting type of FileSystemEntity');\n    return result;\n  }\n\n  /**\n   * Do two paths refer to the same object in the file system?\n   * Links are not identical to their targets, and two links\n   * are not identical just because they point to identical targets.\n   * Links in intermediate directories in the paths are followed, though.\n   *\n   * Throws an error if one of the paths points to an object that does not\n   * exist.\n   * The target of a link can be compared by first getting it with Link.target.\n   */\n  static bool identicalSync(String path1, String path2) {\n    var result = _identical(path1, path2);\n    _throwIfError(result, 'Error in FileSystemEntity.identical');\n    return result;\n  }\n\n  static FileSystemEntityType typeSync(String path, {bool followLinks: true})\n      => FileSystemEntityType._lookup(_getTypeSync(path, followLinks));\n\n  static bool isLinkSync(String path) =>\n      (_getTypeSync(path, false) == FileSystemEntityType.LINK._type);\n\n  static bool isFileSync(String path) =>\n      (_getTypeSync(path, true) == FileSystemEntityType.FILE._type);\n\n  static bool isDirectorySync(String path) =>\n      (_getTypeSync(path, true) == FileSystemEntityType.DIRECTORY._type);\n\n  static _throwIfError(Object result, String msg) {\n    if (result is OSError) {\n      throw new FileIOException(msg, result);\n    } else if (result is ArgumentError) {\n      throw result;\n    }\n  }\n}\n","sdk/lib/io/http.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * HTTP status codes.\n */\nabstract class HttpStatus {\n  static const int CONTINUE = 100;\n  static const int SWITCHING_PROTOCOLS = 101;\n  static const int OK = 200;\n  static const int CREATED = 201;\n  static const int ACCEPTED = 202;\n  static const int NON_AUTHORITATIVE_INFORMATION = 203;\n  static const int NO_CONTENT = 204;\n  static const int RESET_CONTENT = 205;\n  static const int PARTIAL_CONTENT = 206;\n  static const int MULTIPLE_CHOICES = 300;\n  static const int MOVED_PERMANENTLY = 301;\n  static const int FOUND = 302;\n  static const int MOVED_TEMPORARILY = 302; // Common alias for FOUND.\n  static const int SEE_OTHER = 303;\n  static const int NOT_MODIFIED = 304;\n  static const int USE_PROXY = 305;\n  static const int TEMPORARY_REDIRECT = 307;\n  static const int BAD_REQUEST = 400;\n  static const int UNAUTHORIZED = 401;\n  static const int PAYMENT_REQUIRED = 402;\n  static const int FORBIDDEN = 403;\n  static const int NOT_FOUND = 404;\n  static const int METHOD_NOT_ALLOWED = 405;\n  static const int NOT_ACCEPTABLE = 406;\n  static const int PROXY_AUTHENTICATION_REQUIRED = 407;\n  static const int REQUEST_TIMEOUT = 408;\n  static const int CONFLICT = 409;\n  static const int GONE = 410;\n  static const int LENGTH_REQUIRED = 411;\n  static const int PRECONDITION_FAILED = 412;\n  static const int REQUEST_ENTITY_TOO_LARGE = 413;\n  static const int REQUEST_URI_TOO_LONG = 414;\n  static const int UNSUPPORTED_MEDIA_TYPE = 415;\n  static const int REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n  static const int EXPECTATION_FAILED = 417;\n  static const int INTERNAL_SERVER_ERROR = 500;\n  static const int NOT_IMPLEMENTED = 501;\n  static const int BAD_GATEWAY = 502;\n  static const int SERVICE_UNAVAILABLE = 503;\n  static const int GATEWAY_TIMEOUT = 504;\n  static const int HTTP_VERSION_NOT_SUPPORTED = 505;\n  // Client generated status code.\n  static const int NETWORK_CONNECT_TIMEOUT_ERROR = 599;\n}\n\n\n/**\n * HTTP server.\n */\nabstract class HttpServer implements Stream<HttpRequest> {\n  // TODO(ajohnsen): Document with example, once the stream API is final.\n  // TODO(ajohnsen): Add HttpServer.secure.\n  /**\n   * Starts listening for HTTP requests on the specified [address] and\n   * [port].\n   *\n   * The default value for [address] is 127.0.0.1, which will allow\n   * only incoming connections from the local host. To allow for\n   * incoming connection from the network use either the value 0.0.0.0\n   * to bind to all interfaces or the IP address of a specific\n   * interface.\n   *\n   * If [port] has the value [:0:] (the default) an ephemeral port\n   * will be chosen by the system. The actual port used can be\n   * retrieved using the [:port:] getter.\n   *\n   * The optional argument [backlog] can be used to specify the listen\n   * backlog for the underlying OS listen setup. If [backlog] has the\n   * value of [:0:] (the default) a reasonable value will be chosen by\n   * the system.\n   */\n  static Future<HttpServer> bind([String address = \"127.0.0.1\",\n                                  int port = 0,\n                                  int backlog = 0])\n      => _HttpServer.bind(address, port, backlog);\n\n  /**\n   * Starts listening for HTTPS requests on the specified [address] and\n   * [port]. If a [port] of 0 is specified the server will choose an\n   * ephemeral port. The optional argument [backlog] can be used to\n   * specify the listen backlog for the underlying OS listen\n   * setup.\n   *\n   * The certificate with Distinguished Name [certificateName] is looked\n   * up in the certificate database, and is used as the server certificate.\n   * if [requestClientCertificate] is true, the server will request clients\n   * to authenticate with a client certificate.\n   */\n\n  static Future<HttpServer> bindSecure(String address,\n                                       int port,\n                                       {int backlog: 0,\n                                        String certificateName,\n                                        bool requestClientCertificate: false})\n      => _HttpServer.bindSecure(address,\n                                port,\n                                backlog,\n                                certificateName,\n                                requestClientCertificate);\n\n  /**\n   * Attaches the HTTP server to an existing [ServerSocket]. When the\n   * [HttpServer] is closed, the [HttpServer] will just detach itself,\n   * closing current connections but not closing [serverSocket].\n   */\n  factory HttpServer.listenOn(ServerSocket serverSocket)\n      => new _HttpServer.listenOn(serverSocket);\n\n  /**\n   * Permanently stops this [HttpServer] from listening for new connections.\n   * This closes this [Stream] of [HttpRequest]s with a done event.\n   */\n  void close();\n\n  /**\n   * Returns the port that the server is listening on. This can be\n   * used to get the actual port used when a value of 0 for [:port:] is\n   * specified in the [bind] or [bindSecure] call.\n   */\n  int get port;\n\n  /**\n   * Sets the timeout, in seconds, for sessions of this [HttpServer].\n   * The default timeout is 20 minutes.\n   */\n  set sessionTimeout(int timeout);\n\n  /**\n   * Returns an [HttpConnectionsInfo] object summarizing the number of\n   * current connections handled by the server.\n   */\n  HttpConnectionsInfo connectionsInfo();\n}\n\n\n/**\n * Summary statistics about an [HttpServer]s current socket connections.\n */\nclass HttpConnectionsInfo {\n  /**\n   * Total number of socket connections.\n   */\n  int total = 0;\n\n  /**\n   * Number of active connections where actual request/response\n   * processing is active.\n   */\n  int active = 0;\n\n  /**\n   * Number of idle connections held by clients as persistent connections.\n   */\n  int idle = 0;\n\n  /**\n   * Number of connections which are preparing to close. Note: These\n   * connections are also part of the [:active:] count as they might\n   * still be sending data to the client before finally closing.\n   */\n  int closing = 0;\n}\n\n\n/**\n * Access to the HTTP headers for requests and responses. In some\n * situations the headers will be immutable and the mutating methods\n * will then throw exceptions.\n *\n * For all operations on HTTP headers the header name is\n * case-insensitive.\n */\nabstract class HttpHeaders {\n  static const ACCEPT = \"accept\";\n  static const ACCEPT_CHARSET = \"accept-charset\";\n  static const ACCEPT_ENCODING = \"accept-encoding\";\n  static const ACCEPT_LANGUAGE = \"accept-language\";\n  static const ACCEPT_RANGES = \"accept-ranges\";\n  static const AGE = \"age\";\n  static const ALLOW = \"allow\";\n  static const AUTHORIZATION = \"authorization\";\n  static const CACHE_CONTROL = \"cache-control\";\n  static const CONNECTION = \"connection\";\n  static const CONTENT_ENCODING = \"content-encoding\";\n  static const CONTENT_LANGUAGE = \"content-language\";\n  static const CONTENT_LENGTH = \"content-length\";\n  static const CONTENT_LOCATION = \"content-location\";\n  static const CONTENT_MD5 = \"content-md5\";\n  static const CONTENT_RANGE = \"content-range\";\n  static const CONTENT_TYPE = \"content-type\";\n  static const DATE = \"date\";\n  static const ETAG = \"etag\";\n  static const EXPECT = \"expect\";\n  static const EXPIRES = \"expires\";\n  static const FROM = \"from\";\n  static const HOST = \"host\";\n  static const IF_MATCH = \"if-match\";\n  static const IF_MODIFIED_SINCE = \"if-modified-since\";\n  static const IF_NONE_MATCH = \"if-none-match\";\n  static const IF_RANGE = \"if-range\";\n  static const IF_UNMODIFIED_SINCE = \"if-unmodified-since\";\n  static const LAST_MODIFIED = \"last-modified\";\n  static const LOCATION = \"location\";\n  static const MAX_FORWARDS = \"max-forwards\";\n  static const PRAGMA = \"pragma\";\n  static const PROXY_AUTHENTICATE = \"proxy-authenticate\";\n  static const PROXY_AUTHORIZATION = \"proxy-authorization\";\n  static const RANGE = \"range\";\n  static const REFERER = \"referer\";\n  static const RETRY_AFTER = \"retry-after\";\n  static const SERVER = \"server\";\n  static const TE = \"te\";\n  static const TRAILER = \"trailer\";\n  static const TRANSFER_ENCODING = \"transfer-encoding\";\n  static const UPGRADE = \"upgrade\";\n  static const USER_AGENT = \"user-agent\";\n  static const VARY = \"vary\";\n  static const VIA = \"via\";\n  static const WARNING = \"warning\";\n  static const WWW_AUTHENTICATE = \"www-authenticate\";\n\n  // Cookie headers from RFC 6265.\n  static const COOKIE = \"cookie\";\n  static const SET_COOKIE = \"set-cookie\";\n\n  static const GENERAL_HEADERS = const [CACHE_CONTROL,\n                                        CONNECTION,\n                                        DATE,\n                                        PRAGMA,\n                                        TRAILER,\n                                        TRANSFER_ENCODING,\n                                        UPGRADE,\n                                        VIA,\n                                        WARNING];\n\n  static const ENTITY_HEADERS = const [ALLOW,\n                                       CONTENT_ENCODING,\n                                       CONTENT_LANGUAGE,\n                                       CONTENT_LENGTH,\n                                       CONTENT_LOCATION,\n                                       CONTENT_MD5,\n                                       CONTENT_RANGE,\n                                       CONTENT_TYPE,\n                                       EXPIRES,\n                                       LAST_MODIFIED];\n\n\n  static const RESPONSE_HEADERS = const [ACCEPT_RANGES,\n                                         AGE,\n                                         ETAG,\n                                         LOCATION,\n                                         PROXY_AUTHENTICATE,\n                                         RETRY_AFTER,\n                                         SERVER,\n                                         VARY,\n                                         WWW_AUTHENTICATE];\n\n  static const REQUEST_HEADERS = const [ACCEPT,\n                                        ACCEPT_CHARSET,\n                                        ACCEPT_ENCODING,\n                                        ACCEPT_LANGUAGE,\n                                        AUTHORIZATION,\n                                        EXPECT,\n                                        FROM,\n                                        HOST,\n                                        IF_MATCH,\n                                        IF_MODIFIED_SINCE,\n                                        IF_NONE_MATCH,\n                                        IF_RANGE,\n                                        IF_UNMODIFIED_SINCE,\n                                        MAX_FORWARDS,\n                                        PROXY_AUTHORIZATION,\n                                        RANGE,\n                                        REFERER,\n                                        TE,\n                                        USER_AGENT];\n\n  /**\n   * Returns the list of values for the header named [name]. If there\n   * is no header with the provided name, [:null:] will be returned.\n   */\n  List<String> operator[](String name);\n\n  /**\n   * Convenience method for the value for a single valued header. If\n   * there is no header with the provided name, [:null:] will be\n   * returned. If the header has more than one value an exception is\n   * thrown.\n   */\n  String value(String name);\n\n  /**\n   * Adds a header value. The header named [name] will have the value\n   * [value] added to its list of values. Some headers are single\n   * valued, and for these adding a value will replace the previous\n   * value. If the value is of type DateTime a HTTP date format will be\n   * applied. If the value is a [:List:] each element of the list will\n   * be added separately. For all other types the default [:toString:]\n   * method will be used.\n   */\n  void add(String name, Object value);\n\n  /**\n   * Sets a header. The header named [name] will have all its values\n   * cleared before the value [value] is added as its value.\n   */\n  void set(String name, Object value);\n\n  /**\n   * Removes a specific value for a header name. Some headers have\n   * system supplied values and for these the system supplied values\n   * will still be added to the collection of values for the header.\n   */\n  void remove(String name, Object value);\n\n  /**\n   * Removes all values for the specified header name. Some headers\n   * have system supplied values and for these the system supplied\n   * values will still be added to the collection of values for the\n   * header.\n   */\n  void removeAll(String name);\n\n  /**\n   * Enumerates the headers, applying the function [f] to each\n   * header. The header name passed in [:name:] will be all lower\n   * case.\n   */\n  void forEach(void f(String name, List<String> values));\n\n  /**\n   * Disables folding for the header named [name] when sending the HTTP\n   * header. By default, multiple header values are folded into a\n   * single header line by separating the values with commas. The\n   * 'set-cookie' header has folding disabled by default.\n   */\n  void noFolding(String name);\n\n  /**\n   * Gets and sets the date. The value of this property will\n   * reflect the 'date' header.\n   */\n  DateTime date;\n\n  /**\n   * Gets and sets the expiry date. The value of this property will\n   * reflect the 'expires' header.\n   */\n  DateTime expires;\n\n  /**\n   * Gets and sets the \"if-modified-since\" date. The value of this property will\n   * reflect the \"if-modified-since\" header.\n   */\n  DateTime ifModifiedSince;\n\n  /**\n   * Gets and sets the host part of the 'host' header for the\n   * connection.\n   */\n  String host;\n\n  /**\n   * Gets and sets the port part of the 'host' header for the\n   * connection.\n   */\n  int port;\n\n  /**\n   * Gets and sets the content type. Note that the content type in the\n   * header will only be updated if this field is set\n   * directly. Mutating the returned current value will have no\n   * effect.\n   */\n  ContentType contentType;\n\n  /**\n   * Gets and sets the content length header value.\n   */\n  int contentLength;\n\n  /**\n   * Gets and sets the persistent connection header value.\n   */\n  bool persistentConnection;\n\n  /**\n   * Gets and sets the chunked transfer encoding header value.\n   */\n  bool chunkedTransferEncoding;\n}\n\n\n/**\n * Representation of a header value in the form:\n *\n *   [:value; parameter1=value1; parameter2=value2:]\n *\n * [HeaderValue] can be used to conveniently build and parse header\n * values on this form.\n *\n * To build an [:accepts:] header with the value\n *\n *     text/plain; q=0.3, text/html\n *\n * use code like this:\n *\n *     HttpClientRequest request = ...;\n *     var v = new HeaderValue(\"text/plain\", {\"q\": \"0.3\"});\n *     request.headers.add(HttpHeaders.ACCEPT, v);\n *     request.headers.add(HttpHeaders.ACCEPT, \"text/html\");\n *\n * To parse the header values use the [:fromString:] constructor.\n *\n *     HttpRequest request = ...;\n *     List<String> values = request.headers[HttpHeaders.ACCEPT];\n *     values.forEach((value) {\n *       HeaderValue v = new HeaderValue.fromString(value);\n *       // Use v.value and v.parameters\n *     });\n *\n * An instance of [HeaderValue] is immutable.\n */\nabstract class HeaderValue {\n  /**\n   * Creates a new header value object setting the value part.\n   */\n  factory HeaderValue([String value = \"\", Map<String, String> parameters]) {\n    return new _HeaderValue(value, parameters);\n  }\n\n  /**\n   * Creates a new header value object from parsing a header value\n   * string with both value and optional parameters.\n   */\n  factory HeaderValue.fromString(String value,\n                                 {String parameterSeparator: \";\"}) {\n    return new _HeaderValue.fromString(\n        value, parameterSeparator: parameterSeparator);\n  }\n\n  /**\n   * Gets the header value.\n   */\n  String get value;\n\n  /**\n   * Gets the map of parameters.\n   */\n  Map<String, String> get parameters;\n\n  /**\n   * Returns the formatted string representation in the form:\n   *\n   *     value; parameter1=value1; parameter2=value2\n   */\n  String toString();\n}\n\nabstract class HttpSession implements Map {\n  /**\n   * Gets the id for the current session.\n   */\n  String get id;\n\n  /**\n   * Destroys the session. This will terminate the session and any further\n   * connections with this id will be given a new id and session.\n   */\n  void destroy();\n\n  /**\n   * Sets a callback that will be called when the session is timed out.\n   */\n  void set onTimeout(void callback());\n\n  /**\n   * Is true if the session has not been sent to the client yet.\n   */\n  bool get isNew;\n}\n\n\n/**\n * Representation of a content type. An instance of [ContentType] is\n * immutable.\n */\nabstract class ContentType implements HeaderValue {\n  /**\n   * Creates a new content type object setting the primary type and\n   * sub type. The charset and additional parameters can also be set\n   * using [charset] and [parameters]. If charset is passed and\n   * [parameters] contains charset as well the passed [charset] will\n   * override the value in parameters. Keys and values passed in\n   * parameters will be converted to lower case.\n   */\n  factory ContentType(String primaryType,\n                      String subType,\n                      {String charset, Map<String, String> parameters}) {\n    return new _ContentType(primaryType, subType, charset, parameters);\n  }\n\n  /**\n   * Creates a new content type object from parsing a Content-Type\n   * header value. As primary type, sub type and parameter names and\n   * values are not case sensitive all these values will be converted\n   * to lower case. Parsing this string\n   *\n   *     text/html; charset=utf-8\n   *\n   * will create a content type object with primary type [:text:], sub\n   * type [:html:] and parameter [:charset:] with value [:utf-8:].\n   */\n  factory ContentType.fromString(String value) {\n    return new _ContentType.fromString(value);\n  }\n\n  /**\n   * Gets the mime-type, without any parameters.\n   */\n  String get mimeType;\n\n  /**\n   * Gets the primary type.\n   */\n  String get primaryType;\n\n  /**\n   * Gets the sub type.\n   */\n  String get subType;\n\n  /**\n   * Gets the character set.\n   */\n  String get charset;\n}\n\n\n/**\n * Representation of a cookie. For cookies received by the server as\n * Cookie header values only [:name:] and [:value:] fields will be\n * set. When building a cookie for the 'set-cookie' header in the server\n * and when receiving cookies in the client as 'set-cookie' headers all\n * fields can be used.\n */\nabstract class Cookie {\n  /**\n   * Creates a new cookie optionally setting the name and value.\n   */\n  factory Cookie([String name, String value]) => new _Cookie(name, value);\n\n  /**\n   * Creates a new cookie by parsing a header value from a 'set-cookie'\n   * header.\n   */\n  factory Cookie.fromSetCookieValue(String value) {\n    return new _Cookie.fromSetCookieValue(value);\n  }\n\n  /**\n   * Gets and sets the name.\n   */\n  String name;\n\n  /**\n   * Gets and sets the value.\n   */\n  String value;\n\n  /**\n   * Gets and sets the expiry date.\n   */\n  DateTime expires;\n\n  /**\n   * Gets and sets the max age. A value of [:0:] means delete cookie\n   * now.\n   */\n  int maxAge;\n\n  /**\n   * Gets and sets the domain.\n   */\n  String domain;\n\n  /**\n   * Gets and sets the path.\n   */\n  String path;\n\n  /**\n   * Gets and sets whether this cookie is secure.\n   */\n  bool secure;\n\n  /**\n   * Gets and sets whether this cookie is HTTP only.\n   */\n  bool httpOnly;\n\n  /**\n   * Returns the formatted string representation of the cookie. The\n   * string representation can be used for for setting the Cookie or\n   * 'set-cookie' headers\n   */\n  String toString();\n}\n\n\n/**\n * Http request delivered to the HTTP server callback. The [HttpRequest] is a\n * [Stream] of the body content of the request. Listen to the body to handle the\n * data and be notified once the entire body is received.\n */\nabstract class HttpRequest implements Stream<List<int>> {\n  /**\n   * Returns the content length of the request body. If the size of\n   * the request body is not known in advance this -1.\n   */\n  int get contentLength;\n\n  /**\n   * Returns the method for the request.\n   */\n  String get method;\n\n  /**\n   * Returns the URI for the request.\n   */\n  Uri get uri;\n\n  /**\n   * Returns the parsed query string.\n   */\n  Map<String, String> get queryParameters;\n\n  /**\n   * Returns the request headers.\n   */\n  HttpHeaders get headers;\n\n  /**\n   * Returns the cookies in the request (from the Cookie headers).\n   */\n  List<Cookie> get cookies;\n\n  /**\n   * Returns the persistent connection state signaled by the client.\n   */\n  bool get persistentConnection;\n\n  /**\n   * Returns the client certificate of the client making the request.\n   * Returns null if the connection is not a secure TLS or SSL connection,\n   * or if the server does not request a client certificate, or if the client\n   * does not provide one.\n   */\n  X509Certificate get certificate;\n\n  /**\n   * Gets the session for the given request. If the session is\n   * being initialized by this call, [:isNew:] will be true for the returned\n   * session.\n   * See [HttpServer.sessionTimeout] on how to change default timeout.\n   */\n  HttpSession get session;\n\n  /**\n   * Returns the HTTP protocol version used in the request. This will\n   * be \"1.0\" or \"1.1\".\n   */\n  String get protocolVersion;\n\n  /**\n   * Gets information about the client connection. Returns [null] if the socket\n   * is not available.\n   */\n  HttpConnectionInfo get connectionInfo;\n\n  /**\n   * Gets the [HttpResponse] object, used for sending back the response to the\n   * client.\n   */\n  HttpResponse get response;\n}\n\n\n/**\n * HTTP response to be send back to the client.\n *\n * This object has a number of properties for setting up the HTTP\n * header of the response. When the header has been set up the methods\n * from the [IOSink] can be used to write the actual body of the HTTP\n * response. When one of the [IOSink] methods is used for the\n * first time the request header is send. Calling any methods that\n * will change the header after it is sent will throw an exception.\n *\n * When writing string data through the [IOSink] the encoding used\n * will be determined from the \"charset\" parameter of the\n * \"Content-Type\" header.\n *\n *     HttpResponse response = ...\n *     response.headers.contentType\n *         = new ContentType(\"application\", \"json\", charset: \"utf-8\");\n *     response.write(...);  // Strings written will be UTF-8 encoded.\n *\n * If no charset is provided the default of ISO-8859-1 (Latin 1) will\n * be used.\n *\n *     HttpResponse response = ...\n *     response.headers.add(HttpHeaders.CONTENT_TYPE, \"text/plain\");\n *     response.write(...);  // Strings written will be ISO-8859-1 encoded.\n *\n * If an unsupported encoding is used an exception will be thrown if\n * using one of the write methods taking a string.\n */\nabstract class HttpResponse implements IOSink {\n  // TODO(ajohnsen): Add documentation of how to pipe a file to the response.\n  /**\n   * Gets and sets the content length of the response. If the size of\n   * the response is not known in advance set the content length to\n   * -1 - which is also the default if not set.\n   */\n  int contentLength;\n\n  /**\n   * Gets and sets the status code. Any integer value is accepted. For\n   * the official HTTP status codes use the fields from\n   * [HttpStatus]. If no status code is explicitly set the default\n   * value [HttpStatus.OK] is used.\n   */\n  int statusCode;\n\n  /**\n   * Gets and sets the reason phrase. If no reason phrase is explicitly\n   * set a default reason phrase is provided.\n   */\n  String reasonPhrase;\n\n  /**\n   * Gets and sets the persistent connection state. The initial value\n   * of this property is the persistent connection state from the\n   * request.\n   */\n  bool persistentConnection;\n\n  /**\n   * Returns the response headers.\n   */\n  HttpHeaders get headers;\n\n  /**\n   * Cookies to set in the client (in the 'set-cookie' header).\n   */\n  List<Cookie> get cookies;\n\n  /**\n   * Detaches the underlying socket from the HTTP server. When the\n   * socket is detached the HTTP server will no longer perform any\n   * operations on it.\n   *\n   * This is normally used when a HTTP upgrade request is received\n   * and the communication should continue with a different protocol.\n   */\n  Future<Socket> detachSocket();\n\n  /**\n   * Gets information about the client connection. Returns [null] if the socket\n   * is not available.\n   */\n  HttpConnectionInfo get connectionInfo;\n}\n\n\n/**\n * The [HttpClient] class implements the client side of the HTTP\n * protocol. It contains a number of methods to send a HTTP request\n * to a HTTP server and receive a HTTP response back.\n *\n * This is a two-step process, triggered by two futures. When the\n * first future completes with a [HttpClientRequest] the underlying\n * network connection has been established, but no data has yet been\n * sent. The HTTP headers and body can be set on the request, and\n * [:close:] is called to sent it to the server.\n *\n * The second future, which is returned by [:close:], completes with\n * an [HttpClientResponse] object when the response is received from\n * the server. This object contains the headers and body of the\n * response.\n\n * The future for [HttpClientRequest] is created by methods such as\n * [getUrl] and [open].\n *\n * When the HTTP response is ready a [HttpClientResponse] object is\n * provided which provides access to the headers and body of the response.\n *\n *     HttpClient client = new HttpClient();\n *     client.getUrl(new Uri.fromString(\"http://www.example.com/\"))\n *         .then((HttpClientRequest request) {\n *           // Prepare the request then call close on it to send it.\n *           return request.close();\n *         })\n *         .then((HttpClientResponse response) {\n *          // Process the response.\n *         });\n *\n * All [HttpClient] requests set the following header by default:\n *\n *     Accept-Encoding: gzip\n *\n * This allows the HTTP server to use gzip compression for the body if\n * possible. If this behavior is not desired set the\n * \"Accept-Encoding\" header to something else.\n *\n * The [HttpClient] supports persistent connections and caches network\n * connections to reuse then for multiple requests whenever\n * possible. This means that network connections can be kept open for\n * some time after a request have completed. Use [:HttpClient.close:]\n * to force shut down the [HttpClient] object and close the idle\n * network connections.\n *\n * By default the HttpClient uses the proxy configuration available\n * from the environment, see [findProxyFromEnvironment]. To turn off\n * the use of proxies all together set the [findProxy] property to\n * [:null:].\n *\n *     HttpClient client = new HttpClient();\n *     client.findProxy = null;\n */\nabstract class HttpClient {\n  static const int DEFAULT_HTTP_PORT = 80;\n  static const int DEFAULT_HTTPS_PORT = 443;\n\n  factory HttpClient() => new _HttpClient();\n\n  /**\n   * Opens a HTTP connection. The returned [HttpClientRequest] is used to\n   * fill in the content of the request before sending it. The 'host' header for\n   * the request will be set to the value [host]:[port]. This can be overridden\n   * through the [HttpClientRequest] interface before the request is sent.\n   * NOTE if [host] is an IP address this will still be set in the 'host'\n   * header.\n   */\n  Future<HttpClientRequest> open(String method,\n                                 String host,\n                                 int port,\n                                 String path);\n\n  /**\n   * Opens a HTTP connection. The returned [HttpClientRequest] is used to\n   * fill in the content of the request before sending it. The 'hosth header for\n   * the request will be set to the value [host]:[port]. This can be overridden\n   * through the [HttpClientRequest] interface before the request is sent.\n   * NOTE if [host] is an IP address this will still be set in the 'host'\n   * header.\n   */\n  Future<HttpClientRequest> openUrl(String method, Uri url);\n\n  /**\n   * Opens a HTTP connection using the GET method. See [open] for\n   * details. Using this method to open a HTTP connection will set the\n   * content length to 0.\n   */\n  Future<HttpClientRequest> get(String host, int port, String path);\n\n  /**\n   * Opens a HTTP connection using the GET method. See [openUrl] for\n   * details. Using this method to open a HTTP connection will set the\n   * content length to 0.\n   */\n  Future<HttpClientRequest> getUrl(Uri url);\n\n  /**\n   * Opens a HTTP connection using the POST method. See [open] for details.\n   */\n  Future<HttpClientRequest> post(String host, int port, String path);\n\n  /**\n   * Opens a HTTP connection using the POST method. See [openUrl] for details.\n   */\n  Future<HttpClientRequest> postUrl(Uri url);\n\n  /**\n   * Sets the function to be called when a site is requesting\n   * authentication. The URL requested and the security realm from the\n   * server are passed in the arguments [url] and [realm].\n   *\n   * The function returns a [Future] which should complete when the\n   * authentication has been resolved. If credentials cannot be\n   * provided the [Future] should complete with [false]. If\n   * credentials are available the function should add these using\n   * [addCredentials] before completing the [Future] with the value\n   * [true].\n   *\n   * If the [Future] completes with true the request will be retried\n   * using the updated credentials. Otherwise response processing will\n   * continue normally.\n   */\n  set authenticate(Future<bool> f(Uri url, String scheme, String realm));\n\n  /**\n   * Add credentials to be used for authorizing HTTP requests.\n   */\n  void addCredentials(Uri url, String realm, HttpClientCredentials credentials);\n\n  /**\n   * Sets the function used to resolve the proxy server to be used for\n   * opening a HTTP connection to the specified [url]. If this\n   * function is not set, direct connections will always be used.\n   *\n   * The string returned by [f] must be in the format used by browser\n   * PAC (proxy auto-config) scripts. That is either\n   *\n   *   \"DIRECT\"\n   *\n   * for using a direct connection or\n   *\n   *   \"PROXY host:port\"\n   *\n   * for using the proxy server [:host:] on port [:port:].\n   *\n   * A configuration can contain several configuration elements\n   * separated by semicolons, e.g.\n   *\n   *   \"PROXY host:port; PROXY host2:port2; DIRECT\"\n   *\n   * The static function [findProxyFromEnvironment] on this class can\n   * be used to implement proxy server resolving based on environment\n   * variables.\n   */\n  set findProxy(String f(Uri url));\n\n  /**\n   * Function for resolving the proxy server to be used for a HTTP\n   * connection from the proxy configuration specified through\n   * environment variables.\n   *\n   * The following environment variables are taken into account:\n   *\n   *     http_proxy\n   *     https_proxy\n   *     no_proxy\n   *     HTTP_PROXY\n   *     HTTPS_PROXY\n   *     NO_PROXY\n   *\n   * [:http_proxy:] and [:HTTP_PROXY:] specify the proxy server to use for\n   * http:// urls. Use the format [:hostname:port:]. If no port is used a\n   * default of 1080 will be used. If both are set the lower case one takes\n   * precedence.\n   *\n   * [:https_proxy:] and [:HTTPS_PROXY:] specify the proxy server to use for\n   * https:// urls. Use the format [:hostname:port:]. If no port is used a\n   * default of 1080 will be used. If both are set the lower case one takes\n   * precedence.\n   *\n   * [:no_proxy:] and [:NO_PROXY:] specify a comma separated list of\n   * postfixes of hostnames for which not to use the proxy\n   * server. E.g. the value \"localhost,127.0.0.1\" will make requests\n   * to both \"localhost\" and \"127.0.0.1\" not use a proxy. If both are set\n   * the lower case one takes precedence.\n   *\n   * To activate this way of resolving proxies assign this function to\n   * the [findProxy] property on the [HttpClient].\n   *\n   *     HttpClient client = new HttpClient();\n   *     client.findProxy = HttpClient.findProxyFromEnvironment;\n   *\n   * If you don't want to use the system environment you can use a\n   * different one by wrapping the function.\n   *\n   *     HttpClient client = new HttpClient();\n   *     client.findProxy = (url) {\n   *       return HttpClient.findProxyFromEnvironment(\n   *           url, {\"http_proxy\": ..., \"no_proxy\": ...});\n   *     }\n   *\n   * If a proxy requires authentication it is possible to configure\n   * the username and password as well. Use the format\n   * [:username:password@hostname:port:] to include the username and\n   * password. Alternatively the API [addProxyCredentials] can be used\n   * to set credentials for proxies which require authentication.\n   */\n  static String findProxyFromEnvironment(Uri url,\n                                         {Map<String, String> environment}) {\n    return _HttpClient._findProxyFromEnvironment(url, environment);\n  }\n\n  /**\n   * Sets the function to be called when a proxy is requesting\n   * authentication. Information on the proxy in use and the security\n   * realm for the authentication are passed in the arguments [host],\n   * [port] and [realm].\n   *\n   * The function returns a [Future] which should complete when the\n   * authentication has been resolved. If credentials cannot be\n   * provided the [Future] should complete with [false]. If\n   * credentials are available the function should add these using\n   * [addProxyCredentials] before completing the [Future] with the value\n   * [true].\n   *\n   * If the [Future] completes with [true] the request will be retried\n   * using the updated credentials. Otherwise response processing will\n   * continue normally.\n   */\n  set authenticateProxy(\n      Future<bool> f(String host, int port, String scheme, String realm));\n\n  /**\n   * Add credentials to be used for authorizing HTTP proxies.\n   */\n  void addProxyCredentials(String host,\n                           int port,\n                           String realm,\n                           HttpClientCredentials credentials);\n\n  /**\n   * Shutdown the HTTP client. If [force] is [:false:] (the default)\n   * the [:HttpClient:] will be kept alive until all active\n   * connections are done. If [force] is [:true:] any active\n   * connections will be closed to immediately release all\n   * resources. These closed connections will receive an [:onError:]\n   * callback to indicate that the client was shutdown. In both cases\n   * trying to establish a new connection after calling [shutdown]\n   * will throw an exception.\n   */\n  void close({bool force: false});\n}\n\n\n/**\n * HTTP request for a client connection.\n *\n * This object has a number of properties for setting up the HTTP\n * header of the request. When the header has been set up the methods\n * from the [IOSink] can be used to write the actual body of the HTTP\n * request. When one of the [IOSink] methods is used for the first\n * time the request header is send. Calling any methods that will\n * change the header after it is sent will throw an exception.\n *\n * When writing string data through the [IOSink] the\n * encoding used will be determined from the \"charset\" parameter of\n * the \"Content-Type\" header.\n *\n *     HttpClientRequest request = ...\n *     request.headers.contentType\n *         = new ContentType(\"application\", \"json\", charset: \"utf-8\");\n *     request.write(...);  // Strings written will be UTF-8 encoded.\n *\n * If no charset is provided the default of ISO-8859-1 (Latin 1) will\n * be used.\n *\n *     HttpClientRequest request = ...\n *     request.headers.add(HttpHeaders.CONTENT_TYPE, \"text/plain\");\n *     request.write(...);  // Strings written will be ISO-8859-1 encoded.\n *\n * If an unsupported encoding is used an exception will be thrown if\n * using one of the write methods taking a string.\n */\nabstract class HttpClientRequest implements IOSink {\n  /**\n   * Gets and sets the content length of the request. If the size of\n   * the request is not known in advance set content length to -1,\n   * which is also the default.\n   */\n  int contentLength;\n\n  /**\n   * Returns the request headers.\n   */\n  HttpHeaders get headers;\n\n  /**\n   * Cookies to present to the server (in the 'cookie' header).\n   */\n  List<Cookie> get cookies;\n\n  /**\n   * Gets and sets the requested persistent connection state.\n   * The default value is [:true:].\n   */\n  bool persistentConnection;\n\n  /**\n   * A [HttpClientResponse] future that will complete once the response is\n   * available. If an error occurs before the response is available, this\n   * future will complete with an error.\n   */\n  Future<HttpClientResponse> get done;\n\n  /**\n   * Close the request for input. Returns the value of [done].\n   */\n  Future<HttpClientResponse> close();\n\n  /**\n   * Set this property to [:true:] if this request should\n   * automatically follow redirects. The default is [:true:].\n   *\n   * Automatic redirect will only happen for \"GET\" and \"HEAD\" requests\n   * and only for the status codes [:HttpHeaders.MOVED_PERMANENTLY:]\n   * (301), [:HttpStatus.FOUND:] (302),\n   * [:HttpStatus.MOVED_TEMPORARILY:] (302, alias for\n   * [:HttpStatus.FOUND:]), [:HttpStatus.SEE_OTHER:] (303) and\n   * [:HttpStatus.TEMPORARY_REDIRECT:] (307). For\n   * [:HttpStatus.SEE_OTHER:] (303) autmatic redirect will also happen\n   * for \"POST\" requests with the method changed to \"GET\" when\n   * following the redirect.\n   *\n   * All headers added to the request will be added to the redirection\n   * request(s). However, any body send with the request will not be\n   * part of the redirection request(s).\n   */\n  bool followRedirects;\n\n  /**\n   * Set this property to the maximum number of redirects to follow\n   * when [followRedirects] is [:true:]. If this number is exceeded the\n   * [onError] callback will be called with a [RedirectLimitExceeded]\n   * exception. The default value is 5.\n   */\n  int maxRedirects;\n\n  /**\n   * Get information about the client connection. Returns [null] if the socket\n   * is not available.\n   */\n  HttpConnectionInfo get connectionInfo;\n}\n\n\n/**\n * HTTP response for a client connection. The [HttpClientResponse] is a\n * [Stream] of the body content of the response. Listen to the body to handle\n * the data and be notified once the entire body is received.\n */\nabstract class HttpClientResponse implements Stream<List<int>> {\n  /**\n   * Returns the status code.\n   */\n  int get statusCode;\n\n  /**\n   * Returns the reason phrase associated with the status code.\n   */\n  String get reasonPhrase;\n\n  /**\n   * Returns the content length of the request body. Returns -1 if the size of\n   * the request body is not known in advance.\n   */\n  int get contentLength;\n\n  /**\n   * Gets the persistent connection state returned by the server.\n   */\n  bool get persistentConnection;\n\n  /**\n   * Returns whether the status code is one of the normal redirect\n   * codes [HttpStatus.MOVED_PERMANENTLY], [HttpStatus.FOUND],\n   * [HttpStatus.MOVED_TEMPORARILY], [HttpStatus.SEE_OTHER] and\n   * [HttpStatus.TEMPORARY_REDIRECT].\n   */\n  bool get isRedirect;\n\n  /**\n   * Returns the series of redirects this connection has been through. The\n   * list will be empty if no redirects were followed. [redirects] will be\n   * updated both in the case of an automatic and a manual redirect.\n   */\n  List<RedirectInfo> get redirects;\n\n  /**\n   * Redirects this connection to a new URL. The default value for\n   * [method] is the method for the current request. The default value\n   * for [url] is the value of the [HttpHeaders.LOCATION] header of\n   * the current response. All body data must have been read from the\n   * current response before calling [redirect].\n   *\n   * All headers added to the request will be added to the redirection\n   * request. However, any body sent with the request will not be\n   * part of the redirection request.\n   *\n   * If [followLoops] is set to [true], redirect will follow the redirect,\n   * even if the URL was already visited. The default value is [false].\n   *\n   * [redirect] will ignore [maxRedirects] and will always perform the redirect.\n   */\n  Future<HttpClientResponse> redirect([String method,\n                                       Uri url,\n                                       bool followLoops]);\n\n\n  /**\n   * Returns the response headers.\n   */\n  HttpHeaders get headers;\n\n  /**\n   * Detach the underlying socket from the HTTP client. When the\n   * socket is detached the HTTP client will no longer perform any\n   * operations on it.\n   *\n   * This is normally used when a HTTP upgrade is negotiated and the\n   * communication should continue with a different protocol.\n   */\n  Future<Socket> detachSocket();\n\n  /**\n   * Cookies set by the server (from the 'set-cookie' header).\n   */\n  List<Cookie> get cookies;\n\n  /**\n   * Returns the certificate of the HTTPS server providing the response.\n   * Returns null if the connection is not a secure TLS or SSL connection.\n   */\n  X509Certificate get certificate;\n\n  /**\n   * Gets information about the client connection. Returns [null] if the socket\n   * is not available.\n   */\n  HttpConnectionInfo get connectionInfo;\n}\n\n\nabstract class HttpClientCredentials { }\n\n\n/**\n * Represents credentials for basic authentication.\n */\nabstract class HttpClientBasicCredentials extends HttpClientCredentials {\n  factory HttpClientBasicCredentials(String username, String password) =>\n      new _HttpClientBasicCredentials(username, password);\n}\n\n\n/**\n * Represents credentials for digest authentication.\n */\nabstract class HttpClientDigestCredentials extends HttpClientCredentials {\n  factory HttpClientDigestCredentials(String username, String password) =>\n      new _HttpClientDigestCredentials(username, password);\n}\n\n\n/**\n * Information about an [HttpRequest], [HttpResponse], [HttpClientRequest], or\n * [HttpClientResponse] connection.\n */\nabstract class HttpConnectionInfo {\n  String get remoteHost;\n  int get remotePort;\n  int get localPort;\n}\n\n\n/**\n * Redirect information.\n */\nabstract class RedirectInfo {\n  /**\n   * Returns the status code used for the redirect.\n   */\n  int get statusCode;\n\n  /**\n   * Returns the method used for the redirect.\n   */\n  String get method;\n\n  /**\n   * Returns the location for the redirect.\n   */\n  Uri get location;\n}\n\n\n/**\n * When detaching a socket from either the [:HttpServer:] or the\n * [:HttpClient:] due to a HTTP connection upgrade there might be\n * unparsed data already read from the socket. This unparsed data\n * together with the detached socket is returned in an instance of\n * this class.\n */\nabstract class DetachedSocket {\n  Socket get socket;\n  List<int> get unparsedData;\n}\n\n\nclass HttpException implements Exception {\n  const HttpException([String this.message = \"\"]);\n  String toString() => \"HttpException: $message\";\n  final String message;\n}\n\n\nclass RedirectException extends HttpException {\n  const RedirectException(String message,\n                          List<RedirectInfo> this.redirects) : super(message);\n  final List<RedirectInfo> redirects;\n}\n\n\nclass RedirectLimitExceededException extends RedirectException {\n  const RedirectLimitExceededException(List<RedirectInfo> redirects)\n      : super(\"Redirect limit exceeded\", redirects);\n}\n\n\nclass RedirectLoopException extends RedirectException {\n  const RedirectLoopException(List<RedirectInfo> redirects)\n      : super(\"Redirect loop detected\", redirects);\n}\n","sdk/lib/io/http_body.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n\n/**\n * [HttpBodyHandler] is a helper class for parsing and collecting HTTP message\n * data in an easy-to-use [HttpBody] object. The content body is parsed,\n * depending on the 'Content-Type' header field.\n *\n * To use with the [HttpServer] for request messages, [HttpBodyHandler] can be\n * used as either a [StreamTransformer] or as a per-request handler (see\n * [processRequest]).\n *\n *     HttpServer server = ...\n *     server.transform(new HttpBodyHandler())\n *         .listen((HttpRequestBody body) {\n *           ...\n *         });\n *\n * To use with the [HttpClient] for response messages, [HttpBodyHandler] can be\n * used as a per-request handler (see [processResponse]).\n *\n *     HttpClient client = ...\n *     client.get(...)\n *         .then((HttpClientRequest response) => response.close())\n *         .then(HttpBodyHandler.processResponse)\n *         .then((HttpClientResponseBody body) {\n *           ...\n *         });\n *\n * The following mime-types will be handled specially:\n *   - text/\\*\n *   - application/json\n *\n * All other mime-types will be returned as [List<int>].\n */\nclass HttpBodyHandler\n    implements StreamTransformer<HttpRequest, HttpRequestBody> {\n  var _transformer;\n\n  HttpBodyHandler() : _transformer = new _HttpBodyHandlerTransformer();\n\n  /**\n   * Process and parse an incoming [HttpRequest]. The returned [HttpRequestBody]\n   * contains a [response] field for accessing the [HttpResponse].\n   */\n  static Future<HttpRequestBody> processRequest(HttpRequest request) {\n    return _HttpBodyHandler.processRequest(request);\n  }\n\n  /**\n   * Process and parse an incoming [HttpClientResponse].\n   */\n  static Future<HttpClientResponseBody> processResponse(\n      HttpClientResponse response) {\n    return _HttpBodyHandler.processResponse(response);\n  }\n\n  Stream<HttpRequestBody> bind(Stream<HttpRequest> stream) {\n    return _transformer.bind(stream);\n  }\n}\n\n\n/**\n * A HTTP content body produced by [HttpBodyHandler] for either [HttpRequest]\n * or [HttpClientResponse].\n */\nabstract class HttpBody {\n  /**\n   * The content type e.g. application/json, application/octet-stream,\n   * application/x-www-form-urlencoded, text/plain.\n   */\n  String get mimeType;\n\n  /**\n   * A high-level type value, that reflects how the body was parsed, e.g.\n   * \"text\", \"binary\" and \"json\".\n   */\n  String get type;\n\n  /**\n   * The actual body. The type depends on [type].\n   */\n  dynamic get body;\n}\n\n\n/**\n * The [HttpBody] of a [HttpClientResponse] will be of type\n * [HttpClientResponseBody]. It contains the [HttpClientResponse] object\n * for access to the headers.\n */\nabstract class HttpClientResponseBody extends HttpBody {\n  /**\n   * Returns the status code.\n   */\n  int get statusCode;\n\n  /**\n   * Returns the reason phrase associated with the status code.\n   */\n  String get reasonPhrase;\n\n  /**\n   * Returns the response headers.\n   */\n  HttpHeaders get headers;\n\n  /**\n   * The [HttpClientResponse] of the HTTP body.\n   */\n  HttpClientResponse get response;\n}\n\n\n/**\n * The [HttpBody] of a [HttpRequest] will be of type [HttpRequestBody]. It\n * contains the fields used to read all request header information and\n * responding to the client.\n */\nabstract class HttpRequestBody extends HttpBody {\n  /**\n   * Returns the method for the request.\n   */\n  String get method;\n\n  /**\n   * Returns the URI for the request.\n   */\n  Uri get uri;\n\n  /**\n   * Returns the request headers.\n   */\n  HttpHeaders get headers;\n\n  /**\n   * The [HttpResponse] used for responding to the client.\n   */\n  HttpResponse get response;\n}\n","sdk/lib/io/http_body_impl.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass _HttpBodyHandlerTransformer\n    extends StreamEventTransformer<HttpRequest, HttpRequestBody> {\n  void handleData(HttpRequest request, EventSink<HttpRequestBody> sink) {\n    HttpBodyHandler.processRequest(request)\n        .then(sink.add, onError: sink.addError);\n  }\n}\n\nclass _HttpBodyHandler {\n  static Future<HttpRequestBody> processRequest(HttpRequest request) {\n    return process(request, request.headers)\n        .then((body) => new _HttpRequestBody(request, body),\n              onError: (error) {\n                // Try to send BAD_REQUEST response.\n                request.response.statusCode = HttpStatus.BAD_REQUEST;\n                request.response.close();\n                request.response.done.catchError((_) {});\n                throw error;\n              });\n  }\n\n  static Future<HttpClientResponseBody> processResponse(\n      HttpClientResponse response) {\n    return process(response, response.headers)\n        .then((body) => new _HttpClientResponseBody(response, body));\n  }\n\n  static Future<HttpBody> process(Stream<List<int>> stream,\n                                  HttpHeaders headers) {\n    return stream.fold(\n        new _BufferList(),\n        (buffer, data) {\n          // TODO(ajohnsen): Add limit for POST data.\n          buffer.add(data);\n          return buffer;\n        })\n        .then((list) {\n          dynamic content = list.readBytes();\n          String type = \"binary\";\n          ContentType contentType = headers.contentType;\n          if (contentType == null) {\n            return new _HttpBody(null, type, content);\n          }\n          String asText(Encoding defaultEncoding) {\n            var encoding;\n            var charset = contentType.charset;\n            if (charset != null) encoding = Encoding.fromName(charset);\n            if (encoding == null) encoding = defaultEncoding;\n            return _decodeString(content, encoding);\n          }\n          switch (contentType.primaryType) {\n            case \"text\":\n              type = \"text\";\n              content = asText(Encoding.ASCII);\n              break;\n\n            case \"application\":\n              switch (contentType.subType) {\n                case \"json\":\n                  content = JSON.parse(asText(Encoding.UTF_8));\n                  type = \"json\";\n                  break;\n\n                default:\n                  break;\n              }\n              break;\n\n            default:\n              break;\n          }\n          return new _HttpBody(contentType.mimeType, type, content);\n        });\n  }\n}\n\nclass _HttpBody implements HttpBody {\n  final String mimeType;\n  final String type;\n  final dynamic body;\n\n  _HttpBody(String this.mimeType,\n            String this.type,\n            dynamic this.body);\n}\n\nclass _HttpRequestBody extends _HttpBody implements HttpRequestBody {\n  final String method;\n  final Uri uri;\n  final HttpHeaders headers;\n  final HttpResponse response;\n\n  _HttpRequestBody(HttpRequest request, HttpBody body)\n      : super(body.mimeType, body.type, body.body),\n        method = request.method,\n        uri = request.uri,\n        headers = request.headers,\n        response = request.response;\n}\n\nclass _HttpClientResponseBody\n    extends _HttpBody implements HttpClientResponseBody {\n  final HttpClientResponse response;\n\n  _HttpClientResponseBody(HttpClientResponse response, HttpBody body)\n      : super(body.mimeType, body.type, body.body),\n        this.response = response;\n\n  int get statusCode => response.statusCode;\n\n  String get reasonPhrase => response.reasonPhrase;\n\n  HttpHeaders get headers => response.headers;\n}\n","sdk/lib/io/http_headers.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass _HttpHeaders implements HttpHeaders {\n  _HttpHeaders(String this.protocolVersion)\n      : _headers = new Map<String, List<String>>();\n\n  List<String> operator[](String name) {\n    name = name.toLowerCase();\n    return _headers[name];\n  }\n\n  String value(String name) {\n    name = name.toLowerCase();\n    List<String> values = _headers[name];\n    if (values == null) return null;\n    if (values.length > 1) {\n      throw new HttpException(\"More than one value for header $name\");\n    }\n    return values[0];\n  }\n\n  void add(String name, Object value) {\n    _checkMutable();\n    if (value is List) {\n      for (int i = 0; i < value.length; i++) {\n        _add(name, value[i]);\n      }\n    } else {\n      _add(name, value);\n    }\n  }\n\n  void set(String name, Object value) {\n    name = name.toLowerCase();\n    _checkMutable();\n    removeAll(name);\n    add(name, value);\n  }\n\n  void remove(String name, Object value) {\n    _checkMutable();\n    name = name.toLowerCase();\n    List<String> values = _headers[name];\n    if (values != null) {\n      int index = values.indexOf(value);\n      if (index != -1) {\n        values.removeRange(index, index + 1);\n      }\n      if (values.length == 0) _headers.remove(name);\n    }\n  }\n\n  void removeAll(String name) {\n    _checkMutable();\n    name = name.toLowerCase();\n    _headers.remove(name);\n  }\n\n  void forEach(void f(String name, List<String> values)) {\n    _headers.forEach(f);\n  }\n\n  void noFolding(String name) {\n    if (_noFoldingHeaders == null) _noFoldingHeaders = new List<String>();\n    _noFoldingHeaders.add(name);\n  }\n\n  bool get persistentConnection {\n    List<String> connection = _headers[HttpHeaders.CONNECTION];\n    if (protocolVersion == \"1.1\") {\n      if (connection == null) return true;\n      return !connection.any((value) => value.toLowerCase() == \"close\");\n    } else {\n      if (connection == null) return false;\n      return connection.any((value) => value.toLowerCase() == \"keep-alive\");\n    }\n  }\n\n  void set persistentConnection(bool persistentConnection) {\n    _checkMutable();\n    // Determine the value of the \"Connection\" header.\n    remove(HttpHeaders.CONNECTION, \"close\");\n    remove(HttpHeaders.CONNECTION, \"keep-alive\");\n    if (protocolVersion == \"1.1\" && !persistentConnection) {\n      add(HttpHeaders.CONNECTION, \"close\");\n    } else if (protocolVersion == \"1.0\" && persistentConnection) {\n      add(HttpHeaders.CONNECTION, \"keep-alive\");\n    }\n  }\n\n  int get contentLength => _contentLength;\n\n  void set contentLength(int contentLength) {\n    _checkMutable();\n    _contentLength = contentLength;\n    if (_contentLength >= 0) {\n      _set(HttpHeaders.CONTENT_LENGTH, contentLength.toString());\n    } else {\n      removeAll(HttpHeaders.CONTENT_LENGTH);\n    }\n  }\n\n  bool get chunkedTransferEncoding => _chunkedTransferEncoding;\n\n  void set chunkedTransferEncoding(bool chunkedTransferEncoding) {\n    _checkMutable();\n    _chunkedTransferEncoding = chunkedTransferEncoding;\n    List<String> values = _headers[HttpHeaders.TRANSFER_ENCODING];\n    if ((values == null || values[values.length - 1] != \"chunked\") &&\n        chunkedTransferEncoding) {\n      // Headers does not specify chunked encoding - add it if set.\n        _addValue(HttpHeaders.TRANSFER_ENCODING, \"chunked\");\n    } else if (!chunkedTransferEncoding) {\n      // Headers does specify chunked encoding - remove it if not set.\n      remove(HttpHeaders.TRANSFER_ENCODING, \"chunked\");\n    }\n  }\n\n  String get host => _host;\n\n  void set host(String host) {\n    _checkMutable();\n    _host = host;\n    _updateHostHeader();\n  }\n\n  int get port => _port;\n\n  void set port(int port) {\n    _checkMutable();\n    _port = port;\n    _updateHostHeader();\n  }\n\n  DateTime get ifModifiedSince {\n    List<String> values = _headers[HttpHeaders.IF_MODIFIED_SINCE];\n    if (values != null) {\n      try {\n        return _HttpUtils.parseDate(values[0]);\n      } on Exception catch (e) {\n        return null;\n      }\n    }\n    return null;\n  }\n\n  void set ifModifiedSince(DateTime ifModifiedSince) {\n    _checkMutable();\n    // Format \"ifModifiedSince\" header with date in Greenwich Mean Time (GMT).\n    String formatted = _HttpUtils.formatDate(ifModifiedSince.toUtc());\n    _set(HttpHeaders.IF_MODIFIED_SINCE, formatted);\n  }\n\n  DateTime get date {\n    List<String> values = _headers[HttpHeaders.DATE];\n    if (values != null) {\n      try {\n        return _HttpUtils.parseDate(values[0]);\n      } on Exception catch (e) {\n        return null;\n      }\n    }\n    return null;\n  }\n\n  void set date(DateTime date) {\n    _checkMutable();\n    // Format \"DateTime\" header with date in Greenwich Mean Time (GMT).\n    String formatted = _HttpUtils.formatDate(date.toUtc());\n    _set(\"date\", formatted);\n  }\n\n  DateTime get expires {\n    List<String> values = _headers[HttpHeaders.EXPIRES];\n    if (values != null) {\n      try {\n        return _HttpUtils.parseDate(values[0]);\n      } on Exception catch (e) {\n        return null;\n      }\n    }\n    return null;\n  }\n\n  void set expires(DateTime expires) {\n    _checkMutable();\n    // Format \"Expires\" header with date in Greenwich Mean Time (GMT).\n    String formatted = _HttpUtils.formatDate(expires.toUtc());\n    _set(HttpHeaders.EXPIRES, formatted);\n  }\n\n  ContentType get contentType {\n    var values = _headers[\"content-type\"];\n    if (values != null) {\n      return new ContentType.fromString(values[0]);\n    } else {\n      return null;\n    }\n  }\n\n  void set contentType(ContentType contentType) {\n    _checkMutable();\n    _set(HttpHeaders.CONTENT_TYPE, contentType.toString());\n  }\n\n  void _add(String name, Object value) {\n    var lowerCaseName = name.toLowerCase();\n    // TODO(sgjesse): Add immutable state throw HttpException is immutable.\n    if (lowerCaseName == HttpHeaders.CONTENT_LENGTH) {\n      if (value is int) {\n        contentLength = value;\n      } else if (value is String) {\n        contentLength = int.parse(value);\n      } else {\n        throw new HttpException(\"Unexpected type for header named $name\");\n      }\n    } else if (lowerCaseName == HttpHeaders.TRANSFER_ENCODING) {\n      if (value == \"chunked\") {\n        chunkedTransferEncoding = true;\n      } else {\n        _addValue(lowerCaseName, value);\n      }\n    } else if (lowerCaseName == HttpHeaders.DATE) {\n      if (value is DateTime) {\n        date = value;\n      } else if (value is String) {\n        _set(HttpHeaders.DATE, value);\n      } else {\n        throw new HttpException(\"Unexpected type for header named $name\");\n      }\n    } else if (lowerCaseName == HttpHeaders.EXPIRES) {\n      if (value is DateTime) {\n        expires = value;\n      } else if (value is String) {\n        _set(HttpHeaders.EXPIRES, value);\n      } else {\n        throw new HttpException(\"Unexpected type for header named $name\");\n      }\n    } else if (lowerCaseName == HttpHeaders.IF_MODIFIED_SINCE) {\n      if (value is DateTime) {\n        ifModifiedSince = value;\n      } else if (value is String) {\n        _set(HttpHeaders.IF_MODIFIED_SINCE, value);\n      } else {\n        throw new HttpException(\"Unexpected type for header named $name\");\n      }\n    } else if (lowerCaseName == HttpHeaders.HOST) {\n      if (value is String) {\n        int pos = (value as String).indexOf(\":\");\n        if (pos == -1) {\n          _host = value;\n          _port = HttpClient.DEFAULT_HTTP_PORT;\n        } else {\n          if (pos > 0) {\n            _host = (value as String).substring(0, pos);\n          } else {\n            _host = null;\n          }\n          if (pos + 1 == value.length) {\n            _port = HttpClient.DEFAULT_HTTP_PORT;\n          } else {\n            try {\n              _port = int.parse(value.substring(pos + 1));\n            } on FormatException catch (e) {\n              _port = null;\n            }\n          }\n        }\n        _set(HttpHeaders.HOST, value);\n      } else {\n        throw new HttpException(\"Unexpected type for header named $name\");\n      }\n    } else if (lowerCaseName == HttpHeaders.CONTENT_TYPE) {\n      _set(HttpHeaders.CONTENT_TYPE, value);\n    } else {\n      _addValue(lowerCaseName, value);\n    }\n  }\n\n  void _addValue(String name, Object value) {\n    List<String> values = _headers[name];\n    if (values == null) {\n      values = new List<String>();\n      _headers[name] = values;\n    }\n    if (value is DateTime) {\n      values.add(_HttpUtils.formatDate(value));\n    } else {\n      values.add(value.toString());\n    }\n  }\n\n  void _set(String name, String value) {\n    name = name.toLowerCase();\n    List<String> values = new List<String>();\n    _headers[name] = values;\n    values.add(value);\n  }\n\n  _checkMutable() {\n    if (!_mutable) throw new HttpException(\"HTTP headers are not mutable\");\n  }\n\n  _updateHostHeader() {\n    bool defaultPort = _port == null || _port == HttpClient.DEFAULT_HTTP_PORT;\n    String portPart = defaultPort ? \"\" : \":$_port\";\n    _set(\"host\", \"$host$portPart\");\n  }\n\n  _foldHeader(String name) {\n    if (name == HttpHeaders.SET_COOKIE ||\n        (_noFoldingHeaders != null &&\n         _noFoldingHeaders.indexOf(name) != -1)) {\n      return false;\n    }\n    return true;\n  }\n\n  void _synchronize() {\n    // If the content length is not known make sure chunked transfer\n    // encoding is used for HTTP 1.1.\n    if (contentLength < 0) {\n      if (protocolVersion == \"1.0\") {\n        persistentConnection = false;\n      } else {\n        chunkedTransferEncoding = true;\n      }\n    }\n    // If a Transfer-Encoding header field is present the\n    // Content-Length header MUST NOT be sent (RFC 2616 section 4.4).\n    if (chunkedTransferEncoding &&\n        contentLength >= 0 &&\n        protocolVersion == \"1.1\") {\n      contentLength = -1;\n    }\n  }\n\n  void _finalize() {\n    _synchronize();\n    _mutable = false;\n  }\n\n  _write(_BufferList buffer) {\n    final COLONSP = const [_CharCode.COLON, _CharCode.SP];\n    final COMMASP = const [_CharCode.COMMA, _CharCode.SP];\n    final CRLF = const [_CharCode.CR, _CharCode.LF];\n\n    // Format headers.\n    _headers.forEach((String name, List<String> values) {\n      bool fold = _foldHeader(name);\n      var nameData = name.codeUnits;\n      buffer.add(nameData);\n      buffer.add(const [_CharCode.COLON, _CharCode.SP]);\n      for (int i = 0; i < values.length; i++) {\n        if (i > 0) {\n          if (fold) {\n            buffer.add(const [_CharCode.COMMA, _CharCode.SP]);\n          } else {\n            buffer.add(const [_CharCode.CR, _CharCode.LF]);\n            buffer.add(nameData);\n            buffer.add(const [_CharCode.COLON, _CharCode.SP]);\n          }\n        }\n        buffer.add(values[i].codeUnits);\n      }\n      buffer.add(const [_CharCode.CR, _CharCode.LF]);\n    });\n  }\n\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    _headers.forEach((String name, List<String> values) {\n      sb.write(name);\n      sb.write(\": \");\n      bool fold = _foldHeader(name);\n      for (int i = 0; i < values.length; i++) {\n        if (i > 0) {\n          if (fold) {\n            sb.write(\", \");\n          } else {\n            sb.write(\"\\n\");\n            sb.write(name);\n            sb.write(\": \");\n          }\n        }\n        sb.write(values[i]);\n      }\n      sb.write(\"\\n\");\n    });\n    return sb.toString();\n  }\n\n  List<Cookie> _parseCookies() {\n    // Parse a Cookie header value according to the rules in RFC 6265.\n    var cookies = new List<Cookie>();\n    void parseCookieString(String s) {\n      int index = 0;\n\n      bool done() => index == s.length;\n\n      void skipWS() {\n        while (!done()) {\n         if (s[index] != \" \" && s[index] != \"\\t\") return;\n         index++;\n        }\n      }\n\n      String parseName() {\n        int start = index;\n        while (!done()) {\n          if (s[index] == \" \" || s[index] == \"\\t\" || s[index] == \"=\") break;\n          index++;\n        }\n        return s.substring(start, index).toLowerCase();\n      }\n\n      String parseValue() {\n        int start = index;\n        while (!done()) {\n          if (s[index] == \" \" || s[index] == \"\\t\" || s[index] == \";\") break;\n          index++;\n        }\n        return s.substring(start, index).toLowerCase();\n      }\n\n      void expect(String expected) {\n        if (done()) {\n          throw new HttpException(\"Failed to parse header value [$s]\");\n        }\n        if (s[index] != expected) {\n          throw new HttpException(\"Failed to parse header value [$s]\");\n        }\n        index++;\n      }\n\n      while (!done()) {\n        skipWS();\n        if (done()) return;\n        String name = parseName();\n        skipWS();\n        expect(\"=\");\n        skipWS();\n        String value = parseValue();\n        cookies.add(new _Cookie(name, value));\n        skipWS();\n        if (done()) return;\n        expect(\";\");\n      }\n    }\n    List<String> values = _headers[HttpHeaders.COOKIE];\n    if (values != null) {\n      values.forEach((headerValue) => parseCookieString(headerValue));\n    }\n    return cookies;\n  }\n\n\n  bool _mutable = true;  // Are the headers currently mutable?\n  Map<String, List<String>> _headers;\n  List<String> _noFoldingHeaders;\n\n  int _contentLength = -1;\n  bool _chunkedTransferEncoding = false;\n  final String protocolVersion;\n  String _host;\n  int _port;\n}\n\n\nclass _HeaderValue implements HeaderValue {\n  String _value;\n  Map<String, String> _parameters;\n\n  _HeaderValue([String this._value = \"\", this._parameters]);\n\n  _HeaderValue.fromString(String value, {parameterSeparator: \";\"}) {\n    // Parse the string.\n    _parse(value, parameterSeparator);\n  }\n\n  String get value => _value;\n\n  Map<String, String> get parameters {\n    if (_parameters == null) _parameters = new Map<String, String>();\n    return _parameters;\n  }\n\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    sb.write(_value);\n    if (parameters != null && parameters.length > 0) {\n      _parameters.forEach((String name, String value) {\n        sb.write(\"; \");\n        sb.write(name);\n        sb.write(\"=\");\n        sb.write(value);\n      });\n    }\n    return sb.toString();\n  }\n\n  void _parse(String s, String parameterSeparator) {\n    int index = 0;\n\n    bool done() => index == s.length;\n\n    void skipWS() {\n      while (!done()) {\n        if (s[index] != \" \" && s[index] != \"\\t\") return;\n        index++;\n      }\n    }\n\n    String parseValue() {\n      int start = index;\n      while (!done()) {\n        if (s[index] == \" \" ||\n            s[index] == \"\\t\" ||\n            s[index] == parameterSeparator) break;\n        index++;\n      }\n      return s.substring(start, index).toLowerCase();\n    }\n\n    void expect(String expected) {\n      if (done() || s[index] != expected) {\n        throw new HttpException(\"Failed to parse header value\");\n      }\n      index++;\n    }\n\n    void maybeExpect(String expected) {\n      if (s[index] == expected) index++;\n    }\n\n    void parseParameters() {\n      _parameters = new Map<String, String>();\n\n      String parseParameterName() {\n        int start = index;\n        while (!done()) {\n          if (s[index] == \" \" || s[index] == \"\\t\" || s[index] == \"=\") break;\n          index++;\n        }\n        return s.substring(start, index).toLowerCase();\n      }\n\n      String parseParameterValue() {\n        if (s[index] == \"\\\"\") {\n          // Parse quoted value.\n          StringBuffer sb = new StringBuffer();\n          index++;\n          while (!done()) {\n            if (s[index] == \"\\\\\") {\n              if (index + 1 == s.length) {\n                throw new HttpException(\"Failed to parse header value\");\n              }\n              index++;\n            } else if (s[index] == \"\\\"\") {\n              index++;\n              break;\n            }\n            sb.write(s[index]);\n            index++;\n          }\n          return sb.toString();\n        } else {\n          // Parse non-quoted value.\n          return parseValue();\n        }\n      }\n\n      while (!done()) {\n        skipWS();\n        if (done()) return;\n        String name = parseParameterName();\n        skipWS();\n        expect(\"=\");\n        skipWS();\n        String value = parseParameterValue();\n        _parameters[name] = value;\n        skipWS();\n        if (done()) return;\n        expect(parameterSeparator);\n      }\n    }\n\n    skipWS();\n    _value = parseValue();\n    skipWS();\n    if (done()) return;\n    maybeExpect(parameterSeparator);\n    parseParameters();\n  }\n}\n\n\nclass _ContentType extends _HeaderValue implements ContentType {\n  String _primaryType = \"\";\n  String _subType = \"\";\n\n  _ContentType(String primaryType,\n               String subType,\n               String charset,\n               Map<String, String> parameters)\n      : _primaryType = primaryType, _subType = subType, super(\"\") {\n    if (_primaryType == null) _primaryType = \"\";\n    if (_subType == null) _subType = \"\";\n    _value = \"$_primaryType/$_subType\";;\n    if (parameters != null) {\n      parameters.forEach((String key, String value) {\n        this.parameters[key.toLowerCase()] = value.toLowerCase();\n      });\n    }\n    if (charset != null) {\n      this.parameters[\"charset\"] = charset.toLowerCase();\n    }\n  }\n\n  _ContentType.fromString(String value) : super.fromString(value) {\n    int index = _value.indexOf(\"/\");\n    if (index == -1 || index == (_value.length - 1)) {\n      _primaryType = _value.trim().toLowerCase();\n      _subType = \"\";\n    } else {\n      _primaryType = _value.substring(0, index).trim().toLowerCase();\n      _subType = _value.substring(index + 1).trim().toLowerCase();\n    }\n  }\n\n  String get mimeType => '$primaryType/$subType';\n\n  String get primaryType => _primaryType;\n\n  String get subType => _subType;\n\n  String get charset => parameters[\"charset\"];\n}\n\n\nclass _Cookie implements Cookie {\n  _Cookie([String this.name, String this.value]);\n\n  _Cookie.fromSetCookieValue(String value) {\n    // Parse the 'set-cookie' header value.\n    _parseSetCookieValue(value);\n  }\n\n  // Parse a 'set-cookie' header value according to the rules in RFC 6265.\n  void _parseSetCookieValue(String s) {\n    int index = 0;\n\n    bool done() => index == s.length;\n\n    String parseName() {\n      int start = index;\n      while (!done()) {\n        if (s[index] == \"=\") break;\n        index++;\n      }\n      return s.substring(start, index).trim().toLowerCase();\n    }\n\n    String parseValue() {\n      int start = index;\n      while (!done()) {\n        if (s[index] == \";\") break;\n        index++;\n      }\n      return s.substring(start, index).trim().toLowerCase();\n    }\n\n    void expect(String expected) {\n      if (done()) throw new HttpException(\"Failed to parse header value [$s]\");\n      if (s[index] != expected) {\n        throw new HttpException(\"Failed to parse header value [$s]\");\n      }\n      index++;\n    }\n\n    void parseAttributes() {\n      String parseAttributeName() {\n        int start = index;\n        while (!done()) {\n          if (s[index] == \"=\" || s[index] == \";\") break;\n          index++;\n        }\n        return s.substring(start, index).trim().toLowerCase();\n      }\n\n      String parseAttributeValue() {\n        int start = index;\n        while (!done()) {\n          if (s[index] == \";\") break;\n          index++;\n        }\n        return s.substring(start, index).trim().toLowerCase();\n      }\n\n      while (!done()) {\n        String name = parseAttributeName();\n        String value = \"\";\n        if (!done() && s[index] == \"=\") {\n          index++;  // Skip the = character.\n          value = parseAttributeValue();\n        }\n        if (name == \"expires\") {\n          expires = _HttpUtils.parseCookieDate(value);\n        } else if (name == \"max-age\") {\n          maxAge = int.parse(value);\n        } else if (name == \"domain\") {\n          domain = value;\n        } else if (name == \"path\") {\n          path = value;\n        } else if (name == \"httponly\") {\n          httpOnly = true;\n        } else if (name == \"secure\") {\n          secure = true;\n        }\n        if (!done()) index++;  // Skip the ; character\n      }\n    }\n\n    name = parseName();\n    if (done() || name.length == 0) {\n      throw new HttpException(\"Failed to parse header value [$s]\");\n    }\n    index++;  // Skip the = character.\n    value = parseValue();\n    if (done()) return;\n    index++;  // Skip the ; character.\n    parseAttributes();\n  }\n\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    sb.write(name);\n    sb.write(\"=\");\n    sb.write(value);\n    if (expires != null) {\n      sb.write(\"; Expires=\");\n      sb.write(_HttpUtils.formatDate(expires));\n    }\n    if (maxAge != null) {\n      sb.write(\"; Max-Age=\");\n      sb.write(maxAge);\n    }\n    if (domain != null) {\n      sb.write(\"; Domain=\");\n      sb.write(domain);\n    }\n    if (path != null) {\n      sb.write(\"; Path=\");\n      sb.write(path);\n    }\n    if (secure) sb.write(\"; Secure\");\n    if (httpOnly) sb.write(\"; HttpOnly\");\n    return sb.toString();\n  }\n\n  String name;\n  String value;\n  DateTime expires;\n  int maxAge;\n  String domain;\n  String path;\n  bool httpOnly = false;\n  bool secure = false;\n}\n","sdk/lib/io/http_impl.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass _HttpIncoming extends Stream<List<int>> {\n  final int _transferLength;\n  final Completer _dataCompleter = new Completer();\n  Stream<List<int>> _stream;\n\n  bool fullBodyRead = false;\n\n  // Common properties.\n  final _HttpHeaders headers;\n  bool upgraded = false;\n\n  // ClientResponse properties.\n  int statusCode;\n  String reasonPhrase;\n\n  // Request properties.\n  String method;\n  Uri uri;\n\n  // The transfer length if the length of the message body as it\n  // appears in the message (RFC 2616 section 4.4). This can be -1 if\n  // the length of the massage body is not known due to transfer\n  // codings.\n  int get transferLength => _transferLength;\n\n  _HttpIncoming(_HttpHeaders this.headers,\n                int this._transferLength,\n                Stream<List<int>> this._stream) {\n  }\n\n  StreamSubscription<List<int>> listen(void onData(List<int> event),\n                                       {void onError(error),\n                                        void onDone(),\n                                        bool cancelOnError}) {\n    return _stream.listen(onData,\n                          onError: onError,\n                          onDone: onDone,\n                          cancelOnError: cancelOnError);\n  }\n\n  // Is completed once all data have been received.\n  Future get dataDone => _dataCompleter.future;\n\n  void close() {\n    fullBodyRead = true;\n    _dataCompleter.complete();\n  }\n}\n\nabstract class _HttpInboundMessage extends Stream<List<int>> {\n  final _HttpIncoming _incoming;\n  List<Cookie> _cookies;\n\n  _HttpInboundMessage(_HttpIncoming this._incoming);\n\n  List<Cookie> get cookies {\n    if (_cookies != null) return _cookies;\n    return _cookies = headers._parseCookies();\n  }\n\n  _HttpHeaders get headers => _incoming.headers;\n  String get protocolVersion => headers.protocolVersion;\n  int get contentLength => headers.contentLength;\n  bool get persistentConnection => headers.persistentConnection;\n}\n\n\nclass _HttpRequest extends _HttpInboundMessage implements HttpRequest {\n  final HttpResponse response;\n\n  // Lazy initialized parsed query parameters.\n  Map<String, String> _queryParameters;\n\n  final _HttpServer _httpServer;\n\n  final _HttpConnection _httpConnection;\n\n  _HttpSession _session;\n\n  _HttpRequest(_HttpResponse this.response,\n               _HttpIncoming _incoming,\n               _HttpServer this._httpServer,\n               _HttpConnection this._httpConnection)\n      : super(_incoming) {\n    response.headers.persistentConnection = headers.persistentConnection;\n\n    if (_httpServer._sessionManagerInstance != null) {\n      // Map to session if exists.\n      var sessionIds = cookies\n          .where((cookie) => cookie.name.toUpperCase() == _DART_SESSION_ID)\n          .map((cookie) => cookie.value);\n      for (var sessionId in sessionIds) {\n        _session = _httpServer._sessionManager.getSession(sessionId);\n        if (_session != null) {\n          _session._markSeen();\n          break;\n        }\n      }\n    }\n  }\n\n  StreamSubscription<List<int>> listen(void onData(List<int> event),\n                                       {void onError(error),\n                                        void onDone(),\n                                        bool cancelOnError}) {\n    return _incoming.listen(onData,\n                            onError: onError,\n                            onDone: onDone,\n                            cancelOnError: cancelOnError);\n  }\n\n  Map<String, String> get queryParameters {\n    if (_queryParameters == null) {\n      _queryParameters = _HttpUtils.splitQueryString(uri.query);\n    }\n    return _queryParameters;\n  }\n\n  Uri get uri => _incoming.uri;\n\n  String get method => _incoming.method;\n\n  HttpSession get session {\n    if (_session != null) {\n      // It's already mapped, use it.\n      return _session;\n    }\n    // Create session, store it in connection, and return.\n    return _session = _httpServer._sessionManager.createSession();\n  }\n\n  HttpConnectionInfo get connectionInfo => _httpConnection.connectionInfo;\n\n  X509Certificate get certificate {\n    Socket socket = _httpConnection._socket;\n    if (socket is SecureSocket) return socket.peerCertificate;\n    return null;\n  }\n}\n\n\nclass _HttpClientResponse\n    extends _HttpInboundMessage implements HttpClientResponse {\n  List<RedirectInfo> get redirects => _httpRequest._responseRedirects;\n\n  // The HttpClient this response belongs to.\n  final _HttpClient _httpClient;\n\n  // The HttpClientRequest of this response.\n  final _HttpClientRequest _httpRequest;\n\n  List<Cookie> _cookies;\n\n  _HttpClientResponse(_HttpIncoming _incoming,\n                      _HttpClientRequest this._httpRequest,\n                      _HttpClient this._httpClient)\n      : super(_incoming);\n\n  int get statusCode => _incoming.statusCode;\n  String get reasonPhrase => _incoming.reasonPhrase;\n\n  X509Certificate get certificate {\n    var socket = _httpRequest._httpClientConnection._socket;\n    return socket.peerCertificate;\n  }\n\n  List<Cookie> get cookies {\n    if (_cookies != null) return _cookies;\n    _cookies = new List<Cookie>();\n    List<String> values = headers[HttpHeaders.SET_COOKIE];\n    if (values != null) {\n      values.forEach((value) {\n        _cookies.add(new Cookie.fromSetCookieValue(value));\n      });\n    }\n    return _cookies;\n  }\n\n  bool get isRedirect {\n    if (_httpRequest.method == \"GET\" || _httpRequest.method == \"HEAD\") {\n      return statusCode == HttpStatus.MOVED_PERMANENTLY ||\n             statusCode == HttpStatus.FOUND ||\n             statusCode == HttpStatus.SEE_OTHER ||\n             statusCode == HttpStatus.TEMPORARY_REDIRECT;\n    } else if (_httpRequest.method == \"POST\") {\n      return statusCode == HttpStatus.SEE_OTHER;\n    }\n    return false;\n  }\n\n  Future<HttpClientResponse> redirect([String method,\n                                       Uri url,\n                                       bool followLoops]) {\n    if (method == null) {\n      // Set method as defined by RFC 2616 section 10.3.4.\n      if (statusCode == HttpStatus.SEE_OTHER && _httpRequest.method == \"POST\") {\n        method = \"GET\";\n      } else {\n        method = _httpRequest.method;\n      }\n    }\n    if (url == null) {\n      String location = headers.value(HttpHeaders.LOCATION);\n      if (location == null) {\n        throw new StateError(\"Response has no Location header for redirect\");\n      }\n      url = Uri.parse(location);\n    }\n    if (followLoops != true) {\n      for (var redirect in redirects) {\n        if (redirect.location == url) {\n          return new Future.error(\n              new RedirectLoopException(redirects));\n        }\n      }\n    }\n    return _httpClient._openUrlFromRequest(method, url, _httpRequest)\n        .then((request) {\n          request._responseRedirects.addAll(this.redirects);\n          request._responseRedirects.add(new _RedirectInfo(statusCode,\n                                                           method,\n                                                           url));\n          return request.close();\n        });\n  }\n\n  StreamSubscription<List<int>> listen(void onData(List<int> event),\n                                       {void onError(error),\n                                        void onDone(),\n                                        bool cancelOnError}) {\n    var stream = _incoming;\n    if (headers.value(HttpHeaders.CONTENT_ENCODING) == \"gzip\") {\n      stream = stream.transform(new ZLibInflater());\n    }\n    return stream.listen(onData,\n                         onError: onError,\n                         onDone: onDone,\n                         cancelOnError: cancelOnError);\n  }\n\n  Future<Socket> detachSocket() {\n    _httpClient._connectionClosed(_httpRequest._httpClientConnection);\n    return _httpRequest._httpClientConnection.detachSocket();\n  }\n\n  HttpConnectionInfo get connectionInfo => _httpRequest.connectionInfo;\n\n  bool get _shouldAuthenticateProxy {\n    // Only try to authenticate if there is a challenge in the response.\n    List<String> challenge = headers[HttpHeaders.PROXY_AUTHENTICATE];\n    return statusCode == HttpStatus.PROXY_AUTHENTICATION_REQUIRED &&\n        challenge != null && challenge.length == 1;\n  }\n\n  bool get _shouldAuthenticate {\n    // Only try to authenticate if there is a challenge in the response.\n    List<String> challenge = headers[HttpHeaders.WWW_AUTHENTICATE];\n    return statusCode == HttpStatus.UNAUTHORIZED &&\n        challenge != null && challenge.length == 1;\n  }\n\n  Future<HttpClientResponse> _authenticate() {\n    Future<HttpClientResponse> retryWithCredentials(_Credentials cr) {\n      if (cr != null) {\n        // TODO(sgjesse): Support digest.\n        if (cr.scheme == _AuthenticationScheme.BASIC) {\n          // Drain body and retry.\n          return fold(null, (x, y) {}).then((_) {\n              return _httpClient._openUrlFromRequest(_httpRequest.method,\n                                                     _httpRequest.uri,\n                                                     _httpRequest)\n                  .then((request) => request.close());\n            });\n        }\n      }\n\n      // Fall through to here to perform normal response handling if\n      // there is no sensible authorization handling.\n      return new Future.value(this);\n    }\n\n    List<String> challenge = headers[HttpHeaders.WWW_AUTHENTICATE];\n    assert(challenge != null || challenge.length == 1);\n    _HeaderValue header =\n        new _HeaderValue.fromString(challenge[0], parameterSeparator: \",\");\n    _AuthenticationScheme scheme =\n        new _AuthenticationScheme.fromString(header.value);\n    String realm = header.parameters[\"realm\"];\n\n    // See if any credentials are available.\n    _Credentials cr = _httpClient._findCredentials(_httpRequest.uri, scheme);\n\n    if (cr != null && !cr.used) {\n      // If credentials found prepare for retrying the request.\n      return retryWithCredentials(cr);\n    }\n\n    // Ask for more credentials if none found or the one found has\n    // already been used. If it has already been used it must now be\n    // invalid and is removed.\n    if (cr != null) {\n      _httpClient._removeCredentials(cr);\n      cr = null;\n    }\n    if (_httpClient._authenticate != null) {\n      Future authComplete = _httpClient._authenticate(_httpRequest.uri,\n                                                      scheme.toString(),\n                                                      realm);\n      return authComplete.then((credsAvailable) {\n        if (credsAvailable) {\n          cr = _httpClient._findCredentials(_httpRequest.uri, scheme);\n          return retryWithCredentials(cr);\n        } else {\n          // No credentials available, complete with original response.\n          return this;\n        }\n      });\n    }\n\n    // No credentials were found and the callback was not set.\n    return new Future.value(this);\n  }\n\n  Future<HttpClientResponse> _authenticateProxy() {\n    Future<HttpClientResponse> retryWithProxyCredentials(_ProxyCredentials cr) {\n      return fold(null, (x, y) {}).then((_) {\n          return _httpClient._openUrlFromRequest(_httpRequest.method,\n                                                 _httpRequest.uri,\n                                                 _httpRequest)\n              .then((request) => request.close());\n        });\n    }\n\n    List<String> challenge = headers[HttpHeaders.PROXY_AUTHENTICATE];\n    assert(challenge != null || challenge.length == 1);\n    _HeaderValue header =\n        new _HeaderValue.fromString(challenge[0], parameterSeparator: \",\");\n    _AuthenticationScheme scheme =\n        new _AuthenticationScheme.fromString(header.value);\n    String realm = header.parameters[\"realm\"];\n\n    // See if any credentials are available.\n    var proxy = _httpRequest._proxy;\n\n    var cr =  _httpClient._findProxyCredentials(proxy);\n    if (cr != null) {\n      return retryWithProxyCredentials(cr);\n    }\n\n    // Ask for more credentials if none found.\n    if (_httpClient._authenticateProxy != null) {\n      Future authComplete = _httpClient._authenticateProxy(proxy.host,\n                                                           proxy.port,\n                                                           \"basic\",\n                                                           realm);\n      return authComplete.then((credsAvailable) {\n        if (credsAvailable) {\n          var cr =  _httpClient._findProxyCredentials(proxy);\n          return retryWithProxyCredentials(cr);\n        } else {\n          // No credentials available, complete with original response.\n          return this;\n        }\n      });\n    }\n\n    // No credentials were found and the callback was not set.\n    return new Future.value(this);\n  }\n}\n\n\nabstract class _HttpOutboundMessage<T> implements IOSink {\n  // Used to mark when the body should be written. This is used for HEAD\n  // requests and in error handling.\n  bool _ignoreBody = false;\n  bool _headersWritten = false;\n  bool _asGZip = false;\n\n  IOSink _headersSink;\n  IOSink _dataSink;\n\n  final _HttpOutgoing _outgoing;\n\n  final _HttpHeaders headers;\n\n  _HttpOutboundMessage(String protocolVersion, _HttpOutgoing outgoing)\n      : _outgoing = outgoing,\n        _headersSink = new IOSink(outgoing, encoding: Encoding.ASCII),\n        headers = new _HttpHeaders(protocolVersion) {\n    _dataSink = new IOSink(new _HttpOutboundConsumer(this));\n  }\n\n  int get contentLength => headers.contentLength;\n  void set contentLength(int contentLength) {\n    headers.contentLength = contentLength;\n  }\n\n  bool get persistentConnection => headers.persistentConnection;\n  void set persistentConnection(bool p) {\n    headers.persistentConnection = p;\n  }\n\n  Encoding get encoding {\n    var charset;\n    if (headers.contentType != null && headers.contentType.charset != null) {\n      charset = headers.contentType.charset;\n    } else {\n      charset = \"iso-8859-1\";\n    }\n    return Encoding.fromName(charset);\n  }\n\n  void set encoding(Encoding value) {\n    throw new StateError(\"IOSink encoding is not mutable\");\n  }\n\n  void write(Object obj) {\n    _dataSink.write(obj);\n  }\n\n  void writeAll(Iterable objects, [String separator = \"\"]) {\n    _dataSink.writeAll(objects, separator);\n  }\n\n  void writeln([Object obj = \"\"]) {\n    _dataSink.writeln(obj);\n  }\n\n  void writeCharCode(int charCode) {\n    _dataSink.writeCharCode(charCode);\n  }\n\n  void add(List<int> data) {\n    if (data.length == 0) return;\n    _dataSink.add(data);\n  }\n\n  void addError(error) {\n    _dataSink.addError(error);\n  }\n\n  Future<T> addStream(Stream<List<int>> stream) {\n    return _dataSink.addStream(stream);\n  }\n\n  Future close() {\n    return _dataSink.close();\n  }\n\n  Future<T> get done => _dataSink.done;\n\n  void _writeHeaders() {\n    if (_headersWritten) return;\n    _headersWritten = true;\n    headers._synchronize();  // Be sure the 'chunked' option is updated.\n    bool isServerSide = this is _HttpResponse;\n    if (isServerSide && headers.chunkedTransferEncoding) {\n      var response = this;\n      List acceptEncodings =\n          response._httpRequest.headers[HttpHeaders.ACCEPT_ENCODING];\n      List contentEncoding = headers[HttpHeaders.CONTENT_ENCODING];\n      if (acceptEncodings != null &&\n          acceptEncodings\n              .expand((list) => list.split(\",\"))\n              .any((encoding) => encoding.trim().toLowerCase() == \"gzip\") &&\n          contentEncoding == null) {\n        headers.set(HttpHeaders.CONTENT_ENCODING, \"gzip\");\n        _asGZip = true;\n      }\n    }\n    _writeHeader();\n  }\n\n  Future _addStream(Stream<List<int>> stream) {\n    _writeHeaders();\n    int contentLength = headers.contentLength;\n    if (_ignoreBody) {\n      stream.fold(null, (x, y) {}).catchError((_) {});\n      return _headersSink.close();\n    }\n    stream = stream.transform(new _BufferTransformer());\n    if (headers.chunkedTransferEncoding) {\n      if (_asGZip) {\n        stream = stream.transform(new ZLibDeflater(gzip: true, level: 6));\n      }\n      stream = stream.transform(new _ChunkedTransformer());\n    } else if (contentLength >= 0) {\n      stream = stream.transform(new _ContentLengthValidator(contentLength));\n    }\n    return _headersSink.addStream(stream);\n  }\n\n  Future _close() {\n    // TODO(ajohnsen): Currently, contentLength, chunkedTransferEncoding and\n    // persistentConnection is not guaranteed to be in sync.\n    if (!_headersWritten) {\n      if (!_ignoreBody && headers.contentLength == -1) {\n        // If no body was written, _ignoreBody is false (it's not a HEAD\n        // request) and the content-length is unspecified, set contentLength to\n        // 0.\n        headers.chunkedTransferEncoding = false;\n        headers.contentLength = 0;\n      } else if (!_ignoreBody && headers.contentLength > 0) {\n        _headersSink.close().catchError((_) {});\n        return new Future.error(new HttpException(\n            \"No content while contentLength was specified to be greater \"\n            \" than 0: ${headers.contentLength}.\"));\n      }\n    }\n    _writeHeaders();\n    return _headersSink.close();\n  }\n\n  void _writeHeader();  // TODO(ajohnsen): Better name.\n}\n\n\nclass _HttpOutboundConsumer implements StreamConsumer {\n  final _HttpOutboundMessage _outbound;\n  StreamController _controller;\n  StreamSubscription _subscription;\n  Completer _closeCompleter = new Completer();\n  Completer _completer;\n\n  _HttpOutboundConsumer(_HttpOutboundMessage this._outbound);\n\n  void _onPause() {\n    if (_controller.isPaused) {\n      _subscription.pause();\n    } else {\n      _subscription.resume();\n    }\n  }\n\n  void _onListen() {\n    if (!_controller.hasListener && _subscription != null) {\n      _subscription.cancel();\n    }\n  }\n\n  _ensureController() {\n    if (_controller != null) return;\n    _controller = new StreamController(onPause: _onPause,\n                                       onResume: _onPause,\n                                       onListen: _onListen,\n                                       onCancel: _onListen);\n    _outbound._addStream(_controller.stream)\n        .then((_) {\n                _done();\n                _closeCompleter.complete(_outbound);\n              },\n              onError: (error) {\n                if (!_done(error)) {\n                  _closeCompleter.completeError(error);\n                }\n              });\n  }\n\n  bool _done([error]) {\n    if (_completer == null) return false;\n    var tmp = _completer;\n    _completer = null;\n    if (error != null) {\n      tmp.completeError(error);\n    } else {\n      tmp.complete(_outbound);\n    }\n    return true;\n  }\n\n  Future addStream(var stream) {\n    _ensureController();\n    _completer = new Completer();\n    _subscription = stream.listen(\n        (data) {\n          _controller.add(data);\n        },\n        onDone: () {\n          _done();\n        },\n        onError: (error) {\n          _done(error);\n        },\n        cancelOnError: true);\n    return _completer.future;\n  }\n\n  Future close() {\n    Future closeOutbound() {\n      return _outbound._close().then((_) => _outbound);\n    }\n    if (_controller == null) return closeOutbound();\n    _controller.close();\n    return _closeCompleter.future.then((_) => closeOutbound());\n  }\n}\n\n\nclass _BufferTransformer extends StreamEventTransformer<List<int>, List<int>> {\n  const int MIN_CHUNK_SIZE = 4 * 1024;\n  const int MAX_BUFFER_SIZE = 16 * 1024;\n\n  final _BufferList _buffer = new _BufferList();\n\n  void handleData(List<int> data, EventSink<List<int>> sink) {\n    // TODO(ajohnsen): Use timeout?\n    if (data.length == 0) return;\n    if (data.length >= MIN_CHUNK_SIZE) {\n      flush(sink);\n      sink.add(data);\n    } else {\n      _buffer.add(data);\n      if (_buffer.length >= MAX_BUFFER_SIZE) {\n        flush(sink);\n      }\n    }\n  }\n\n  void handleDone(EventSink<List<int>> sink) {\n    flush(sink);\n    sink.close();\n  }\n\n  void flush(EventSink<List<int>> sink) {\n    if (_buffer.length > 0) {\n      sink.add(_buffer.readBytes());\n      _buffer.clear();\n    }\n  }\n}\n\n\nclass _HttpResponse extends _HttpOutboundMessage<HttpResponse>\n    implements HttpResponse {\n  int statusCode = 200;\n  String _reasonPhrase;\n  List<Cookie> _cookies;\n  _HttpRequest _httpRequest;\n\n  _HttpResponse(String protocolVersion,\n                _HttpOutgoing _outgoing)\n      : super(protocolVersion, _outgoing);\n\n  List<Cookie> get cookies {\n    if (_cookies == null) _cookies = new List<Cookie>();\n    return _cookies;\n  }\n\n  String get reasonPhrase => _findReasonPhrase(statusCode);\n  void set reasonPhrase(String reasonPhrase) {\n    if (_headersWritten) throw new StateError(\"Header already sent\");\n    _reasonPhrase = reasonPhrase;\n  }\n\n  Future<Socket> detachSocket() {\n    if (_headersWritten) throw new StateError(\"Headers already sent\");\n    _writeHeaders();\n    var future = _httpRequest._httpConnection.detachSocket();\n    // Close connection so the socket is 'free'.\n    close();\n    done.catchError((_) {\n      // Catch any error on done, as they automatically will be\n      // propagated to the websocket.\n    });\n    return future;\n  }\n\n  HttpConnectionInfo get connectionInfo => _httpRequest.connectionInfo;\n\n  void _writeHeader() {\n    var buffer = new _BufferList();\n    writeSP() => buffer.add(const [_CharCode.SP]);\n    writeCRLF() => buffer.add(const [_CharCode.CR, _CharCode.LF]);\n\n    // Write status line.\n    if (headers.protocolVersion == \"1.1\") {\n      buffer.add(_Const.HTTP11);\n    } else {\n      buffer.add(_Const.HTTP10);\n    }\n    writeSP();\n    buffer.add(statusCode.toString().codeUnits);\n    writeSP();\n    buffer.add(reasonPhrase.codeUnits);\n    writeCRLF();\n\n    var session = _httpRequest._session;\n    if (session != null && !session._destroyed) {\n      // Mark as not new.\n      session._isNew = false;\n      // Make sure we only send the current session id.\n      bool found = false;\n      for (int i = 0; i < cookies.length; i++) {\n        if (cookies[i].name.toUpperCase() == _DART_SESSION_ID) {\n          cookies[i].value = session.id;\n          cookies[i].httpOnly = true;\n          cookies[i].path = \"/\";\n          found = true;\n        }\n      }\n      if (!found) {\n        var cookie = new Cookie(_DART_SESSION_ID, session.id);\n        cookie.httpOnly = true;\n        cookie.path = \"/\";\n        cookies.add(cookie);\n      }\n    }\n    // Add all the cookies set to the headers.\n    if (_cookies != null) {\n      _cookies.forEach((cookie) {\n        headers.add(HttpHeaders.SET_COOKIE, cookie);\n      });\n    }\n\n    headers._finalize();\n\n    // Write headers.\n    headers._write(buffer);\n    writeCRLF();\n    _headersSink.add(buffer.readBytes());\n  }\n\n  String _findReasonPhrase(int statusCode) {\n    if (_reasonPhrase != null) {\n      return _reasonPhrase;\n    }\n\n    switch (statusCode) {\n      case HttpStatus.CONTINUE: return \"Continue\";\n      case HttpStatus.SWITCHING_PROTOCOLS: return \"Switching Protocols\";\n      case HttpStatus.OK: return \"OK\";\n      case HttpStatus.CREATED: return \"Created\";\n      case HttpStatus.ACCEPTED: return \"Accepted\";\n      case HttpStatus.NON_AUTHORITATIVE_INFORMATION:\n        return \"Non-Authoritative Information\";\n      case HttpStatus.NO_CONTENT: return \"No Content\";\n      case HttpStatus.RESET_CONTENT: return \"Reset Content\";\n      case HttpStatus.PARTIAL_CONTENT: return \"Partial Content\";\n      case HttpStatus.MULTIPLE_CHOICES: return \"Multiple Choices\";\n      case HttpStatus.MOVED_PERMANENTLY: return \"Moved Permanently\";\n      case HttpStatus.FOUND: return \"Found\";\n      case HttpStatus.SEE_OTHER: return \"See Other\";\n      case HttpStatus.NOT_MODIFIED: return \"Not Modified\";\n      case HttpStatus.USE_PROXY: return \"Use Proxy\";\n      case HttpStatus.TEMPORARY_REDIRECT: return \"Temporary Redirect\";\n      case HttpStatus.BAD_REQUEST: return \"Bad Request\";\n      case HttpStatus.UNAUTHORIZED: return \"Unauthorized\";\n      case HttpStatus.PAYMENT_REQUIRED: return \"Payment Required\";\n      case HttpStatus.FORBIDDEN: return \"Forbidden\";\n      case HttpStatus.NOT_FOUND: return \"Not Found\";\n      case HttpStatus.METHOD_NOT_ALLOWED: return \"Method Not Allowed\";\n      case HttpStatus.NOT_ACCEPTABLE: return \"Not Acceptable\";\n      case HttpStatus.PROXY_AUTHENTICATION_REQUIRED:\n        return \"Proxy Authentication Required\";\n      case HttpStatus.REQUEST_TIMEOUT: return \"Request Time-out\";\n      case HttpStatus.CONFLICT: return \"Conflict\";\n      case HttpStatus.GONE: return \"Gone\";\n      case HttpStatus.LENGTH_REQUIRED: return \"Length Required\";\n      case HttpStatus.PRECONDITION_FAILED: return \"Precondition Failed\";\n      case HttpStatus.REQUEST_ENTITY_TOO_LARGE:\n        return \"Request Entity Too Large\";\n      case HttpStatus.REQUEST_URI_TOO_LONG: return \"Request-URI Too Large\";\n      case HttpStatus.UNSUPPORTED_MEDIA_TYPE: return \"Unsupported Media Type\";\n      case HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE:\n        return \"Requested range not satisfiable\";\n      case HttpStatus.EXPECTATION_FAILED: return \"Expectation Failed\";\n      case HttpStatus.INTERNAL_SERVER_ERROR: return \"Internal Server Error\";\n      case HttpStatus.NOT_IMPLEMENTED: return \"Not Implemented\";\n      case HttpStatus.BAD_GATEWAY: return \"Bad Gateway\";\n      case HttpStatus.SERVICE_UNAVAILABLE: return \"Service Unavailable\";\n      case HttpStatus.GATEWAY_TIMEOUT: return \"Gateway Time-out\";\n      case HttpStatus.HTTP_VERSION_NOT_SUPPORTED:\n        return \"Http Version not supported\";\n      default: return \"Status $statusCode\";\n    }\n  }\n}\n\n\nclass _HttpClientRequest extends _HttpOutboundMessage<HttpClientResponse>\n    implements HttpClientRequest {\n  final String method;\n  final Uri uri;\n  final List<Cookie> cookies = new List<Cookie>();\n\n  // The HttpClient this request belongs to.\n  final _HttpClient _httpClient;\n  final _HttpClientConnection _httpClientConnection;\n\n  final Completer<HttpClientResponse> _responseCompleter\n      = new Completer<HttpClientResponse>();\n\n  final _Proxy _proxy;\n\n  Future<HttpClientResponse> _response;\n\n  // TODO(ajohnsen): Get default value from client?\n  bool _followRedirects = true;\n\n  int _maxRedirects = 5;\n\n  List<RedirectInfo> _responseRedirects = [];\n\n  _HttpClientRequest(_HttpOutgoing outgoing,\n                     Uri this.uri,\n                     String this.method,\n                     _Proxy this._proxy,\n                     _HttpClient this._httpClient,\n                     _HttpClientConnection this._httpClientConnection)\n      : super(\"1.1\", outgoing) {\n    // GET and HEAD have 'content-length: 0' by default.\n    if (method == \"GET\" || method == \"HEAD\") {\n      contentLength = 0;\n    }\n  }\n\n  Future<HttpClientResponse> get done {\n    if (_response == null) {\n      _response = Future.wait([_responseCompleter.future,\n                               super.done])\n        .then((list) => list[0]);\n    }\n    return _response;\n  }\n\n  Future<HttpClientResponse> close() {\n    super.close();\n    return done;\n  }\n\n  int get maxRedirects => _maxRedirects;\n  void set maxRedirects(int maxRedirects) {\n    if (_headersWritten) throw new StateError(\"Request already sent\");\n    _maxRedirects = maxRedirects;\n  }\n\n  bool get followRedirects => _followRedirects;\n  void set followRedirects(bool followRedirects) {\n    if (_headersWritten) throw new StateError(\"Request already sent\");\n    _followRedirects = followRedirects;\n  }\n\n  HttpConnectionInfo get connectionInfo => _httpClientConnection.connectionInfo;\n\n  void _onIncoming(_HttpIncoming incoming) {\n    var response = new _HttpClientResponse(incoming,\n                                           this,\n                                          _httpClient);\n    Future<HttpClientResponse> future;\n    if (followRedirects && response.isRedirect) {\n      if (response.redirects.length < maxRedirects) {\n        // Redirect and drain response.\n        future = response.fold(null, (x, y) {})\n          .then((_) => response.redirect());\n      } else {\n        // End with exception, too many redirects.\n        future = response.fold(null, (x, y) {})\n            .then((_) => new Future.error(\n                new RedirectLimitExceededException(response.redirects)));\n      }\n    } else if (response._shouldAuthenticateProxy) {\n      future = response._authenticateProxy();\n    } else if (response._shouldAuthenticate) {\n      future = response._authenticate();\n    } else {\n      future = new Future<HttpClientResponse>.value(response);\n    }\n    future.then(\n        (v) => _responseCompleter.complete(v),\n        onError: (e) {\n          _responseCompleter.completeError(e);\n        });\n  }\n\n  void _onError(error) {\n    _responseCompleter.completeError(error);\n  }\n\n  void _writeHeader() {\n    var buffer = new _BufferList();\n    writeSP() => buffer.add(const [_CharCode.SP]);\n    writeCRLF() => buffer.add(const [_CharCode.CR, _CharCode.LF]);\n\n    buffer.add(method.codeUnits);\n    writeSP();\n    // Send the path for direct connections and the whole URL for\n    // proxy connections.\n    if (_proxy.isDirect) {\n      String path = uri.path;\n      if (path.length == 0) path = \"/\";\n      if (uri.query != \"\") {\n        if (uri.fragment != \"\") {\n          path = \"${path}?${uri.query}#${uri.fragment}\";\n        } else {\n          path = \"${path}?${uri.query}\";\n        }\n      }\n      buffer.add(path.codeUnits);\n    } else {\n      buffer.add(uri.toString().codeUnits);\n    }\n    writeSP();\n    buffer.add(_Const.HTTP11);\n    writeCRLF();\n\n    // Add the cookies to the headers.\n    if (!cookies.isEmpty) {\n      StringBuffer sb = new StringBuffer();\n      for (int i = 0; i < cookies.length; i++) {\n        if (i > 0) sb.write(\"; \");\n        sb.write(cookies[i].name);\n        sb.write(\"=\");\n        sb.write(cookies[i].value);\n      }\n      headers.add(HttpHeaders.COOKIE, sb.toString());\n    }\n\n    headers._finalize();\n\n    // Write headers.\n    headers._write(buffer);\n    writeCRLF();\n    _headersSink.add(buffer.readBytes());\n  }\n}\n\n\n// Transformer that transforms data to HTTP Chunked Encoding.\nclass _ChunkedTransformer extends StreamEventTransformer<List<int>, List<int>> {\n  void handleData(List<int> data, EventSink<List<int>> sink) {\n    sink.add(_chunkHeader(data.length));\n    if (data.length > 0) sink.add(data);\n    sink.add(_chunkFooter);\n  }\n\n  void handleDone(EventSink<List<int>> sink) {\n    handleData(const [], sink);\n    sink.close();\n  }\n\n  static List<int> _chunkHeader(int length) {\n    const hexDigits = const [0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n                             0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46];\n    var header = [];\n    if (length == 0) {\n      header.add(hexDigits[length]);\n    } else {\n      while (length > 0) {\n        header.insert(0, hexDigits[length % 16]);\n        length = length >> 4;\n      }\n    }\n    header.add(_CharCode.CR);\n    header.add(_CharCode.LF);\n    return header;\n  }\n\n  // Footer is just a CRLF.\n  static List<int> get _chunkFooter => const [_CharCode.CR, _CharCode.LF];\n}\n\n\n// Transformer that validates the content length.\nclass _ContentLengthValidator\n    extends StreamEventTransformer<List<int>, List<int>> {\n  final int expectedContentLength;\n  int _bytesWritten = 0;\n\n  _ContentLengthValidator(int this.expectedContentLength);\n\n  void handleData(List<int> data, EventSink<List<int>> sink) {\n    _bytesWritten += data.length;\n    if (_bytesWritten > expectedContentLength) {\n      sink.addError(new HttpException(\n          \"Content size exceeds specified contentLength. \"\n          \"$_bytesWritten bytes written while expected \"\n          \"$expectedContentLength. \"\n          \"[${new String.fromCharCodes(data)}]\"));\n      sink.close();\n    } else {\n      sink.add(data);\n    }\n  }\n\n  void handleDone(EventSink<List<int>> sink) {\n    if (_bytesWritten < expectedContentLength) {\n      sink.addError(new HttpException(\n          \"Content size below specified contentLength. \"\n          \" $_bytesWritten bytes written while expected \"\n          \"$expectedContentLength.\"));\n    }\n    sink.close();\n  }\n}\n\n\n// Extends StreamConsumer as this is an internal type, only used to pipe to.\nclass _HttpOutgoing implements StreamConsumer<List<int>> {\n  final Completer _doneCompleter = new Completer();\n  final StreamConsumer _consumer;\n\n  _HttpOutgoing(StreamConsumer this._consumer);\n\n  Future addStream(Stream<List<int>> stream) {\n    return _consumer.addStream(stream)\n        .catchError((error) {\n          _doneCompleter.completeError(error);\n          throw error;\n        });\n  }\n\n  Future close() {\n    _doneCompleter.complete(_consumer);\n    return new Future.value();\n  }\n\n  Future get done => _doneCompleter.future;\n}\n\n\nclass _HttpClientConnection {\n  final String key;\n  final Socket _socket;\n  final _HttpParser _httpParser;\n  StreamSubscription _subscription;\n  final _HttpClient _httpClient;\n\n  Completer<_HttpIncoming> _nextResponseCompleter;\n  Future _streamFuture;\n\n  _HttpClientConnection(String this.key,\n                        Socket this._socket,\n                        _HttpClient this._httpClient)\n      : _httpParser = new _HttpParser.responseParser() {\n    _socket.pipe(_httpParser);\n\n    // Set up handlers on the parser here, so we are sure to get 'onDone' from\n    // the parser.\n    _subscription = _httpParser.listen(\n        (incoming) {\n          // Only handle one incoming response at the time. Keep the\n          // stream paused until the response have been processed.\n          _subscription.pause();\n          // We assume the response is not here, until we have send the request.\n          assert(_nextResponseCompleter != null);\n          var completer = _nextResponseCompleter;\n          _nextResponseCompleter = null;\n          completer.complete(incoming);\n        },\n        onError: (error) {\n          if (_nextResponseCompleter != null) {\n            _nextResponseCompleter.completeError(error);\n            _nextResponseCompleter = null;\n          }\n        },\n        onDone: () {\n          close();\n        });\n  }\n\n  _HttpClientRequest send(Uri uri, int port, String method, _Proxy proxy) {\n    // Start with pausing the parser.\n    _subscription.pause();\n    var outgoing = new _HttpOutgoing(_socket);\n    // Create new request object, wrapping the outgoing connection.\n    var request = new _HttpClientRequest(outgoing,\n                                         uri,\n                                         method,\n                                         proxy,\n                                         _httpClient,\n                                         this);\n    request.headers.host = uri.domain;\n    request.headers.port = port;\n    request.headers.set(HttpHeaders.ACCEPT_ENCODING, \"gzip\");\n    if (proxy.isAuthenticated) {\n      // If the proxy configuration contains user information use that\n      // for proxy basic authorization.\n      String auth = CryptoUtils.bytesToBase64(\n          _encodeString(\"${proxy.username}:${proxy.password}\"));\n      request.headers.set(HttpHeaders.PROXY_AUTHORIZATION, \"Basic $auth\");\n    } else if (!proxy.isDirect && _httpClient._proxyCredentials.length > 0) {\n      var cr =  _httpClient._findProxyCredentials(proxy);\n      if (cr != null) {\n        cr.authorize(request);\n      }\n    }\n    if (uri.userInfo != null && !uri.userInfo.isEmpty) {\n      // If the URL contains user information use that for basic\n      // authorization.\n      String auth =\n          CryptoUtils.bytesToBase64(_encodeString(uri.userInfo));\n      request.headers.set(HttpHeaders.AUTHORIZATION, \"Basic $auth\");\n    } else {\n      // Look for credentials.\n      _Credentials cr = _httpClient._findCredentials(uri);\n      if (cr != null) {\n        cr.authorize(request);\n      }\n    }\n    // Start sending the request (lazy, delayed until the user provides\n    // data).\n    _httpParser.responseToMethod = method;\n    _streamFuture = outgoing.done\n        .then((s) {\n          // Request sent, set up response completer.\n          _nextResponseCompleter = new Completer();\n\n          // Listen for response.\n          _nextResponseCompleter.future\n              .then((incoming) {\n                incoming.dataDone.then((_) {\n                  if (incoming.headers.persistentConnection &&\n                      request.persistentConnection) {\n                    // Return connection, now we are done.\n                    _httpClient._returnConnection(this);\n                    _subscription.resume();\n                  } else {\n                    destroy();\n                  }\n                });\n                request._onIncoming(incoming);\n              })\n              // If we see a state error, we failed to get the 'first'\n              // element.\n              // Transform the error to a HttpParserException, for\n              // consistency.\n              .catchError((error) {\n                throw new HttpParserException(\n                    \"Connection closed before data was received\");\n              }, test: (error) => error is StateError)\n              .catchError((error) {\n                // We are done with the socket.\n                destroy();\n                request._onError(error);\n              });\n\n          // Resume the parser now we have a handler.\n          _subscription.resume();\n          return s;\n        }, onError: (e) {\n          destroy();\n        });\n    return request;\n  }\n\n  Future<Socket> detachSocket() {\n    return _streamFuture.then(\n        (_) => new _DetachedSocket(_socket, _httpParser.detachIncoming()));\n  }\n\n  void destroy() {\n    _httpClient._connectionClosed(this);\n    _socket.destroy();\n  }\n\n  void close() {\n    _httpClient._connectionClosed(this);\n    _streamFuture\n          // TODO(ajohnsen): Add timeout.\n        .then((_) => _socket.destroy());\n  }\n\n  HttpConnectionInfo get connectionInfo => _HttpConnectionInfo.create(_socket);\n}\n\nclass _ConnnectionInfo {\n  _ConnnectionInfo(_HttpClientConnection this.connection, _Proxy this.proxy);\n  final _HttpClientConnection connection;\n  final _Proxy proxy;\n}\n\n\nclass _HttpClient implements HttpClient {\n  // TODO(ajohnsen): Use eviction timeout.\n  static const int DEFAULT_EVICTION_TIMEOUT = 60000;\n  bool _closing = false;\n\n  final Map<String, Set<_HttpClientConnection>> _idleConnections\n      = new Map<String, Set<_HttpClientConnection>>();\n  final Set<_HttpClientConnection> _activeConnections\n      = new Set<_HttpClientConnection>();\n  final List<_Credentials> _credentials = [];\n  final List<_ProxyCredentials> _proxyCredentials = [];\n  Function _authenticate;\n  Function _authenticateProxy;\n  Function _findProxy = HttpClient.findProxyFromEnvironment;\n\n  Future<HttpClientRequest> open(String method,\n                                 String host,\n                                 int port,\n                                 String path) {\n    // TODO(sgjesse): The path set here can contain both query and\n    // fragment. They should be cracked and set correctly.\n    return _openUrl(method, new Uri.fromComponents(\n        scheme: \"http\", domain: host, port: port, path: path));\n  }\n\n  Future<HttpClientRequest> openUrl(String method, Uri url) {\n    return _openUrl(method, url);\n  }\n\n  Future<HttpClientRequest> get(String host,\n                                int port,\n                                String path) {\n    return open(\"get\", host, port, path);\n  }\n\n  Future<HttpClientRequest> getUrl(Uri url) {\n    return _openUrl(\"get\", url);\n  }\n\n  Future<HttpClientRequest> post(String host,\n                                 int port,\n                                 String path) {\n    return open(\"post\", host, port, path);\n  }\n\n  Future<HttpClientRequest> postUrl(Uri url) {\n    return _openUrl(\"post\", url);\n  }\n\n  void close({bool force: false}) {\n    _closing = true;\n    // Create flattened copy of _idleConnections, as 'destory' will manipulate\n    // it.\n    var idle = _idleConnections.values.fold(\n        [],\n        (l, e) {\n          l.addAll(e);\n          return l;\n        });\n    idle.forEach((e) {\n      e.close();\n    });\n    assert(_idleConnections.isEmpty);\n    if (force) {\n      for (var connection in _activeConnections.toList()) {\n        connection.destroy();\n      }\n      assert(_activeConnections.isEmpty);\n      _activeConnections.clear();\n    }\n  }\n\n  set authenticate(Future<bool> f(Uri url, String scheme, String realm)) {\n    _authenticate = f;\n  }\n\n  void addCredentials(Uri url, String realm, HttpClientCredentials cr) {\n    _credentials.add(new _Credentials(url, realm, cr));\n  }\n\n  set authenticateProxy(\n      Future<bool> f(String host, int port, String scheme, String realm)) {\n    _authenticateProxy = f;\n  }\n\n  void addProxyCredentials(String host,\n                           int port,\n                           String realm,\n                           HttpClientCredentials cr) {\n    _proxyCredentials.add(new _ProxyCredentials(host, port, realm, cr));\n  }\n\n  set findProxy(String f(Uri uri)) => _findProxy = f;\n\n  Future<HttpClientRequest> _openUrl(String method, Uri uri) {\n    if (method == null) {\n      throw new ArgumentError(method);\n    }\n    if (uri.domain.isEmpty || (uri.scheme != \"http\" && uri.scheme != \"https\")) {\n      throw new ArgumentError(\"Unsupported scheme '${uri.scheme}' in $uri\");\n    }\n\n    bool isSecure = (uri.scheme == \"https\");\n    int port = uri.port;\n    if (port == 0) {\n      port = isSecure ?\n          HttpClient.DEFAULT_HTTPS_PORT :\n          HttpClient.DEFAULT_HTTP_PORT;\n    }\n    // Check to see if a proxy server should be used for this connection.\n    var proxyConf = const _ProxyConfiguration.direct();\n    if (_findProxy != null) {\n      // TODO(sgjesse): Keep a map of these as normally only a few\n      // configuration strings will be used.\n      try {\n        proxyConf = new _ProxyConfiguration(_findProxy(uri));\n      } catch (error, stackTrace) {\n        return new Future.error(error, stackTrace);\n      }\n    }\n    return _getConnection(uri.domain, port, proxyConf, isSecure)\n        .then((info) {\n          return info.connection.send(uri,\n                                      port,\n                                      method.toUpperCase(),\n                                      info.proxy);\n        });\n  }\n\n  Future<HttpClientRequest> _openUrlFromRequest(String method,\n                                                Uri uri,\n                                                _HttpClientRequest previous) {\n    return openUrl(method, uri).then((_HttpClientRequest request) {\n          // Only follow redirects if initial request did.\n          request.followRedirects = previous.followRedirects;\n          // Allow same number of redirects.\n          request.maxRedirects = previous.maxRedirects;\n          // Copy headers.\n          for (var header in previous.headers._headers.keys) {\n            if (request.headers[header] == null) {\n              request.headers.set(header, previous.headers[header]);\n            }\n          }\n          request.headers.chunkedTransferEncoding = false;\n          request.contentLength = 0;\n          return request;\n        });\n  }\n\n  // Return a live connection to the idle pool.\n  void _returnConnection(_HttpClientConnection connection) {\n    _activeConnections.remove(connection);\n    if (_closing) {\n      connection.close();\n      return;\n    }\n    // TODO(ajohnsen): Listen for socket close events.\n    if (!_idleConnections.containsKey(connection.key)) {\n      _idleConnections[connection.key] = new LinkedHashSet();\n    }\n    _idleConnections[connection.key].add(connection);\n  }\n\n  // Remove a closed connnection from the active set.\n  void _connectionClosed(_HttpClientConnection connection) {\n    _activeConnections.remove(connection);\n    if (_idleConnections.containsKey(connection.key)) {\n      _idleConnections[connection.key].remove(connection);\n      if (_idleConnections[connection.key].isEmpty) {\n        _idleConnections.remove(connection.key);\n      }\n    }\n  }\n\n  // Get a new _HttpClientConnection, either from the idle pool or created from\n  // a new Socket.\n  Future<_ConnnectionInfo> _getConnection(String uriHost,\n                                          int uriPort,\n                                          _ProxyConfiguration proxyConf,\n                                          bool isSecure) {\n    Iterator<_Proxy> proxies = proxyConf.proxies.iterator;\n\n    Future<_ConnnectionInfo> connect(error) {\n      if (!proxies.moveNext()) return new Future.error(error);\n      _Proxy proxy = proxies.current;\n      String host = proxy.isDirect ? uriHost: proxy.host;\n      int port = proxy.isDirect ? uriPort: proxy.port;\n      String key = isSecure ? \"ssh:$host:$port\" : \"$host:$port\";\n      if (_idleConnections.containsKey(key)) {\n        var connection = _idleConnections[key].first;\n        _idleConnections[key].remove(connection);\n        if (_idleConnections[key].isEmpty) {\n          _idleConnections.remove(key);\n        }\n        _activeConnections.add(connection);\n        return new Future.value(new _ConnnectionInfo(connection, proxy));\n      }\n      return (isSecure && proxy.isDirect\n                  ? SecureSocket.connect(host,\n                                         port,\n                                         sendClientCertificate: true)\n                  : Socket.connect(host, port))\n        .then((socket) {\n          socket.setOption(SocketOption.TCP_NODELAY, true);\n          var connection = new _HttpClientConnection(key, socket, this);\n          _activeConnections.add(connection);\n          return new _ConnnectionInfo(connection, proxy);\n        }, onError: (error) {\n          // Continue with next proxy.\n          return connect(error);\n        });\n    }\n    return connect(new HttpException(\"No proxies given\"));\n  }\n\n  _Credentials _findCredentials(Uri url, [_AuthenticationScheme scheme]) {\n    // Look for credentials.\n    _Credentials cr =\n        _credentials.fold(null, (_Credentials prev, _Credentials value) {\n          if (value.applies(url, scheme)) {\n            if (prev == null) return value;\n            return value.uri.path.length > prev.uri.path.length ? value : prev;\n          } else {\n            return prev;\n          }\n        });\n    return cr;\n  }\n\n  _ProxyCredentials _findProxyCredentials(_Proxy proxy) {\n    // Look for credentials.\n    var it = _proxyCredentials.iterator;\n    while (it.moveNext()) {\n      if (it.current.applies(proxy, _AuthenticationScheme.BASIC)) {\n        return it.current;\n      }\n    }\n  }\n\n  void _removeCredentials(_Credentials cr) {\n    int index = _credentials.indexOf(cr);\n    if (index != -1) {\n      _credentials.removeAt(index);\n    }\n  }\n\n  static String _findProxyFromEnvironment(Uri url,\n                                          Map<String, String> environment) {\n    checkNoProxy(String option) {\n      if (option == null) return null;\n      Iterator<String> names = option.split(\",\").map((s) => s.trim()).iterator;\n      while (names.moveNext()) {\n        if (url.domain.endsWith(names.current)) {\n          return \"DIRECT\";\n        }\n      }\n      return null;\n    }\n\n    checkProxy(String option) {\n      if (option == null) return null;\n      int pos = option.indexOf(\"://\");\n      if (pos >= 0) {\n        option = option.substring(pos + 3);\n      }\n      if (option.indexOf(\":\") == -1) option = \"$option:1080\";\n      return \"PROXY $option\";\n    }\n\n    // Default to using the process current environment.\n    if (environment == null) environment = Platform.environment;\n\n    String proxyCfg;\n\n    String noProxy = environment[\"no_proxy\"];\n    if (noProxy == null) noProxy = environment[\"NO_PROXY\"];\n    if ((proxyCfg = checkNoProxy(noProxy)) != null) {\n      return proxyCfg;\n    }\n\n    if (url.scheme == \"http\") {\n      String proxy = environment[\"http_proxy\"];\n      if (proxy == null) proxy = environment[\"HTTP_PROXY\"];\n      if ((proxyCfg = checkProxy(proxy)) != null) {\n        return proxyCfg;\n      }\n    } else if (url.scheme == \"https\") {\n      String proxy = environment[\"https_proxy\"];\n      if (proxy == null) proxy = environment[\"HTTPS_PROXY\"];\n      if ((proxyCfg = checkProxy(proxy)) != null) {\n        return proxyCfg;\n      }\n    }\n    return \"DIRECT\";\n  }\n}\n\n\nclass _HttpConnection {\n  static const _ACTIVE = 0;\n  static const _IDLE = 1;\n  static const _CLOSING = 2;\n  static const _DETACHED = 3;\n\n  int _state = _IDLE;\n\n  final Socket _socket;\n  final _HttpServer _httpServer;\n  final _HttpParser _httpParser;\n  StreamSubscription _subscription;\n\n  Future _streamFuture;\n\n  _HttpConnection(Socket this._socket, _HttpServer this._httpServer)\n      : _httpParser = new _HttpParser.requestParser() {\n    _socket.pipe(_httpParser);\n    _subscription = _httpParser.listen(\n        (incoming) {\n          // Only handle one incoming request at the time. Keep the\n          // stream paused until the request has been send.\n          _subscription.pause();\n          _state = _ACTIVE;\n          var outgoing = new _HttpOutgoing(_socket);\n          var response = new _HttpResponse(incoming.headers.protocolVersion,\n                                           outgoing);\n          var request = new _HttpRequest(response, incoming, _httpServer, this);\n          _streamFuture = outgoing.done\n              .then((_) {\n                if (_state == _DETACHED) return;\n                if (response.persistentConnection &&\n                    request.persistentConnection &&\n                    incoming.fullBodyRead) {\n                  _state = _IDLE;\n                  // Resume the subscription for incoming requests as the\n                  // request is now processed.\n                  _subscription.resume();\n                } else {\n                  // Close socket, keep-alive not used or body sent before\n                  // received data was handled.\n                  destroy();\n                }\n              })\n              .catchError((e) {\n                destroy();\n              });\n          response._ignoreBody = request.method == \"HEAD\";\n          response._httpRequest = request;\n          _httpServer._handleRequest(request);\n        },\n        onDone: () {\n          destroy();\n        },\n        onError: (error) {\n          _httpServer._handleError(error);\n          destroy();\n        });\n  }\n\n  void destroy() {\n    if (_state == _CLOSING || _state == _DETACHED) return;\n    _state = _CLOSING;\n    _socket.destroy();\n    _httpServer._connectionClosed(this);\n  }\n\n  Future<Socket> detachSocket() {\n    _state = _DETACHED;\n    // Remove connection from server.\n    _httpServer._connectionClosed(this);\n\n    _HttpDetachedIncoming detachedIncoming = _httpParser.detachIncoming();\n\n    return _streamFuture.then((_) {\n      return new _DetachedSocket(_socket, detachedIncoming);\n    });\n  }\n\n  HttpConnectionInfo get connectionInfo => _HttpConnectionInfo.create(_socket);\n\n  bool get _isActive => _state == _ACTIVE;\n  bool get _isIdle => _state == _IDLE;\n  bool get _isClosing => _state == _CLOSING;\n  bool get _isDetached => _state == _DETACHED;\n}\n\n\n// HTTP server waiting for socket connections.\nclass _HttpServer extends Stream<HttpRequest> implements HttpServer {\n\n  static Future<HttpServer> bind(String host, int port, int backlog) {\n    return ServerSocket.bind(host, port, backlog).then((socket) {\n      return new _HttpServer._(socket, true);\n    });\n  }\n\n  static Future<HttpServer> bindSecure(String host,\n                                       int port,\n                                       int backlog,\n                                       String certificate_name,\n                                       bool requestClientCertificate) {\n    return SecureServerSocket.bind(\n        host,\n        port,\n        backlog,\n        certificate_name,\n        requestClientCertificate: requestClientCertificate)\n        .then((socket) {\n          return new _HttpServer._(socket, true);\n        });\n  }\n\n  _HttpServer._(this._serverSocket, this._closeServer);\n\n  _HttpServer.listenOn(ServerSocket this._serverSocket)\n      : _closeServer = false;\n\n  StreamSubscription<HttpRequest> listen(void onData(HttpRequest event),\n                                         {void onError(error),\n                                         void onDone(),\n                                         bool cancelOnError}) {\n    _serverSocket.listen(\n        (Socket socket) {\n          socket.setOption(SocketOption.TCP_NODELAY, true);\n          // Accept the client connection.\n          _HttpConnection connection = new _HttpConnection(socket, this);\n          _connections.add(connection);\n        },\n        onError: _controller.addError,\n        onDone: _controller.close);\n    return _controller.stream.listen(onData,\n                                     onError: onError,\n                                     onDone: onDone,\n                                     cancelOnError: cancelOnError);\n  }\n\n  void close() {\n    closed = true;\n    if (_serverSocket != null && _closeServer) {\n      _serverSocket.close();\n    }\n    if (_sessionManagerInstance != null) {\n      _sessionManagerInstance.close();\n      _sessionManagerInstance = null;\n    }\n    for (_HttpConnection connection in _connections.toList()) {\n      connection.destroy();\n    }\n    _connections.clear();\n  }\n\n  int get port {\n    if (closed) throw new HttpException(\"HttpServer is not bound to a socket\");\n    return _serverSocket.port;\n  }\n\n  set sessionTimeout(int timeout) {\n    _sessionManager.sessionTimeout = timeout;\n  }\n\n  void _handleRequest(HttpRequest request) {\n    _controller.add(request);\n  }\n\n  void _handleError(error) {\n    if (!closed) _controller.addError(error);\n  }\n\n  void _connectionClosed(_HttpConnection connection) {\n    _connections.remove(connection);\n  }\n\n  _HttpSessionManager get _sessionManager {\n    // Lazy init.\n    if (_sessionManagerInstance == null) {\n      _sessionManagerInstance = new _HttpSessionManager();\n    }\n    return _sessionManagerInstance;\n  }\n\n  HttpConnectionsInfo connectionsInfo() {\n    HttpConnectionsInfo result = new HttpConnectionsInfo();\n    result.total = _connections.length;\n    _connections.forEach((_HttpConnection conn) {\n      if (conn._isActive) {\n        result.active++;\n      } else if (conn._isIdle) {\n        result.idle++;\n      } else {\n        assert(conn._isClosing);\n        result.closing++;\n      }\n    });\n    return result;\n  }\n\n  _HttpSessionManager _sessionManagerInstance;\n\n  // Indicated if the http server has been closed.\n  bool closed = false;\n\n  // The server listen socket.\n  final ServerSocket _serverSocket;\n  final bool _closeServer;\n\n  // Set of currently connected clients.\n  final Set<_HttpConnection> _connections = new Set<_HttpConnection>();\n  final StreamController<HttpRequest> _controller\n      = new StreamController<HttpRequest>();\n\n  // TODO(ajohnsen): Use close queue?\n}\n\n\nclass _ProxyConfiguration {\n  static const String PROXY_PREFIX = \"PROXY \";\n  static const String DIRECT_PREFIX = \"DIRECT\";\n\n  _ProxyConfiguration(String configuration) : proxies = new List<_Proxy>() {\n    if (configuration == null) {\n      throw new HttpException(\"Invalid proxy configuration $configuration\");\n    }\n    List<String> list = configuration.split(\";\");\n    list.forEach((String proxy) {\n      proxy = proxy.trim();\n      if (!proxy.isEmpty) {\n        if (proxy.startsWith(PROXY_PREFIX)) {\n          String username;\n          String password;\n          // Skip the \"PROXY \" prefix.\n          proxy = proxy.substring(PROXY_PREFIX.length).trim();\n          // Look for proxy authentication.\n          int at = proxy.indexOf(\"@\");\n          if (at != -1) {\n            String userinfo = proxy.substring(0, at).trim();\n            proxy = proxy.substring(at + 1).trim();\n            int colon = userinfo.indexOf(\":\");\n            if (colon == -1 || colon == 0 || colon == proxy.length - 1) {\n              throw new HttpException(\n                  \"Invalid proxy configuration $configuration\");\n            }\n            username = userinfo.substring(0, colon).trim();\n            password = userinfo.substring(colon + 1).trim();\n          }\n          // Look for proxy host and port.\n          int colon = proxy.indexOf(\":\");\n          if (colon == -1 || colon == 0 || colon == proxy.length - 1) {\n            throw new HttpException(\n                \"Invalid proxy configuration $configuration\");\n          }\n          String host = proxy.substring(0, colon).trim();\n          String portString = proxy.substring(colon + 1).trim();\n          int port;\n          try {\n            port = int.parse(portString);\n          } on FormatException catch (e) {\n            throw new HttpException(\n                \"Invalid proxy configuration $configuration, \"\n                \"invalid port '$portString'\");\n          }\n          proxies.add(new _Proxy(host, port, username, password));\n        } else if (proxy.trim() == DIRECT_PREFIX) {\n          proxies.add(new _Proxy.direct());\n        } else {\n          throw new HttpException(\"Invalid proxy configuration $configuration\");\n        }\n      }\n    });\n  }\n\n  const _ProxyConfiguration.direct()\n      : proxies = const [const _Proxy.direct()];\n\n  final List<_Proxy> proxies;\n}\n\n\nclass _Proxy {\n  const _Proxy(\n      this.host, this.port, this.username, this.password) : isDirect = false;\n  const _Proxy.direct() : host = null, port = null,\n                          username = null, password = null, isDirect = true;\n\n  bool get isAuthenticated => username != null;\n\n  final String host;\n  final int port;\n  final String username;\n  final String password;\n  final bool isDirect;\n}\n\n\nclass _HttpConnectionInfo implements HttpConnectionInfo {\n  static _HttpConnectionInfo create(Socket socket) {\n    if (socket == null) return null;\n    try {\n      _HttpConnectionInfo info = new _HttpConnectionInfo._();\n      info.remoteHost = socket.remoteHost;\n      info.remotePort = socket.remotePort;\n      info.localPort = socket.port;\n      return info;\n    } catch (e) { }\n    return null;\n  }\n\n  _HttpConnectionInfo._();\n\n  String remoteHost;\n  int remotePort;\n  int localPort;\n}\n\n\nclass _DetachedSocket extends Stream<List<int>> implements Socket {\n  final Stream<List<int>> _incoming;\n  final Socket _socket;\n\n  _DetachedSocket(this._socket, this._incoming);\n\n  StreamSubscription<List<int>> listen(void onData(List<int> event),\n                                       {void onError(error),\n                                        void onDone(),\n                                        bool cancelOnError}) {\n    return _incoming.listen(onData,\n                            onError: onError,\n                            onDone: onDone,\n                            cancelOnError: cancelOnError);\n  }\n\n  Encoding get encoding => _socket.encoding;\n\n  void set encoding(Encoding value) {\n    _socket.encoding = value;\n  }\n\n  void write(Object obj) => _socket.write(obj);\n\n  void writeln([Object obj = \"\"]) => _socket.writeln(obj);\n\n  void writeCharCode(int charCode) => _socket.writeCharCode(charCode);\n\n  void writeAll(Iterable objects, [String separator = \"\"]) {\n    _socket.writeAll(objects, separator);\n  }\n\n  void add(List<int> bytes) => _socket.add(bytes);\n\n  void addError(error) => _socket.addError(error);\n\n  Future<Socket> addStream(Stream<List<int>> stream) {\n    return _socket.addStream(stream);\n  }\n\n  void destroy() => _socket.destroy();\n\n  Future close() => _socket.close();\n\n  Future<Socket> get done => _socket.done;\n\n  int get port => _socket.port;\n\n  InternetAddress get address => _socket.address;\n\n  String get remoteHost => _socket.remoteHost;\n\n  int get remotePort => _socket.remotePort;\n\n  bool setOption(SocketOption option, bool enabled) {\n    return _socket.setOption(option, enabled);\n  }\n}\n\n\nclass _AuthenticationScheme {\n  static const UNKNOWN = const _AuthenticationScheme(-1);\n  static const BASIC = const _AuthenticationScheme(0);\n  static const DIGEST = const _AuthenticationScheme(1);\n\n  const _AuthenticationScheme(this._scheme);\n\n  factory _AuthenticationScheme.fromString(String scheme) {\n    if (scheme.toLowerCase() == \"basic\") return BASIC;\n    if (scheme.toLowerCase() == \"digest\") return DIGEST;\n    return UNKNOWN;\n  }\n\n  String toString() {\n    if (this == BASIC) return \"Basic\";\n    if (this == DIGEST) return \"Digest\";\n    return \"Unknown\";\n  }\n\n  final int _scheme;\n}\n\n\nclass _Credentials {\n  _Credentials(this.uri, this.realm, this.credentials);\n\n  _AuthenticationScheme get scheme => credentials.scheme;\n\n  bool applies(Uri uri, _AuthenticationScheme scheme) {\n    if (scheme != null && credentials.scheme != scheme) return false;\n    if (uri.domain != this.uri.domain) return false;\n    int thisPort =\n        this.uri.port == 0 ? HttpClient.DEFAULT_HTTP_PORT : this.uri.port;\n    int otherPort = uri.port == 0 ? HttpClient.DEFAULT_HTTP_PORT : uri.port;\n    if (otherPort != thisPort) return false;\n    return uri.path.startsWith(this.uri.path);\n  }\n\n  void authorize(HttpClientRequest request) {\n    credentials.authorize(this, request);\n    used = true;\n  }\n\n  bool used = false;\n  Uri uri;\n  String realm;\n  _HttpClientCredentials credentials;\n\n  // Digest specific fields.\n  String nonce;\n  String algorithm;\n  String qop;\n}\n\n\nclass _ProxyCredentials {\n  _ProxyCredentials(this.host, this.port, this.realm, this.credentials);\n\n  _AuthenticationScheme get scheme => credentials.scheme;\n\n  bool applies(_Proxy proxy, _AuthenticationScheme scheme) {\n    return proxy.host == host && proxy.port == port;\n  }\n\n  void authorize(HttpClientRequest request) {\n    credentials.authorizeProxy(this, request);\n  }\n\n  String host;\n  int port;\n  String realm;\n  _HttpClientCredentials credentials;\n}\n\n\nabstract class _HttpClientCredentials implements HttpClientCredentials {\n  _AuthenticationScheme get scheme;\n  void authorize(_Credentials credentials, HttpClientRequest request);\n  void authorizeProxy(_ProxyCredentials credentials, HttpClientRequest request);\n}\n\n\nclass _HttpClientBasicCredentials\n    extends _HttpClientCredentials\n    implements HttpClientBasicCredentials {\n  _HttpClientBasicCredentials(this.username,\n                              this.password);\n\n  _AuthenticationScheme get scheme => _AuthenticationScheme.BASIC;\n\n  String authorization() {\n    // There is no mentioning of username/password encoding in RFC\n    // 2617. However there is an open draft for adding an additional\n    // accept-charset parameter to the WWW-Authenticate and\n    // Proxy-Authenticate headers, see\n    // http://tools.ietf.org/html/draft-reschke-basicauth-enc-06. For\n    // now always use UTF-8 encoding.\n    String auth =\n        CryptoUtils.bytesToBase64(_encodeString(\"$username:$password\"));\n    return \"Basic $auth\";\n  }\n\n  void authorize(_Credentials _, HttpClientRequest request) {\n    request.headers.set(HttpHeaders.AUTHORIZATION, authorization());\n  }\n\n  void authorizeProxy(_ProxyCredentials _, HttpClientRequest request) {\n    request.headers.set(HttpHeaders.PROXY_AUTHORIZATION, authorization());\n  }\n\n  String username;\n  String password;\n}\n\n\nclass _HttpClientDigestCredentials\n    extends _HttpClientCredentials\n    implements HttpClientDigestCredentials {\n  _HttpClientDigestCredentials(this.username,\n                               this.password);\n\n  _AuthenticationScheme get scheme => _AuthenticationScheme.DIGEST;\n\n  void authorize(_Credentials credentials, HttpClientRequest request) {\n    // TODO(sgjesse): Implement!!!\n    throw new UnsupportedError(\"Digest authentication not yet supported\");\n  }\n\n  void authorizeProxy(_ProxyCredentials credentials,\n                      HttpClientRequest request) {\n    // TODO(sgjesse): Implement!!!\n    throw new UnsupportedError(\"Digest authentication not yet supported\");\n  }\n\n  String username;\n  String password;\n}\n\n\nclass _RedirectInfo implements RedirectInfo {\n  const _RedirectInfo(int this.statusCode,\n                      String this.method,\n                      Uri this.location);\n  final int statusCode;\n  final String method;\n  final Uri location;\n}\n","sdk/lib/io/http_parser.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n// Global constants.\nclass _Const {\n  // Bytes for \"HTTP\".\n  static const HTTP = const [72, 84, 84, 80];\n  // Bytes for \"HTTP/1.\".\n  static const HTTP1DOT = const [72, 84, 84, 80, 47, 49, 46];\n  // Bytes for \"HTTP/1.0\".\n  static const HTTP10 = const [72, 84, 84, 80, 47, 49, 46, 48];\n  // Bytes for \"HTTP/1.1\".\n  static const HTTP11 = const [72, 84, 84, 80, 47, 49, 46, 49];\n\n  static const END_CHUNKED = const [0x30, 13, 10, 13, 10];\n\n  // Bytes for '()<>@,;:\\\\\"/[]?={} \\t'.\n  static const SEPARATORS = const [40, 41, 60, 62, 64, 44, 59, 58, 92, 34, 47,\n                                   91, 93, 63, 61, 123, 125, 32, 9];\n\n  // Bytes for '()<>@,;:\\\\\"/[]?={} \\t\\r\\n'.\n  static const SEPARATORS_AND_CR_LF = const [40, 41, 60, 62, 64, 44, 59, 58, 92,\n                                             34, 47, 91, 93, 63, 61, 123, 125,\n                                             32, 9, 13, 10];\n}\n\n\n// Frequently used character codes.\nclass _CharCode {\n  static const int HT = 9;\n  static const int LF = 10;\n  static const int CR = 13;\n  static const int SP = 32;\n  static const int COMMA = 44;\n  static const int DASH = 45;\n  static const int SLASH = 47;\n  static const int ZERO = 48;\n  static const int ONE = 49;\n  static const int COLON = 58;\n  static const int SEMI_COLON = 59;\n}\n\n\n// States of the HTTP parser state machine.\nclass _State {\n  static const int START = 0;\n  static const int METHOD_OR_RESPONSE_HTTP_VERSION = 1;\n  static const int RESPONSE_HTTP_VERSION = 2;\n  static const int REQUEST_LINE_METHOD = 3;\n  static const int REQUEST_LINE_URI = 4;\n  static const int REQUEST_LINE_HTTP_VERSION = 5;\n  static const int REQUEST_LINE_ENDING = 6;\n  static const int RESPONSE_LINE_STATUS_CODE = 7;\n  static const int RESPONSE_LINE_REASON_PHRASE = 8;\n  static const int RESPONSE_LINE_ENDING = 9;\n  static const int HEADER_START = 10;\n  static const int HEADER_FIELD = 11;\n  static const int HEADER_VALUE_START = 12;\n  static const int HEADER_VALUE = 13;\n  static const int HEADER_VALUE_FOLDING_OR_ENDING = 14;\n  static const int HEADER_VALUE_FOLD_OR_END = 15;\n  static const int HEADER_ENDING = 16;\n\n  static const int CHUNK_SIZE_STARTING_CR = 17;\n  static const int CHUNK_SIZE_STARTING_LF = 18;\n  static const int CHUNK_SIZE = 19;\n  static const int CHUNK_SIZE_EXTENSION = 20;\n  static const int CHUNK_SIZE_ENDING = 21;\n  static const int CHUNKED_BODY_DONE_CR = 22;\n  static const int CHUNKED_BODY_DONE_LF = 23;\n  static const int BODY = 24;\n  static const int CLOSED = 25;\n  static const int UPGRADED = 26;\n  static const int FAILURE = 27;\n\n  static const int FIRST_BODY_STATE = CHUNK_SIZE_STARTING_CR;\n}\n\n// HTTP version of the request or response being parsed.\nclass _HttpVersion {\n  static const int UNDETERMINED = 0;\n  static const int HTTP10 = 1;\n  static const int HTTP11 = 2;\n}\n\n// States of the HTTP parser state machine.\nclass _MessageType {\n  static const int UNDETERMINED = 0;\n  static const int REQUEST = 1;\n  static const int RESPONSE = 0;\n}\n\nclass _HttpDetachedIncoming extends Stream<List<int>> {\n  StreamController<List<int>> controller;\n  final StreamSubscription subscription;\n\n  List<int> carryOverData;\n  bool paused;\n\n  Completer resumeCompleter;\n\n  _HttpDetachedIncoming(StreamSubscription this.subscription,\n                        List<int> this.carryOverData,\n                        Completer oldResumeCompleter) {\n    controller = new StreamController<List<int>>(\n        onListen: resume,\n        onPause: pause,\n        onResume: resume,\n        onCancel: () => subscription.cancel());\n    if (subscription == null) {\n      // Socket was already closed.\n      if (carryOverData != null) controller.add(carryOverData);\n      controller.close();\n    } else {\n      pause();\n      if (oldResumeCompleter != null) oldResumeCompleter.complete();\n      subscription.resume();\n      subscription.onData(controller.add);\n      subscription.onDone(controller.close);\n      subscription.onError(controller.addError);\n    }\n  }\n\n  StreamSubscription<List<int>> listen(void onData(List<int> event),\n                                       {void onError(error),\n                                        void onDone(),\n                                        bool cancelOnError}) {\n    return controller.stream.listen(\n        onData,\n        onError: onError,\n        onDone: onDone,\n        cancelOnError: cancelOnError);\n  }\n\n  void resume() {\n    paused = false;\n    if (carryOverData != null) {\n      var data = carryOverData;\n      carryOverData = null;\n      controller.add(data);\n      // If the consumer pauses again after the carry-over data, we'll not\n      // continue our subscriber until the next resume.\n      if (paused) return;\n    }\n    if (resumeCompleter != null) {\n      resumeCompleter.complete();\n      resumeCompleter = null;\n    }\n  }\n\n  void pause() {\n    paused = true;\n    if (resumeCompleter == null) {\n      resumeCompleter = new Completer();\n      subscription.pause(resumeCompleter.future);\n    }\n  }\n}\n\n\n/**\n * HTTP parser which parses the data stream given to [consume].\n *\n * If an HTTP parser error occours, the parser will signal an error to either\n * the current _HttpIncoming or the _parser itself.\n *\n * The connection upgrades (e.g. switching from HTTP/1.1 to the\n * WebSocket protocol) is handled in a special way. If connection\n * upgrade is specified in the headers, then on the callback to\n * [:responseStart:] the [:upgrade:] property on the [:HttpParser:]\n * object will be [:true:] indicating that from now on the protocol is\n * not HTTP anymore and no more callbacks will happen, that is\n * [:dataReceived:] and [:dataEnd:] are not called in this case as\n * there is no more HTTP data. After the upgrade the method\n * [:readUnparsedData:] can be used to read any remaining bytes in the\n * HTTP parser which are part of the protocol the connection is\n * upgrading to. These bytes cannot be processed by the HTTP parser\n * and should be handled according to whatever protocol is being\n * upgraded to.\n */\nclass _HttpParser\n    extends Stream<_HttpIncoming>\n    implements StreamConsumer<List<int>> {\n\n  factory _HttpParser.requestParser() {\n    return new _HttpParser._(true);\n  }\n\n  factory _HttpParser.responseParser() {\n    return new _HttpParser._(false);\n  }\n\n  _HttpParser._(this._requestParser) {\n    _controller = new StreamController<_HttpIncoming>(\n          onListen: _updateParsePauseState,\n          onPause: _updateParsePauseState,\n          onResume: _updateParsePauseState,\n          onCancel: _updateParsePauseState);\n    _reset();\n  }\n\n\n  StreamSubscription<_HttpIncoming> listen(void onData(_HttpIncoming event),\n                                           {void onError(error),\n                                            void onDone(),\n                                            bool cancelOnError}) {\n    return _controller.stream.listen(onData,\n                                     onError: onError,\n                                     onDone: onDone,\n                                     cancelOnError: cancelOnError);\n  }\n\n  Future<_HttpParser> addStream(Stream<List<int>> stream) {\n    // Listen to the stream and handle data accordingly. When a\n    // _HttpIncoming is created, _dataPause, _dataResume, _dataDone is\n    // given to provide a way of controlling the parser.\n    // TODO(ajohnsen): Remove _dataPause, _dataResume and _dataDone and clean up\n    // how the _HttpIncoming signals the parser.\n    var completer = new Completer();\n    _socketSubscription = stream.listen(\n        _onData,\n        onError: _onError,\n        onDone: () {\n          completer.complete(this);\n        });\n    return completer.future;\n  }\n\n  Future<_HttpParser> close() {\n    _onDone();\n    return new Future.value(this);\n  }\n\n  void _parse() {\n    try {\n      _doParse();\n    } catch (e, s) {\n      _state = _State.FAILURE;\n      error(e, s);\n    }\n  }\n\n  // From RFC 2616.\n  // generic-message = start-line\n  //                   *(message-header CRLF)\n  //                   CRLF\n  //                   [ message-body ]\n  // start-line      = Request-Line | Status-Line\n  // Request-Line    = Method SP Request-URI SP HTTP-Version CRLF\n  // Status-Line     = HTTP-Version SP Status-Code SP Reason-Phrase CRLF\n  // message-header  = field-name \":\" [ field-value ]\n  void _doParse() {\n    assert(!_parserCalled);\n    _parserCalled = true;\n    if (_state == _State.CLOSED) {\n      throw new HttpParserException(\"Data on closed connection\");\n    }\n    if (_state == _State.FAILURE) {\n      throw new HttpParserException(\"Data on failed connection\");\n    }\n    while (_buffer != null &&\n           _index < _buffer.length &&\n           _state != _State.FAILURE &&\n           _state != _State.UPGRADED) {\n      if (_paused) {\n        _parserCalled = false;\n        return;\n      }\n      int byte = _buffer[_index++];\n      switch (_state) {\n        case _State.START:\n          if (byte == _Const.HTTP[0]) {\n            // Start parsing method or HTTP version.\n            _httpVersionIndex = 1;\n            _state = _State.METHOD_OR_RESPONSE_HTTP_VERSION;\n          } else {\n            // Start parsing method.\n            if (!_isTokenChar(byte)) {\n              throw new HttpParserException(\"Invalid request method\");\n            }\n            _method_or_status_code.add(byte);\n            if (!_requestParser) {\n              throw new HttpParserException(\"Invalid response line\");\n            }\n            _state = _State.REQUEST_LINE_METHOD;\n          }\n          break;\n\n        case _State.METHOD_OR_RESPONSE_HTTP_VERSION:\n          if (_httpVersionIndex < _Const.HTTP.length &&\n              byte == _Const.HTTP[_httpVersionIndex]) {\n            // Continue parsing HTTP version.\n            _httpVersionIndex++;\n          } else if (_httpVersionIndex == _Const.HTTP.length &&\n                     byte == _CharCode.SLASH) {\n            // HTTP/ parsed. As method is a token this cannot be a\n            // method anymore.\n            _httpVersionIndex++;\n            if (_requestParser) {\n              throw new HttpParserException(\"Invalid request line\");\n            }\n            _state = _State.RESPONSE_HTTP_VERSION;\n          } else {\n            // Did not parse HTTP version. Expect method instead.\n            for (int i = 0; i < _httpVersionIndex; i++) {\n              _method_or_status_code.add(_Const.HTTP[i]);\n            }\n            if (byte == _CharCode.SP) {\n              _state = _State.REQUEST_LINE_URI;\n            } else {\n              _method_or_status_code.add(byte);\n              _httpVersion = _HttpVersion.UNDETERMINED;\n              if (!_requestParser) {\n                throw new HttpParserException(\"Invalid response line\");\n              }\n              _state = _State.REQUEST_LINE_METHOD;\n            }\n          }\n          break;\n\n        case _State.RESPONSE_HTTP_VERSION:\n          if (_httpVersionIndex < _Const.HTTP1DOT.length) {\n            // Continue parsing HTTP version.\n            _expect(byte, _Const.HTTP1DOT[_httpVersionIndex]);\n            _httpVersionIndex++;\n          } else if (_httpVersionIndex == _Const.HTTP1DOT.length &&\n                     byte == _CharCode.ONE) {\n            // HTTP/1.1 parsed.\n            _httpVersion = _HttpVersion.HTTP11;\n            _persistentConnection = true;\n            _httpVersionIndex++;\n          } else if (_httpVersionIndex == _Const.HTTP1DOT.length &&\n                     byte == _CharCode.ZERO) {\n            // HTTP/1.0 parsed.\n            _httpVersion = _HttpVersion.HTTP10;\n            _persistentConnection = false;\n            _httpVersionIndex++;\n          } else if (_httpVersionIndex == _Const.HTTP1DOT.length + 1) {\n            _expect(byte, _CharCode.SP);\n            // HTTP version parsed.\n            _state = _State.RESPONSE_LINE_STATUS_CODE;\n          } else {\n            throw new HttpParserException(\"Invalid response line\");\n          }\n          break;\n\n        case _State.REQUEST_LINE_METHOD:\n          if (byte == _CharCode.SP) {\n            _state = _State.REQUEST_LINE_URI;\n          } else {\n            if (_Const.SEPARATORS_AND_CR_LF.indexOf(byte) != -1) {\n              throw new HttpParserException(\"Invalid request method\");\n            }\n            _method_or_status_code.add(byte);\n          }\n          break;\n\n        case _State.REQUEST_LINE_URI:\n          if (byte == _CharCode.SP) {\n            if (_uri_or_reason_phrase.length == 0) {\n              throw new HttpParserException(\"Invalid request URI\");\n            }\n            _state = _State.REQUEST_LINE_HTTP_VERSION;\n            _httpVersionIndex = 0;\n          } else {\n            if (byte == _CharCode.CR || byte == _CharCode.LF) {\n              throw new HttpParserException(\"Invalid request URI\");\n            }\n            _uri_or_reason_phrase.add(byte);\n          }\n          break;\n\n        case _State.REQUEST_LINE_HTTP_VERSION:\n          if (_httpVersionIndex < _Const.HTTP1DOT.length) {\n            _expect(byte, _Const.HTTP11[_httpVersionIndex]);\n            _httpVersionIndex++;\n          } else if (_httpVersionIndex == _Const.HTTP1DOT.length) {\n            if (byte == _CharCode.ONE) {\n              // HTTP/1.1 parsed.\n              _httpVersion = _HttpVersion.HTTP11;\n              _persistentConnection = true;\n              _httpVersionIndex++;\n            } else if (byte == _CharCode.ZERO) {\n              // HTTP/1.0 parsed.\n              _httpVersion = _HttpVersion.HTTP10;\n              _persistentConnection = false;\n              _httpVersionIndex++;\n            } else {\n              throw new HttpParserException(\"Invalid response line\");\n            }\n          } else {\n            _expect(byte, _CharCode.CR);\n            _state = _State.REQUEST_LINE_ENDING;\n          }\n          break;\n\n        case _State.REQUEST_LINE_ENDING:\n          _expect(byte, _CharCode.LF);\n          _messageType = _MessageType.REQUEST;\n          _state = _State.HEADER_START;\n          break;\n\n        case _State.RESPONSE_LINE_STATUS_CODE:\n          if (byte == _CharCode.SP) {\n            if (_method_or_status_code.length != 3) {\n              throw new HttpParserException(\"Invalid response status code\");\n            }\n            _state = _State.RESPONSE_LINE_REASON_PHRASE;\n          } else {\n            if (byte < 0x30 && 0x39 < byte) {\n              throw new HttpParserException(\"Invalid response status code\");\n            } else {\n              _method_or_status_code.add(byte);\n            }\n          }\n          break;\n\n        case _State.RESPONSE_LINE_REASON_PHRASE:\n          if (byte == _CharCode.CR) {\n            _state = _State.RESPONSE_LINE_ENDING;\n          } else {\n            if (byte == _CharCode.CR || byte == _CharCode.LF) {\n              throw new HttpParserException(\"Invalid response reason phrase\");\n            }\n            _uri_or_reason_phrase.add(byte);\n          }\n          break;\n\n        case _State.RESPONSE_LINE_ENDING:\n          _expect(byte, _CharCode.LF);\n          _messageType == _MessageType.RESPONSE;\n          _statusCode = int.parse(\n              new String.fromCharCodes(_method_or_status_code));\n          if (_statusCode < 100 || _statusCode > 599) {\n            throw new HttpParserException(\"Invalid response status code\");\n          } else {\n            // Check whether this response will never have a body.\n            _noMessageBody = _statusCode <= 199 || _statusCode == 204 ||\n                _statusCode == 304;\n          }\n          _state = _State.HEADER_START;\n          break;\n\n        case _State.HEADER_START:\n          _headers = new _HttpHeaders(version);\n          if (byte == _CharCode.CR) {\n            _state = _State.HEADER_ENDING;\n          } else {\n            // Start of new header field.\n            _headerField.add(_toLowerCase(byte));\n            _state = _State.HEADER_FIELD;\n          }\n          break;\n\n        case _State.HEADER_FIELD:\n          if (byte == _CharCode.COLON) {\n            _state = _State.HEADER_VALUE_START;\n          } else {\n            if (!_isTokenChar(byte)) {\n              throw new HttpParserException(\"Invalid header field name\");\n            }\n            _headerField.add(_toLowerCase(byte));\n          }\n          break;\n\n        case _State.HEADER_VALUE_START:\n          if (byte == _CharCode.CR) {\n            _state = _State.HEADER_VALUE_FOLDING_OR_ENDING;\n          } else if (byte != _CharCode.SP && byte != _CharCode.HT) {\n            // Start of new header value.\n            _headerValue.add(byte);\n            _state = _State.HEADER_VALUE;\n          }\n          break;\n\n        case _State.HEADER_VALUE:\n          if (byte == _CharCode.CR) {\n            _state = _State.HEADER_VALUE_FOLDING_OR_ENDING;\n          } else {\n            _headerValue.add(byte);\n          }\n          break;\n\n        case _State.HEADER_VALUE_FOLDING_OR_ENDING:\n          _expect(byte, _CharCode.LF);\n          _state = _State.HEADER_VALUE_FOLD_OR_END;\n          break;\n\n        case _State.HEADER_VALUE_FOLD_OR_END:\n          if (byte == _CharCode.SP || byte == _CharCode.HT) {\n            _state = _State.HEADER_VALUE_START;\n          } else {\n            String headerField = new String.fromCharCodes(_headerField);\n            String headerValue = new String.fromCharCodes(_headerValue);\n            if (headerField == \"transfer-encoding\" &&\n                       headerValue.toLowerCase() == \"chunked\") {\n              _chunked = true;\n            }\n            if (headerField == \"connection\") {\n              List<String> tokens = _tokenizeFieldValue(headerValue);\n              for (int i = 0; i < tokens.length; i++) {\n                if (tokens[i].toLowerCase() == \"upgrade\") {\n                  _connectionUpgrade = true;\n                }\n                _headers.add(headerField, tokens[i]);\n              }\n            } else {\n              _headers.add(headerField, headerValue);\n            }\n            _headerField.clear();\n            _headerValue.clear();\n\n            if (byte == _CharCode.CR) {\n              _state = _State.HEADER_ENDING;\n            } else {\n              // Start of new header field.\n              _headerField.add(_toLowerCase(byte));\n              _state = _State.HEADER_FIELD;\n            }\n          }\n          break;\n\n        case _State.HEADER_ENDING:\n          _expect(byte, _CharCode.LF);\n          _headers._mutable = false;\n\n          _transferLength = _headers.contentLength;\n          // Ignore the Content-Length header if Transfer-Encoding\n          // is chunked (RFC 2616 section 4.4)\n          if (_chunked) _transferLength = -1;\n\n          // If a request message has neither Content-Length nor\n          // Transfer-Encoding the message must not have a body (RFC\n          // 2616 section 4.3).\n          if (_messageType == _MessageType.REQUEST &&\n              _transferLength < 0 &&\n              _chunked == false) {\n            _transferLength = 0;\n          }\n          if (_connectionUpgrade) {\n            _state = _State.UPGRADED;\n            _transferLength = 0;\n          }\n          _createIncoming(_transferLength);\n          if (_requestParser) {\n            _incoming.method =\n                new String.fromCharCodes(_method_or_status_code);\n            _incoming.uri =\n                Uri.parse(\n                    new String.fromCharCodes(_uri_or_reason_phrase));\n          } else {\n            _incoming.statusCode = _statusCode;\n            _incoming.reasonPhrase =\n                new String.fromCharCodes(_uri_or_reason_phrase);\n          }\n          _method_or_status_code.clear();\n          _uri_or_reason_phrase.clear();\n          if (_connectionUpgrade) {\n            _incoming.upgraded = true;\n            _controller.add(_incoming);\n            break;\n          }\n          if (_transferLength == 0 ||\n              (_messageType == _MessageType.RESPONSE &&\n               (_noMessageBody || _responseToMethod == \"HEAD\"))) {\n            _reset();\n            var tmp = _incoming;\n            _closeIncoming();\n            _controller.add(tmp);\n            break;\n          } else if (_chunked) {\n            _state = _State.CHUNK_SIZE;\n            _remainingContent = 0;\n          } else if (_transferLength > 0) {\n            _remainingContent = _transferLength;\n            _state = _State.BODY;\n          } else {\n            // Neither chunked nor content length. End of body\n            // indicated by close.\n            _state = _State.BODY;\n          }\n          _controller.add(_incoming);\n          break;\n\n        case _State.CHUNK_SIZE_STARTING_CR:\n          _expect(byte, _CharCode.CR);\n          _state = _State.CHUNK_SIZE_STARTING_LF;\n          break;\n\n        case _State.CHUNK_SIZE_STARTING_LF:\n          _expect(byte, _CharCode.LF);\n          _state = _State.CHUNK_SIZE;\n          break;\n\n        case _State.CHUNK_SIZE:\n          if (byte == _CharCode.CR) {\n            _state = _State.CHUNK_SIZE_ENDING;\n          } else if (byte == _CharCode.SEMI_COLON) {\n            _state = _State.CHUNK_SIZE_EXTENSION;\n          } else {\n            int value = _expectHexDigit(byte);\n            _remainingContent = _remainingContent * 16 + value;\n          }\n          break;\n\n        case _State.CHUNK_SIZE_EXTENSION:\n          if (byte == _CharCode.CR) {\n            _state = _State.CHUNK_SIZE_ENDING;\n          }\n          break;\n\n        case _State.CHUNK_SIZE_ENDING:\n          _expect(byte, _CharCode.LF);\n          if (_remainingContent > 0) {\n            _state = _State.BODY;\n          } else {\n            _state = _State.CHUNKED_BODY_DONE_CR;\n          }\n          break;\n\n        case _State.CHUNKED_BODY_DONE_CR:\n          _expect(byte, _CharCode.CR);\n          _state = _State.CHUNKED_BODY_DONE_LF;\n          break;\n\n        case _State.CHUNKED_BODY_DONE_LF:\n          _expect(byte, _CharCode.LF);\n          _reset();\n          _closeIncoming();\n          break;\n\n        case _State.BODY:\n          // The body is not handled one byte at a time but in blocks.\n          _index--;\n          int dataAvailable = _buffer.length - _index;\n          List<int> data;\n          if (_remainingContent == null ||\n              dataAvailable <= _remainingContent) {\n            if (_index == 0) {\n              data = _buffer;\n            } else {\n              data = new Uint8List(dataAvailable);\n              data.setRange(0, dataAvailable, _buffer, _index);\n            }\n          } else {\n            data = new Uint8List(_remainingContent);\n            data.setRange(0, _remainingContent, _buffer, _index);\n          }\n          _bodyController.add(data);\n          if (_remainingContent != null) {\n            _remainingContent -= data.length;\n          }\n          _index += data.length;\n          if (_remainingContent == 0) {\n            if (!_chunked) {\n              _reset();\n              _closeIncoming();\n            } else {\n              _state = _State.CHUNK_SIZE_STARTING_CR;\n            }\n          }\n          break;\n\n        case _State.FAILURE:\n          // Should be unreachable.\n          assert(false);\n          break;\n\n        default:\n          // Should be unreachable.\n          assert(false);\n          break;\n      }\n    }\n\n    _parserCalled = false;\n    if (_buffer != null && _index == _buffer.length) {\n      // If all data is parsed release the buffer and resume receiving\n      // data.\n      _releaseBuffer();\n      if (_state != _State.UPGRADED && _state != _State.FAILURE) {\n        _socketSubscription.resume();\n      }\n    }\n  }\n\n  void _onData(List<int> buffer) {\n    _socketSubscription.pause();\n    assert(_buffer == null);\n    _buffer = buffer;\n    _index = 0;\n    _parse();\n  }\n\n  void _onDone() {\n    // onDone cancles the subscription.\n    _socketSubscription = null;\n    if (_state == _State.CLOSED || _state == _State.FAILURE) return;\n\n    if (_incoming != null) {\n      if (_state != _State.UPGRADED &&\n          !(_state == _State.START && !_requestParser) &&\n          !(_state == _State.BODY && !_chunked && _transferLength == -1)) {\n        _bodyController.addError(\n              new HttpParserException(\n                  \"Connection closed while receiving data\"));\n      }\n      _closeIncoming();\n      _controller.close();\n      return;\n    }\n    // If the connection is idle the HTTP stream is closed.\n    if (_state == _State.START) {\n      if (!_requestParser) {\n        error(new HttpParserException(\n                    \"Connection closed before full header was received\"));\n      }\n      _controller.close();\n      return;\n    }\n\n    if (_state == _State.UPGRADED) {\n      _controller.close();\n      return;\n    }\n\n    if (_state < _State.FIRST_BODY_STATE) {\n      _state = _State.FAILURE;\n      // Report the error through the error callback if any. Otherwise\n      // throw the error.\n      error(new HttpParserException(\n                  \"Connection closed before full header was received\"));\n      _controller.close();\n      return;\n    }\n\n    if (!_chunked && _transferLength == -1) {\n      _state = _State.CLOSED;\n    } else {\n      _state = _State.FAILURE;\n      // Report the error through the error callback if any. Otherwise\n      // throw the error.\n      error(new HttpParserException(\n                  \"Connection closed before full body was received\"));\n    }\n    _controller.close();\n  }\n\n  void _onError(e) {\n    _controller.addError(e);\n  }\n\n  String get version {\n    switch (_httpVersion) {\n      case _HttpVersion.HTTP10:\n        return \"1.0\";\n      case _HttpVersion.HTTP11:\n        return \"1.1\";\n    }\n    return null;\n  }\n\n  int get messageType => _messageType;\n  int get transferLength => _transferLength;\n  bool get upgrade => _connectionUpgrade && _state == _State.UPGRADED;\n  bool get persistentConnection => _persistentConnection;\n\n  void set responseToMethod(String method) { _responseToMethod = method; }\n\n  _HttpDetachedIncoming detachIncoming() {\n    var completer = _pauseCompleter;\n    _pauseCompleter = null;\n    return new _HttpDetachedIncoming(_socketSubscription,\n                                     readUnparsedData(),\n                                     completer);\n  }\n\n  List<int> readUnparsedData() {\n    if (_buffer == null) return null;\n    if (_index == _buffer.length) return null;\n    var result = _buffer.sublist(_index);\n    _releaseBuffer();\n    return result;\n  }\n\n  _reset() {\n    if (_state == _State.UPGRADED) return;\n    _state = _State.START;\n    _messageType = _MessageType.UNDETERMINED;\n    _headerField = new List();\n    _headerValue = new List();\n    _method_or_status_code = new List();\n    _uri_or_reason_phrase = new List();\n\n    _httpVersion = _HttpVersion.UNDETERMINED;\n    _transferLength = -1;\n    _persistentConnection = false;\n    _connectionUpgrade = false;\n    _chunked = false;\n\n    _noMessageBody = false;\n    _responseToMethod = null;\n    _remainingContent = null;\n\n    _headers = null;\n  }\n\n  _releaseBuffer() {\n    _buffer = null;\n    _index = null;\n  }\n\n  bool _isTokenChar(int byte) {\n    return byte > 31 && byte < 128 && _Const.SEPARATORS.indexOf(byte) == -1;\n  }\n\n  List<String> _tokenizeFieldValue(String headerValue) {\n    List<String> tokens = new List<String>();\n    int start = 0;\n    int index = 0;\n    while (index < headerValue.length) {\n      if (headerValue[index] == \",\") {\n        tokens.add(headerValue.substring(start, index));\n        start = index + 1;\n      } else if (headerValue[index] == \" \" || headerValue[index] == \"\\t\") {\n        start++;\n      }\n      index++;\n    }\n    tokens.add(headerValue.substring(start, index));\n    return tokens;\n  }\n\n  int _toLowerCase(int byte) {\n    final int aCode = \"A\".codeUnitAt(0);\n    final int zCode = \"Z\".codeUnitAt(0);\n    final int delta = \"a\".codeUnitAt(0) - aCode;\n    return (aCode <= byte && byte <= zCode) ? byte + delta : byte;\n  }\n\n  int _expect(int val1, int val2) {\n    if (val1 != val2) {\n      throw new HttpParserException(\"Failed to parse HTTP\");\n    }\n  }\n\n  int _expectHexDigit(int byte) {\n    if (0x30 <= byte && byte <= 0x39) {\n      return byte - 0x30;  // 0 - 9\n    } else if (0x41 <= byte && byte <= 0x46) {\n      return byte - 0x41 + 10;  // A - F\n    } else if (0x61 <= byte && byte <= 0x66) {\n      return byte - 0x61 + 10;  // a - f\n    } else {\n      throw new HttpParserException(\"Failed to parse HTTP\");\n    }\n  }\n\n  void _createIncoming(int transferLength) {\n    assert(_incoming == null);\n    assert(_bodyController == null);\n    _bodyController = new StreamController<List<int>>(\n        onListen: _bodySubscriptionStateChange,\n        onPause: _updateParsePauseState,\n        onResume: _updateParsePauseState,\n        onCancel: _bodySubscriptionStateChange);\n    _incoming = new _HttpIncoming(\n        _headers, transferLength, _bodyController.stream);\n    _pauseParsing();  // Needed to handle detaching - don't start on the body!\n  }\n\n  void _closeIncoming() {\n    // Ignore multiple close (can happend in re-entrance).\n    if (_incoming == null) return;\n    var tmp = _incoming;\n    _incoming = null;\n    tmp.close();\n    if (_bodyController != null) {\n      _bodyController.close();\n      _bodyController = null;\n    }\n    _updateParsePauseState();\n  }\n\n  void _continueParsing() {\n    _paused = false;\n    if (!_parserCalled && _buffer != null) _parse();\n  }\n\n  void _pauseParsing() {\n    _paused = true;\n  }\n\n  void _bodySubscriptionStateChange() {\n    if (_incoming != null && !_bodyController.hasListener) {\n      _closeIncoming();\n    } else {\n      _updateParsePauseState();\n    }\n  }\n\n  void _updateParsePauseState() {\n    if (_bodyController != null) {\n      if (_bodyController.hasListener && !_bodyController.isPaused) {\n        _continueParsing();\n      } else {\n        _pauseParsing();\n      }\n    } else {\n      if (_controller.hasListener && !_controller.isPaused) {\n        _continueParsing();\n      } else {\n        _pauseParsing();\n      }\n    }\n  }\n\n  void error(error, [stackTrace]) {\n    if (_socketSubscription != null) _socketSubscription.cancel();\n    _state = _State.FAILURE;\n    _controller.addError(error, stackTrace);\n    _controller.close();\n  }\n\n  // State.\n  bool _parserCalled = false;\n\n  // The data that is currently being parsed.\n  List<int> _buffer;\n  int _index;\n\n  final bool _requestParser;\n  int _state;\n  int _httpVersionIndex;\n  int _messageType;\n  int _statusCode;\n  List _method_or_status_code;\n  List _uri_or_reason_phrase;\n  List _headerField;\n  List _headerValue;\n\n  int _httpVersion;\n  int _transferLength;\n  bool _persistentConnection;\n  bool _connectionUpgrade;\n  bool _chunked;\n\n  bool _noMessageBody;\n  String _responseToMethod;  // Indicates the method used for the request.\n  int _remainingContent;\n\n  _HttpHeaders _headers;\n\n  // The current incoming connection.\n  _HttpIncoming _incoming;\n  StreamSubscription _socketSubscription;\n  bool _paused = false;\n  Completer _pauseCompleter;\n  StreamController<_HttpIncoming> _controller;\n  StreamController<List<int>> _bodyController;\n}\n\n\nclass HttpParserException implements Exception {\n  const HttpParserException([String this.message = \"\"]);\n  String toString() => \"HttpParserException: $message\";\n  final String message;\n}\n","sdk/lib/io/http_session.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nconst String _DART_SESSION_ID = \"DARTSESSID\";\n\n// A _HttpSession is a node in a double-linked list, with _next and _prev being\n// the previous and next pointers.\nclass _HttpSession implements HttpSession {\n  // Destroyed marked. Used by the http connection to see if a session is valid.\n  bool _destroyed = false;\n  bool _isNew = true;\n  DateTime _lastSeen;\n  Function _timeoutCallback;\n  _HttpSessionManager _sessionManager;\n  // Pointers in timeout queue.\n  _HttpSession _prev;\n  _HttpSession _next;\n\n  final Map _data = new Map();\n\n  _HttpSession(_HttpSessionManager this._sessionManager, String this.id)\n    : _lastSeen = new DateTime.now();\n\n  void destroy() {\n    _destroyed = true;\n    _sessionManager._removeFromTimeoutQueue(this);\n    _sessionManager._sessions.remove(id);\n  }\n\n  // Mark the session as seen. This will reset the timeout and move the node to\n  // the end of the timeout queue.\n  void _markSeen() {\n    _lastSeen = new DateTime.now();\n    _sessionManager._bumpToEnd(this);\n  }\n\n  DateTime get lastSeen => _lastSeen;\n\n  bool get isNew => _isNew;\n\n  final String id;\n\n  void set onTimeout(void callback()) {\n    _timeoutCallback = callback;\n  }\n\n  // Map implementation:\n  bool containsValue(value) => _data.containsValue(value);\n  bool containsKey(key) => _data.containsKey(key);\n  operator [](key) => _data[key];\n  void operator []=(key, value) { _data[key] = value; }\n  putIfAbsent(key, ifAbsent) => _data.putIfAbsent(key, ifAbsent);\n  remove(key) => _data.remove(key);\n  void clear() => _data.clear();\n  void forEach(void f(key, value)) => _data.forEach(f);\n  Iterable get keys => _data.keys;\n  Iterable get values => _data.values;\n  int get length => _data.length;\n  bool get isEmpty => _data.isEmpty;\n}\n\n// Private class used to manage all the active sessions. The sessions are stored\n// in two ways:\n//\n//  * In a map, mapping from ID to HttpSession.\n//  * In a linked list, used as a timeout queue.\nclass _HttpSessionManager {\n  _HttpSessionManager() : _sessions = {};\n\n  String createSessionId() {\n    const int _KEY_LENGTH = 16;  // 128 bits.\n    var data = _IOCrypto.getRandomBytes(_KEY_LENGTH);\n    return CryptoUtils.bytesToHex(data);\n  }\n\n  _HttpSession getSession(String id) {\n    return _sessions[id];\n  }\n\n  _HttpSession createSession() {\n    var id = createSessionId();\n    // TODO(ajohnsen): Consider adding a limit and throwing an exception.\n    // Should be very unlikely however.\n    while (_sessions.containsKey(id)) {\n      id = createSessionId();\n    }\n    var session = _sessions[id] = new _HttpSession(this, id);\n    _addToTimeoutQueue(session);\n    return session;\n  }\n\n  void set sessionTimeout(int timeout) {\n    _sessionTimeout = timeout;\n    _stopTimer();\n    _startTimer();\n  }\n\n  void close() {\n    _stopTimer();\n  }\n\n  void _bumpToEnd(_HttpSession session) {\n    _removeFromTimeoutQueue(session);\n    _addToTimeoutQueue(session);\n  }\n\n  void _addToTimeoutQueue(_HttpSession session) {\n    if (_head == null) {\n      assert(_tail == null);\n      _tail = _head = session;\n      _startTimer();\n    } else {\n      assert(_timer != null);\n      assert(_tail != null);\n      // Add to end.\n      _tail._next = session;\n      session._prev = _tail;\n      _tail = session;\n    }\n  }\n\n  void _removeFromTimeoutQueue(_HttpSession session) {\n    if (session._next != null) {\n      session._next._prev = session._prev;\n    }\n    if (session._prev != null) {\n      session._prev._next = session._next;\n    }\n    if (_head == session) {\n      // We removed the head element, start new timer.\n      _head = session._next;\n      _stopTimer();\n      _startTimer();\n    }\n    if (_tail == session) {\n      _tail = session._prev;\n    }\n    session._next = session._prev = null;\n  }\n\n  void _timerTimeout() {\n    _stopTimer();  // Clear timer.\n    assert(_head != null);\n    var session = _head;\n    session.destroy();  // Will remove the session from timeout queue and map.\n    if (session._timeoutCallback != null) {\n      session._timeoutCallback();\n    }\n  }\n\n  void _startTimer() {\n    assert(_timer == null);\n    if (_head != null) {\n      int seconds = new DateTime.now().difference(_head.lastSeen).inSeconds;\n      _timer = new Timer(new Duration(seconds: _sessionTimeout - seconds),\n                         _timerTimeout);\n    }\n  }\n\n  void _stopTimer() {\n    if (_timer != null) {\n      _timer.cancel();\n      _timer = null;\n    }\n  }\n\n  Map<String, _HttpSession> _sessions;\n  int _sessionTimeout = 20 * 60;  // 20 mins.\n  _HttpSession _head;\n  _HttpSession _tail;\n  Timer _timer;\n}\n\n","sdk/lib/io/http_utils.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass _HttpUtils {\n  static String decodeUrlEncodedString(String urlEncoded) {\n    // First check the string for any encoding.\n    int index = 0;\n    bool encoded = false;\n    while (!encoded && index < urlEncoded.length) {\n      encoded = urlEncoded[index] == \"+\" || urlEncoded[index] == \"%\";\n      index++;\n    }\n    if (!encoded) return urlEncoded;\n    index--;\n\n    // Start decoding from the first encoded character.\n    List<int> bytes = new List<int>();\n    for (int i = 0; i < index; i++) bytes.add(urlEncoded.codeUnitAt(i));\n    for (int i = index; i < urlEncoded.length; i++) {\n      if (urlEncoded[i] == \"+\") {\n        bytes.add(32);\n      } else if (urlEncoded[i] == \"%\") {\n        if (urlEncoded.length - i < 2) {\n          throw new HttpException(\"Invalid URL encoding\");\n        }\n        int byte = 0;\n        for (int j = 0; j < 2; j++) {\n          var charCode = urlEncoded.codeUnitAt(i + j + 1);\n          if (0x30 <= charCode && charCode <= 0x39) {\n            byte = byte * 16 + charCode - 0x30;\n          } else {\n            // Check ranges A-F (0x41-0x46) and a-f (0x61-0x66).\n            charCode |= 0x20;\n            if (0x61 <= charCode && charCode <= 0x66) {\n              byte = byte * 16 + charCode - 0x57;\n            } else {\n              throw new ArgumentError(\"Invalid URL encoding\");\n            }\n          }\n        }\n        bytes.add(byte);\n        i += 2;\n      } else {\n        bytes.add(urlEncoded.codeUnitAt(i));\n      }\n    }\n    return decodeUtf8(bytes);\n  }\n\n  static Map<String, String> splitQueryString(String queryString) {\n    Map<String, String> result = new Map<String, String>();\n    int currentPosition = 0;\n    while (currentPosition < queryString.length) {\n      int position = queryString.indexOf(\"=\", currentPosition);\n      if (position == -1) {\n        break;\n      }\n      String name = queryString.substring(currentPosition, position);\n      currentPosition = position + 1;\n      position = queryString.indexOf(\"&\", currentPosition);\n      String value;\n      if (position == -1) {\n        value = queryString.substring(currentPosition);\n        currentPosition = queryString.length;\n      } else {\n        value = queryString.substring(currentPosition, position);\n        currentPosition = position + 1;\n      }\n      result[_HttpUtils.decodeUrlEncodedString(name)] =\n        _HttpUtils.decodeUrlEncodedString(value);\n    }\n    return result;\n  }\n\n  // From RFC 2616 section \"3.3.1 Full Date\"\n  // HTTP-date    = rfc1123-date | rfc850-date | asctime-date\n  // rfc1123-date = wkday \",\" SP date1 SP time SP \"GMT\"\n  // rfc850-date  = weekday \",\" SP date2 SP time SP \"GMT\"\n  // asctime-date = wkday SP date3 SP time SP 4DIGIT\n  // date1        = 2DIGIT SP month SP 4DIGIT\n  //                ; day month year (e.g., 02 Jun 1982)\n  // date2        = 2DIGIT \"-\" month \"-\" 2DIGIT\n  //                ; day-month-year (e.g., 02-Jun-82)\n  // date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))\n  //                ; month day (e.g., Jun  2)\n  // time         = 2DIGIT \":\" 2DIGIT \":\" 2DIGIT\n  //                ; 00:00:00 - 23:59:59\n  // wkday        = \"Mon\" | \"Tue\" | \"Wed\"\n  //              | \"Thu\" | \"Fri\" | \"Sat\" | \"Sun\"\n  // weekday      = \"Monday\" | \"Tuesday\" | \"Wednesday\"\n  //              | \"Thursday\" | \"Friday\" | \"Saturday\" | \"Sunday\"\n  // month        = \"Jan\" | \"Feb\" | \"Mar\" | \"Apr\"\n  //              | \"May\" | \"Jun\" | \"Jul\" | \"Aug\"\n  //              | \"Sep\" | \"Oct\" | \"Nov\" | \"Dec\"\n\n  // Format as RFC 1123 date.\n  static String formatDate(DateTime date) {\n    const List wkday = const [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"];\n    const List month = const [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                              \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n    DateTime d = date.toUtc();\n    StringBuffer sb = new StringBuffer();\n    sb.write(wkday[d.weekday - 1]);\n    sb.write(\", \");\n    sb.write(d.day.toString());\n    sb.write(\" \");\n    sb.write(month[d.month - 1]);\n    sb.write(\" \");\n    sb.write(d.year.toString());\n    sb.write(d.hour < 9 ? \" 0\" : \" \");\n    sb.write(d.hour.toString());\n    sb.write(d.minute < 9 ? \":0\" : \":\");\n    sb.write(d.minute.toString());\n    sb.write(d.second < 9 ? \":0\" : \":\");\n    sb.write(d.second.toString());\n    sb.write(\" GMT\");\n    return sb.toString();\n  }\n\n  static DateTime parseDate(String date) {\n    final int SP = 32;\n    const List wkdays = const [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"];\n    const List weekdays = const [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\",\n                           \"Friday\", \"Saturday\", \"Sunday\"];\n    const List months = const [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                         \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n    const List wkdaysLowerCase =\n        const [\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"];\n    const List weekdaysLowerCase = const [\"monday\", \"tuesday\", \"wednesday\",\n                                          \"thursday\", \"friday\", \"saturday\",\n                                          \"sunday\"];\n    const List monthsLowerCase = const [\"jan\", \"feb\", \"mar\", \"apr\", \"may\",\n                                        \"jun\", \"jul\", \"aug\", \"sep\", \"oct\",\n                                        \"nov\", \"dec\"];\n\n    final int formatRfc1123 = 0;\n    final int formatRfc850 = 1;\n    final int formatAsctime = 2;\n\n    int index = 0;\n    String tmp;\n    int format;\n\n    void expect(String s) {\n      if (date.length - index < s.length) {\n        throw new HttpException(\"Invalid HTTP date $date\");\n      }\n      String tmp = date.substring(index, index + s.length);\n      if (tmp != s) {\n        throw new HttpException(\"Invalid HTTP date $date\");\n      }\n      index += s.length;\n    }\n\n    int expectWeekday() {\n      int weekday;\n      // The formatting of the weekday signals the format of the date string.\n      int pos = date.indexOf(\",\", index);\n      if (pos == -1) {\n        int pos = date.indexOf(\" \", index);\n        if (pos == -1) throw new HttpException(\"Invalid HTTP date $date\");\n        tmp = date.substring(index, pos);\n        index = pos + 1;\n        weekday = wkdays.indexOf(tmp);\n        if (weekday != -1) {\n          format = formatAsctime;\n          return weekday;\n        }\n      } else {\n        tmp = date.substring(index, pos);\n        index = pos + 1;\n        weekday = wkdays.indexOf(tmp);\n        if (weekday != -1) {\n          format = formatRfc1123;\n          return weekday;\n        }\n        weekday = weekdays.indexOf(tmp);\n        if (weekday != -1) {\n          format = formatRfc850;\n          return weekday;\n        }\n      }\n      throw new HttpException(\"Invalid HTTP date $date\");\n    }\n\n    int expectMonth(String separator) {\n      int pos = date.indexOf(separator, index);\n      if (pos - index != 3) throw new HttpException(\"Invalid HTTP date $date\");\n      tmp = date.substring(index, pos);\n      index = pos + 1;\n      int month = months.indexOf(tmp);\n      if (month != -1) return month;\n      throw new HttpException(\"Invalid HTTP date $date\");\n    }\n\n    int expectNum(String separator) {\n      int pos;\n      if (separator.length > 0) {\n        pos = date.indexOf(separator, index);\n      } else {\n        pos = date.length;\n      }\n      String tmp = date.substring(index, pos);\n      index = pos + separator.length;\n      try {\n        int value = int.parse(tmp);\n        return value;\n      } on FormatException catch (e) {\n        throw new HttpException(\"Invalid HTTP date $date\");\n      }\n    }\n\n    void expectEnd() {\n      if (index != date.length) {\n        throw new HttpException(\"Invalid HTTP date $date\");\n      }\n    }\n\n    int weekday = expectWeekday();\n    int day;\n    int month;\n    int year;\n    int hours;\n    int minutes;\n    int seconds;\n    if (format == formatAsctime) {\n      month = expectMonth(\" \");\n      if (date.codeUnitAt(index) == SP) index++;\n      day = expectNum(\" \");\n      hours = expectNum(\":\");\n      minutes = expectNum(\":\");\n      seconds = expectNum(\" \");\n      year = expectNum(\"\");\n    } else {\n      expect(\" \");\n      day = expectNum(format == formatRfc1123 ? \" \" : \"-\");\n      month = expectMonth(format == formatRfc1123 ? \" \" : \"-\");\n      year = expectNum(\" \");\n      hours = expectNum(\":\");\n      minutes = expectNum(\":\");\n      seconds = expectNum(\" \");\n      expect(\"GMT\");\n    }\n    expectEnd();\n    return new DateTime.utc(year, month + 1, day, hours, minutes, seconds, 0);\n  }\n\n  static DateTime parseCookieDate(String date) {\n    const List monthsLowerCase = const [\"jan\", \"feb\", \"mar\", \"apr\", \"may\",\n                                        \"jun\", \"jul\", \"aug\", \"sep\", \"oct\",\n                                        \"nov\", \"dec\"];\n\n    int position = 0;\n\n    void error() {\n      throw new HttpException(\"Invalid cookie date $date\");\n    }\n\n    bool isEnd() {\n      return position == date.length;\n    }\n\n    bool isDelimiter(String s) {\n      int char = s.codeUnitAt(0);\n      if (char == 0x09) return true;\n      if (char >= 0x20 && char <= 0x2F) return true;\n      if (char >= 0x3B && char <= 0x40) return true;\n      if (char >= 0x5B && char <= 0x60) return true;\n      if (char >= 0x7B && char <= 0x7E) return true;\n      return false;\n    }\n\n    bool isNonDelimiter(String s) {\n      int char = s.codeUnitAt(0);\n      if (char >= 0x00 && char <= 0x08) return true;\n      if (char >= 0x0A && char <= 0x1F) return true;\n      if (char >= 0x30 && char <= 0x39) return true;  // Digit\n      if (char == 0x3A) return true;  // ':'\n      if (char >= 0x41 && char <= 0x5A) return true;  // Alpha\n      if (char >= 0x61 && char <= 0x7A) return true;  // Alpha\n      if (char >= 0x7F && char <= 0xFF) return true;  // Alpha\n      return false;\n    }\n\n    bool isDigit(String s) {\n      int char = s.codeUnitAt(0);\n      if (char > 0x2F && char < 0x3A) return true;\n      return false;\n    }\n\n    int getMonth(String month) {\n      if (month.length < 3) return -1;\n      return monthsLowerCase.indexOf(month.substring(0, 3));\n    }\n\n    int toInt(String s) {\n      int index = 0;\n      for (; index < s.length && isDigit(s[index]); index++);\n      return int.parse(s.substring(0, index));\n    }\n\n    var tokens = [];\n    while (!isEnd()) {\n      while (!isEnd() && isDelimiter(date[position])) position++;\n      int start = position;\n      while (!isEnd() && isNonDelimiter(date[position])) position++;\n      tokens.add(date.substring(start, position).toLowerCase());\n      while (!isEnd() && isDelimiter(date[position])) position++;\n    }\n\n    String timeStr;\n    String dayOfMonthStr;\n    String monthStr;\n    String yearStr;\n\n    for (var token in tokens) {\n      if (token.length < 1) continue;\n      if (timeStr == null && token.length >= 5 && isDigit(token[0]) &&\n          (token[1] == \":\" || (isDigit(token[1]) && token[2] == \":\"))) {\n        timeStr = token;\n      } else if (dayOfMonthStr == null && isDigit(token[0])) {\n        dayOfMonthStr = token;\n      } else if (monthStr == null && getMonth(token) >= 0) {\n        monthStr = token;\n      } else if (yearStr == null && token.length >= 2 &&\n                 isDigit(token[0]) && isDigit(token[1])) {\n        yearStr = token;\n      }\n    }\n\n    if (timeStr == null || dayOfMonthStr == null ||\n        monthStr == null || yearStr == null) {\n      error();\n    }\n\n    int year = toInt(yearStr);\n    if (year >= 70 && year <= 99) year += 1900;\n    else if (year >= 0 && year <= 69) year += 2000;\n    if (year < 1601) error();\n\n    int dayOfMonth = toInt(dayOfMonthStr);\n    if (dayOfMonth < 1 || dayOfMonth > 31) error();\n\n    int month = getMonth(monthStr) + 1;\n\n    var timeList = timeStr.split(\":\");\n    if (timeList.length != 3) error();\n    int hour = toInt(timeList[0]);\n    int minute = toInt(timeList[1]);\n    int second = toInt(timeList[2]);\n    if (hour > 23) error();\n    if (minute > 59) error();\n    if (second > 59) error();\n\n    return new DateTime.utc(year, month, dayOfMonth, hour, minute, second, 0);\n  }\n}\n","sdk/lib/io/io.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/**\n * The IO library is used for Dart server applications,\n * which run on a stand-alone Dart VM from the command line.\n * *This library does not work in browser based applications.*\n *\n * This library allows you to work with files, directories,\n * sockets, processes, HTTP servers and clients, and more.\n */\nlibrary dart.io;\n\nimport 'dart:async';\nimport 'dart:collection' show Queue,\n                              LinkedHashSet,\n                              DoubleLinkedQueue,\n                              DoubleLinkedQueueEntry;\nimport 'dart:crypto';\nimport 'dart:isolate';\nimport 'dart:json' as JSON;\nimport 'dart:math';\nimport 'dart:uri';\nimport 'dart:utf';\nimport 'dart:typed_data';\n\npart 'base64.dart';\npart 'buffer_list.dart';\npart 'common.dart';\npart 'data_transformer.dart';\npart 'directory.dart';\npart 'directory_impl.dart';\npart 'eventhandler.dart';\npart 'file.dart';\npart 'file_impl.dart';\npart 'file_system_entity.dart';\npart 'http.dart';\npart 'http_body.dart';\npart 'http_body_impl.dart';\npart 'http_headers.dart';\npart 'http_impl.dart';\npart 'http_parser.dart';\npart 'http_session.dart';\npart 'http_utils.dart';\npart 'io_sink.dart';\npart 'link.dart';\npart 'mime_multipart_parser.dart';\npart 'options.dart';\npart 'path.dart';\npart 'path_impl.dart';\npart 'platform.dart';\npart 'platform_impl.dart';\npart 'process.dart';\npart 'socket.dart';\npart 'stdio.dart';\npart 'string_transformer.dart';\npart 'timer_impl.dart';\npart 'secure_socket.dart';\npart 'secure_server_socket.dart';\npart 'websocket.dart';\npart 'websocket_impl.dart';\n","sdk/lib/io/io_sink.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * Helper class to wrap a [StreamConsumer<List<int>>] and provide\n * utility functions for writing to the StreamConsumer directly. The\n * [IOSink] buffers the input given by all [StringSink] methods and will delay\n * a [addStream] until the buffer is flushed.\n *\n * When the [IOSink] is bound to a stream (through [addStream]) any call\n * to the [IOSink] will throw a [StateError]. When the [addStream] compeltes,\n * the [IOSink] will again be open for all calls.\n */\nabstract class IOSink implements StreamSink<List<int>>, StringSink {\n  factory IOSink(StreamConsumer<List<int>> target,\n                 {Encoding encoding: Encoding.UTF_8})\n      => new _IOSinkImpl(target, encoding);\n\n  /**\n   * The [Encoding] used when writing strings. Depending on the\n   * underlying consumer this property might be mutable.\n   */\n  Encoding encoding;\n\n  /**\n   * Writes the bytes uninterpreted to the consumer.\n   */\n  void add(List<int> data);\n\n  /**\n   * Writes an error to the consumer.\n   */\n  void addError(error);\n\n  /**\n   * Adds all elements of the given [stream] to `this`.\n   */\n  Future addStream(Stream<List<int>> stream);\n\n  /**\n   * Close the target.\n   */\n  Future close();\n\n  /**\n   * Get a future that will complete when all synchronous have completed, or an\n   * error happened. This future is identical to the future returned from close.\n   */\n  Future get done;\n}\n\nclass _StreamSinkImpl<T> implements StreamSink<T> {\n  final StreamConsumer<T> _target;\n  Completer _doneCompleter = new Completer();\n  Future _doneFuture;\n  StreamController<T> _controllerInstance;\n  Completer _controllerCompleter;\n  bool _isClosed = false;\n  bool _isBound = false;\n\n  _StreamSinkImpl(StreamConsumer<T> this._target) {\n    _doneFuture = _doneCompleter.future;\n  }\n\n  void add(T data) {\n    _controller.add(data);\n  }\n\n  void addError(error) {\n    _controller.addError(error);\n  }\n\n  Future addStream(Stream<T> stream) {\n    if (_isBound) {\n      throw new StateError(\"StreamSink is already bound to a stream\");\n    }\n    _isBound = true;\n    // Wait for any sync operations to complete.\n    Future targetAddStream() {\n      return _target.addStream(stream)\n          .whenComplete(() {\n            _isBound = false;\n          });\n    }\n    if (_controllerInstance == null) return targetAddStream();\n    var future = _controllerCompleter.future;\n    _controllerInstance.close();\n    return future.then((_) => targetAddStream());\n  }\n\n  Future close() {\n    if (_isBound) {\n      throw new StateError(\"StreamSink is bound to a stream\");\n    }\n    if (!_isClosed) {\n      _isClosed = true;\n      if (_controllerInstance != null) {\n        _controllerInstance.close();\n      } else {\n        _closeTarget();\n      }\n    }\n    return done;\n  }\n\n  void _closeTarget() {\n    _target.close()\n        .then((value) => _completeDone(value: value),\n              onError: (error) => _completeDone(error: error));\n  }\n\n  Future get done => _doneFuture;\n\n  void _completeDone({value, error}) {\n    if (_doneCompleter == null) return;\n    var tmp = _doneCompleter;\n    _doneCompleter = null;\n    if (error == null) {\n      tmp.complete(value);\n    } else {\n      tmp.completeError(error);\n    }\n  }\n\n  StreamController<T> get _controller {\n    if (_isBound) {\n      throw new StateError(\"StreamSink is bound to a stream\");\n    }\n    if (_isClosed) {\n      throw new StateError(\"StreamSink is closed\");\n    }\n    if (_controllerInstance == null) {\n      _controllerInstance = new StreamController<T>();\n      _controllerCompleter = new Completer();\n      _target.addStream(_controller.stream)\n          .then(\n              (_) {\n                if (_isBound) {\n                  // A new stream takes over - forward values to that stream.\n                  var completer = _controllerCompleter;\n                  _controllerCompleter = null;\n                  _controllerInstance = null;\n                  completer.complete();\n                } else {\n                  // No new stream, .close was called. Close _target.\n                  _closeTarget();\n                }\n              },\n              onError: (error) {\n                if (_isBound) {\n                  // A new stream takes over - forward errors to that stream.\n                  var completer = _controllerCompleter;\n                  _controllerCompleter = null;\n                  _controllerInstance = null;\n                  completer.completeError(error);\n                } else {\n                  // No new stream. No need to close target, as it have already\n                  // failed.\n                  _completeDone(error: error);\n                }\n              });\n    }\n    return _controllerInstance;\n  }\n}\n\n\nclass _IOSinkImpl extends _StreamSinkImpl<List<int>> implements IOSink {\n  Encoding _encoding;\n  bool _encodingMutable = true;\n\n  _IOSinkImpl(StreamConsumer<List<int>> target, this._encoding)\n      : super(target);\n\n  Encoding get encoding => _encoding;\n\n  void set encoding(Encoding value) {\n    if (!_encodingMutable) {\n      throw new StateError(\"IOSink encoding is not mutable\");\n    }\n    _encoding = value;\n  }\n\n  void write(Object obj) {\n    // This comment is copied from runtime/lib/string_buffer_patch.dart.\n    // TODO(srdjan): The following four lines could be replaced by\n    // '$obj', but apparently this is too slow on the Dart VM.\n    String string;\n    if (obj is String) {\n      string = obj;\n    } else {\n      string = obj.toString();\n      if (string is! String) {\n        throw new ArgumentError('toString() did not return a string');\n      }\n    }\n    if (string.isEmpty) return;\n    add(_encodeString(string, _encoding));\n  }\n\n  void writeAll(Iterable objects, [String separator = \"\"]) {\n    Iterator iterator = objects.iterator;\n    if (!iterator.moveNext()) return;\n    if (separator.isEmpty) {\n      do {\n        write(iterator.current);\n      } while (iterator.moveNext());\n    } else {\n      write(iterator.current);\n      while (iterator.moveNext()) {\n        write(separator);\n        write(iterator.current);\n      }\n    }\n  }\n\n  void writeln([Object obj = \"\"]) {\n    write(obj);\n    write(\"\\n\");\n  }\n\n  void writeCharCode(int charCode) {\n    write(new String.fromCharCode(charCode));\n  }\n}\n","sdk/lib/io/link.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * [Link] objects are references to filesystem links.\n *\n */\nabstract class Link extends FileSystemEntity {\n  /**\n   * Creates a Link object.\n   */\n  factory Link(String path) => new _Link(path);\n\n  /**\n   * Creates a Link object from a Path object.\n   */\n  factory Link.fromPath(Path path) => new _Link.fromPath(path);\n\n  /**\n   * Checks if the link exists. The link may exist, even if its target\n   * is missing or deleted.\n   * Returns a [:Future<bool>:] that completes when the answer is known.\n   */\n  Future<bool> exists();\n\n  /**\n   * Synchronously checks if the link exists. The link may exist, even if\n   * its target is missing or deleted.\n   */\n  bool existsSync();\n\n  /**\n   * Creates a symbolic link. Returns a [:Future<Link>:] that completes with\n   * the link when it has been created. If the link exists,\n   * the future will complete with an error.\n   *\n   * On the Windows platform, this will only work with directories, and the\n   * target directory must exist. The link will be created as a Junction.\n   * Only absolute links will be created, and relative paths to the target\n   * will be converted to absolute paths.\n   *\n   * On other platforms, the posix symlink() call is used to make a symbolic\n   * link containing the string [target].  If [target] is a relative path,\n   * it will be interpreted relative to the directory containing the link.\n   */\n  Future<Link> create(String target);\n\n  /**\n   * Synchronously create the link. Calling [createSync] on an existing link\n   * will throw an exception.\n   *\n   * On the Windows platform, this will only work with directories, and the\n   * target directory must exist. The link will be created as a Junction.\n   * Only absolute links will be created, and relative paths to the target\n   * will be converted to absolute paths.\n   *\n   * On other platforms, the posix symlink() call is used to make a symbolic\n   * link containing the string [target].  If [target] is a relative path,\n   * it will be interpreted relative to the directory containing the link.\n   */\n  void createSync(String target);\n\n  /**\n   * Synchronously updates the link. Calling [updateSync] on a non-existing link\n   * will throw an exception.\n   *\n   * If [linkRelative] is true, the target argument should be a relative path,\n   * and the link will interpret the target as a path relative to the link's\n   * directory.\n   *\n   * On the Windows platform, this will only work with directories, and the\n   * target directory must exist.\n   */\n  void updateSync(String target, {bool linkRelative: false });\n\n  /**\n   * Deletes the link. Returns a [:Future<Link>:] that completes with\n   * the link when it has been deleted. This does not delete, or otherwise\n   * affect, the target of the link. It also works on broken links, but if\n   * the link does not exist or is not actually a link, it completes the\n   * future with a LinkIOException.\n   */\n  Future<Link> delete();\n\n  /**\n   * Synchronously deletes the link. This does not delete, or otherwise\n   * affect, the target of the link.  It also works on broken links, but if\n   * the link does not exist or is not actually a link, it throws a\n   * LinkIOException.\n   */\n  void deleteSync();\n\n  /**\n   * Gets the target of the link. Returns a future that completes with\n   * the path to the target.\n   *\n   * If the returned target is a relative path, it is relative to the\n   * directory containing the link.\n   *\n   * If the link does not exist, or is not a link, the future completes with\n   * a LinkIOException.\n   */\n  Future<String> target();\n\n  /**\n   * Synchronously gets the target of the link. Returns the path to the target.\n   *\n   * If the returned target is a relative path, it is relative to the\n   * directory containing the link.\n   *\n   * If the link does not exist, or is not a link, throws a LinkIOException.\n   */\n  String targetSync();\n}\n\n\nclass _Link extends FileSystemEntity implements Link {\n  final String path;\n\n  SendPort _fileService;\n\n  _Link(String this.path);\n\n  _Link.fromPath(Path inputPath) : path = inputPath.toNativePath();\n\n  String toString() => \"Link: '$path'\";\n\n  Future<bool> exists() {\n    // TODO(whesse): Replace with asynchronous version.\n    return new Future.value(existsSync());\n  }\n\n  bool existsSync() => FileSystemEntity.isLinkSync(path);\n\n  Future<Link> create(String target) {\n    _ensureFileService();\n    if (Platform.operatingSystem == 'windows') {\n      target = _makeWindowsLinkTarget(target);\n    }\n    List request = new List(3);\n    request[0] = _CREATE_LINK_REQUEST;\n    request[1] = path;\n    request[2] = target;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n            \"Cannot create link '$path' to target '$target'\");\n      }\n      return this;\n    });\n  }\n\n  void createSync(String target) {\n    if (Platform.operatingSystem == 'windows') {\n      target = _makeWindowsLinkTarget(target);\n    }\n    var result = _File._createLink(path, target);\n    throwIfError(result, \"Cannot create link '$path'\");\n  }\n\n  // Put target into the form \"\\??\\C:\\my\\target\\dir\".\n  String _makeWindowsLinkTarget(String target) {\n    if (target.startsWith('\\\\??\\\\')) {\n      return target;\n    }\n    if (!(target.length > 3 && target[1] == ':' && target[2] == '\\\\')) {\n      target = new File(target).fullPathSync();\n    }\n    if (target.length > 3 && target[1] == ':' && target[2] == '\\\\') {\n      target = '\\\\??\\\\$target';\n    } else {\n      throw new ArgumentError(\n          'Target $target of Link.create on Windows cannot be converted' +\n          ' to start with a drive letter.  Unexpected error.');\n    }\n    return target;\n  }\n\n  void updateSync(String target, {bool linkRelative: false }) {\n    // TODO(whesse): Replace with atomic update, where supported by platform.\n    deleteSync();\n    createSync(target);\n  }\n\n  Future<Link> delete() {\n    _ensureFileService();\n    List request = new List(2);\n    request[0] = _DELETE_LINK_REQUEST;\n    request[1] = path;\n    return _fileService.call(request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"Cannot delete link '$path'\");\n      }\n      return this;\n    });\n  }\n\n  void deleteSync() {\n    var result = _File._deleteLink(path);\n    throwIfError(result, \"Cannot delete link '$path'\");\n  }\n\n  Future<String> target() {\n    // TODO(whesse): Replace with asynchronous version.\n    return new Future.sync(targetSync);\n  }\n\n  String targetSync() {\n    var result = _File._linkTarget(path);\n    throwIfError(result, \"Cannot read link '$path'\");\n    return result;\n  }\n\n  static throwIfError(Object result, String msg) {\n    if (result is OSError) {\n      throw new LinkIOException(msg, result);\n    }\n  }\n\n  bool _isErrorResponse(response) {\n    return response is List && response[0] != _SUCCESS_RESPONSE;\n  }\n\n  void _ensureFileService() {\n    if (_fileService == null) {\n      _fileService = _FileUtils._newServicePort();\n    }\n  }\n\n  _exceptionFromResponse(response, String message) {\n    assert(_isErrorResponse(response));\n    switch (response[_ERROR_RESPONSE_ERROR_TYPE]) {\n      case _ILLEGAL_ARGUMENT_RESPONSE:\n        return new ArgumentError();\n      case _OSERROR_RESPONSE:\n        var err = new OSError(response[_OSERROR_RESPONSE_MESSAGE],\n                              response[_OSERROR_RESPONSE_ERROR_CODE]);\n        return new LinkIOException(message, err);\n      default:\n        return new Exception(\"Unknown error\");\n    }\n  }\n}\n\n\nclass LinkIOException implements Exception {\n  const LinkIOException([String this.message = \"\",\n                         String this.path = \"\",\n                         OSError this.osError = null]);\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    sb.write(\"LinkIOException\");\n    if (!message.isEmpty) {\n      sb.write(\": $message\");\n      if (path != null) {\n        sb.write(\", path = $path\");\n      }\n      if (osError != null) {\n        sb.write(\" ($osError)\");\n      }\n    } else if (osError != null) {\n      sb.write(\": $osError\");\n      if (path != null) {\n        sb.write(\", path = $path\");\n      }\n    }\n    return sb.toString();\n  }\n  final String message;\n  final String path;\n  final OSError osError;\n}\n","sdk/lib/io/mime_multipart_parser.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * Parser for MIME multipart types of data as described in RFC 2046\n * section 5.1.1. The data to parse is supplied through the [:update:]\n * method. As the data is parsed the following callbacks are called:\n *\n *   [:partStart;\n *   [:headerReceived;\n *   [:headersComplete;\n *   [:partDataReceived;\n *   [:partEnd;\n *   [:error:]\n */\n\nclass _MimeMultipartParser {\n  const int _START = 0;\n  const int _FIRST_BOUNDARY_ENDING = 111;\n  const int _FIRST_BOUNDARY_END = 112;\n  const int _BOUNDARY_ENDING = 1;\n  const int _BOUNDARY_END = 2;\n  const int _HEADER_START = 3;\n  const int _HEADER_FIELD = 4;\n  const int _HEADER_VALUE_START = 5;\n  const int _HEADER_VALUE = 6;\n  const int _HEADER_VALUE_FOLDING_OR_ENDING = 7;\n  const int _HEADER_VALUE_FOLD_OR_END = 8;\n  const int _HEADER_ENDING = 9;\n  const int _CONTENT = 10;\n  const int _LAST_BOUNDARY_DASH2 = 11;\n  const int _LAST_BOUNDARY_ENDING = 12;\n  const int _LAST_BOUNDARY_END = 13;\n  const int _DONE = 14;\n  const int _FAILURE = 15;\n\n  // Construct a new MIME multipart parser with the boundary\n  // [boundary]. The boundary should be as specified in the content\n  // type parameter, that is without the -- prefix.\n  _MimeMultipartParser(String boundary) {\n    List<int> charCodes = boundary.codeUnits;\n    _boundary = new List<int>(4 + charCodes.length);\n    // Set-up the matching boundary preceding it with CRLF and two\n    // dashes.\n    _boundary[0] = _CharCode.CR;\n    _boundary[1] = _CharCode.LF;\n    _boundary[2] = _CharCode.DASH;\n    _boundary[3] = _CharCode.DASH;\n    _boundary.setRange(4, 4 + charCodes.length, charCodes);\n    _state = _START;\n    _headerField = new StringBuffer();\n    _headerValue = new StringBuffer();\n  }\n\n  int update(List<int> buffer, int offset, int count) {\n    // Current index in the data buffer. If index is negative then it\n    // is the index into the artificial prefix of the boundary string.\n    int index;\n    // Number of boundary bytes to artificially place before the supplied data.\n    int boundaryPrefix = 0;\n    // Position where content starts. Will be null if no known content\n    // start exists. Will be negative of the content starts in the\n    // boundary prefix. Will be zero or position if the content starts\n    // in the current buffer.\n    int contentStartIndex;\n\n    // Function to report content data for the current part. The data\n    // reported is from the current content start index up til the\n    // current index. As the data can be artificially prefixed with a\n    // prefix of the boundary both the content start index and index\n    // can be negative.\n    void reportData() {\n      if (partDataReceived == null) return;\n\n      if (contentStartIndex < 0) {\n        var contentLength = boundaryPrefix + index - _boundaryIndex;\n        if (contentLength <= boundaryPrefix) {\n          partDataReceived(\n              _boundary.sublist(0, contentLength));\n        } else {\n          partDataReceived(\n              _boundary.sublist(0, boundaryPrefix));\n          partDataReceived(\n              buffer.sublist(0, contentLength - boundaryPrefix));\n        }\n      } else {\n        var contentEndIndex = index - _boundaryIndex;\n        partDataReceived(\n            buffer.sublist(contentStartIndex, contentEndIndex));\n      }\n    }\n\n    // Prepare for processing the buffer.\n    index = offset;\n    int lastIndex = offset + count;\n    if (_state == _CONTENT && _boundaryIndex == 0) {\n      contentStartIndex = 0;\n    } else {\n      contentStartIndex = null;\n    }\n    // The data to parse might be \"artificially\" prefixed with a\n    // partial match of the boundary.\n    boundaryPrefix = _boundaryIndex;\n\n    while ((index < lastIndex) && _state != _FAILURE && _state != _DONE) {\n      int byte;\n      if (index < 0) {\n        byte = _boundary[boundaryPrefix + index];\n      } else {\n        byte = buffer[index];\n      }\n      switch (_state) {\n        case _START:\n          if (_toLowerCase(byte) == _toLowerCase(_boundary[_boundaryIndex])) {\n            _boundaryIndex++;\n            if (_boundaryIndex == _boundary.length) {\n              _state = _FIRST_BOUNDARY_ENDING;\n              _boundaryIndex = 0;\n            }\n          } else {\n            // Restart matching of the boundary.\n            index = index - _boundaryIndex;\n            _boundaryIndex = 0;\n          }\n          break;\n\n        case _FIRST_BOUNDARY_ENDING:\n          if (byte == _CharCode.CR) {\n            _state = _FIRST_BOUNDARY_END;\n          } else {\n            _expectWS(byte);\n          }\n          break;\n\n        case _FIRST_BOUNDARY_END:\n          _expect(byte, _CharCode.LF);\n          _state = _HEADER_START;\n          break;\n\n        case _BOUNDARY_ENDING:\n          if (byte == _CharCode.CR) {\n            _state = _BOUNDARY_END;\n          } else if (byte == _CharCode.DASH) {\n            _state = _LAST_BOUNDARY_DASH2;\n          } else {\n            _expectWS(byte);\n          }\n          break;\n\n        case _BOUNDARY_END:\n          _expect(byte, _CharCode.LF);\n          if (partEnd != null) {\n            partEnd(false);\n          }\n          _state = _HEADER_START;\n          break;\n\n        case _HEADER_START:\n          if (byte == _CharCode.CR) {\n            _state = _HEADER_ENDING;\n            } else {\n              // Start of new header field.\n              _headerField.writeCharCode(_toLowerCase(byte));\n              _state = _HEADER_FIELD;\n            }\n            break;\n\n          case _HEADER_FIELD:\n            if (byte == _CharCode.COLON) {\n              _state = _HEADER_VALUE_START;\n            } else {\n              if (!_isTokenChar(byte)) {\n                throw new MimeParserException(\"Invalid header field name\");\n              }\n              _headerField.writeCharCode(_toLowerCase(byte));\n            }\n            break;\n\n          case _HEADER_VALUE_START:\n            if (byte == _CharCode.CR) {\n              _state = _HEADER_VALUE_FOLDING_OR_ENDING;\n            } else if (byte != _CharCode.SP && byte != _CharCode.HT) {\n              // Start of new header value.\n              _headerValue.writeCharCode(byte);\n              _state = _HEADER_VALUE;\n            }\n            break;\n\n          case _HEADER_VALUE:\n            if (byte == _CharCode.CR) {\n              _state = _HEADER_VALUE_FOLDING_OR_ENDING;\n            } else {\n              _headerValue.writeCharCode(byte);\n            }\n            break;\n\n          case _HEADER_VALUE_FOLDING_OR_ENDING:\n            _expect(byte, _CharCode.LF);\n            _state = _HEADER_VALUE_FOLD_OR_END;\n            break;\n\n          case _HEADER_VALUE_FOLD_OR_END:\n            if (byte == _CharCode.SP || byte == _CharCode.HT) {\n              _state = _HEADER_VALUE_START;\n            } else {\n              String headerField = _headerField.toString();\n              String headerValue =_headerValue.toString();\n              if (headerReceived != null) {\n                headerReceived(headerField, headerValue);\n              }\n              _headerField = new StringBuffer();\n              _headerValue = new StringBuffer();\n              if (byte == _CharCode.CR) {\n                _state = _HEADER_ENDING;\n              } else {\n                // Start of new header field.\n                _headerField.writeCharCode(_toLowerCase(byte));\n                _state = _HEADER_FIELD;\n              }\n            }\n            break;\n\n          case _HEADER_ENDING:\n            _expect(byte, _CharCode.LF);\n            if (headersComplete != null) headersComplete();\n            _state = _CONTENT;\n            contentStartIndex = index + 1;\n            break;\n\n          case _CONTENT:\n            if (_toLowerCase(byte) == _toLowerCase(_boundary[_boundaryIndex])) {\n              _boundaryIndex++;\n              if (_boundaryIndex == _boundary.length) {\n                if (contentStartIndex != null) {\n                  index++;\n                  reportData();\n                  index--;\n                }\n                _boundaryIndex = 0;\n                _state = _BOUNDARY_ENDING;\n              }\n            } else {\n              // Restart matching of the boundary.\n              index = index - _boundaryIndex;\n              if (contentStartIndex == null) contentStartIndex = index;\n              _boundaryIndex = 0;\n            }\n            break;\n\n        case _LAST_BOUNDARY_DASH2:\n          _expect(byte, _CharCode.DASH);\n          _state = _LAST_BOUNDARY_ENDING;\n          break;\n\n        case _LAST_BOUNDARY_ENDING:\n          if (byte == _CharCode.CR) {\n            _state = _LAST_BOUNDARY_END;\n          } else {\n            _expectWS(byte);\n          }\n          break;\n\n        case _LAST_BOUNDARY_END:\n          _expect(byte, _CharCode.LF);\n          if (partEnd != null) {\n            partEnd(true);\n          }\n          _state = _DONE;\n          break;\n\n        default:\n          // Should be unreachable.\n          assert(false);\n          break;\n      }\n\n      // Move to the next byte.\n      index++;\n    }\n\n    // Report any known content.\n    if (_state == _CONTENT && contentStartIndex != null) {\n      reportData();\n    }\n    return index - offset;\n  }\n\n  bool _isTokenChar(int byte) {\n    return byte > 31 && byte < 128 && _Const.SEPARATORS.indexOf(byte) == -1;\n  }\n\n  int _toLowerCase(int byte) {\n    final int aCode = \"A\".codeUnitAt(0);\n    final int zCode = \"Z\".codeUnitAt(0);\n    final int delta = \"a\".codeUnitAt(0) - aCode;\n    return (aCode <= byte && byte <= zCode) ? byte + delta : byte;\n  }\n\n  void _expect(int val1, int val2) {\n    if (val1 != val2) {\n      throw new MimeParserException(\"Failed to parse multipart mime 1\");\n    }\n  }\n\n  void _expectWS(int byte) {\n    if (byte != _CharCode.SP && byte != _CharCode.HT) {\n      throw new MimeParserException(\"Failed to parse multipart mime 2\");\n    }\n  }\n\n  List<int> _boundary;\n  int _state;\n  int _boundaryIndex = 0;\n\n  StringBuffer _headerField;\n  StringBuffer _headerValue;\n\n  Function partStart;\n  Function headerReceived;\n  Function headersComplete;\n  Function partDataReceived;\n  Function partEnd;\n}\n\n\nclass MimeParserException implements Exception {\n  const MimeParserException([String this.message = \"\"]);\n  String toString() => \"MimeParserException: $message\";\n  final String message;\n}\n","sdk/lib/io/options.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * The Options object allows accessing the arguments which have been passed to\n * the current isolate.\n */\nabstract class Options {\n  /**\n   * A newly constructed Options object contains the arguments exactly as they\n   * have been passed to the isolate.\n   */\n  factory Options() => new _OptionsImpl();\n\n  /**\n   * Returns a list of arguments that have been passed to this isolate. Any\n   * modifications to the list will be contained to the options object owning\n   * this list.\n   *\n   * If the execution environment does not support [arguments] an empty list\n   * is returned.\n   */\n  List<String> get arguments;\n\n  /**\n   * Returns the path of the executable used to run the script in this\n   * isolate.\n   *\n   * If the execution environment does not support [executable] an empty\n   * string is returned.\n   */\n  String get executable;\n\n  /**\n   * Returns the path of the script being run in this isolate.\n   *\n   * If the executable environment does not support [script] an empty\n   * string is returned.\n   */\n  String get script;\n}\n\nclass _OptionsImpl implements Options {\n  List<String> get arguments {\n    if (_arguments == null) {\n      // On first access make a copy of the native arguments.\n      _arguments = _nativeArguments.sublist(0, _nativeArguments.length);\n    }\n    return _arguments;\n  }\n\n  String get executable {\n    return _nativeExecutable;\n  }\n\n  String get script {\n    return _nativeScript;\n  }\n\n  List<String> _arguments = null;\n\n  // This arguments singleton is written to by the embedder if applicable.\n  static List<String> _nativeArguments = const [];\n\n  // This executable singleton is written to by the embedder if applicable.\n  static String _nativeExecutable = '';\n\n  // This script singleton is written to by the embedder if applicable.\n  static String _nativeScript = '';\n}\n","sdk/lib/io/path.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * A Path is an immutable wrapper of a String, with additional member functions\n * for useful path manipulations and queries.\n * On the Windows platform, Path also converts from native paths to paths using\n * '/' as a path separator, and vice versa.\n *\n * Joining of paths and path normalization handle '.' and '..' in the usual way.\n */\nabstract class Path {\n  /**\n   * Creates a Path from a String that uses the native filesystem's conventions.\n   *\n   * On Windows, this converts '\\' to '/' and has special handling for drive\n   * letters and shares.\n   *\n   * If the path starts with a drive letter, like 'C:',  a '/' is added\n   * before the drive letter.\n   *\n   *     new Path(r'c:\\a\\b').toString() == '/c:/a/b'\n   *\n   * A path starting with a drive letter is\n   * treated specially.  Backwards links ('..') cannot cancel the drive letter.\n   *\n   * If the path is a share path this is recorded in the Path object and\n   * maintained in operations on the Path object.\n   *\n   *     var share = new Path(r'\\\\share\\a\\b\\c');\n   *     share.isWindowsShare == true\n   *     share.toString() == '/share/a/b/c'\n   *     share.toNativePath() == r'\\\\share\\a\\b\\c'\n   *     share.append('final').isWindowsShare == true\n   */\n  factory Path(String source) => new _Path(source);\n\n  /**\n   * Creates a Path from the String [source].  [source] is used as-is, so if\n   * the string does not consist of segments separated by forward slashes, the\n   * behavior may not be as expected.  Paths are immutable.\n   */\n  factory Path.raw(String source) => new _Path.raw(source);\n\n  /**\n   * Is this path the empty string?\n   */\n  bool get isEmpty;\n\n  /**\n   * Is this path an absolute path, beginning with a '/'?  Note that\n   * Windows paths beginning with '\\' or with a drive letter are absolute,\n   * and a leading '/' is added when they are converted to a Path.\n   */\n  bool get isAbsolute;\n\n  /**\n   * Is this path a Windows share path?\n   */\n  bool get isWindowsShare;\n\n  /**\n   * Does this path end with a '/'?\n   */\n  bool get hasTrailingSeparator;\n\n  /**\n   * Does this path contain no consecutive '/'s, no segments that\n   * are '.' unless the path is exactly '.', and segments that are '..' only\n   * as the leading segments on a relative path?\n   */\n  bool get isCanonical;\n\n  /**\n   * Make a path canonical by dropping segments that are '.', cancelling\n   * segments that are '..' with preceding segments, if possible,\n   * and combining consecutive '/'s.  Leading '..' segments\n   * are kept on relative paths, and dropped from absolute paths.\n   */\n  Path canonicalize();\n\n  /**\n   * Joins the relative path [further] to this path.  Canonicalizes the\n   * resulting joined path using [canonicalize],\n   * interpreting '.' and '..' as directory traversal commands, and removing\n   * consecutive '/'s.\n   *\n   * If [further] is an absolute path, an IllegalArgument exception is thrown.\n   *\n   * Examples:\n   *   `new Path('/a/b/c').join(new Path('d/e'))` returns the Path object\n   *   containing `'a/b/c/d/e'`.\n   *\n   *   `new Path('a/b/../c/').join(new Path('d/./e//')` returns the Path\n   *   containing `'a/c/d/e/'`.\n   *\n   *   `new Path('a/b/c').join(new Path('d/../../e')` returns the Path\n   *   containing `'a/b/e'`.\n   *\n   * Note that the join operation does not drop the last segment of the\n   * base path, the way URL joining does.  To join basepath to further using\n   * URL semantics, use\n   *    [:basepath.directoryPath.join(further):].\n   *\n   * If you want to avoid joins that traverse\n   * parent directories in the base, you can check whether\n   * `further.canonicalize()` starts with '../' or equals '..'.\n   */\n  Path join(Path further);\n\n\n  /**\n   * Returns a path [:relative:] such that\n   *    [:base.join(relative) == this.canonicalize():].\n   * Throws an exception if such a path is impossible.\n   * For example, if [base] is '../../a/b' and [this] is '.'.\n   * The computation is independent of the file system and current directory.\n   *\n   * To compute a relative path using URL semantics, where the final\n   * path component of the base is dropped unless it ends with a slash,\n   * call [: a.relativeTo(b.directoryPath) :] instead of [: a.relativeTo(b) :].\n   */\n  Path relativeTo(Path base);\n\n  /**\n   * Converts a path to a string using the native filesystem's conventions.\n   *\n   * Always returns '.' if the path is empty.\n   * On Windows, converts '/'s to backwards slashes, and removes\n   * the leading '/' if the path starts with a drive specification.\n   * For most valid Windows paths, this should be the inverse of the\n   * conversion that the constructor new Path() performs.  If the path is\n   * a Windows share, restores the '\\\\' at the start of the path.\n   */\n  String toNativePath();\n\n  /**\n   * Returns the path as a string.  If this path is constructed using\n   * new Path.raw(), or new Path() on a non-Windows system, the\n   * returned value is the original string argument to the constructor.\n   */\n  String toString();\n\n  /**\n   * Gets the segments of a Path. The segments are just the result of\n   * splitting the path on any '/' characters, except that a '/' at the\n   * beginning does not create an empty segment before it, and a '/' at\n   * the end does not create an empty segment after it.\n   *\n   *     new Path('/a/b/c/d').segments() == ['a', 'b', 'c', d'];\n   *     new Path(' foo bar //../') == [' foo bar ', '', '..'];\n   */\n  List<String> segments();\n\n  /**\n   * Appends [finalSegment] to a path as a new segment.  Adds a '/'\n   * between the path and [finalSegment] if the path does not already end in\n   * a '/'.  The path is not canonicalized, and [finalSegment] may\n   * contain '/'s.\n   */\n  Path append(String finalSegment);\n\n  /**\n   * Drops the final '/' and whatever follows it from this Path,\n   * and returns the resulting Path object.  If the only '/' in\n   * this Path is the first character, returns '/' instead of the empty string.\n   * If there is no '/' in the Path, returns the empty string.\n   *\n   *     new Path('../images/dot.gif').directoryPath == '../images'\n   *     new Path('/usr/geoffrey/www/').directoryPath == '/usr/geoffrey/www'\n   *     new Path('lost_file_old').directoryPath == ''\n   *     new Path('/src').directoryPath == '/'\n   *     Note: new Path('/D:/src').directoryPath == '/D:'\n   */\n  Path get directoryPath;\n\n  /**\n   * The part of the path after the last '/', or the entire path if\n   * it contains no '/'.\n   *\n   *     new Path('images/DSC_0027.jpg).filename == 'DSC_0027.jpg'\n   *     new Path('users/fred/').filename == ''\n   */\n  String get filename;\n\n  /**\n   * The part of [filename] before the last '.', or the entire filename if it\n   * contains no '.'.  If [filename] is '.' or '..' it is unchanged.\n   *\n   *     new Path('/c:/My Documents/Heidi.txt').filenameWithoutExtension\n   *     would return 'Heidi'.\n   *     new Path('not what I would call a path').filenameWithoutExtension\n   *     would return 'not what I would call a path'.\n   */\n  String get filenameWithoutExtension;\n\n  /**\n   * The part of [filename] after the last '.', or '' if [filename]\n   * contains no '.'.  If [filename] is '.' or '..', returns ''.\n   *\n   *     new Path('tiger.svg').extension == 'svg'\n   *     new Path('/src/dart/dart_secrets').extension == ''\n   */\n  String get extension;\n}\n","sdk/lib/io/path_impl.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass _Path implements Path {\n  final String _path;\n  final bool isWindowsShare;\n\n  _Path(String source)\n      : _path = _clean(source), isWindowsShare = _isWindowsShare(source);\n\n  _Path.raw(String source) : _path = source, isWindowsShare = false;\n\n  _Path._internal(String this._path, bool this.isWindowsShare);\n\n  static String _clean(String source) {\n    if (Platform.operatingSystem == 'windows') return _cleanWindows(source);\n    return source;\n  }\n\n  static String _cleanWindows(String source) {\n    // Change \\ to /.\n    var clean = source.replaceAll('\\\\', '/');\n    // Add / before intial [Drive letter]:\n    if (clean.length >= 2 && clean[1] == ':') {\n      clean = '/$clean';\n    }\n    if (_isWindowsShare(source)) {\n      return clean.substring(1, clean.length);\n    }\n    return clean;\n  }\n\n  static bool _isWindowsShare(String source) {\n    return Platform.operatingSystem == 'windows' && source.startsWith('\\\\\\\\');\n  }\n\n  int get hashCode => _path.hashCode;\n  bool get isEmpty => _path.isEmpty;\n  bool get isAbsolute => _path.startsWith('/');\n  bool get hasTrailingSeparator => _path.endsWith('/');\n\n  String toString() => _path;\n\n  Path relativeTo(Path base) {\n    // Returns a path \"relative\" such that\n    // base.join(relative) == this.canonicalize.\n    // Throws exception if an impossible case is reached.\n    if (base.isAbsolute != isAbsolute ||\n        base.isWindowsShare != isWindowsShare) {\n      throw new ArgumentError(\n          \"Invalid case of Path.relativeTo(base):\\n\"\n          \"  Path and base must both be relative, or both absolute.\\n\"\n          \"  Arguments: $_path.relativeTo($base)\");\n    }\n\n    var basePath = base.toString();\n    // Handle drive letters specially on Windows.\n    if (base.isAbsolute && Platform.operatingSystem == 'windows') {\n      bool baseHasDrive =\n          basePath.length >= 4 && basePath[2] == ':' && basePath[3] == '/';\n      bool pathHasDrive =\n          _path.length >= 4 && _path[2] == ':' && _path[3] == '/';\n      if (baseHasDrive && pathHasDrive) {\n        int baseDrive = basePath.codeUnitAt(1) | 32;  // Convert to uppercase.\n        if (baseDrive >= 'a'.codeUnitAt(0) &&\n            baseDrive <= 'z'.codeUnitAt(0) &&\n            baseDrive == (_path.codeUnitAt(1) | 32)) {\n          if(basePath[1] != _path[1]) {\n            // Replace the drive letter in basePath with that from _path.\n            basePath = '/${_path[1]}:/${basePath.substring(4)}';\n            base = new Path(basePath);\n          }\n        } else {\n          throw new ArgumentError(\n              \"Invalid case of Path.relativeTo(base):\\n\"\n              \"  Base path and target path are on different Windows drives.\\n\"\n              \"  Arguments: $_path.relativeTo($base)\");\n        }\n      } else if (baseHasDrive != pathHasDrive) {\n        throw new ArgumentError(\n            \"Invalid case of Path.relativeTo(base):\\n\"\n            \"  Base path must start with a drive letter if and \"\n            \"only if target path does.\\n\"\n            \"  Arguments: $_path.relativeTo($base)\");\n      }\n\n    }\n    if (_path.startsWith(basePath)) {\n      if (_path == basePath) return new Path('.');\n      // There must be a '/' at the end of the match, or immediately after.\n      int matchEnd = basePath.length;\n      if (_path[matchEnd - 1] == '/' || _path[matchEnd] == '/') {\n        // Drop any extra '/' characters at matchEnd\n        while (matchEnd < _path.length && _path[matchEnd] == '/') {\n          matchEnd++;\n        }\n        return new Path(_path.substring(matchEnd)).canonicalize();\n      }\n    }\n\n    List<String> baseSegments = base.canonicalize().segments();\n    List<String> pathSegments = canonicalize().segments();\n    if (baseSegments.length == 1 && baseSegments[0] == '.') {\n      baseSegments = [];\n    }\n    if (pathSegments.length == 1 && pathSegments[0] == '.') {\n      pathSegments = [];\n    }\n    int common = 0;\n    int length = min(pathSegments.length, baseSegments.length);\n    while (common < length && pathSegments[common] == baseSegments[common]) {\n      common++;\n    }\n    final segments = new List<String>();\n\n    if (common < baseSegments.length && baseSegments[common] == '..') {\n      throw new ArgumentError(\n          \"Invalid case of Path.relativeTo(base):\\n\"\n          \"  Base path has more '..'s than path does.\\n\"\n          \"  Arguments: $_path.relativeTo($base)\");\n    }\n    for (int i = common; i < baseSegments.length; i++) {\n      segments.add('..');\n    }\n    for (int i = common; i < pathSegments.length; i++) {\n      segments.add('${pathSegments[i]}');\n    }\n    if (segments.isEmpty) {\n      segments.add('.');\n    }\n    if (hasTrailingSeparator) {\n        segments.add('');\n    }\n    return new Path(segments.join('/'));\n  }\n\n\n  Path join(Path further) {\n    if (further.isAbsolute) {\n      throw new ArgumentError(\n          \"Path.join called with absolute Path as argument.\");\n    }\n    if (isEmpty) {\n      return further.canonicalize();\n    }\n    if (hasTrailingSeparator) {\n      var joined = new _Path._internal('$_path${further}', isWindowsShare);\n      return joined.canonicalize();\n    }\n    var joined = new _Path._internal('$_path/${further}', isWindowsShare);\n    return joined.canonicalize();\n  }\n\n  // Note: The URI RFC names for canonicalize, join, and relativeTo\n  // are normalize, resolve, and relativize.  But resolve and relativize\n  // drop the last segment of the base path (the filename), on URIs.\n  Path canonicalize() {\n    if (isCanonical) return this;\n    return makeCanonical();\n  }\n\n  bool get isCanonical {\n    // Contains no consecutive path separators.\n    // Contains no segments that are '.'.\n    // Absolute paths have no segments that are '..'.\n    // All '..' segments of a relative path are at the beginning.\n    if (isEmpty) return false;  // The canonical form of '' is '.'.\n    if (_path == '.') return true;\n    List segs = _path.split('/');  // Don't mask the getter 'segments'.\n    if (segs[0] == '') {  // Absolute path\n      segs[0] = null;  // Faster than removeRange().\n    } else {  // A canonical relative path may start with .. segments.\n      for (int pos = 0;\n           pos < segs.length && segs[pos] == '..';\n           ++pos) {\n        segs[pos] = null;\n      }\n    }\n    if (segs.last == '') segs.removeLast();  // Path ends with /.\n    // No remaining segments can be ., .., or empty.\n    return !segs.any((s) => s == '' || s == '.' || s == '..');\n  }\n\n  Path makeCanonical() {\n    bool isAbs = isAbsolute;\n    List segs = segments();\n    String drive;\n    if (isAbs &&\n        !segs.isEmpty &&\n        segs[0].length == 2 &&\n        segs[0][1] == ':') {\n      drive = segs[0];\n      segs.removeRange(0, 1);\n    }\n    List newSegs = [];\n    for (String segment in segs) {\n      switch (segment) {\n        case '..':\n          // Absolute paths drop leading .. markers, including after a drive.\n          if (newSegs.isEmpty) {\n            if (isAbs) {\n              // Do nothing: drop the segment.\n            } else {\n              newSegs.add('..');\n            }\n          } else if (newSegs.last == '..') {\n            newSegs.add('..');\n          } else {\n            newSegs.removeLast();\n          }\n          break;\n        case '.':\n        case '':\n          // Do nothing - drop the segment.\n          break;\n        default:\n          newSegs.add(segment);\n          break;\n      }\n    }\n\n    List segmentsToJoin = [];\n    if (isAbs) {\n      segmentsToJoin.add('');\n      if (drive != null) {\n        segmentsToJoin.add(drive);\n      }\n    }\n\n    if (newSegs.isEmpty) {\n      if (isAbs) {\n        segmentsToJoin.add('');\n      } else {\n        segmentsToJoin.add('.');\n      }\n    } else {\n      segmentsToJoin.addAll(newSegs);\n      if (hasTrailingSeparator) {\n        segmentsToJoin.add('');\n      }\n    }\n    return new _Path._internal(segmentsToJoin.join('/'), isWindowsShare);\n  }\n\n  String toNativePath() {\n    if (isEmpty) return '.';\n    if (Platform.operatingSystem == 'windows') {\n      String nativePath = _path;\n      // Drop '/' before a drive letter.\n      if (nativePath.length >= 3 &&\n          nativePath.startsWith('/') &&\n          nativePath[2] == ':') {\n        nativePath = nativePath.substring(1);\n      }\n      nativePath = nativePath.replaceAll('/', '\\\\');\n      if (isWindowsShare) {\n        return '\\\\$nativePath';\n      }\n      return nativePath;\n    }\n    return _path;\n  }\n\n  List<String> segments() {\n    List result = _path.split('/');\n    if (isAbsolute) result.removeRange(0, 1);\n    if (hasTrailingSeparator) result.removeLast();\n    return result;\n  }\n\n  Path append(String finalSegment) {\n    if (isEmpty) {\n      return new _Path._internal(finalSegment, isWindowsShare);\n    } else if (hasTrailingSeparator) {\n      return new _Path._internal('$_path$finalSegment', isWindowsShare);\n    } else {\n      return new _Path._internal('$_path/$finalSegment', isWindowsShare);\n    }\n  }\n\n  String get filenameWithoutExtension {\n    var name = filename;\n    if (name == '.' || name == '..') return name;\n    int pos = name.lastIndexOf('.');\n    return (pos < 0) ? name : name.substring(0, pos);\n  }\n\n  String get extension {\n    var name = filename;\n    int pos = name.lastIndexOf('.');\n    return (pos < 0) ? '' : name.substring(pos + 1);\n  }\n\n  Path get directoryPath {\n    int pos = _path.lastIndexOf('/');\n    if (pos < 0) return new Path('');\n    while (pos > 0 && _path[pos - 1] == '/') --pos;\n    var dirPath = (pos > 0) ? _path.substring(0, pos) : '/';\n    return new _Path._internal(dirPath, isWindowsShare);\n  }\n\n  String get filename {\n    int pos = _path.lastIndexOf('/');\n    return _path.substring(pos + 1);\n  }\n}\n","sdk/lib/io/platform.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * The [Platform] class exposes details of the machine and operating\n * system.\n */\nclass Platform {\n  /**\n   * Get the number of processors of the machine.\n   */\n  static int get numberOfProcessors => _Platform.numberOfProcessors;\n\n  /**\n   * Get the path separator used by the operating system to separate\n   * components in file paths.\n   */\n  static String get pathSeparator => _Platform.pathSeparator;\n\n  /**\n   * Get a string ('macos', 'windows', 'linux') representing the\n   * operating system.\n   */\n  static String get operatingSystem => _Platform.operatingSystem;\n\n  /**\n   * Get the local hostname for the system.\n   */\n  static String get localHostname => _Platform.localHostname;\n\n  /**\n   * Get the environment for this process.\n   *\n   * Environment variables on Windows are case-insensitive. The map\n   * returned on Windows is therefore case-insensitive and will convert\n   * all keys to upper case. On other platforms the returned map is\n   * a standard case-sensitive map.\n   */\n  static Map<String, String> get environment => _Platform.environment;\n}\n","sdk/lib/io/platform_impl.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass _Platform {\n  external static int _numberOfProcessors();\n  external static String _pathSeparator();\n  external static String _operatingSystem();\n  external static _localHostname();\n  external static _environment();\n\n  static int get numberOfProcessors {\n    return _numberOfProcessors();\n  }\n\n  static String get pathSeparator {\n    return _pathSeparator();\n  }\n\n  static String get operatingSystem {\n    return _operatingSystem();\n  }\n\n  static String get localHostname {\n    var result = _localHostname();\n    if (result is OSError) {\n      throw result;\n    } else {\n      return result;\n    }\n  }\n\n  static Map<String, String> get environment {\n    var env = _environment();\n    if (env is OSError) {\n      throw env;\n    } else {\n      var isWindows = operatingSystem == 'windows';\n      var result = isWindows ? new _CaseInsensitiveStringMap() : new Map();\n      for (var str in env) {\n        // When running on Windows through cmd.exe there are strange\n        // environment variables that are used to record the current\n        // working directory for each drive and the exit code for the\n        // last command. As an example: '=A:=A:\\subdir' records the\n        // current working directory on the 'A' drive.  In order to\n        // handle these correctly we search for a second occurrence of\n        // of '=' in the string if the first occurrence is at index 0.\n        var equalsIndex = str.indexOf('=');\n        if (equalsIndex == 0) {\n          equalsIndex = str.indexOf('=', 1);\n        }\n        assert(equalsIndex != -1);\n        result[str.substring(0, equalsIndex)] = str.substring(equalsIndex + 1);\n      }\n      return result;\n    }\n  }\n}\n\n// Environment variables are case-insensitive on Windows. In order\n// to reflect that we use a case-insensitive string map on Windows.\nclass _CaseInsensitiveStringMap<V> implements Map<String, V> {\n  _CaseInsensitiveStringMap() : _map = new Map<String, V>();\n\n  _CaseInsensitiveStringMap.from(Map<String, V> other)\n      : _map = new Map<String, V>() {\n    other.forEach((String key, V value) {\n      _map[key.toUpperCase()] = value;\n    });\n  }\n\n  bool containsKey(String key) => _map.containsKey(key.toUpperCase());\n  bool containsValue(V value) => _map.containsValue(value);\n  V operator [](String key) => _map[key.toUpperCase()];\n  void operator []=(String key, V value) {\n    _map[key.toUpperCase()] = value;\n  }\n  V putIfAbsent(String key, V ifAbsent()) {\n    _map.putIfAbsent(key.toUpperCase(), ifAbsent);\n  }\n  V remove(String key) => _map.remove(key.toUpperCase());\n  void clear() => _map.clear();\n  void forEach(void f(String key, V value)) => _map.forEach(f);\n  Iterable<String> get keys => _map.keys;\n  Iterable<V> get values => _map.values;\n  int get length => _map.length;\n  bool get isEmpty => _map.isEmpty;\n\n  Map<String, V> _map;\n}\n","sdk/lib/io/process.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n// TODO(ager): The only reason for this class is that we\n// cannot patch a top-level at this point.\nclass _ProcessUtils {\n  external static void _exit(int status);\n  external static void _setExitCode(int status);\n  external static void _sleep(int millis);\n  external static int _pid(Process process);\n}\n\n/**\n * Exit the Dart VM process immediately with the given [status] code.\n *\n * This does not wait for any asynchronous operations to terminate. Using\n * [exit] is therefore very likely to lose data.\n */\nvoid exit(int status) {\n  if (status is !int) {\n    throw new ArgumentError(\"exit: int status expected\");\n  }\n  _ProcessUtils._exit(status);\n}\n\n/**\n * Global exit code for the Dart VM.\n *\n * The exit code is global for the Dart VM and the last assignment to\n * exitCode from any isolate determines the exit code of the Dart VM\n * on normal termination.\n */\nset exitCode(int status) {\n  if (status is !int) {\n    throw new ArgumentError(\"setExitCode: int status expected\");\n  }\n  _ProcessUtils._setExitCode(status);\n}\n\n/**\n * Sleep for the duration specified in [duration].\n *\n * Use this with care, as no asynchronous operations can be processed\n * in a isolate while it is blocked in a [sleep] call.\n */\nvoid sleep(Duration duration) {\n  int milliseconds = duration.inMilliseconds;\n  if (milliseconds < 0) {\n    throw new ArgumentError(\"sleep: duration cannot be negative\");\n  }\n  _ProcessUtils._sleep(milliseconds);\n}\n\n/**\n * Returns the PID if the current process.\n */\nint get pid => _ProcessUtils._pid(null);\n\n/**\n * [Process] is used to start new processes using the static\n * [start] and [run] methods.\n */\nabstract class Process {\n  /**\n   * Starts a process running the [executable] with the specified\n   * [arguments]. Returns a [:Future<Process>:] that completes with a\n   * Process instance when the process has been successfully\n   * started. That [Process] object can be used to interact with the\n   * process. If the process cannot be started the returned [Future]\n   * completes with an exception.\n   *\n   * An optional [ProcessOptions] object can be passed to specify\n   * options other than the executable and the arguments.\n   *\n   * Users must read all data coming on the [stdout] and [stderr]\n   * streams of processes started with [:Process.start:]. If the user\n   * does not read all data on the streams the underlying system\n   * resources will not be freed since there is still pending data.\n   */\n  external static Future<Process> start(String executable,\n                                        List<String> arguments,\n                                        [ProcessOptions options]);\n\n  /**\n   * Starts a process and runs it non-interactively to completion. The\n   * process run is [executable] with the specified [arguments].\n   *\n   * An optional [ProcessOptions] object can be passed to specify\n   * options other than the executable and the arguments.\n   *\n   * Returns a [:Future<ProcessResult>:] that completes with the\n   * result of running the process, i.e., exit code, standard out and\n   * standard in.\n   */\n  external static Future<ProcessResult> run(String executable,\n                                            List<String> arguments,\n                                            [ProcessOptions options]);\n\n  /**\n   * Returns the standard output stream of the process as a [:Stream:].\n   *\n   * Throws an [UnsupportedError] if the process is\n   * non-interactive.\n   */\n  Stream<List<int>> get stdout;\n\n  /**\n   * Returns the standard error stream of the process as a [:Stream:].\n   *\n   * Throws an [UnsupportedError] if the process is\n   * non-interactive.\n   */\n  Stream<List<int>> get stderr;\n\n  /**\n   * Returns the standard input stream of the process as an [IOSink].\n   *\n   * Throws an [UnsupportedError] if the process is\n   * non-interactive.\n   */\n  IOSink get stdin;\n\n  /**\n   * Returns the process id of the process.\n   */\n  int get pid;\n\n  /**\n   * Returns a [:Future:] which completes with the exit code of the process\n   * when the process completes.\n   *\n   * Throws an [UnsupportedError] if the process is\n   * non-interactive.\n   */\n  Future<int> exitCode;\n\n  /**\n   * On Windows, [kill] kills the process, ignoring the [signal]\n   * flag. On Posix systems, [kill] sends [signal] to the\n   * process. Depending on the signal giving, it'll have different\n   * meanings. When the process terminates as a result of calling\n   * [kill] [onExit] is called.\n   *\n   * Returns [:true:] if the process is successfully killed (the\n   * signal is successfully sent). Returns [:false:] if the process\n   * could not be killed (the signal could not be sent). Usually,\n   * a [:false:] return value from kill means that the process is\n   * already dead.\n   */\n  bool kill([ProcessSignal signal = ProcessSignal.SIGTERM]);\n}\n\n\n/**\n * [ProcessResult] represents the result of running a non-interactive\n * process started with [:Process.run:].\n */\nabstract class ProcessResult {\n  /**\n   * Exit code for the process.\n   */\n  int get exitCode;\n\n  /**\n   * Standard output from the process as a string.\n   */\n  String get stdout;\n\n  /**\n   * Standard error from the process as a string.\n   */\n  String get stderr;\n\n  /**\n   * Process id from the process.\n   */\n  int get pid;\n}\n\n\n/**\n * [ProcessOptions] represents the options that can be supplied when\n * starting a process.\n */\nclass ProcessOptions {\n  /**\n   * The working directory from which the process is started.  Note\n   * that the change of directory occurs before executing the process\n   * on some platforms, which may have impact when using relative\n   * paths for the executable and the arguments.\n   */\n  String workingDirectory;\n\n  /**\n   * The encoding used for text on stdout when starting a\n   * non-interactive process with [:Process.run:].\n   *\n   * This option is ignored for interactive processes started with\n   * [:Process.start:].\n   *\n   * The default stdoutEncoding is SYSTEM.\n   */\n  Encoding stdoutEncoding;\n\n  /**\n   * The encoding used for text on stderr when starting a\n   * non-interactive process with [:Process.run:].\n   *\n   * This option is ignored for interactive processes started with\n   * [:Process.start:].\n   *\n   * The default stderrEncoding is SYSTEM.\n   */\n  Encoding stderrEncoding;\n\n  /**\n   * Provides the environment variables for the process. If not set\n   * the environment of the parent process is inherited.\n   *\n   * Currently, only ASCII environment variables are supported and\n   * errors are likely to occur if an environment variables with\n   * code-points outside the ASCII range is passed in.\n   */\n  Map<String, String> environment;\n}\n\n/**\n * On Posix systems, [ProcessSignal] is used to send a specific signal\n * to a child process, see [:Process.kill:].\n */\nclass ProcessSignal {\n  static const ProcessSignal SIGHUP = const ProcessSignal._signal(1);\n  static const ProcessSignal SIGINT = const ProcessSignal._signal(2);\n  static const ProcessSignal SIGQUIT = const ProcessSignal._signal(3);\n  static const ProcessSignal SIGILL = const ProcessSignal._signal(4);\n  static const ProcessSignal SIGTRAP = const ProcessSignal._signal(5);\n  static const ProcessSignal SIGABRT = const ProcessSignal._signal(6);\n  static const ProcessSignal SIGBUS = const ProcessSignal._signal(7);\n  static const ProcessSignal SIGFPE = const ProcessSignal._signal(8);\n  static const ProcessSignal SIGKILL = const ProcessSignal._signal(9);\n  static const ProcessSignal SIGUSR1 = const ProcessSignal._signal(10);\n  static const ProcessSignal SIGSEGV = const ProcessSignal._signal(11);\n  static const ProcessSignal SIGUSR2 = const ProcessSignal._signal(12);\n  static const ProcessSignal SIGPIPE = const ProcessSignal._signal(13);\n  static const ProcessSignal SIGALRM = const ProcessSignal._signal(14);\n  static const ProcessSignal SIGTERM = const ProcessSignal._signal(15);\n  static const ProcessSignal SIGCHLD = const ProcessSignal._signal(17);\n  static const ProcessSignal SIGCONT = const ProcessSignal._signal(18);\n  static const ProcessSignal SIGSTOP = const ProcessSignal._signal(19);\n  static const ProcessSignal SIGTSTP = const ProcessSignal._signal(20);\n  static const ProcessSignal SIGTTIN = const ProcessSignal._signal(21);\n  static const ProcessSignal SIGTTOU = const ProcessSignal._signal(22);\n  static const ProcessSignal SIGURG = const ProcessSignal._signal(23);\n  static const ProcessSignal SIGXCPU = const ProcessSignal._signal(24);\n  static const ProcessSignal SIGXFSZ = const ProcessSignal._signal(25);\n  static const ProcessSignal SIGVTALRM = const ProcessSignal._signal(26);\n  static const ProcessSignal SIGPROF = const ProcessSignal._signal(27);\n  static const ProcessSignal SIGPOLL = const ProcessSignal._signal(29);\n  static const ProcessSignal SIGSYS = const ProcessSignal._signal(31);\n\n  const ProcessSignal._signal(int this._signalNumber);\n  final int _signalNumber;\n}\n\n\nclass ProcessException implements Exception {\n  const ProcessException(String this.executable,\n                         List<String> this.arguments,\n                         [String this.message = \"\",\n                          int this.errorCode = 0]);\n  String toString() {\n    var msg = (message == null) ? 'OS error code: $errorCode' : message;\n    var args = arguments.join(' ');\n    return \"ProcessException: $msg\\n  Command: $executable $args\";\n  }\n\n  /**\n   * Contains the executable provided for the process.\n   */\n  final String executable;\n\n  /**\n   * Contains the arguments provided for the process.\n   */\n  final List<String> arguments;\n\n  /**\n   * Contains the system message for the process exception if any.\n   */\n  final String message;\n\n  /**\n   * Contains the OS error code for the process exception if any.\n   */\n  final int errorCode;\n}\n","sdk/lib/io/secure_server_socket.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * The [SecureServerSocket] is a server socket, providing a stream of high-level\n * [Socket]s.\n *\n * See [SecureSocket] for more info.\n */\nclass SecureServerSocket extends Stream<SecureSocket> implements ServerSocket {\n  final RawSecureServerSocket _socket;\n\n  SecureServerSocket._(RawSecureServerSocket this._socket);\n\n  /**\n   * Returns a future for a [SecureServerSocket]. When the future\n   * completes the server socket is bound to the given [address] and\n   * [port] and has started listening on it.\n   *\n   * If [port] has the value [:0:] (the default) an ephemeral port will\n   * be chosen by the system. The actual port used can be retrieved\n   * using the [port] getter.\n   *\n   * If [backlog] has the value of [:0:] a reasonable value will be\n   * chosen by the system.\n   *\n   * Incoming client connections are promoted to secure connections, using\n   * the server certificate given by [certificateName].\n   *\n   * [address] must be given as a numeric address, not a host name.\n   *\n   * [certificateName] is the nickname or the distinguished name (DN) of\n   * the certificate in the certificate database. It is looked up in the\n   * NSS certificate database set by SecureSocket.setCertificateDatabase.\n   * If [certificateName] contains \"CN=\", it is assumed to be a distinguished\n   * name.  Otherwise, it is looked up as a nickname.\n   *\n   * To request or require that clients authenticate by providing an SSL (TLS)\n   * client certificate, set the optional parameter [requestClientCertificate]\n   * or [requireClientCertificate] to true.  Requiring a certificate implies\n   * requesting a certificate, so one doesn't need to set both to true.\n   * To check whether a client certificate was received, check\n   * SecureSocket.peerCertificate after connecting.  If no certificate\n   * was received, the result will be null.\n   */\n  static Future<SecureServerSocket> bind(\n      String address,\n      int port,\n      int backlog,\n      String certificateName,\n      {bool requestClientCertificate: false,\n       bool requireClientCertificate: false}) {\n    return RawSecureServerSocket.bind(\n        address,\n        port,\n        backlog,\n        certificateName,\n        requestClientCertificate: requestClientCertificate,\n        requireClientCertificate: requireClientCertificate).then(\n            (serverSocket) => new SecureServerSocket._(serverSocket));\n  }\n\n  StreamSubscription<SecureSocket> listen(void onData(SecureSocket socket),\n                                          {void onError(error),\n                                           void onDone(),\n                                           bool cancelOnError}) {\n    return _socket.map((rawSocket) => new SecureSocket._(rawSocket))\n                  .listen(onData,\n                          onError: onError,\n                          onDone: onDone,\n                          cancelOnError: cancelOnError);\n  }\n\n  /**\n   * Returns the port used by this socket.\n   */\n  int get port => _socket.port;\n\n  /**\n   * Closes the socket.\n   */\n  void close() => _socket.close();\n}\n\n\n/**\n * The RawSecureServerSocket is a server socket, providing a stream of low-level\n * [RawSecureSocket]s.\n *\n * See [RawSecureSocket] for more info.\n */\nclass RawSecureServerSocket extends Stream<RawSecureSocket> {\n  RawServerSocket _socket;\n  StreamController<RawSecureSocket> _controller;\n  StreamSubscription<RawSocket> _subscription;\n  final String certificateName;\n  final bool requestClientCertificate;\n  final bool requireClientCertificate;\n  bool _closed = false;\n\n  RawSecureServerSocket._(RawServerSocket serverSocket,\n                          String this.certificateName,\n                          bool this.requestClientCertificate,\n                          bool this.requireClientCertificate) {\n    _socket = serverSocket;\n    _controller = new StreamController<RawSecureSocket>(\n        onListen: _onSubscriptionStateChange,\n        onPause: _onPauseStateChange,\n        onResume: _onPauseStateChange,\n        onCancel: _onSubscriptionStateChange);\n  }\n\n  /**\n   * Returns a future for a [RawSecureServerSocket]. When the future\n   * completes the server socket is bound to the given [address] and\n   * [port] and has started listening on it.\n   *\n   * If [port] has the value [:0:] (the default) an ephemeral port will\n   * be chosen by the system. The actual port used can be retrieved\n   * using the [port] getter.\n   *\n   * If [backlog] has the value of [:0:] a reasonable value will be\n   * chosen by the system.\n   *\n   * Incoming client connections are promoted to secure connections,\n   * using the server certificate given by [certificateName].\n   *\n   * [address] must be given as a numeric address, not a host name.\n   *\n   * [certificateName] is the nickname or the distinguished name (DN) of\n   * the certificate in the certificate database. It is looked up in the\n   * NSS certificate database set by SecureSocket.setCertificateDatabase.\n   * If [certificateName] contains \"CN=\", it is assumed to be a distinguished\n   * name.  Otherwise, it is looked up as a nickname.\n   *\n   * To request or require that clients authenticate by providing an SSL (TLS)\n   * client certificate, set the optional parameters requestClientCertificate or\n   * requireClientCertificate to true.  Require implies request, so one doesn't\n   * need to specify both.  To check whether a client certificate was received,\n   * check SecureSocket.peerCertificate after connecting.  If no certificate\n   * was received, the result will be null.\n   */\n  static Future<RawSecureServerSocket> bind(\n      String address,\n      int port,\n      int backlog,\n      String certificateName,\n      {bool requestClientCertificate: false,\n       bool requireClientCertificate: false}) {\n    return RawServerSocket.bind(address, port, backlog)\n        .then((serverSocket) => new RawSecureServerSocket._(\n            serverSocket,\n            certificateName,\n            requestClientCertificate,\n            requireClientCertificate));\n  }\n\n  StreamSubscription<RawSecureSocket> listen(void onData(RawSecureSocket s),\n                                             {void onError(error),\n                                              void onDone(),\n                                              bool cancelOnError}) {\n    return _controller.stream.listen(onData,\n                                     onError: onError,\n                                     onDone: onDone,\n                                     cancelOnError: cancelOnError);\n  }\n\n  /**\n   * Returns the port used by this socket.\n   */\n  int get port => _socket.port;\n\n  /**\n   * Closes the socket.\n   */\n  void close() {\n    _closed = true;\n    _socket.close();\n  }\n\n  void _onData(RawSocket connection) {\n    _RawSecureSocket.connect(\n        connection.remoteHost,\n        connection.remotePort,\n        certificateName,\n        is_server: true,\n        socket: connection,\n        requestClientCertificate: requestClientCertificate,\n        requireClientCertificate: requireClientCertificate)\n    .then((RawSecureSocket secureConnection) {\n      if (_closed) {\n        secureConnection.close();\n      } else {\n        _controller.add(secureConnection);\n      }\n    }).catchError((e) {\n      if (_closed) {\n        throw e;\n      } else {\n        _controller.addError(e);\n        close();\n      }\n    });\n  }\n\n  void _onError(e) {\n    _controller.addError(e);\n    close();\n  }\n\n  void _onDone() {\n    _controller.close();\n  }\n\n  void _onPauseStateChange() {\n    if (_controller.isPaused) {\n      _subscription.pause();\n    } else {\n      _subscription.resume();\n    }\n  }\n\n  void _onSubscriptionStateChange() {\n    if (_controller.hasListener) {\n      _subscription = _socket.listen(_onData,\n                                     onDone: _onDone,\n                                     onError: _onError);\n    } else {\n      close();\n    }\n  }\n}\n\n\n","sdk/lib/io/secure_socket.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * A high-level class for communicating securely over a TCP socket, using\n * TLS and SSL. The [SecureSocket] exposes both a [Stream] and an\n * [IOSink] interface, making it ideal for using together with\n * other [Stream]s.\n */\nabstract class SecureSocket implements Socket {\n  external factory SecureSocket._(RawSecureSocket rawSocket);\n\n  /**\n   * Constructs a new secure client socket and connect it to the given\n   * [host] on port [port]. The returned Future will complete with a\n   * [SecureSocket] that is connected and ready for subscription.\n   *\n   * If [sendClientCertificate] is set to true, the socket will send a client\n   * certificate if one is requested by the server.\n   *\n   * If [certificateName] is the nickname of a certificate in the certificate\n   * database, that certificate will be sent.\n   *\n   * If [certificateName] is null, which is the usual use case, an\n   * appropriate certificate will be searched for in the database and\n   * sent automatically, based on what the server says it will accept.\n   *\n   * [onBadCertificate] is an optional handler for unverifiable certificates.\n   * The handler receives the [X509Certificate], and can inspect it and\n   * decide (or let the user decide) whether to accept\n   * the connection or not.  The handler should return true\n   * to continue the [SecureSocket] connection.\n   */\n  static Future<SecureSocket> connect(\n      host,\n      int port,\n      {bool sendClientCertificate: false,\n       String certificateName,\n       bool onBadCertificate(X509Certificate certificate)}) {\n    return RawSecureSocket.connect(host,\n                                   port,\n                                   sendClientCertificate: sendClientCertificate,\n                                   certificateName: certificateName,\n                                   onBadCertificate: onBadCertificate)\n        .then((rawSocket) => new SecureSocket._(rawSocket));\n  }\n\n  /**\n   * Takes an already connected [socket] and starts client side TLS\n   * handshake to make the communication secure. When the returned\n   * future completes the [SecureSocket] has completed the TLS\n   * handshake. Using this function requires that the other end of the\n   * connection is prepared for TLS handshake.\n   *\n   * If the [socket] already has a subscription, this subscription\n   * will no longer receive and events. In most cases calling\n   * [:pause:] on this subscription before starting TLS handshake is\n   * the right thing to do.\n   *\n   * See [connect] for more information on the arguments.\n   *\n   */\n  static Future<SecureSocket> secure(\n      Socket socket,\n      {bool sendClientCertificate: false,\n       String certificateName,\n       bool onBadCertificate(X509Certificate certificate)}) {\n    var completer = new Completer();\n    (socket as dynamic)._detachRaw()\n        .then((detachedRaw) {\n          return RawSecureSocket.secure(\n            detachedRaw[0],\n            subscription: detachedRaw[1],\n            sendClientCertificate: sendClientCertificate,\n            onBadCertificate: onBadCertificate);\n          })\n        .then((raw) {\n          completer.complete(new SecureSocket._(raw));\n        });\n    return completer.future;\n  }\n\n  /**\n   * Takes an already connected [socket] and starts server side TLS\n   * handshake to make the communication secure. When the returned\n   * future completes the [SecureSocket] has completed the TLS\n   * handshake. Using this function requires that the other end of the\n   * connection is going to start the TLS handshake.\n   *\n   * If the [socket] already has a subscription, this subscription\n   * will no longer receive and events. In most cases calling\n   * [:pause:] on this subscription before starting TLS handshake is\n   * the right thing to do.\n   *\n   * If some of the data of the TLS handshake has already been read\n   * from the socket this data can be passed in the [carryOverData]\n   * parameter. This data will be processed before any other data\n   * available on the socket.\n   *\n   * See [SecureServerSocket.bind] for more information on the\n   * arguments.\n   *\n   */\n  static Future<SecureSocket> secureServer(\n      Socket socket,\n      String certificateName,\n      {List<int> carryOverData,\n       bool requestClientCertificate: false,\n       bool requireClientCertificate: false}) {\n    var completer = new Completer();\n    (socket as dynamic)._detachRaw()\n        .then((detachedRaw) {\n          return RawSecureSocket.secureServer(\n            detachedRaw[0],\n            certificateName,\n            subscription: detachedRaw[1],\n            carryOverData: carryOverData,\n            requestClientCertificate: requestClientCertificate,\n            requireClientCertificate: requireClientCertificate);\n          })\n        .then((raw) {\n          completer.complete(new SecureSocket._(raw));\n        });\n    return completer.future;\n  }\n\n  /**\n   * Get the peer certificate for a connected SecureSocket.  If this\n   * SecureSocket is the server end of a secure socket connection,\n   * [peerCertificate] will return the client certificate, or null, if no\n   * client certificate was received.  If it is the client end,\n   * [peerCertificate] will return the server's certificate.\n   */\n  X509Certificate get peerCertificate;\n\n  /**\n   * Initializes the NSS library.  If [initialize] is not called, the library\n   * is automatically initialized as if [initialize] were called with no\n   * arguments.\n   *\n   * The optional argument [database] is the path to a certificate database\n   * containing root certificates for verifying certificate paths on\n   * client connections, and server certificates to provide on server\n   * connections.  The argument [password] should be used when creating\n   * secure server sockets, to allow the private key of the server\n   * certificate to be fetched.  If [useBuiltinRoots] is true (the default),\n   * then a built-in set of root certificates for trusted certificate\n   * authorities is merged with the certificates in the database.\n   *\n   * Examples:\n   *   1) Use only the builtin root certificates:\n   *     SecureSocket.initialize(); or\n   *\n   *   2) Use a specified database and the builtin roots:\n   *     SecureSocket.initialize(database: 'path/to/my/database',\n   *                             password: 'my_password');\n   *\n   *   3) Use a specified database, without builtin roots:\n   *     SecureSocket.initialize(database: 'path/to/my/database',\n   *                             password: 'my_password'.\n   *                             useBuiltinRoots: false);\n   *\n   * The database should be an NSS certificate database directory\n   * containing a cert9.db file, not a cert8.db file.  This version of\n   * the database can be created using the NSS certutil tool with \"sql:\" in\n   * front of the absolute path of the database directory, or setting the\n   * environment variable [[NSS_DEFAULT_DB_TYPE]] to \"sql\".\n   */\n  external static void initialize({String database,\n                                   String password,\n                                   bool useBuiltinRoots: true});\n}\n\n\n/**\n * RawSecureSocket provides a secure (SSL or TLS) network connection.\n * Client connections to a server are provided by calling\n * RawSecureSocket.connect.  A secure server, created with\n * RawSecureServerSocket, also returns RawSecureSocket objects representing\n * the server end of a secure connection.\n * The certificate provided by the server is checked\n * using the certificate database provided in SecureSocket.initialize, and/or\n * the default built-in root certificates.\n */\nabstract class RawSecureSocket implements RawSocket {\n  /**\n   * Constructs a new secure client socket and connect it to the given\n   * host on the given port. The returned Future is completed with the\n   * RawSecureSocket when it is connected and ready for subscription.\n   *\n   * The certificate provided by the server is checked using the certificate\n   * database provided in [SecureSocket.initialize], and/or the default built-in\n   * root certificates. If [sendClientCertificate] is\n   * set to true, the socket will send a client certificate if one is\n   * requested by the server. If [certificateName] is the nickname of\n   * a certificate in the certificate database, that certificate will be sent.\n   * If [certificateName] is null, which is the usual use case, an\n   * appropriate certificate will be searched for in the database and\n   * sent automatically, based on what the server says it will accept.\n   *\n   * [onBadCertificate] is an optional handler for unverifiable certificates.\n   * The handler receives the [X509Certificate], and can inspect it and\n   * decide (or let the user decide) whether to accept\n   * the connection or not.  The handler should return true\n   * to continue the [RawSecureSocket] connection.\n   */\n  static Future<RawSecureSocket> connect(\n      host,\n      int port,\n      {bool sendClientCertificate: false,\n       String certificateName,\n       bool onBadCertificate(X509Certificate certificate)}) {\n    return  _RawSecureSocket.connect(\n        host,\n        port,\n        certificateName,\n        is_server: false,\n        sendClientCertificate: sendClientCertificate,\n        onBadCertificate: onBadCertificate);\n  }\n\n  /**\n   * Takes an already connected [socket] and starts client side TLS\n   * handshake to make the communication secure. When the returned\n   * future completes the [RawSecureSocket] has completed the TLS\n   * handshake. Using this function requires that the other end of the\n   * connection is prepared for TLS handshake.\n   *\n   * If the [socket] already has a subscription, pass the existing\n   * subscription in the [subscription] parameter. The secure socket\n   * will take over the subscription and process any subsequent\n   * events.\n   *\n   * See [connect] for more information on the arguments.\n   *\n   */\n  static Future<RawSecureSocket> secure(\n      RawSocket socket,\n      {StreamSubscription subscription,\n       bool sendClientCertificate: false,\n       String certificateName,\n       bool onBadCertificate(X509Certificate certificate)}) {\n    return  _RawSecureSocket.connect(\n        socket.address,\n        socket.port,\n        certificateName,\n        is_server: false,\n        socket: socket,\n        subscription: subscription,\n        sendClientCertificate: sendClientCertificate,\n        onBadCertificate: onBadCertificate);\n  }\n\n  /**\n   * Takes an already connected [socket] and starts server side TLS\n   * handshake to make the communication secure. When the returned\n   * future completes the [RawSecureSocket] has completed the TLS\n   * handshake. Using this function requires that the other end of the\n   * connection is going to start the TLS handshake.\n   *\n   * If the [socket] already has a subscription, pass the existing\n   * subscription in the [subscription] parameter. The secure socket\n   * will take over the subscription and process any subsequent\n   * events.\n   *\n   * If some of the data of the TLS handshake has already been read\n   * from the socket this data can be passed in the [carryOverData]\n   * parameter. This data will be processed before any other data\n   * available on the socket.\n   *\n   * See [RawSecureServerSocket.bind] for more information on the\n   * arguments.\n   *\n   */\n  static Future<RawSecureSocket> secureServer(\n      RawSocket socket,\n      String certificateName,\n      {StreamSubscription subscription,\n       List<int> carryOverData,\n       bool requestClientCertificate: false,\n       bool requireClientCertificate: false}) {\n    return _RawSecureSocket.connect(\n        socket.remoteHost,\n        socket.remotePort,\n        certificateName,\n        is_server: true,\n        socket: socket,\n        subscription: subscription,\n        carryOverData: carryOverData,\n        requestClientCertificate: requestClientCertificate,\n        requireClientCertificate: requireClientCertificate);\n  }\n\n  /**\n   * Get the peer certificate for a connected RawSecureSocket.  If this\n   * RawSecureSocket is the server end of a secure socket connection,\n   * [peerCertificate] will return the client certificate, or null, if no\n   * client certificate was received.  If it is the client end,\n   * [peerCertificate] will return the server's certificate.\n   */\n  X509Certificate get peerCertificate;\n}\n\n\n/**\n * X509Certificate represents an SSL certificate, with accessors to\n * get the fields of the certificate.\n */\nclass X509Certificate {\n  X509Certificate(this.subject,\n                  this.issuer,\n                  this.startValidity,\n                  this.endValidity);\n  final String subject;\n  final String issuer;\n  final DateTime startValidity;\n  final DateTime endValidity;\n}\n\n\nclass _RawSecureSocket extends Stream<RawSocketEvent>\n                       implements RawSecureSocket {\n  // Status states\n  static final int NOT_CONNECTED = 200;\n  static final int HANDSHAKE = 201;\n  static final int CONNECTED = 202;\n  static final int CLOSED = 203;\n\n  // Buffer identifiers.\n  // These must agree with those in the native C++ implementation.\n  static final int READ_PLAINTEXT = 0;\n  static final int WRITE_PLAINTEXT = 1;\n  static final int READ_ENCRYPTED = 2;\n  static final int WRITE_ENCRYPTED = 3;\n  static final int NUM_BUFFERS = 4;\n\n  RawSocket _socket;\n  final Completer<_RawSecureSocket> _handshakeComplete =\n      new Completer<_RawSecureSocket>();\n  StreamController<RawSocketEvent> _controller;\n  Stream<RawSocketEvent> _stream;\n  StreamSubscription<RawSocketEvent> _socketSubscription;\n  List<int> _carryOverData;\n  int _carryOverDataIndex = 0;\n  final InternetAddress address;\n  final bool is_server;\n  final String certificateName;\n  final bool requestClientCertificate;\n  final bool requireClientCertificate;\n  final bool sendClientCertificate;\n  final Function onBadCertificate;\n\n  var _status = NOT_CONNECTED;\n  bool _writeEventsEnabled = true;\n  bool _readEventsEnabled = true;\n  bool _socketClosedRead = false;  // The network socket is closed for reading.\n  bool _socketClosedWrite = false;  // The network socket is closed for writing.\n  bool _closedRead = false;  // The secure socket has fired an onClosed event.\n  bool _closedWrite = false;  // The secure socket has been closed for writing.\n  bool _filterReadEmpty = true;  // There is no buffered data to read.\n  bool _filterWriteEmpty = true;  // There is no buffered data to be written.\n  bool _connectPending = false;\n  _SecureFilter _secureFilter = new _SecureFilter();\n\n  static Future<_RawSecureSocket> connect(\n      host,\n      int requestedPort,\n      String certificateName,\n      {bool is_server,\n       RawSocket socket,\n       StreamSubscription subscription,\n       List<int> carryOverData,\n       bool requestClientCertificate: false,\n       bool requireClientCertificate: false,\n       bool sendClientCertificate: false,\n       bool onBadCertificate(X509Certificate certificate)}) {\n    var future;\n    if (host is String) {\n      future = InternetAddress.lookup(host).then((addrs) => addrs.first);\n    } else {\n      future = new Future.value(host);\n    }\n    return future.then((addr) {\n     return new _RawSecureSocket(addr,\n                                 requestedPort,\n                                 certificateName,\n                                 is_server,\n                                 socket,\n                                 subscription,\n                                 carryOverData,\n                                 requestClientCertificate,\n                                 requireClientCertificate,\n                                 sendClientCertificate,\n                                 onBadCertificate)\n         ._handshakeComplete.future;\n    });\n  }\n\n  _RawSecureSocket(\n      InternetAddress this.address,\n      int requestedPort,\n      String this.certificateName,\n      bool this.is_server,\n      RawSocket socket,\n      StreamSubscription this._socketSubscription,\n      List<int> this._carryOverData,\n      bool this.requestClientCertificate,\n      bool this.requireClientCertificate,\n      bool this.sendClientCertificate,\n      bool this.onBadCertificate(X509Certificate certificate)) {\n    _controller = new StreamController<RawSocketEvent>(\n        onListen: _onSubscriptionStateChange,\n        onPause: _onPauseStateChange,\n        onResume: _onPauseStateChange,\n        onCancel: _onSubscriptionStateChange);\n    _stream = _controller.stream;\n    // Throw an ArgumentError if any field is invalid.  After this, all\n    // errors will be reported through the future or the stream.\n    _verifyFields();\n    _secureFilter.init();\n    if (_carryOverData != null) _readFromCarryOver();\n    _secureFilter.registerHandshakeCompleteCallback(\n        _secureHandshakeCompleteHandler);\n    if (onBadCertificate != null) {\n      _secureFilter.registerBadCertificateCallback(onBadCertificate);\n    }\n    var futureSocket;\n    if (socket == null) {\n      futureSocket = RawSocket.connect(address, requestedPort);\n    } else {\n      futureSocket = new Future.value(socket);\n    }\n    futureSocket.then((rawSocket) {\n      _socket = rawSocket;\n      _socket.readEventsEnabled = true;\n      _socket.writeEventsEnabled = false;\n      if (_socketSubscription == null) {\n        // If a current subscription is provided use this otherwise\n        // create a new one.\n        _socketSubscription = _socket.listen(_eventDispatcher,\n                                             onError: _errorHandler,\n                                             onDone: _doneHandler);\n      } else {\n        _socketSubscription.onData(_eventDispatcher);\n        _socketSubscription.onError(_errorHandler);\n        _socketSubscription.onDone(_doneHandler);\n      }\n      _connectPending = true;\n      _secureFilter.connect(rawSocket.address.host,\n                            port,\n                            is_server,\n                            certificateName,\n                            requestClientCertificate ||\n                                requireClientCertificate,\n                            requireClientCertificate,\n                            sendClientCertificate);\n      _status = HANDSHAKE;\n      _secureHandshake();\n    })\n    .catchError((error) {\n      _handshakeComplete.completeError(error);\n      _close();\n    });\n  }\n\n  StreamSubscription listen(void onData(RawSocketEvent data),\n                            {void onError(error),\n                             void onDone(),\n                             bool cancelOnError}) {\n    if (_writeEventsEnabled) {\n      _writeEventsEnabled = false;\n      _controller.add(RawSocketEvent.WRITE);\n    }\n    return _stream.listen(onData,\n                          onError: onError,\n                          onDone: onDone,\n                          cancelOnError: cancelOnError);\n  }\n\n  void _verifyFields() {\n    assert(is_server is bool);\n    assert(_socket == null || _socket is RawSocket);\n    if (address is! InternetAddress) {\n      throw new ArgumentError(\n          \"RawSecureSocket constructor: host is not an InternetAddress\");\n    }\n    if (certificateName != null && certificateName is! String) {\n      throw new ArgumentError(\"certificateName is not null or a String\");\n    }\n    if (certificateName == null && is_server) {\n      throw new ArgumentError(\"certificateName is null on a server\");\n    }\n    if (requestClientCertificate is! bool) {\n      throw new ArgumentError(\"requestClientCertificate is not a bool\");\n    }\n    if (requireClientCertificate is! bool) {\n      throw new ArgumentError(\"requireClientCertificate is not a bool\");\n    }\n    if (sendClientCertificate is! bool) {\n      throw new ArgumentError(\"sendClientCertificate is not a bool\");\n    }\n    if (onBadCertificate != null && onBadCertificate is! Function) {\n      throw new ArgumentError(\"onBadCertificate is not null or a Function\");\n    }\n   }\n\n  int get port => _socket.port;\n\n  String get remoteHost => _socket.remoteHost;\n\n  int get remotePort => _socket.remotePort;\n\n  int available() {\n    if (_status != CONNECTED) return 0;\n    _readEncryptedData();\n    return _secureFilter.buffers[READ_PLAINTEXT].length;\n  }\n\n  void close() {\n    shutdown(SocketDirection.BOTH);\n  }\n\n  void _close() {\n    _closedWrite = true;\n    _closedRead = true;\n    if (_socket != null) {\n      _socket.close();\n    }\n    _socketClosedWrite = true;\n    _socketClosedRead = true;\n    if (_secureFilter != null) {\n      _secureFilter.destroy();\n      _secureFilter = null;\n    }\n    if (_socketSubscription != null) {\n      _socketSubscription.cancel();\n    }\n    _controller.close();\n    _status = CLOSED;\n  }\n\n  void shutdown(SocketDirection direction) {\n    if (direction == SocketDirection.SEND ||\n        direction == SocketDirection.BOTH) {\n      _closedWrite = true;\n      _writeEncryptedData();\n      if (_filterWriteEmpty) {\n        _socket.shutdown(SocketDirection.SEND);\n        _socketClosedWrite = true;\n        if (_closedRead) {\n          _close();\n        }\n      }\n    }\n    if (direction == SocketDirection.RECEIVE ||\n        direction == SocketDirection.BOTH) {\n      _closedRead = true;\n      _socketClosedRead = true;\n      _socket.shutdown(SocketDirection.RECEIVE);\n      if (_socketClosedWrite) {\n        _close();\n      }\n    }\n  }\n\n  bool get writeEventsEnabled => _writeEventsEnabled;\n\n  void set writeEventsEnabled(bool value) {\n    if (value &&\n        _controller.hasListener &&\n        _secureFilter != null &&\n        _secureFilter.buffers[WRITE_PLAINTEXT].free > 0) {\n      Timer.run(() => _controller.add(RawSocketEvent.WRITE));\n    } else {\n      _writeEventsEnabled = value;\n    }\n  }\n\n  bool get readEventsEnabled => _readEventsEnabled;\n\n  void set readEventsEnabled(bool value) {\n    _readEventsEnabled = value;\n    if (value &&\n        ((_secureFilter != null &&\n          _secureFilter.buffers[READ_PLAINTEXT].length > 0) ||\n         _socketClosedRead)) {\n      // We might not have no underlying socket to set off read events.\n      Timer.run(_readHandler);\n    }\n  }\n\n  List<int> read([int len]) {\n    if (_closedRead) {\n      throw new SocketIOException(\"Reading from a closed socket\");\n    }\n    if (_status != CONNECTED) {\n      return null;\n    }\n    var buffer = _secureFilter.buffers[READ_PLAINTEXT];\n    _readEncryptedData();\n    int toRead = buffer.length;\n    if (len != null) {\n      if (len is! int || len < 0) {\n        throw new ArgumentError(\n            \"Invalid len parameter in SecureSocket.read (len: $len)\");\n      }\n      if (len < toRead) {\n        toRead = len;\n      }\n    }\n    List<int> result = (toRead == 0) ? null :\n        buffer.data.sublist(buffer.start, buffer.start + toRead);\n    buffer.advanceStart(toRead);\n\n    // Set up a read event if the filter still has data.\n    if (!_filterReadEmpty) {\n      Timer.run(_readHandler);\n    }\n\n    if (_socketClosedRead) {  // An onClose event is pending.\n      // _closedRead is false, since we are in a read  call.\n      if (!_filterReadEmpty) {\n        // _filterReadEmpty may be out of date since read empties\n        // the plaintext buffer after calling _readEncryptedData.\n        // TODO(whesse): Fix this as part of fixing read.\n        _readEncryptedData();\n      }\n      if (_filterReadEmpty) {\n        // This can't be an else clause: the value of _filterReadEmpty changes.\n        // This must be asynchronous, because we are in a read call.\n        Timer.run(_closeHandler);\n      }\n    }\n\n    return result;\n  }\n\n  // Write the data to the socket, and flush it as much as possible\n  // until it would block.  If the write would block, _writeEncryptedData sets\n  // up handlers to flush the pipeline when possible.\n  int write(List<int> data, [int offset, int bytes]) {\n    if (_closedWrite) {\n      _controller.addError(new SocketIOException(\"Writing to a closed socket\"));\n      return 0;\n    }\n    if (_status != CONNECTED) return 0;\n\n    if (offset == null) offset = 0;\n    if (bytes == null) bytes = data.length - offset;\n\n    var buffer = _secureFilter.buffers[WRITE_PLAINTEXT];\n    if (bytes > buffer.free) {\n      bytes = buffer.free;\n    }\n    if (bytes > 0) {\n      int startIndex = buffer.start + buffer.length;\n      buffer.data.setRange(startIndex, startIndex + bytes, data, offset);\n      buffer.length += bytes;\n    }\n    _writeEncryptedData();  // Tries to flush all pipeline stages.\n    return bytes;\n  }\n\n  X509Certificate get peerCertificate => _secureFilter.peerCertificate;\n\n  bool setOption(SocketOption option, bool enabled) {\n    if (_socket == null) return false;\n    return _socket.setOption(option, enabled);\n  }\n\n  void _writeHandler() {\n    if (_status == CLOSED) return;\n    _writeEncryptedData();\n    if (_filterWriteEmpty && _closedWrite && !_socketClosedWrite) {\n      // Close _socket for write, by calling shutdown(), to avoid cloning the\n      // socket closing code in shutdown().\n      shutdown(SocketDirection.SEND);\n    }\n    if (_status == HANDSHAKE) {\n      try {\n        _secureHandshake();\n      } catch (e) { _reportError(e, \"RawSecureSocket error\"); }\n    } else if (_status == CONNECTED &&\n               _controller.hasListener &&\n               _writeEventsEnabled &&\n               _secureFilter.buffers[WRITE_PLAINTEXT].free > 0) {\n      // Reset the one-shot handler.\n      _writeEventsEnabled = false;\n      _controller.add(RawSocketEvent.WRITE);\n    }\n  }\n\n  void _eventDispatcher(RawSocketEvent event) {\n    if (event == RawSocketEvent.READ) {\n      _readHandler();\n    } else if (event == RawSocketEvent.WRITE) {\n      _writeHandler();\n    } else if (event == RawSocketEvent.READ_CLOSED) {\n      _closeHandler();\n    }\n  }\n\n  void _readFromCarryOver() {\n    assert(_carryOverData != null);\n    var encrypted = _secureFilter.buffers[READ_ENCRYPTED];\n    var bytes = _carryOverData.length - _carryOverDataIndex;\n    int startIndex = encrypted.start + encrypted.length;\n    encrypted.data.setRange(startIndex,\n                            startIndex + bytes,\n                            _carryOverData,\n                            _carryOverDataIndex);\n    encrypted.length += bytes;\n    _carryOverDataIndex += bytes;\n    if (_carryOverData.length == _carryOverDataIndex) {\n      _carryOverData = null;\n    }\n  }\n\n  void _readHandler() {\n    if (_status == CLOSED) {\n      return;\n    } else if (_status == HANDSHAKE) {\n      try {\n        _secureHandshake();\n        if (_status != HANDSHAKE) _readHandler();\n      } catch (e) { _reportError(e, \"RawSecureSocket error\"); }\n    } else {\n      if (_status != CONNECTED) {\n        // Cannot happen.\n        throw new SocketIOException(\"Internal SocketIO Error\");\n      }\n      try {\n        _readEncryptedData();\n      } catch (e) { _reportError(e, \"RawSecureSocket error\"); }\n      if (!_filterReadEmpty) {\n        if (_readEventsEnabled) {\n          if (_secureFilter.buffers[READ_PLAINTEXT].length > 0) {\n            _controller.add(RawSocketEvent.READ);\n          }\n          if (_socketClosedRead) {\n            // Keep firing read events until we are paused or buffer is empty.\n            Timer.run(_readHandler);\n          }\n        }\n      } else if (_socketClosedRead) {\n        _closeHandler();\n      }\n    }\n  }\n\n  void _doneHandler() {\n    if (_filterReadEmpty) {\n      _close();\n    }\n  }\n\n  void _errorHandler(e) {\n    _reportError(e, 'Error on underlying RawSocket');\n  }\n\n  void _reportError(e, String message) {\n    // TODO(whesse): Call _reportError from all internal functions that throw.\n    if (e is SocketIOException) {\n      e = new SocketIOException('$message (${e.message})', e.osError);\n    } else if (e is OSError) {\n      e = new SocketIOException(message, e);\n    } else {\n      e = new SocketIOException('$message (${e.toString()})', null);\n    }\n    if (_connectPending) {\n      _handshakeComplete.completeError(e);\n    } else {\n      _controller.addError(e);\n    }\n    _close();\n  }\n\n  void _closeHandler() {\n    if  (_status == CONNECTED) {\n      if (_closedRead) return;\n      _socketClosedRead = true;\n      if (_filterReadEmpty) {\n        _closedRead = true;\n        _controller.add(RawSocketEvent.READ_CLOSED);\n        if (_socketClosedWrite) {\n          _close();\n        }\n      }\n    } else if (_status == HANDSHAKE) {\n      _reportError(\n          new SocketIOException('Connection terminated during handshake'),\n          'handshake error');\n    }\n  }\n\n  void _secureHandshake() {\n    _readEncryptedData();\n    _secureFilter.handshake();\n    _writeEncryptedData();\n  }\n\n  void _secureHandshakeCompleteHandler() {\n    _status = CONNECTED;\n    if (_connectPending) {\n      _connectPending = false;\n      // If we complete the future synchronously, user code will run here,\n      // and modify the state of the RawSecureSocket.  For example, it\n      // could close the socket, and set _filter to null.\n      Timer.run(() => _handshakeComplete.complete(this));\n    }\n  }\n\n  void _onPauseStateChange() {\n    if (!_socketClosedRead || !_socketClosedWrite) {\n      if (_controller.isPaused) {\n        _socketSubscription.pause();\n      } else {\n        _socketSubscription.resume();\n      }\n    }\n  }\n\n  void _onSubscriptionStateChange() {\n    if (_controller.hasListener) {\n      // TODO(ajohnsen): Do something here?\n    }\n  }\n\n  void _readEncryptedData() {\n    // Read from the socket, and push it through the filter as far as\n    // possible.\n    var encrypted = _secureFilter.buffers[READ_ENCRYPTED];\n    var plaintext = _secureFilter.buffers[READ_PLAINTEXT];\n    bool progress = true;\n    while (progress) {\n      progress = false;\n      // Do not try to read plaintext from the filter while handshaking.\n      if ((_status == CONNECTED) && plaintext.free > 0) {\n        int bytes = _secureFilter.processBuffer(READ_PLAINTEXT);\n        if (bytes > 0) {\n          plaintext.length += bytes;\n          progress = true;\n        }\n      }\n      if (encrypted.length > 0) {\n        int bytes = _secureFilter.processBuffer(READ_ENCRYPTED);\n        if (bytes > 0) {\n          encrypted.advanceStart(bytes);\n          progress = true;\n        }\n      }\n      if (!_socketClosedRead && encrypted.free > 0) {\n        if (_carryOverData != null) {\n          _readFromCarryOver();\n          progress = true;\n        } else {\n          List<int> data = _socket.read(encrypted.free);\n          if (data != null) {\n            int bytes = data.length;\n            int startIndex = encrypted.start + encrypted.length;\n            encrypted.data.setRange(startIndex, startIndex + bytes, data);\n            encrypted.length += bytes;\n            progress = true;\n          }\n        }\n      }\n    }\n    // If there is any data in any stages of the filter, there should\n    // be data in the plaintext buffer after this process.\n    // TODO(whesse): Verify that this is true, and there can be no\n    // partial encrypted block stuck in the secureFilter.\n    _filterReadEmpty = (plaintext.length == 0);\n  }\n\n  void _writeEncryptedData() {\n    if (_socketClosedWrite) return;\n    var encrypted = _secureFilter.buffers[WRITE_ENCRYPTED];\n    var plaintext = _secureFilter.buffers[WRITE_PLAINTEXT];\n    while (true) {\n      if (encrypted.length > 0) {\n        // Write from the filter to the socket.\n        int bytes = _socket.write(encrypted.data,\n                                  encrypted.start,\n                                  encrypted.length);\n        encrypted.advanceStart(bytes);\n        if (encrypted.length > 0) {\n          // The socket has blocked while we have data to write.\n          // We must be notified when it becomes unblocked.\n          _socket.writeEventsEnabled = true;\n          _filterWriteEmpty = false;\n          break;\n        }\n      } else {\n        var plaintext = _secureFilter.buffers[WRITE_PLAINTEXT];\n        if (plaintext.length > 0) {\n           int plaintext_bytes = _secureFilter.processBuffer(WRITE_PLAINTEXT);\n           plaintext.advanceStart(plaintext_bytes);\n        }\n        int bytes = _secureFilter.processBuffer(WRITE_ENCRYPTED);\n        if (bytes <= 0) {\n          // We know the WRITE_ENCRYPTED buffer is empty, and the\n          // filter wrote zero bytes to it, so the filter must be empty.\n          // Also, the WRITE_PLAINTEXT buffer must have been empty, or\n          // it would have written to the filter.\n          // TODO(whesse): Verify that the filter works this way.\n          _filterWriteEmpty = true;\n          break;\n        }\n        encrypted.length += bytes;\n      }\n    }\n  }\n}\n\n\nclass _ExternalBuffer {\n  // Performance is improved if a full buffer of plaintext fits\n  // in the encrypted buffer, when encrypted.\n  static final int SIZE = 8 * 1024;\n  static final int ENCRYPTED_SIZE = 10 * 1024;\n  _ExternalBuffer() : start = 0, length = 0;\n\n  // TODO(whesse): Consider making this a circular buffer.  Only if it helps.\n  void advanceStart(int numBytes) {\n    start += numBytes;\n    length -= numBytes;\n    if (length == 0) {\n      start = 0;\n    }\n  }\n\n  int get free => data.length - (start + length);\n\n  List data;  // This will be a ExternalByteArray, backed by C allocated data.\n  int start;\n  int length;\n}\n\n\nabstract class _SecureFilter {\n  external factory _SecureFilter();\n\n  void connect(String hostName,\n               int port,\n               bool is_server,\n               String certificateName,\n               bool requestClientCertificate,\n               bool requireClientCertificate,\n               bool sendClientCertificate);\n  void destroy();\n  void handshake();\n  void init();\n  X509Certificate get peerCertificate;\n  int processBuffer(int bufferIndex);\n  void registerBadCertificateCallback(Function callback);\n  void registerHandshakeCompleteCallback(Function handshakeCompleteHandler);\n\n  List<_ExternalBuffer> get buffers;\n}\n","sdk/lib/io/socket.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n\n/**\n * [InternetAddressType] is the type an [InternetAddress]. Currently, IPv4 and\n * IPv6 are supported.\n */\nclass InternetAddressType {\n  static const InternetAddressType IPv4 = const InternetAddressType._(0);\n  static const InternetAddressType IPv6 = const InternetAddressType._(1);\n  static const InternetAddressType ANY = const InternetAddressType._(-1);\n\n  final int _value;\n\n  const InternetAddressType._(int this._value);\n\n  factory InternetAddressType._from(int value) {\n    if (value == 0) return IPv4;\n    if (value == 1) return IPv6;\n    throw new ArgumentError(\"Invalid type: $value\");\n  }\n\n  /**\n   * Get the name of the type, e.g. \"IPv4\" or \"IPv6\".\n   */\n  String get name {\n    switch (_value) {\n      case -1: return \"ANY\";\n      case 0: return \"IPv4\";\n      case 1: return \"IPv6\";\n      default: throw new ArgumentError(\"Invalid InternetAddress\");\n    }\n  }\n\n  String toString() => \"InternetAddressType($name)\";\n}\n\n\n/**\n * The [InternetAddress] is an object reflecting either a remote or a local\n * address, for wich a socket can be connected to or bound on.\n *\n */\nabstract class InternetAddress {\n  /**\n   * The [type] of the [InternetAddress] specified what IP procotol.\n   */\n  InternetAddressType type;\n\n  /**\n   * The resolved address of the host.\n   */\n  String get address;\n\n  /**\n   * The host used to lookup the address.\n   */\n  String get host;\n\n  /**\n   * Lookup a host, returning a Future of a list of [InternetAddress]s. If\n   * [type] is [InternetAddressType.ANY], it will lookup both IPv4 and IPv6\n   * addresses. The order of the list depends on the local machine and the DNS\n   * lookup performed, and can as such change over time.\n   */\n  external static Future<List<InternetAddress>> lookup(\n      String host, {InternetAddressType type: InternetAddressType.IPv4});\n}\n\n/**\n * The RawServerSocket is a server socket, providing a stream of low-level\n * [RawSocket]s.\n *\n * See [RawSocket] for more info.\n */\nabstract class RawServerSocket implements Stream<RawSocket> {\n  /**\n   * Returns a future for a [:RawServerSocket:]. When the future\n   * completes the server socket is bound to the given [address] and\n   * [port] and has started listening on it.\n   *\n   * The default value for [address] is 127.0.0.1, which will allow\n   * only incoming connections from the local host. To allow for\n   * incoming connection from the network use either the value 0.0.0.0\n   * to bind to all interfaces or the IP address of a specific\n   * interface.\n   *\n   * If [port] has the value [:0:] (the default) an ephemeral port will\n   * be chosen by the system. The actual port used can be retrieved\n   * using the [:port:] getter.\n   *\n   * The optional argument [backlog] can be used to specify the listen\n   * backlog for the underlying OS listen setup. If [backlog] has the\n   * value of [:0:] (the default) a reasonable value will be chosen by\n   * the system.\n   */\n  external static Future<RawServerSocket> bind([address = \"127.0.0.1\",\n                                                int port = 0,\n                                                int backlog = 0]);\n\n  /**\n   * Returns the port used by this socket.\n   */\n  int get port;\n\n  /**\n   * Closes the socket.\n   */\n  void close();\n}\n\n\n/**\n * The [ServerSocket] is server socket, providing a stream of high-level\n * [Socket]s.\n *\n * See [Socket] for more info.\n */\nabstract class ServerSocket implements Stream<Socket> {\n  /**\n   * Returns a future for a [:ServerSocket:]. When the future\n   * completes the server socket is bound to the given [address] and\n   * [port] and has started listening on it.\n   *\n   * The default value for [address] is 127.0.0.1, which will allow\n   * only incoming connections from the local host. To allow for\n   * incoming connection from the network use either the value 0.0.0.0\n   * to bind to all interfaces or the IP address of a specific\n   * interface.\n   *\n   * If [port] has the value [:0:] (the default) an ephemeral port will\n   * be chosen by the system. The actual port used can be retrieved\n   * using the [port] getter.\n   *\n   * The optional argument [backlog] can be used to specify the listen\n   * backlog for the underlying OS listen setup. If [backlog] has the\n   * value of [:0:] (the default) a reasonable value will be chosen by\n   * the system.\n   */\n  external static Future<ServerSocket> bind([address = \"127.0.0.1\",\n                                             int port = 0,\n                                             int backlog = 0]);\n\n  /**\n   * Returns the port used by this socket.\n   */\n  int get port;\n\n  /**\n   * Closes the socket.\n   */\n  void close();\n}\n\n/**\n * The [SocketDirection] is used as a parameter to [Socket.close] and\n * [RawSocket.close] to close a socket in the specified direction(s).\n */\nclass SocketDirection {\n  static const SocketDirection RECEIVE = const SocketDirection._(0);\n  static const SocketDirection SEND = const SocketDirection._(1);\n  static const SocketDirection BOTH = const SocketDirection._(2);\n  const SocketDirection._(this._value);\n  final _value;\n}\n\n/**\n * The [SocketOption] is used as a parameter to [Socket.setOption] and\n * [RawSocket.setOption] to set customize the behaviour of the underlying\n * socket.\n */\nclass SocketOption {\n  /**\n   * Enable or disable no-delay on the socket. If TCP_NODELAY is enabled, the\n   * socket will not buffer data internally, but instead write each data chunk\n   * as an invidual TCP packet.\n   *\n   * TCP_NODELAY is disabled by default.\n   */\n  static const SocketOption TCP_NODELAY = const SocketOption._(0);\n  const SocketOption._(this._value);\n  final _value;\n}\n\n/**\n * Events for the [RawSocket].\n */\nclass RawSocketEvent {\n  static const RawSocketEvent READ = const RawSocketEvent._(0);\n  static const RawSocketEvent WRITE = const RawSocketEvent._(1);\n  static const RawSocketEvent READ_CLOSED = const RawSocketEvent._(2);\n  const RawSocketEvent._(this._value);\n  final int _value;\n  String toString() {\n    return ['RawSocketEvent:READ',\n            'RawSocketEvent:WRITE',\n            'RawSocketEvent:READ_CLOSED'][_value];\n  }\n}\n\n/**\n * The [RawSocket] is a low-level interface to a socket, exposing the raw\n * events signaled by the system. It's a [Stream] of [RawSocketEvent]s.\n */\nabstract class RawSocket implements Stream<RawSocketEvent> {\n  /**\n   * Creates a new socket connection to the host and port and returns a [Future]\n   * that will complete with either a [RawSocket] once connected or an error\n   * if the host-lookup or connection failed.\n   *\n   * [host] can either be a [String] or an [InternetAddress]. If [host] is a\n   * [String], [connect] will perform a [InternetAddress.lookup] and use\n   * the first value in the list.\n   */\n  external static Future<RawSocket> connect(host, int port);\n\n  /**\n   * Returns the number of received and non-read bytes in the socket that\n   * can be read.\n   */\n  int available();\n\n  /**\n   * Read up to [len] bytes from the socket. This function is\n   * non-blocking and will only return data if data is available. The\n   * number of bytes read can be less then [len] if fewer bytes are\n   * available for immediate reading. If no data is available [null]\n   * is returned.\n   */\n  List<int> read([int len]);\n\n  /**\n   * Writes up to [count] bytes of the buffer from [offset] buffer offset to\n   * the socket. The number of successfully written bytes is returned. This\n   * function is non-blocking and will only write data if buffer space is\n   * available in the socket.\n   */\n  int write(List<int> buffer, [int offset, int count]);\n\n  /**\n   * Returns the port used by this socket.\n   */\n  int get port;\n\n  /**\n   * Returns the remote port connected to by this socket.\n   */\n  int get remotePort;\n\n  /**\n   * Returns the [InternetAddress] used to connect this socket.\n   */\n  InternetAddress get address;\n\n  /**\n   * Returns the remote host connected to by this socket.\n   */\n  String get remoteHost;\n\n  /**\n   * Closes the socket. Calling [close] will never throw an exception\n   * and calling it several times is supported. Calling [close] can result in\n   * a [RawSocketEvent.READ_CLOSED] event.\n   */\n  void close();\n\n  /**\n   * Shutdown the socket in the [direction]. Calling [shutdown] will never\n   * throw an exception and calling it several times is supported. Calling\n   * shutdown with either [SocketDirection.BOTH] or [SocketDirection.RECEIVE]\n   * can result in a [RawSocketEvent.READ_CLOSED] event.\n   */\n  void shutdown(SocketDirection direction);\n\n  /**\n   * Set or get, if the [RawSocket] should listen for [RawSocketEvent.READ]\n   * events. Default is [true].\n   */\n  bool readEventsEnabled;\n\n  /**\n   * Set or get, if the [RawSocket] should listen for [RawSocketEvent.WRITE]\n   * events. Default is [true].\n   * This is a one-shot listener, and writeEventsEnabled must be set\n   * to true again to receive another write event.\n   */\n  bool writeEventsEnabled;\n\n  /**\n   * Use [setOption] to customize the [RawSocket]. See [SocketOption] for\n   * available options.\n   *\n   * Returns [true] if the option was set successfully, false otherwise.\n   */\n  bool setOption(SocketOption option, bool enabled);\n}\n\n/**\n * A high-level class for communicating over a TCP socket. The [Socket] exposes\n * both a [Stream] and a [IOSink] interface, making it ideal for\n * using together with other [Stream]s.\n */\nabstract class Socket implements Stream<List<int>>, IOSink {\n  /**\n   * Creats a new socket connection to the host and port and returns a [Future]\n   * that will complete with either a [Socket] once connected or an error\n   * if the host-lookup or connection failed.\n   *\n   * [host] can either be a [String] or an [InternetAddress]. If [host] is a\n   * [String], [connect] will perform a [InternetAddress.lookup] and use\n   * the first value in the list.\n   */\n  external static Future<Socket> connect(host, int port);\n\n  /**\n   * Destroy the socket in both directions. Calling [destroy] will make the\n   * send a close event on the stream and will no longer react on data being\n   * piped to it.\n   *\n   * Call [close](inherited from [IOSink]) to only close the [Socket]\n   * for sending data.\n   */\n  void destroy();\n\n  /**\n   * Use [setOption] to customize the [RawSocket]. See [SocketOption] for\n   * available options.\n   *\n   * Returns [true] if the option was set successfully, false otherwise.\n   */\n  bool setOption(SocketOption option, bool enabled);\n\n  /**\n   * Returns the port used by this socket.\n   */\n  int get port;\n\n  /**\n   * Returns the remote port connected to by this socket.\n   */\n  int get remotePort;\n\n  /**\n   * Returns the [InternetAddress] used to connect this socket.\n   */\n  InternetAddress get address;\n\n  /**\n   * Returns the remote host connected to by this socket.\n   */\n  String get remoteHost;\n}\n\n\nclass SocketIOException implements Exception {\n  const SocketIOException([String this.message = \"\",\n                           OSError this.osError = null]);\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    sb.write(\"SocketIOException\");\n    if (!message.isEmpty) {\n      sb.write(\": $message\");\n      if (osError != null) {\n        sb.write(\" ($osError)\");\n      }\n    } else if (osError != null) {\n      sb.write(\": $osError\");\n    }\n    return sb.toString();\n  }\n  final String message;\n  final OSError osError;\n}\n","sdk/lib/io/stdio.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nconst int _STDIO_HANDLE_TYPE_TERMINAL = 0;\nconst int _STDIO_HANDLE_TYPE_PIPE = 1;\nconst int _STDIO_HANDLE_TYPE_FILE = 2;\nconst int _STDIO_HANDLE_TYPE_SOCKET = 3;\nconst int _STDIO_HANDLE_TYPE_OTHER = 4;\n\nclass _StdStream extends Stream<List<int>> {\n  final Stream<List<int>> _stream;\n\n  _StdStream(Stream<List<int>> this._stream);\n\n  StreamSubscription<List<int>> listen(void onData(List<int> event),\n                                       {void onError(error),\n                                        void onDone(),\n                                        bool cancelOnError}) {\n    return _stream.listen(\n        onData,\n        onError: onError,\n        onDone: onDone,\n        cancelOnError: cancelOnError);\n  }\n}\n\nclass _StdSink implements IOSink {\n  final IOSink _sink;\n\n  _StdSink(IOSink this._sink);\n\n  Encoding get encoding => _sink.encoding;\n  void set encoding(Encoding encoding) {\n    _sink.encoding = encoding;\n  }\n  void write(object) => _sink.write(object);\n  void writeln([object = \"\" ]) => _sink.writeln(object);\n  void writeAll(objects, [sep = \"\"]) => _sink.writeAll(objects, sep);\n  void add(List<int> data) => _sink.add(data);\n  void addError(error) => _sink.addError(error);\n  void writeCharCode(int charCode) => _sink.writeCharCode(charCode);\n  Future addStream(Stream<List<int>> stream) => _sink.addStream(stream);\n  Future close() => _sink.close();\n  Future get done => _sink.done;\n}\n\nclass StdioType {\n  static const StdioType TERMINAL = const StdioType._(\"terminal\");\n  static const StdioType PIPE = const StdioType._(\"pipe\");\n  static const StdioType FILE = const StdioType._(\"file\");\n  static const StdioType OTHER = const StdioType._(\"other\");\n  final String name;\n  const StdioType._(String this.name);\n  String toString() => \"StdioType: $name\";\n}\n\n\nStream<List<int>> _stdin;\nIOSink _stdout;\nIOSink _stderr;\n\n\nStream<List<int>> get stdin {\n  if (_stdin == null) {\n    _stdin = _StdIOUtils._getStdioInputStream();\n  }\n  return _stdin;\n}\n\n\nIOSink get stdout {\n  if (_stdout == null) {\n    _stdout = _StdIOUtils._getStdioOutputStream(1);\n  }\n  return _stdout;\n}\n\n\nIOSink get stderr {\n  if (_stderr == null) {\n    _stderr = _StdIOUtils._getStdioOutputStream(2);\n  }\n  return _stderr;\n}\n\n\nStdioType stdioType(object) {\n  if (object is _StdStream) {\n    object = object._stream;\n  } else if (object is _StdSink) {\n    object = object._sink;\n  }\n  if (object is _FileStream) {\n    return StdioType.FILE;\n  }\n  if (object is Socket) {\n    switch (_StdIOUtils._socketType(object._nativeSocket)) {\n      case _STDIO_HANDLE_TYPE_TERMINAL: return StdioType.TERMINAL;\n      case _STDIO_HANDLE_TYPE_PIPE: return StdioType.PIPE;\n      case _STDIO_HANDLE_TYPE_FILE:  return StdioType.FILE;\n    }\n  }\n  if (object is IOSink) {\n    try {\n      if (object._target is _FileStreamConsumer) {\n        return StdioType.FILE;\n      }\n    } catch (e) {\n      // Only the interface implemented, _sink not available.\n    }\n  }\n  return StdioType.OTHER;\n}\n\n\nclass _StdIOUtils {\n  external static IOSink _getStdioOutputStream(int fd);\n  external static Stream<List<int>> _getStdioInputStream();\n  external static int _socketType(nativeSocket);\n}\n","sdk/lib/io/string_transformer.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * String encodings.\n */\nclass Encoding {\n  static const Encoding UTF_8 = const Encoding._internal(\"utf-8\");\n  static const Encoding ISO_8859_1 = const Encoding._internal(\"iso-8859-1\");\n  static const Encoding ASCII = const Encoding._internal(\"us-ascii\");\n\n  /**\n   * SYSTEM encoding is the current code page on Windows and UTF-8 on\n   * Linux and Mac.\n   */\n  static const Encoding SYSTEM = const Encoding._internal(\"system\");\n\n  // All aliasses (in lowercase) of supported encoding from\n  // http://www.iana.org/assignments/character-sets/character-sets.xml.\n  static Map<String, Encoding> _nameToEncoding = <String, Encoding> {\n    // ISO_8859-1:1987.\n    \"iso_8859-1:1987\": ISO_8859_1,\n    \"iso-ir-100\": ISO_8859_1,\n    \"iso_8859-1\": ISO_8859_1,\n    \"iso-8859-1\": ISO_8859_1,\n    \"latin1\": ISO_8859_1,\n    \"l1\": ISO_8859_1,\n    \"ibm819\": ISO_8859_1,\n    \"cp819\": ISO_8859_1,\n    \"csisolatin1\": ISO_8859_1,\n\n    // US-ASCII.\n    \"iso-ir-6\": ASCII,\n    \"ansi_x3.4-1968\": ASCII,\n    \"ansi_x3.4-1986\": ASCII,\n    \"iso_646.irv:1991\": ASCII,\n    \"iso646-us\": ASCII,\n    \"us-ascii\": ASCII,\n    \"us\": ASCII,\n    \"ibm367\": ASCII,\n    \"cp367\": ASCII,\n    \"csascii\": ASCII,\n    \"ascii\": ASCII,  // This is not in the IANA official names.\n\n    // UTF-8.\n    \"csutf8\": UTF_8,\n    \"utf-8\": UTF_8\n  };\n\n  /**\n   * Gets an [Encoding] object from the name of the character set\n   * name. The names used are the IANA official names for the\n   * character set (see\n   * http://www.iana.org/assignments/character-sets/character-sets.xml).\n   *\n   * The [name] passed is case insensitive.\n   *\n   * If character set is not supported [:null:] is returned.\n   */\n  static Encoding fromName(String name) {\n    if (name == null) return null;\n    name = name.toLowerCase();\n    return _nameToEncoding[name];\n  }\n\n  /**\n   * Name of the encoding. This will be the lower-case version of one of the\n   * IANA official names for the character set (see\n   * http://www.iana.org/assignments/character-sets/character-sets.xml)\n   */\n  final String name;\n\n  const Encoding._internal(String this.name);\n}\n\nconst UTF_8 = Encoding.UTF_8;\nconst ISO_8859_1 = Encoding.ISO_8859_1;\nconst ASCII = Encoding.ASCII;\n\n/**\n * Stream transformer that can decode a stream of bytes into a stream of\n * strings using [encoding].\n *\n * Invalid or forbidden byte-sequences will not produce errors, but will instead\n * insert [replacementChar] in the decoded strings.\n */\nclass StringDecoder implements StreamTransformer<List<int>, String> {\n  var _decoder;\n\n  /**\n   * Create a new [StringDecoder] with an optional [encoding] and\n   * [replacementChar].\n   */\n  StringDecoder([Encoding encoding = Encoding.UTF_8, int replacementChar]) {\n    switch (encoding) {\n      case Encoding.UTF_8:\n        if (replacementChar == null) {\n          replacementChar = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT;\n        }\n        _decoder = new Utf8DecoderTransformer(replacementChar);\n        break;\n      case Encoding.ASCII:\n        if (replacementChar == null) {\n          replacementChar = '?'.codeUnitAt(0);\n        } else if (replacementChar > 127) {\n          throw new ArgumentError(\"Invalid replacement character for ASCII\");\n        }\n        _decoder = new _AsciiDecoder(replacementChar);\n        break;\n      case Encoding.ISO_8859_1:\n        if (replacementChar == null) {\n          replacementChar = '?'.codeUnitAt(0);\n        } else if (replacementChar > 255) {\n          throw new ArgumentError(\n              \"Invalid replacement character for ISO_8859_1\");\n        }\n        _decoder = new _Latin1Decoder(replacementChar);\n        break;\n      case Encoding.SYSTEM:\n        if (Platform.operatingSystem == \"windows\") {\n          _decoder = new _WindowsCodePageDecoder();\n        } else {\n          if (replacementChar != null) {\n            // TODO(ajohnsen): Handle replacement character.\n            throw new UnsupportedError(\n                \"Replacement character is not supported for SYSTEM encoding\");\n          }\n          _decoder = new Utf8DecoderTransformer();\n        }\n        break;\n      default:\n        throw new ArgumentError(\"Unsupported encoding '$encoding'\");\n    }\n  }\n\n  Stream<String> bind(Stream<List<int>> stream) => _decoder.bind(stream);\n}\n\n\n/**\n * Stream transformer that can encode a stream of strings info a stream of\n * bytes using [encoding].\n *\n * Strings that cannot be represented in the given encoding will result in an\n * error and a close event on the stream.\n */\nclass StringEncoder implements StreamTransformer<String, List<int>> {\n  var _encoder;\n\n  /**\n   * Create a new [StringDecoder] with an optional [encoding] and\n   * [replacementChar].\n   */\n  StringEncoder([Encoding encoding = Encoding.UTF_8]) {\n    switch (encoding) {\n      case Encoding.UTF_8:\n        _encoder = new Utf8EncoderTransformer();\n        break;\n      case Encoding.ASCII:\n        _encoder = new _AsciiEncoder();\n        break;\n      case Encoding.ISO_8859_1:\n        _encoder = new _Latin1Encoder();\n        break;\n      case Encoding.SYSTEM:\n        if (Platform.operatingSystem == \"windows\") {\n          _encoder = new _WindowsCodePageEncoder();\n        } else {\n          _encoder = new Utf8EncoderTransformer();\n        }\n        break;\n      default:\n        throw new ArgumentError(\"Unsupported encoding '$encoding'\");\n    }\n  }\n\n  Stream<List<int>> bind(Stream<String> stream) => _encoder.bind(stream);\n}\n\n\n// Utility function to synchronously decode a list of bytes.\nString _decodeString(List<int> bytes, [Encoding encoding = Encoding.UTF_8]) {\n  if (bytes.length == 0) return \"\";\n  var string;\n  var controller = new StreamController();\n  controller.stream\n    .transform(new StringDecoder(encoding))\n    .listen((data) => string = data);\n  controller.add(bytes);\n  controller.close();\n  assert(string != null);\n  return string;\n}\n\n\n// Utility function to synchronously encode a String.\n// Will throw an exception if the encoding is invalid.\nList<int> _encodeString(String string, [Encoding encoding = Encoding.UTF_8]) {\n  if (string.length == 0) return [];\n  var bytes;\n  var controller = new StreamController();\n  controller.stream\n    .transform(new StringEncoder(encoding))\n    .listen((data) => bytes = data);\n  controller.add(string);\n  controller.close();\n  assert(bytes != null);\n  return bytes;\n}\n\n\nclass LineTransformer extends StreamEventTransformer<String, String> {\n  const int _LF = 10;\n  const int _CR = 13;\n\n  StringBuffer _buffer = new StringBuffer();\n  String _carry;\n\n  void _handle(String data, EventSink<String> sink, bool isClosing) {\n    if (_carry != null) {\n      data = _carry + data;\n      _carry = null;\n    }\n    int startPos = 0;\n    int pos = 0;\n    while (pos < data.length) {\n      int skip = 0;\n      int char = data.codeUnitAt(pos);\n      if (char == _LF) {\n        skip = 1;\n      } else if (char == _CR) {\n        skip = 1;\n        if (pos + 1 < data.length) {\n          if (data.codeUnitAt(pos + 1) == _LF) {\n            skip = 2;\n          }\n        } else if (!isClosing) {\n          _carry = data.substring(startPos);\n          return;\n        }\n      }\n      if (skip > 0) {\n        _buffer.write(data.substring(startPos, pos));\n        sink.add(_buffer.toString());\n        _buffer = new StringBuffer();\n        startPos = pos = pos + skip;\n      } else {\n        pos++;\n      }\n    }\n    if (pos != startPos) {\n      // Add remaining\n      _buffer.write(data.substring(startPos, pos));\n    }\n    if (isClosing && !_buffer.isEmpty) {\n      sink.add(_buffer.toString());\n      _buffer = new StringBuffer();\n    }\n  }\n\n  void handleData(String data, EventSink<String> sink) {\n    _handle(data, sink, false);\n  }\n\n  void handleDone(EventSink<String> sink) {\n    _handle(\"\", sink, true);\n    sink.close();\n  }\n}\n\n\nabstract class _SingleByteDecoder\n    extends StreamEventTransformer<List<int>, String> {\n  final int _replacementChar;\n\n  _SingleByteDecoder(this._replacementChar);\n\n  void handleData(List<int> data, EventSink<String> sink) {\n    var buffer = new List<int>(data.length);\n    for (int i = 0; i < data.length; i++) {\n      int char = _decodeByte(data[i]);\n      if (char < 0) char = _replacementChar;\n      buffer[i] = char;\n    }\n    sink.add(new String.fromCharCodes(buffer));\n  }\n\n  int _decodeByte(int byte);\n}\n\n\n// Utility class for decoding ascii data delivered as a stream of\n// bytes.\nclass _AsciiDecoder extends _SingleByteDecoder {\n  _AsciiDecoder(int replacementChar) : super(replacementChar);\n\n  int _decodeByte(int byte) => ((byte & 0x7f) == byte) ? byte : -1;\n}\n\n\n// Utility class for decoding Latin-1 data delivered as a stream of\n// bytes.\nclass _Latin1Decoder extends _SingleByteDecoder {\n  _Latin1Decoder(int replacementChar) : super(replacementChar);\n\n  int _decodeByte(int byte) => ((byte & 0xFF) == byte) ? byte : -1;\n}\n\n\nabstract class _SingleByteEncoder\n    extends StreamEventTransformer<String, List<int>> {\n  void handleData(String data, EventSink<List<int>> sink) {\n    var bytes = _encode(data);\n    if (bytes == null) {\n      sink.addError(new FormatException(\"Invalid character for encoding\"));\n      sink.close();\n    } else {\n      sink.add(bytes);\n    }\n  }\n\n  List<int> _encode(String string);\n}\n\n\n// Utility class for encoding a string into an ASCII byte stream.\nclass _AsciiEncoder extends _SingleByteEncoder {\n  List<int> _encode(String string) {\n    var bytes = string.codeUnits;\n    for (var byte in bytes) {\n      if (byte > 127) return null;\n    }\n    return bytes;\n  }\n}\n\n\n// Utility class for encoding a string into a Latin1 byte stream.\nclass _Latin1Encoder extends _SingleByteEncoder {\n  List<int> _encode(String string) {\n    var bytes = string.codeUnits;\n    for (var byte in bytes) {\n      if (byte > 255) return null;\n    }\n    return bytes;\n  }\n}\n\n\n// Utility class for encoding a string into a current windows\n// code page byte list.\n// Implemented on top of a _SingleByteEncoder, even though it's not really a\n// single byte encoder, to avoid copying boilerplate.\nclass _WindowsCodePageEncoder extends _SingleByteEncoder {\n  List<int> _encode(String string) => _encodeString(string);\n\n  external static List<int> _encodeString(String string);\n}\n\n\n// Utility class for decoding Windows current code page data delivered\n// as a stream of bytes.\nclass _WindowsCodePageDecoder extends StreamEventTransformer<List<int>, String> {\n  void handleData(List<int> data, EventSink<String> sink) {\n    sink.add(_decodeBytes(data));\n  }\n\n  external static String _decodeBytes(List<int> bytes);\n}\n","sdk/lib/io/timer_impl.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass _Timer implements Timer {\n  // Set jitter to wake up timer events that would happen in _TIMER_JITTER ms.\n  static const int _TIMER_JITTER = 0;\n\n  // Disables the timer.\n  static const int _NO_TIMER = -1;\n\n  static Timer _createTimer(void callback(Timer timer),\n                           int milliSeconds,\n                           bool repeating) {\n    _EventHandler._start();\n    if (_timers == null) {\n      _timers = new DoubleLinkedQueue<_Timer>();\n    }\n    _Timer timer = new _Timer._internal();\n    timer._callback = callback;\n    timer._milliSeconds = milliSeconds;\n    timer._wakeupTime = (new DateTime.now()).millisecondsSinceEpoch + milliSeconds;\n    timer._repeating = repeating;\n    timer._addTimerToList();\n    timer._notifyEventHandler();\n    return timer;\n  }\n\n  factory _Timer(int milliSeconds, void callback(Timer timer)) {\n    return _createTimer(callback, milliSeconds, false);\n  }\n\n  factory _Timer.periodic(int milliSeconds, void callback(Timer timer)) {\n    return _createTimer(callback, milliSeconds, true);\n  }\n\n  _Timer._internal() {}\n\n  void _clear() {\n    _callback = null;\n    _milliSeconds = 0;\n    _wakeupTime = 0;\n    _repeating = false;\n  }\n\n\n  // Cancels a set timer. The timer is removed from the timer list and if\n  // the given timer is the earliest timer the native timer is reset.\n  void cancel() {\n    _clear();\n    DoubleLinkedQueueEntry<_Timer> entry = _timers.firstEntry();\n    DoubleLinkedQueueEntry<_Timer> first = _timers.firstEntry();\n\n     while (entry != null) {\n      if (identical(entry.element, this)) {\n        entry.remove();\n        if (first.element == this) {\n          entry = _timers.firstEntry();\n          _notifyEventHandler();\n        }\n        return;\n      }\n      entry = entry.nextEntry();\n    }\n  }\n\n  void _advanceWakeupTime() {\n    _wakeupTime += _milliSeconds;\n  }\n\n  // Adds a timer to the timer list and resets the native timer if it is the\n  // earliest timer in the list.  Timers with the same wakeup time are enqueued\n  // in order and notified in FIFO order.\n  void _addTimerToList() {\n    if (_callback != null) {\n\n      DoubleLinkedQueueEntry<_Timer> entry = _timers.firstEntry();\n      while (entry != null) {\n        if (_wakeupTime < entry.element._wakeupTime) {\n          entry.prepend(this);\n          return;\n        }\n        entry = entry.nextEntry();\n      }\n      _timers.add(this);\n    }\n  }\n\n\n  void _notifyEventHandler() {\n    if (_handling_callbacks) {\n      // While we are already handling callbacks we will not notify the event\n      // handler. _handleTimeout will call _notifyEventHandler once all pending\n      // timers are processed.\n      return;\n    }\n\n    if (_timers.firstEntry() == null) {\n      // No pending timers: Close the receive port and let the event handler\n      // know.\n      if (_receivePort != null) {\n        _EventHandler._sendData(null, _receivePort, _NO_TIMER);\n        _shutdownTimerHandler();\n      }\n    } else {\n      if (_receivePort == null) {\n        // Create a receive port and register a message handler for the timer\n        // events.\n        _createTimerHandler();\n      }\n      _EventHandler._sendData(null,\n                              _receivePort,\n                              _timers.firstEntry().element._wakeupTime);\n    }\n  }\n\n\n  // Creates a receive port and registers the timer handler on that\n  // receive port.\n  void _createTimerHandler() {\n\n    void _handleTimeout() {\n      int currentTime =\n          (new DateTime.now()).millisecondsSinceEpoch + _TIMER_JITTER;\n\n      // Collect all pending timers.\n      DoubleLinkedQueueEntry<_Timer> entry = _timers.firstEntry();\n      var pending_timers = new List();\n      while (entry != null) {\n        _Timer timer = entry.element;\n        if (timer._wakeupTime <= currentTime) {\n          entry.remove();\n          pending_timers.add(timer);\n          entry = _timers.firstEntry();\n        } else {\n          break;\n        }\n      }\n\n      // Trigger all of the pending timers. New timers added as part of the\n      // callbacks will be enqueued now and notified in the next spin at the\n      // earliest.\n      _handling_callbacks = true;\n      try {\n        for (var timer in pending_timers) {\n          // One of the timers in the pending_timers list can cancel\n          // one of the later timers which will set the callback to\n          // null.\n          if (timer._callback != null) {\n            timer._callback(timer);\n            if (timer._repeating) {\n              timer._advanceWakeupTime();\n              timer._addTimerToList();\n            }\n          }\n        }\n      } finally {\n        _handling_callbacks = false;\n      }\n      _notifyEventHandler();\n    }\n\n    if(_receivePort == null) {\n      _receivePort = new ReceivePort();\n      _receivePort.receive((var message, ignored) {\n        _handleTimeout();\n      });\n    }\n  }\n\n  void _shutdownTimerHandler() {\n    _receivePort.close();\n    _receivePort = null;\n  }\n\n\n  // Timers are ordered by wakeup time.\n  static DoubleLinkedQueue<_Timer> _timers;\n\n  static ReceivePort _receivePort;\n  static bool _handling_callbacks = false;\n\n  var _callback;\n  int _milliSeconds;\n  int _wakeupTime;\n  bool _repeating;\n}\n\n// Provide a closure which will allocate a Timer object to be able to hook\n// up the Timer interface in dart:isolate with the implementation here.\n_getTimerFactoryClosure() {\n  return (int milliSeconds, void callback(Timer timer), bool repeating) {\n    if (repeating) {\n      return new _Timer.periodic(milliSeconds, callback);\n    }\n    return new _Timer(milliSeconds, callback);\n  };\n}\n\n\n","sdk/lib/io/websocket.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * Web socket status codes used when closing a web socket connection.\n */\nabstract class WebSocketStatus {\n  static const int NORMAL_CLOSURE = 1000;\n  static const int GOING_AWAY = 1001;\n  static const int PROTOCOL_ERROR = 1002;\n  static const int UNSUPPORTED_DATA = 1003;\n  static const int RESERVED_1004  = 1004;\n  static const int NO_STATUS_RECEIVED = 1005;\n  static const int ABNORMAL_CLOSURE = 1006;\n  static const int INVALID_FRAME_PAYLOAD_DATA = 1007;\n  static const int POLICY_VIOLATION = 1008;\n  static const int MESSAGE_TOO_BIG = 1009;\n  static const int MISSING_MANDATORY_EXTENSION = 1010;\n  static const int INTERNAL_SERVER_ERROR = 1011;\n  static const int RESERVED_1015 = 1015;\n}\n\n/**\n * The [WebSocketTransformer] provides the ability to upgrade a\n * [HttpRequest] to a [WebSocket] connection. It supports both\n * upgrading a single [HttpRequest] and upgrading a stream of\n * [HttpRequest]s.\n *\n * To upgrade a single [HttpRequest] use the static [upgrade] method.\n *\n *     HttpServer server;\n *     server.listen((request) {\n *       if (...) {\n *         WebSocketTransformer.upgrade(request).then(websocket) {\n *           ...\n *         }\n *       } else {\n *         // Do normal HTTP request processing.\n *       }\n *     });\n *\n * To transform a stream of [HttpRequest] events as it implements a\n * stream transformer that transforms a stream of HttpRequest into a\n * stream of WebSockets by upgrading each HttpRequest from the HTTP or\n * HTTPS server, to the WebSocket protocol.\n *\n *     server.transform(new WebSocketTransformer()).listen((webSocket) => ...);\n *\n * This transformer strives to implement web sockets as specified by RFC6455.\n */\nabstract class WebSocketTransformer\n    implements StreamTransformer<HttpRequest, WebSocket> {\n  factory WebSocketTransformer() => new _WebSocketTransformerImpl();\n\n  /**\n   * Upgrades a [HttpRequest] to a [WebSocket] connection. If the\n   * request is not a valid web socket upgrade request a HTTP response\n   * with status code 500 will be returned. Otherwise the returned\n   * future will complete with the [WebSocket] when the upgrade pocess\n   * is complete.\n   */\n  static Future<WebSocket> upgrade(HttpRequest request) {\n    return _WebSocketTransformerImpl._upgrade(request);\n  }\n\n  /**\n   * Checks whether the request is a valid WebSocket upgrade request.\n   */\n  static bool isUpgradeRequest(HttpRequest request) {\n    return _WebSocketTransformerImpl._isUpgradeRequest(request);\n  }\n}\n\n\n/**\n * A client or server web socket connection. The stream exposes the\n * messages received. A text message will be of type [:String:] and a\n * binary message will be of type [:List<int>:].\n */\nabstract class WebSocket implements Stream, StreamSink {\n  /**\n   * Possible states of the connection.\n   */\n  static const int CONNECTING = 0;\n  static const int OPEN = 1;\n  static const int CLOSING = 2;\n  static const int CLOSED = 3;\n\n  /**\n   * Create a new web socket connection. The URL supplied in [url]\n   * must use the scheme [:ws:] or [:wss:]. The [protocols] argument is either\n   * a [:String:] or [:List<String>:] specifying the subprotocols the\n   * client is willing to speak.\n   */\n  static Future<WebSocket> connect(String url, [protocols]) =>\n      _WebSocketImpl.connect(url, protocols);\n\n  /**\n   * Returns the current state of the connection.\n   */\n  int get readyState;\n\n  /**\n   * The extensions property is initially the empty string. After the\n   * web socket connection is established this string reflects the\n   * extensions used by the server.\n   */\n  String get extensions;\n\n  /**\n   * The protocol property is initially the empty string. After the\n   * web socket connection is established the value is the subprotocol\n   * selected by the server. If no subprotocol is negotiated the\n   * value will remain [:null:].\n   */\n  String get protocol;\n\n  /**\n   * The close code set when the web socket connection is closed. If\n   * there is no close code available this property will be [:null:]\n   */\n  int get closeCode;\n\n  /**\n   * The close reason set when the web socket connection is closed. If\n   * there is no close reason available this property will be [:null:]\n   */\n  String get closeReason;\n\n  /**\n   * Closes the web socket connection. Set the optional [code] and [reason]\n   * arguments to send close information to the remote peer. If they are\n   * omitted, the peer will see [WebSocketStatus.NO_STATUS_RECEIVED] code\n   * with no reason.\n   */\n  Future close([int code, String reason]);\n\n  /**\n   * Sends data on the web socket connection. The data in [data] must\n   * be either a [:String:], or a [:List<int>:] holding bytes.\n   */\n  void add(data);\n\n  /**\n   * Sends data from a stream on web socket connection. Each data event from\n   * [stream] will be send as a single WebSocket frame. The data from [stream]\n   * must be either [:String:]s, or [:List<int>:]s holding bytes.\n   */\n  Future addStream(Stream stream);\n}\n\n\nclass WebSocketException implements Exception {\n  const WebSocketException([String this.message = \"\"]);\n  String toString() => \"WebSocketException: $message\";\n  final String message;\n}\n","sdk/lib/io/websocket_impl.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nconst String _webSocketGUID = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n\nclass _WebSocketMessageType {\n  static const int NONE = 0;\n  static const int BINARY = 1;\n  static const int TEXT = 2;\n}\n\n\nclass _WebSocketOpcode {\n  static const int CONTINUATION = 0;\n  static const int TEXT = 1;\n  static const int BINARY = 2;\n  static const int RESERVED_3 = 3;\n  static const int RESERVED_4 = 4;\n  static const int RESERVED_5 = 5;\n  static const int RESERVED_6 = 6;\n  static const int RESERVED_7 = 7;\n  static const int CLOSE = 8;\n  static const int PING = 9;\n  static const int PONG = 10;\n  static const int RESERVED_B = 11;\n  static const int RESERVED_C = 12;\n  static const int RESERVED_D = 13;\n  static const int RESERVED_E = 14;\n  static const int RESERVED_F = 15;\n}\n\n/**\n * The web socket protocol transformer handles the protocol byte stream\n * which is supplied through the [:handleData:]. As the protocol is processed,\n * it'll output frame data as either a List<int> or String.\n *\n * Important infomation about usage: Be sure you use cancelOnError, so the\n * socket will be closed when the processer encounter an error. Not using it\n * will lead to undefined behaviour.\n */\nclass _WebSocketProtocolTransformer extends StreamEventTransformer {\n  static const int START = 0;\n  static const int LEN_FIRST = 1;\n  static const int LEN_REST = 2;\n  static const int MASK = 3;\n  static const int PAYLOAD = 4;\n  static const int CLOSED = 5;\n  static const int FAILURE = 6;\n\n  bool _serverSide;\n\n  _WebSocketProtocolTransformer([bool this._serverSide = false]) {\n    _prepareForNextFrame();\n    _currentMessageType = _WebSocketMessageType.NONE;\n  }\n\n  /**\n   * Process data received from the underlying communication channel.\n   */\n  void handleData(List<int> buffer, EventSink sink) {\n    int count = buffer.length;\n    int index = 0;\n    int lastIndex = count;\n    try {\n      if (_state == CLOSED) {\n        throw new WebSocketException(\"Data on closed connection\");\n      }\n      if (_state == FAILURE) {\n        throw new WebSocketException(\"Data on failed connection\");\n      }\n      while ((index < lastIndex) && _state != CLOSED && _state != FAILURE) {\n        int byte = buffer[index];\n        switch (_state) {\n          case START:\n            _fin = (byte & 0x80) != 0;\n            _opcode = (byte & 0xF);\n            switch (_opcode) {\n            case _WebSocketOpcode.CONTINUATION:\n              if (_currentMessageType == _WebSocketMessageType.NONE) {\n                throw new WebSocketException(\"Protocol error\");\n              }\n              break;\n\n            case _WebSocketOpcode.TEXT:\n              if (_currentMessageType != _WebSocketMessageType.NONE) {\n                throw new WebSocketException(\"Protocol error\");\n              }\n              _currentMessageType = _WebSocketMessageType.TEXT;\n              _buffer = new StringBuffer();\n              break;\n\n            case _WebSocketOpcode.BINARY:\n              if (_currentMessageType != _WebSocketMessageType.NONE) {\n                throw new WebSocketException(\"Protocol error\");\n              }\n              _currentMessageType = _WebSocketMessageType.BINARY;\n              _buffer = new _BufferList();\n              break;\n\n            case _WebSocketOpcode.CLOSE:\n            case _WebSocketOpcode.PING:\n            case _WebSocketOpcode.PONG:\n              // Control frames cannot be fragmented.\n              if (!_fin) throw new WebSocketException(\"Protocol error\");\n              break;\n\n            default:\n              throw new WebSocketException(\"Protocol error\");\n            }\n            _state = LEN_FIRST;\n            break;\n\n          case LEN_FIRST:\n            _masked = (byte & 0x80) != 0;\n            _len = byte & 0x7F;\n            if (_isControlFrame() && _len > 126) {\n              throw new WebSocketException(\"Protocol error\");\n            }\n            if (_len < 126) {\n              _lengthDone(sink);\n            } else if (_len == 126) {\n              _len = 0;\n              _remainingLenBytes = 2;\n              _state = LEN_REST;\n            } else if (_len == 127) {\n              _len = 0;\n              _remainingLenBytes = 8;\n              _state = LEN_REST;\n            }\n            break;\n\n          case LEN_REST:\n            _len = _len << 8 | byte;\n            _remainingLenBytes--;\n            if (_remainingLenBytes == 0) {\n              _lengthDone(sink);\n            }\n            break;\n\n          case MASK:\n            _maskingKey = _maskingKey << 8 | byte;\n            _remainingMaskingKeyBytes--;\n            if (_remainingMaskingKeyBytes == 0) {\n              _maskDone(sink);\n            }\n            break;\n\n          case PAYLOAD:\n            // The payload is not handled one byte at a time but in blocks.\n            int payload;\n            if (lastIndex - index <= _remainingPayloadBytes) {\n              payload = lastIndex - index;\n            } else {\n              payload = _remainingPayloadBytes;\n            }\n            _remainingPayloadBytes -= payload;\n\n            // Unmask payload if masked.\n            if (_masked) {\n              for (int i = 0; i < payload; i++) {\n                int maskingByte =\n                    ((_maskingKey >> ((3 - _unmaskingIndex) * 8)) & 0xFF);\n                buffer[index + i] = buffer[index + i] ^ maskingByte;\n                _unmaskingIndex = (_unmaskingIndex + 1) % 4;\n              }\n            }\n\n            if (_isControlFrame()) {\n              if (payload > 0) {\n                // Allocate a buffer for collecting the control frame\n                // payload if any.\n                if (_controlPayload == null) {\n                  _controlPayload = new List<int>();\n                }\n                _controlPayload.addAll(buffer.sublist(index, index + payload));\n                index += payload;\n              }\n\n              if (_remainingPayloadBytes == 0) {\n                _controlFrameEnd(sink);\n              }\n            } else {\n              switch (_currentMessageType) {\n                case _WebSocketMessageType.NONE:\n                  throw new WebSocketException(\"Protocol error\");\n\n                case _WebSocketMessageType.TEXT:\n                  _buffer.write(_decodeString(\n                      buffer.sublist(index, index + payload)));\n                  index += payload;\n                  if (_remainingPayloadBytes == 0) {\n                    _messageFrameEnd(sink);\n                  }\n                  break;\n\n                case _WebSocketMessageType.BINARY:\n                  _buffer.write(buffer.sublist(index, index + payload));\n                  index += payload;\n                  if (_remainingPayloadBytes == 0) {\n                    _messageFrameEnd(sink);\n                  }\n                  break;\n\n                default:\n                  throw new WebSocketException(\"Protocol error\");\n              }\n            }\n\n            // Hack - as we always do index++ below.\n            index--;\n            break;\n        }\n\n        // Move to the next byte.\n        index++;\n      }\n    } catch (e) {\n      _state = FAILURE;\n      sink.addError(e);\n    }\n  }\n\n  void _lengthDone(EventSink sink) {\n    if (_masked) {\n      if (!_serverSide) {\n        throw new WebSocketException(\"Received masked frame from server\");\n      }\n      _state = MASK;\n      _remainingMaskingKeyBytes = 4;\n    } else {\n      if (_serverSide) {\n        throw new WebSocketException(\"Received unmasked frame from client\");\n      }\n      _remainingPayloadBytes = _len;\n      _startPayload(sink);\n    }\n  }\n\n  void _maskDone(EventSink sink) {\n    _remainingPayloadBytes = _len;\n    _startPayload(sink);\n  }\n\n  void _startPayload(EventSink sink) {\n    // If there is no actual payload perform perform callbacks without\n    // going through the PAYLOAD state.\n    if (_remainingPayloadBytes == 0) {\n      if (_isControlFrame()) {\n        switch (_opcode) {\n          case _WebSocketOpcode.CLOSE:\n            _state = CLOSED;\n            sink.close();\n            break;\n          case _WebSocketOpcode.PING:\n            // TODO(ajohnsen): Handle ping.\n            break;\n          case _WebSocketOpcode.PONG:\n            // TODO(ajohnsen): Handle pong.\n            break;\n        }\n        _prepareForNextFrame();\n      } else {\n        _messageFrameEnd(sink);\n      }\n    } else {\n      _state = PAYLOAD;\n    }\n  }\n\n  void _messageFrameEnd(EventSink sink) {\n    if (_fin) {\n      switch (_currentMessageType) {\n        case _WebSocketMessageType.TEXT:\n          sink.add(_buffer.toString());\n          break;\n        case _WebSocketMessageType.BINARY:\n          sink.add(_buffer.readBytes());\n          break;\n      }\n      _buffer = null;\n      _currentMessageType = _WebSocketMessageType.NONE;\n    }\n    _prepareForNextFrame();\n  }\n\n  void _controlFrameEnd(EventSink sink) {\n    switch (_opcode) {\n      case _WebSocketOpcode.CLOSE:\n        closeCode = WebSocketStatus.NO_STATUS_RECEIVED;\n        if (_controlPayload.length > 0) {\n          if (_controlPayload.length == 1) {\n            throw new WebSocketException(\"Protocol error\");\n          }\n          closeCode = _controlPayload[0] << 8 | _controlPayload[1];\n          if (closeCode == WebSocketStatus.NO_STATUS_RECEIVED) {\n            throw new WebSocketException(\"Protocol error\");\n          }\n          if (_controlPayload.length > 2) {\n            closeReason = _decodeString(\n                _controlPayload.sublist(2));\n          }\n        }\n        _state = CLOSED;\n        sink.close();\n        break;\n\n      case _WebSocketOpcode.PING:\n        // TODO(ajohnsen): Handle ping.\n        break;\n\n      case _WebSocketOpcode.PONG:\n        // TODO(ajohnsen): Handle pong.\n        break;\n    }\n    _prepareForNextFrame();\n  }\n\n  bool _isControlFrame() {\n    return _opcode == _WebSocketOpcode.CLOSE ||\n           _opcode == _WebSocketOpcode.PING ||\n           _opcode == _WebSocketOpcode.PONG;\n  }\n\n  void _prepareForNextFrame() {\n    if (_state != CLOSED && _state != FAILURE) _state = START;\n    _fin = null;\n    _opcode = null;\n    _len = null;\n    _masked = null;\n    _maskingKey = 0;\n    _remainingLenBytes = null;\n    _remainingMaskingKeyBytes = null;\n    _remainingPayloadBytes = null;\n    _unmaskingIndex = 0;\n    _controlPayload = null;\n  }\n\n  int _state;\n  bool _fin;\n  int _opcode;\n  int _len;\n  bool _masked;\n  int _maskingKey;\n  int _remainingLenBytes;\n  int _remainingMaskingKeyBytes;\n  int _remainingPayloadBytes;\n  int _unmaskingIndex;\n\n  int _currentMessageType;\n  List<int> _controlPayload;\n  var _buffer;  // Either StringBuffer or _BufferList.\n\n  int closeCode = WebSocketStatus.NO_STATUS_RECEIVED;\n  String closeReason = \"\";\n}\n\n\nclass _WebSocketTransformerImpl implements WebSocketTransformer {\n  final StreamController<WebSocket> _controller =\n      new StreamController<WebSocket>();\n\n  Stream<WebSocket> bind(Stream<HttpRequest> stream) {\n    stream.listen((request) {\n        _upgrade(request)\n            .then((WebSocket webSocket) => _controller.add(webSocket))\n            .catchError((error) => _controller.addError(error));\n    });\n\n    return _controller.stream;\n  }\n\n  static Future<WebSocket> _upgrade(HttpRequest request) {\n    var response = request.response;\n    if (!_isUpgradeRequest(request)) {\n      // Send error response and drain the request.\n      request.listen((_) {}, onDone: () {\n        response.statusCode = HttpStatus.BAD_REQUEST;\n        response.contentLength = 0;\n        response.close();\n      });\n      return new Future.error(\n          new WebSocketException(\"Invalid WebSocket upgrade request\"));\n    }\n\n    // Send the upgrade response.\n    response.statusCode = HttpStatus.SWITCHING_PROTOCOLS;\n    response.headers.add(HttpHeaders.CONNECTION, \"Upgrade\");\n    response.headers.add(HttpHeaders.UPGRADE, \"websocket\");\n    String key = request.headers.value(\"Sec-WebSocket-Key\");\n    SHA1 sha1 = new SHA1();\n    sha1.add(\"$key$_webSocketGUID\".codeUnits);\n    String accept = _Base64._encode(sha1.close());\n    response.headers.add(\"Sec-WebSocket-Accept\", accept);\n    response.headers.contentLength = 0;\n    return response.detachSocket()\n        .then((socket) => new _WebSocketImpl._fromSocket(socket, true));\n  }\n\n  static bool _isUpgradeRequest(HttpRequest request) {\n    if (request.method != \"GET\") {\n      return false;\n    }\n    if (request.headers[HttpHeaders.CONNECTION] == null) {\n      return false;\n    }\n    bool isUpgrade = false;\n    request.headers[HttpHeaders.CONNECTION].forEach((String value) {\n      if (value.toLowerCase() == \"upgrade\") isUpgrade = true;\n    });\n    if (!isUpgrade) return false;\n    String upgrade = request.headers.value(HttpHeaders.UPGRADE);\n    if (upgrade == null || upgrade.toLowerCase() != \"websocket\") {\n      return false;\n    }\n    String version = request.headers.value(\"Sec-WebSocket-Version\");\n    if (version == null || version != \"13\") {\n      return false;\n    }\n    String key = request.headers.value(\"Sec-WebSocket-Key\");\n    if (key == null) {\n      return false;\n    }\n    return true;\n  }\n}\n\n\nclass _WebSocketOutgoingTransformer extends StreamEventTransformer {\n  final _WebSocketImpl webSocket;\n\n  _WebSocketOutgoingTransformer(_WebSocketImpl this.webSocket);\n\n  void handleData(message, EventSink<List<int>> sink) {\n    List<int> data;\n    int opcode;\n    if (message != null) {\n      if (message is String) {\n        opcode = _WebSocketOpcode.TEXT;\n        data = _encodeString(message);\n      } else {\n        if (message is !List<int>) {\n          throw new ArgumentError(message);\n        }\n        opcode = _WebSocketOpcode.BINARY;\n        data = message;\n      }\n    } else {\n      opcode = _WebSocketOpcode.TEXT;\n    }\n    addFrame(opcode, data, sink);\n  }\n\n  void handleDone(EventSink<List<int>> sink) {\n    int code = webSocket._outCloseCode;\n    String reason = webSocket._outCloseReason;\n    List<int> data;\n    if (code != null) {\n      data = new List<int>();\n      data.add((code >> 8) & 0xFF);\n      data.add(code & 0xFF);\n      if (reason != null) {\n        data.addAll(_encodeString(reason));\n      }\n    }\n    addFrame(_WebSocketOpcode.CLOSE, data, sink);\n    sink.close();\n  }\n\n  void addFrame(int opcode, List<int> data, EventSink<List<int>> sink) {\n    bool mask = !webSocket._serverSide;  // Masking not implemented for server.\n    int dataLength = data == null ? 0 : data.length;\n    // Determine the header size.\n    int headerSize = (mask) ? 6 : 2;\n    if (dataLength > 65535) {\n      headerSize += 8;\n    } else if (dataLength > 125) {\n      headerSize += 2;\n    }\n    List<int> header = new List<int>(headerSize);\n    int index = 0;\n    // Set FIN and opcode.\n    header[index++] = 0x80 | opcode;\n    // Determine size and position of length field.\n    int lengthBytes = 1;\n    int firstLengthByte = 1;\n    if (dataLength > 65535) {\n      header[index++] = 127;\n      lengthBytes = 8;\n    } else if (dataLength > 125) {\n      header[index++] = 126;\n      lengthBytes = 2;\n    }\n    // Write the length in network byte order into the header.\n    for (int i = 0; i < lengthBytes; i++) {\n      header[index++] = dataLength >> (((lengthBytes - 1) - i) * 8) & 0xFF;\n    }\n    if (mask) {\n      header[1] |= 1 << 7;\n      var maskBytes = _IOCrypto.getRandomBytes(4);\n      header.setRange(index, index + 4, maskBytes);\n      index += 4;\n      if (data != null) {\n        var list = new Uint8List(data.length);\n        for (int i = 0; i < data.length; i++) {\n          list[i] = data[i] ^ maskBytes[i % 4];\n        }\n        data = list;\n      }\n    }\n    assert(index == headerSize);\n    sink.add(header);\n    if (data != null) {\n      sink.add(data);\n    }\n  }\n}\n\n\nclass _WebSocketConsumer implements StreamConsumer {\n  final _WebSocketImpl webSocket;\n  final Socket socket;\n  StreamController _controller;\n  StreamSubscription _subscription;\n  Completer _closeCompleter = new Completer();\n  Completer _completer;\n\n  _WebSocketConsumer(_WebSocketImpl this.webSocket, Socket this.socket);\n\n  void _onListen() {\n    if (_subscription != null) {\n      _subscription.cancel();\n    }\n  }\n\n  _ensureController() {\n    if (_controller != null) return;\n    _controller = new StreamController(onPause: () => _subscription.pause(),\n                                       onResume: () => _subscription.resume(),\n                                       onCancel: _onListen);\n    var stream = _controller.stream.transform(\n        new _WebSocketOutgoingTransformer(webSocket));\n    socket.addStream(stream)\n        .then((_) {\n                _done();\n                _closeCompleter.complete(webSocket);\n              },\n              onError: (error) {\n                if (!_done(error)) {\n                  _closeCompleter.completeError(error);\n                }\n              });\n  }\n\n  bool _done([error]) {\n    if (_completer == null) return false;\n    var tmp = _completer;\n    _completer = null;\n    if (error != null) {\n      tmp.completeError(error);\n    } else {\n      tmp.complete(webSocket);\n    }\n    return true;\n  }\n\n  Future addStream(var stream) {\n    _ensureController();\n    _completer = new Completer();\n    _subscription = stream.listen(\n        (data) {\n          _controller.add(data);\n        },\n        onDone: () {\n          _done();\n        },\n        onError: (error) {\n          _done(error);\n        },\n        cancelOnError: true);\n    return _completer.future;\n  }\n\n  Future close() {\n    Future closeSocket() {\n      return socket.close().then((_) => webSocket);\n    }\n    if (_controller == null) return closeSocket();\n    _controller.close();\n    return _closeCompleter.future.then((_) => closeSocket());\n  }\n}\n\n\nclass _WebSocketImpl extends Stream implements WebSocket {\n  final StreamController _controller = new StreamController();\n  StreamSink _sink;\n\n  final Socket _socket;\n  final bool _serverSide;\n  int _readyState = WebSocket.CONNECTING;\n  bool _writeClosed = false;\n  int _closeCode;\n  String _closeReason;\n\n  int _outCloseCode;\n  String _outCloseReason;\n\n  static final HttpClient _httpClient = new HttpClient();\n\n  static Future<WebSocket> connect(String url, [protocols]) {\n    Uri uri = Uri.parse(url);\n    if (uri.scheme != \"ws\" && uri.scheme != \"wss\") {\n      throw new WebSocketException(\"Unsupported URL scheme '${uri.scheme}'\");\n    }\n    if (uri.userInfo != \"\") {\n      throw new WebSocketException(\"Unsupported user info '${uri.userInfo}'\");\n    }\n\n    Random random = new Random();\n    // Generate 16 random bytes.\n    List<int> nonceData = new List<int>(16);\n    for (int i = 0; i < 16; i++) {\n      nonceData[i] = random.nextInt(256);\n    }\n    String nonce = _Base64._encode(nonceData);\n\n    uri = new Uri.fromComponents(scheme: uri.scheme == \"wss\" ? \"https\" : \"http\",\n                                 userInfo: uri.userInfo,\n                                 domain: uri.domain,\n                                 port: uri.port,\n                                 path: uri.path,\n                                 query: uri.query,\n                                 fragment: uri.fragment);\n    return _httpClient.openUrl(\"GET\", uri)\n      .then((request) {\n        // Setup the initial handshake.\n        request.headers.add(HttpHeaders.CONNECTION, \"upgrade\");\n        request.headers.set(HttpHeaders.UPGRADE, \"websocket\");\n        request.headers.set(\"Sec-WebSocket-Key\", nonce);\n        request.headers.set(\"Sec-WebSocket-Version\", \"13\");\n        return request.close();\n      })\n      .then((response) {\n        void error(String message) {\n          // Flush data.\n          response.detachSocket().then((socket) {\n            socket.destroy();\n          });\n          throw new WebSocketException(message);\n        }\n        if (response.statusCode != HttpStatus.SWITCHING_PROTOCOLS ||\n            response.headers[HttpHeaders.CONNECTION] == null ||\n            !response.headers[HttpHeaders.CONNECTION].any(\n                (value) => value.toLowerCase() == \"upgrade\") ||\n            response.headers.value(HttpHeaders.UPGRADE).toLowerCase() !=\n                \"websocket\") {\n          error(\"Connection to '$uri' was not upgraded to websocket\");\n        }\n        String accept = response.headers.value(\"Sec-WebSocket-Accept\");\n        if (accept == null) {\n          error(\"Response did not contain a 'Sec-WebSocket-Accept' header\");\n        }\n        SHA1 sha1 = new SHA1();\n        sha1.add(\"$nonce$_webSocketGUID\".codeUnits);\n        List<int> expectedAccept = sha1.close();\n        List<int> receivedAccept = _Base64._decode(accept);\n        if (expectedAccept.length != receivedAccept.length) {\n          error(\"Reasponse header 'Sec-WebSocket-Accept' is the wrong length\");\n        }\n        for (int i = 0; i < expectedAccept.length; i++) {\n          if (expectedAccept[i] != receivedAccept[i]) {\n            error(\"Bad response 'Sec-WebSocket-Accept' header\");\n          }\n        }\n        return response.detachSocket()\n            .then((socket) => new _WebSocketImpl._fromSocket(socket));\n      });\n  }\n\n  _WebSocketImpl._fromSocket(Socket this._socket,\n                             [bool this._serverSide = false]) {\n    _sink = new _StreamSinkImpl(new _WebSocketConsumer(this, _socket));\n    _readyState = WebSocket.OPEN;\n\n    var transformer = new _WebSocketProtocolTransformer(_serverSide);\n    _socket.transform(transformer).listen(\n        (data) {\n          _controller.add(data);\n        },\n        onError: (error) {\n          _controller.addError(error);\n          _controller.close();\n        },\n        onDone: () {\n          if (_readyState == WebSocket.OPEN) {\n            _readyState = WebSocket.CLOSING;\n            if (transformer.closeCode != WebSocketStatus.NO_STATUS_RECEIVED) {\n              close(transformer.closeCode);\n            } else {\n              close();\n            }\n            _readyState = WebSocket.CLOSED;\n          }\n          _closeCode = transformer.closeCode;\n          _closeReason = transformer.closeReason;\n          _controller.close();\n        },\n        cancelOnError: true);\n  }\n\n  StreamSubscription listen(void onData(message),\n                            {void onError(error),\n                             void onDone(),\n                             bool cancelOnError}) {\n    return _controller.stream.listen(onData,\n                                     onError: onError,\n                                     onDone: onDone,\n                                     cancelOnError: cancelOnError);\n  }\n\n  int get readyState => _readyState;\n\n  String get extensions => null;\n  String get protocol => null;\n  int get closeCode => _closeCode;\n  String get closeReason => _closeReason;\n\n  void add(data) => _sink.add(data);\n  void addError(error) => _sink.addError(error);\n  Future addStream(Stream stream) => _sink.addStream(stream);\n  Future get done => _sink.done;\n\n  Future close([int code, String reason]) {\n    if (!_writeClosed) {\n      if (code == WebSocketStatus.RESERVED_1004 ||\n          code == WebSocketStatus.NO_STATUS_RECEIVED ||\n          code == WebSocketStatus.RESERVED_1015) {\n        throw new WebSocketException(\"Reserved status code $code\");\n      }\n      _outCloseCode = code;\n      _outCloseReason = reason;\n      _writeClosed = true;\n    }\n    return _sink.close();\n  }\n}\n","sdk/lib/isolate/isolate.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart.isolate;\n\nimport \"dart:async\";\n\npart \"isolate_stream.dart\";\n\nclass IsolateSpawnException implements Exception {\n  const IsolateSpawnException(String this._s);\n  String toString() => \"IsolateSpawnException: '$_s'\";\n  final String _s;\n}\n\n/**\n * The initial [ReceivePort] available by default for this isolate. This\n * [ReceivePort] is created automatically and it is commonly used to establish\n * the first communication between isolates (see [spawnFunction] and\n * [spawnUri]).\n */\nReceivePort get port => _Isolate.port;\n\n/**\n * Creates and spawns an isolate that shares the same code as the current\n * isolate, but that starts from [topLevelFunction]. The [topLevelFunction]\n * argument must be a static top-level function or a static method that takes no\n * arguments. It is illegal to pass a function closure.\n *\n * When any isolate starts (even the main script of the application), a default\n * [ReceivePort] is created for it. This port is available from the top-level\n * getter [port] defined in this library.\n *\n * [spawnFunction] returns a [SendPort] derived from the child isolate's default\n * port.\n *\n * The optional [unhandledExceptionCallback] argument is invoked whenever an\n * exception inside the isolate is unhandled. It can be seen as a big\n * `try/catch` around everything that is executed inside the isolate. The\n * callback should return `true` when it was able to handled the exception.\n */\nSendPort spawnFunction(void topLevelFunction(),\n    [bool unhandledExceptionCallback(IsolateUnhandledException e)])\n    => _Isolate.spawnFunction(topLevelFunction, unhandledExceptionCallback);\n\n/**\n * Creates and spawns an isolate whose code is available at [uri].  Like with\n * [spawnFunction], the child isolate will have a default [ReceivePort], and a\n * this function returns a [SendPort] derived from it.\n */\nSendPort spawnUri(String uri) => _Isolate.spawnUri(uri);\n\n/**\n * [SendPort]s are created from [ReceivePort]s. Any message sent through\n * a [SendPort] is delivered to its respective [ReceivePort]. There might be\n * many [SendPort]s for the same [ReceivePort].\n *\n * [SendPort]s can be transmitted to other isolates.\n */\nabstract class SendPort {\n\n  /**\n   * Sends an asynchronous [message] to this send port. The message is copied to\n   * the receiving isolate. If specified, the [replyTo] port will be provided to\n   * the receiver to facilitate exchanging sequences of messages.\n   *\n   * The content of [message] can be: primitive values (null, num, bool, double,\n   * String), instances of [SendPort], and lists and maps whose elements are any\n   * of these. List and maps are also allowed to be cyclic.\n   *\n   * In the special circumstances when two isolates share the same code and are\n   * running in the same process (e.g. isolates created via [spawnFunction]), it\n   * is also possible to send object instances (which would be copied in the\n   * process). This is currently only supported by the dartvm.  For now, the\n   * dart2js compiler only supports the restricted messages described above.\n   *\n   * Deprecation note: it is no longer valid to transmit a [ReceivePort] in a\n   * message. Previously they were translated to the corresponding send port\n   * before being transmitted.\n   */\n  void send(var message, [SendPort replyTo]);\n\n  /**\n   * Sends a message to this send port and returns a [Future] of the reply.\n   * Basically, this internally creates a new receive port, sends a\n   * message to this send port with replyTo set to such receive port, and, when\n   * a reply is received, it closes the receive port and completes the returned\n   * future.\n   */\n  Future call(var message);\n\n  /**\n   * Tests whether [other] is a [SendPort] pointing to the same\n   * [ReceivePort] as this one.\n   */\n  bool operator==(var other);\n\n  /**\n   * Returns an immutable hash code for this send port that is\n   * consistent with the == operator.\n   */\n  int get hashCode;\n\n}\n\n/**\n * [ReceivePort]s, together with [SendPort]s, are the only means of\n * communication between isolates. [ReceivePort]s have a [:toSendPort:] method\n * which returns a [SendPort]. Any message that is sent through this [SendPort]\n * is delivered to the [ReceivePort] it has been created from. There, they are\n * dispatched to the callback that has been registered on the receive port.\n *\n * A [ReceivePort] may have many [SendPort]s.\n */\nabstract class ReceivePort {\n\n  /**\n   * Opens a long-lived port for receiving messages. The returned port\n   * must be explicitly closed through [ReceivePort.close].\n   */\n  external factory ReceivePort();\n\n  /**\n   * Sets up a callback function for receiving pending or future\n   * messages on this receive port.\n   */\n  void receive(void callback(var message, SendPort replyTo));\n\n  /**\n   * Closes this receive port immediately. Pending messages will not\n   * be processed and it is impossible to re-open the port. Single-shot\n   * reply ports, such as those created through [SendPort.call], are\n   * automatically closed when the reply has been received. Multiple\n   * invocations of [close] are allowed but ignored.\n   */\n  void close();\n\n  /**\n   * Creates a new send port that sends to this receive port. It is legal to\n   * create several [SendPort]s from the same [ReceivePort].\n   */\n  SendPort toSendPort();\n\n}\n\n/**\n * [SendPortSync]s are created from [ReceivePortSync]s. Any message sent through\n * a [SendPortSync] is delivered to its respective [ReceivePortSync]. There\n * might be many [SendPortSync]s for the same [ReceivePortSync].\n *\n * [SendPortSync]s can be transmitted to other isolates.\n */\nabstract class SendPortSync {\n  /**\n   * Sends a synchronous message to this send port and returns the result.\n   */\n  callSync(var message);\n\n  /**\n   * Tests whether [other] is a [SendPortSync] pointing to the same\n   * [ReceivePortSync] as this one.\n   */\n  bool operator==(var other);\n\n  /**\n   * Returns an immutable hash code for this send port that is\n   * consistent with the == operator.\n   */\n  int get hashCode;\n}\n\n// The VM doesn't support accessing external globals in the same library. We\n// therefore create this wrapper class.\n// TODO(6997): Don't go through static class for external variables.\nabstract class _Isolate {\n  external static ReceivePort get port;\n  external static SendPort spawnFunction(void topLevelFunction(),\n    [bool unhandledExceptionCallback(IsolateUnhandledException e)]);\n  external static SendPort spawnUri(String uri);\n}\n\n/**\n * Wraps unhandled exceptions thrown during isolate execution. It is\n * used to show both the error message and the stack trace for unhandled\n * exceptions.\n */\nclass IsolateUnhandledException implements Exception {\n  /** Message being handled when exception occurred. */\n  final message;\n\n  /** Wrapped exception. */\n  final source;\n\n  /** Trace for the wrapped exception. */\n  final Object stackTrace;\n\n  const IsolateUnhandledException(this.message, this.source, this.stackTrace);\n\n  String toString() {\n    return 'IsolateUnhandledException: exception while handling message: '\n        '${message} \\n  '\n        '${source.toString().replaceAll(\"\\n\", \"\\n  \")}\\n'\n        'original stack trace:\\n  '\n        '${stackTrace.toString().replaceAll(\"\\n\",\"\\n  \")}';\n  }\n}\n","sdk/lib/isolate/isolate_stream.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.isolate;\n\n/**\n * The initial [IsolateStream] available by default for this isolate. This\n * [IsolateStream] is created automatically and it is commonly used to establish\n * the first communication between isolates (see [streamSpawnFunction] and\n * [streamSpawnUri]).\n */\nfinal IsolateStream stream = new IsolateStream._fromOriginalReceivePort(port);\n\n/**\n * A [MessageBox] creates an [IsolateStream], [stream], and an [IsolateSink],\n * [sink].\n *\n * Any message that is written into the [sink] (independent of the isolate) is\n * sent to the [stream] where its subscribers can react to the messages.\n */\nclass MessageBox {\n  final IsolateStream stream;\n  final IsolateSink sink;\n\n  external MessageBox.oneShot();\n  external MessageBox();\n}\n\nexternal bool _isCloseToken(var object);\n\n/**\n * [IsolateStream]s, together with [IsolateSink]s, are the only means of\n * communication between isolates. Each IsolateStream has a corresponding\n * [IsolateSink]. Any message written into that sink will be delivered to\n * the stream and then dispatched to the stream's subscribers.\n */\nclass IsolateStream extends Stream<dynamic> {\n  bool _isClosed = false;\n  final ReceivePort _port;\n  StreamController _controller = new StreamController();\n\n  IsolateStream._fromOriginalReceivePort(this._port) {\n    _port.receive((message, replyTo) {\n      assert(replyTo == null);\n      _add(message);\n    });\n  }\n\n  IsolateStream._fromOriginalReceivePortOneShot(this._port) {\n    _port.receive((message, replyTo) {\n      assert(replyTo == null);\n      _add(message);\n      close();\n    });\n  }\n\n  void _add(var message) {\n    if (_isCloseToken(message)) {\n      close();\n    } else {\n      _controller.sink.add(message);\n    }\n  }\n\n  /**\n   * Close the stream from the receiving end.\n   *\n   * Closing an already closed port has no effect.\n   */\n  void close() {\n    if (!_isClosed) {\n      _isClosed = true;\n      _port.close();\n      _controller.close();\n    }\n  }\n\n  StreamSubscription listen(void onData(event),\n                            { void onError(error),\n                              void onDone(),\n                              bool cancelOnError}) {\n      return _controller.stream.listen(onData,\n                                       onError: onError,\n                                       onDone: onDone,\n                                       cancelOnError: cancelOnError);\n  }\n}\n\n/**\n * [IsolateSink]s represent the feed for [IsolateStream]s. Any message written\n * to [this] is delivered to its respective [IsolateStream]. [IsolateSink]s are\n * created by [MessageBox]es.\n *\n * [IsolateSink]s can be transmitted to other isolates.\n */\nabstract class IsolateSink extends EventSink<dynamic> {\n  // TODO(floitsch): Actually it should be a StreamSink (being able to flow-\n  // control).\n\n  /**\n   * Sends an asynchronous [message] to the linked [IsolateStream]. The message\n   * is copied to the receiving isolate.\n   *\n   * The content of [message] can be: primitive values (null, num, bool, double,\n   * String), instances of [IsolateSink]s, and lists and maps whose elements are\n   * any of these. List and maps are also allowed to be cyclic.\n   *\n   * In the special circumstances when two isolates share the same code and are\n   * running in the same process (e.g. isolates created via [spawnFunction]), it\n   * is also possible to send object instances (which would be copied in the\n   * process). This is currently only supported by the dartvm.  For now, the\n   * dart2js compiler only supports the restricted messages described above.\n   */\n  void add(dynamic message);\n\n  void addError(errorEvent);\n\n  /** Closing multiple times is allowed. */\n  void close();\n\n  /**\n   * Tests whether [other] is an [IsolateSink] feeding into the same\n   * [IsolateStream] as this one.\n   */\n  bool operator==(var other);\n}\n\n\n/**\n * Creates and spawns an isolate that shares the same code as the current\n * isolate, but that starts from [topLevelFunction]. The [topLevelFunction]\n * argument must be a static top-level function or a static method that takes no\n * arguments.\n *\n * When any isolate starts (even the main script of the application), a default\n * [IsolateStream] is created for it. This sink is available from the top-level\n * getter [stream] defined in this library.\n *\n * [spawnFunction] returns an [IsolateSink] feeding into the child isolate's\n * default stream.\n *\n * The optional [unhandledExceptionCallback] argument is invoked whenever an\n * exception inside the isolate is unhandled. It can be seen as a big\n * `try/catch` around everything that is executed inside the isolate. The\n * callback should return `true` when it was able to handled the exception.\n */\nexternal IsolateSink streamSpawnFunction(\n    void topLevelFunction(),\n    [bool unhandledExceptionCallback(IsolateUnhandledException e)]);\n","sdk/lib/json/json.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart.json;\n\n// JSON parsing and serialization.\n\n/**\n * Error thrown by JSON serialization if an object cannot be serialized.\n *\n * The [unsupportedObject] field holds that object that failed to be serialized.\n *\n * If an object isn't directly serializable, the serializer calls the 'toJson'\n * method on the object. If that call fails, the error will be stored in the\n * [cause] field. If the call returns an object that isn't directly\n * serializable, the [cause] will be null.\n */\nclass JsonUnsupportedObjectError implements Error {\n  /** The object that could not be serialized. */\n  final unsupportedObject;\n  /** The exception thrown by object's [:toJson:] method, if any. */\n  final cause;\n\n  JsonUnsupportedObjectError(this.unsupportedObject, { this.cause });\n\n  String toString() {\n    if (cause != null) {\n      return \"Calling toJson method on object failed.\";\n    } else {\n      return \"Object toJson method returns non-serializable value.\";\n    }\n  }\n}\n\n\n/**\n * Reports that an object could not be stringified due to cyclic references.\n *\n * An object that references itself cannot be serialized by [stringify].\n * When the cycle is detected, a [JsonCyclicError] is thrown.\n */\nclass JsonCyclicError extends JsonUnsupportedObjectError {\n  /** The first object that was detected as part of a cycle. */\n  JsonCyclicError(Object object): super(object);\n  String toString() => \"Cyclic error in JSON stringify\";\n}\n\n\n/**\n * Parses [json] and build the corresponding parsed JSON value.\n *\n * Parsed JSON values are of the types [num], [String], [bool], [Null],\n * [List]s of parsed JSON values or [Map]s from [String] to parsed\n * JSON values.\n *\n * The optional [revivier] function, if provided, is called once for each\n * object or list property parsed. The arguments are the property name\n * ([String]) or list index ([int]), and the value is the parsed value.\n * The return value of the revivier will be used as the value of that property\n * instead the parsed value.\n *\n * Throws [FormatException] if the input is not valid JSON text.\n */\nexternal parse(String json, [reviver(var key, var value)]);\n\n_parse(String json, reviver(var key, var value)) {\n  BuildJsonListener listener;\n  if (reviver == null) {\n    listener = new BuildJsonListener();\n  } else {\n    listener = new ReviverJsonListener(reviver);\n  }\n  new JsonParser(json, listener).parse();\n  return listener.result;\n}\n\n/**\n * Serializes [object] into a JSON string.\n *\n * Directly serializable values are [num], [String], [bool], and [Null], as well\n * as some [List] and [Map] values.\n * For [List], the elements must all be serializable.\n * For [Map], the keys must be [String] and the values must be serializable.\n *\n * If a value is any other type is attempted serialized, a \"toJson()\" method\n * is invoked on the object and the result, which must be a directly\n * serializable value, is serialized instead of the original value.\n *\n * If the object does not support this method, throws, or returns a\n * value that is not directly serializable, a [JsonUnsupportedObjectError]\n * exception is thrown. If the call throws (including the case where there\n * is no nullary \"toJson\" method, the error is caught and stored in the\n * [JsonUnsupportedObjectError]'s [:cause:] field.\n *\n * If a [List] or [Map] contains a reference to itself, directly or through\n * other lists or maps, it cannot be serialized and a [JsonCyclicError] is\n * thrown.\n *\n * Json Objects should not change during serialization.\n * If an object is serialized more than once, [stringify] is allowed to cache\n * the JSON text for it. I.e., if an object changes after it is first\n * serialized, the new values may or may not be reflected in the result.\n */\nString stringify(Object object) {\n  return _JsonStringifier.stringify(object);\n}\n\n/**\n * Serializes [object] into [output] stream.\n *\n * Performs the same operations as [stringify] but outputs the resulting\n * string to an existing [StringBuffer] instead of creating a new [String].\n *\n * If serialization fails by throwing, some data might have been added to\n * [output], but it won't contain valid JSON text.\n */\nvoid printOn(Object object, StringBuffer output) {\n  return _JsonStringifier.printOn(object, output);\n}\n\n//// Implementation ///////////////////////////////////////////////////////////\n\n// Simple API for JSON parsing.\n\nabstract class JsonListener {\n  void handleString(String value) {}\n  void handleNumber(num value) {}\n  void handleBool(bool value) {}\n  void handleNull() {}\n  void beginObject() {}\n  void propertyName() {}\n  void propertyValue() {}\n  void endObject() {}\n  void beginArray() {}\n  void arrayElement() {}\n  void endArray() {}\n  /** Called on failure to parse [source]. */\n  void fail(String source, int position, String message) {}\n}\n\n/**\n * A [JsonListener] that builds data objects from the parser events.\n *\n * This is a simple stack-based object builder. It keeps the most recently\n * seen value in a variable, and uses it depending on the following event.\n */\nclass BuildJsonListener extends JsonListener {\n  /**\n   * Stack used to handle nested containers.\n   *\n   * The current container is pushed on the stack when a new one is\n   * started. If the container is a [Map], there is also a current [key]\n   * which is also stored on the stack.\n   */\n  List stack = [];\n  /** The current [Map] or [List] being built. */\n  var currentContainer;\n  /** The most recently read property key. */\n  String key;\n  /** The most recently read value. */\n  var value;\n\n  /** Pushes the currently active container (and key, if a [Map]). */\n  void pushContainer() {\n    if (currentContainer is Map) stack.add(key);\n    stack.add(currentContainer);\n  }\n\n  /** Pops the top container from the [stack], including a key if applicable. */\n  void popContainer() {\n    value = currentContainer;\n    currentContainer = stack.removeLast();\n    if (currentContainer is Map) key = stack.removeLast();\n  }\n\n  void handleString(String value) { this.value = value; }\n  void handleNumber(num value) { this.value = value; }\n  void handleBool(bool value) { this.value = value; }\n  void handleNull() { this.value = value; }\n\n  void beginObject() {\n    pushContainer();\n    currentContainer = {};\n  }\n\n  void propertyName() {\n    key = value;\n    value = null;\n  }\n\n  void propertyValue() {\n    Map map = currentContainer;\n    map[key] = value;\n    key = value = null;\n  }\n\n  void endObject() {\n    popContainer();\n  }\n\n  void beginArray() {\n    pushContainer();\n    currentContainer = [];\n  }\n\n  void arrayElement() {\n    List list = currentContainer;\n    currentContainer.add(value);\n    value = null;\n  }\n\n  void endArray() {\n    popContainer();\n  }\n\n  /** Read out the final result of parsing a JSON string. */\n  get result {\n    assert(currentContainer == null);\n    return value;\n  }\n}\n\ntypedef _Reviver(var key, var value);\n\nclass ReviverJsonListener extends BuildJsonListener {\n  final _Reviver reviver;\n  ReviverJsonListener(reviver(key, value)) : this.reviver = reviver;\n\n  void arrayElement() {\n    List list = currentContainer;\n    value = reviver(list.length, value);\n    super.arrayElement();\n  }\n\n  void propertyValue() {\n    value = reviver(key, value);\n    super.propertyValue();\n  }\n\n  get result {\n    return reviver(\"\", value);\n  }\n}\n\nclass JsonParser {\n  // A simple non-recursive state-based parser for JSON.\n  //\n  // Literal values accepted in states ARRAY_EMPTY, ARRAY_COMMA, OBJECT_COLON\n  // and strings also in OBJECT_EMPTY, OBJECT_COMMA.\n  //               VALUE  STRING  :  ,  }  ]        Transitions to\n  // EMPTY            X      X                   -> END\n  // ARRAY_EMPTY      X      X             @     -> ARRAY_VALUE / pop\n  // ARRAY_VALUE                     @     @     -> ARRAY_COMMA / pop\n  // ARRAY_COMMA      X      X                   -> ARRAY_VALUE\n  // OBJECT_EMPTY            X          @        -> OBJECT_KEY / pop\n  // OBJECT_KEY                   @              -> OBJECT_COLON\n  // OBJECT_COLON     X      X                   -> OBJECT_VALUE\n  // OBJECT_VALUE                    @  @        -> OBJECT_COMMA / pop\n  // OBJECT_COMMA            X                   -> OBJECT_KEY\n  // END\n  // Starting a new array or object will push the current state. The \"pop\"\n  // above means restoring this state and then marking it as an ended value.\n  // X means generic handling, @ means special handling for just that\n  // state - that is, values are handled generically, only punctuation\n  // cares about the current state.\n  // Values for states are chosen so bits 0 and 1 tell whether\n  // a string/value is allowed, and setting bits 0 through 2 after a value\n  // gets to the next state (not empty, doesn't allow a value).\n\n  // State building-block constants.\n  static const int INSIDE_ARRAY = 1;\n  static const int INSIDE_OBJECT = 2;\n  static const int AFTER_COLON = 3;  // Always inside object.\n\n  static const int ALLOW_STRING_MASK = 8;  // Allowed if zero.\n  static const int ALLOW_VALUE_MASK = 4;  // Allowed if zero.\n  static const int ALLOW_VALUE = 0;\n  static const int STRING_ONLY = 4;\n  static const int NO_VALUES = 12;\n\n  // Objects and arrays are \"empty\" until their first property/element.\n  static const int EMPTY = 0;\n  static const int NON_EMPTY = 16;\n  static const int EMPTY_MASK = 16;  // Empty if zero.\n\n\n  static const int VALUE_READ_BITS = NO_VALUES | NON_EMPTY;\n\n  // Actual states.\n  static const int STATE_INITIAL      = EMPTY | ALLOW_VALUE;\n  static const int STATE_END          = NON_EMPTY | NO_VALUES;\n\n  static const int STATE_ARRAY_EMPTY  = INSIDE_ARRAY | EMPTY | ALLOW_VALUE;\n  static const int STATE_ARRAY_VALUE  = INSIDE_ARRAY | NON_EMPTY | NO_VALUES;\n  static const int STATE_ARRAY_COMMA  = INSIDE_ARRAY | NON_EMPTY | ALLOW_VALUE;\n\n  static const int STATE_OBJECT_EMPTY = INSIDE_OBJECT | EMPTY | STRING_ONLY;\n  static const int STATE_OBJECT_KEY   = INSIDE_OBJECT | NON_EMPTY | NO_VALUES;\n  static const int STATE_OBJECT_COLON = AFTER_COLON | NON_EMPTY | ALLOW_VALUE;\n  static const int STATE_OBJECT_VALUE = AFTER_COLON | NON_EMPTY | NO_VALUES;\n  static const int STATE_OBJECT_COMMA = INSIDE_OBJECT | NON_EMPTY | STRING_ONLY;\n\n  // Character code constants.\n  static const int BACKSPACE       = 0x08;\n  static const int TAB             = 0x09;\n  static const int NEWLINE         = 0x0a;\n  static const int CARRIAGE_RETURN = 0x0d;\n  static const int FORM_FEED       = 0x0c;\n  static const int SPACE           = 0x20;\n  static const int QUOTE           = 0x22;\n  static const int PLUS            = 0x2b;\n  static const int COMMA           = 0x2c;\n  static const int MINUS           = 0x2d;\n  static const int DECIMALPOINT    = 0x2e;\n  static const int SLASH           = 0x2f;\n  static const int CHAR_0          = 0x30;\n  static const int CHAR_9          = 0x39;\n  static const int COLON           = 0x3a;\n  static const int CHAR_E          = 0x45;\n  static const int LBRACKET        = 0x5b;\n  static const int BACKSLASH       = 0x5c;\n  static const int RBRACKET        = 0x5d;\n  static const int CHAR_a          = 0x61;\n  static const int CHAR_b          = 0x62;\n  static const int CHAR_e          = 0x65;\n  static const int CHAR_f          = 0x66;\n  static const int CHAR_l          = 0x6c;\n  static const int CHAR_n          = 0x6e;\n  static const int CHAR_r          = 0x72;\n  static const int CHAR_s          = 0x73;\n  static const int CHAR_t          = 0x74;\n  static const int CHAR_u          = 0x75;\n  static const int LBRACE          = 0x7b;\n  static const int RBRACE          = 0x7d;\n\n  final String source;\n  final JsonListener listener;\n  JsonParser(this.source, this.listener);\n\n  /** Parses [source], or throws if it fails. */\n  void parse() {\n    final List<int> states = <int>[];\n    int state = STATE_INITIAL;\n    int position = 0;\n    int length = source.length;\n    while (position < length) {\n      int char = source.codeUnitAt(position);\n      switch (char) {\n        case SPACE:\n        case CARRIAGE_RETURN:\n        case NEWLINE:\n        case TAB:\n          position++;\n          break;\n        case QUOTE:\n          if ((state & ALLOW_STRING_MASK) != 0) fail(position);\n          position = parseString(position + 1);\n          state |= VALUE_READ_BITS;\n          break;\n        case LBRACKET:\n          if ((state & ALLOW_VALUE_MASK) != 0) fail(position);\n          listener.beginArray();\n          states.add(state);\n          state = STATE_ARRAY_EMPTY;\n          position++;\n          break;\n        case LBRACE:\n          if ((state & ALLOW_VALUE_MASK) != 0) fail(position);\n          listener.beginObject();\n          states.add(state);\n          state = STATE_OBJECT_EMPTY;\n          position++;\n          break;\n        case CHAR_n:\n          if ((state & ALLOW_VALUE_MASK) != 0) fail(position);\n          position = parseNull(position);\n          state |= VALUE_READ_BITS;\n          break;\n        case CHAR_f:\n          if ((state & ALLOW_VALUE_MASK) != 0) fail(position);\n          position = parseFalse(position);\n          state |= VALUE_READ_BITS;\n          break;\n        case CHAR_t:\n          if ((state & ALLOW_VALUE_MASK) != 0) fail(position);\n          position = parseTrue(position);\n          state |= VALUE_READ_BITS;\n          break;\n        case COLON:\n          if (state != STATE_OBJECT_KEY) fail(position);\n          listener.propertyName();\n          state = STATE_OBJECT_COLON;\n          position++;\n          break;\n        case COMMA:\n          if (state == STATE_OBJECT_VALUE) {\n            listener.propertyValue();\n            state = STATE_OBJECT_COMMA;\n            position++;\n          } else if (state == STATE_ARRAY_VALUE) {\n            listener.arrayElement();\n            state = STATE_ARRAY_COMMA;\n            position++;\n          } else {\n            fail(position);\n          }\n          break;\n        case RBRACKET:\n          if (state == STATE_ARRAY_EMPTY) {\n            listener.endArray();\n          } else if (state == STATE_ARRAY_VALUE) {\n            listener.arrayElement();\n            listener.endArray();\n          } else {\n            fail(position);\n          }\n          state = states.removeLast() | VALUE_READ_BITS;\n          position++;\n          break;\n        case RBRACE:\n          if (state == STATE_OBJECT_EMPTY) {\n            listener.endObject();\n          } else if (state == STATE_OBJECT_VALUE) {\n            listener.propertyValue();\n            listener.endObject();\n          } else {\n            fail(position);\n          }\n          state = states.removeLast() | VALUE_READ_BITS;\n          position++;\n          break;\n        default:\n          if ((state & ALLOW_VALUE_MASK) != 0) fail(position);\n          position = parseNumber(char, position);\n          state |= VALUE_READ_BITS;\n          break;\n      }\n    }\n    if (state != STATE_END) fail(position);\n  }\n\n  /**\n   * Parses a \"true\" literal starting at [position].\n   *\n   * [:source[position]:] must be \"t\".\n   */\n  int parseTrue(int position) {\n    assert(source.codeUnitAt(position) == CHAR_t);\n    if (source.length < position + 4) fail(position, \"Unexpected identifier\");\n    if (source.codeUnitAt(position + 1) != CHAR_r ||\n        source.codeUnitAt(position + 2) != CHAR_u ||\n        source.codeUnitAt(position + 3) != CHAR_e) {\n      fail(position);\n    }\n    listener.handleBool(true);\n    return position + 4;\n  }\n\n  /**\n   * Parses a \"false\" literal starting at [position].\n   *\n   * [:source[position]:] must be \"f\".\n   */\n  int parseFalse(int position) {\n    assert(source.codeUnitAt(position) == CHAR_f);\n    if (source.length < position + 5) fail(position, \"Unexpected identifier\");\n    if (source.codeUnitAt(position + 1) != CHAR_a ||\n        source.codeUnitAt(position + 2) != CHAR_l ||\n        source.codeUnitAt(position + 3) != CHAR_s ||\n        source.codeUnitAt(position + 4) != CHAR_e) {\n      fail(position);\n    }\n    listener.handleBool(false);\n    return position + 5;\n  }\n\n  /** Parses a \"null\" literal starting at [position].\n   *\n   * [:source[position]:] must be \"n\".\n   */\n  int parseNull(int position) {\n    assert(source.codeUnitAt(position) == CHAR_n);\n    if (source.length < position + 4) fail(position, \"Unexpected identifier\");\n    if (source.codeUnitAt(position + 1) != CHAR_u ||\n        source.codeUnitAt(position + 2) != CHAR_l ||\n        source.codeUnitAt(position + 3) != CHAR_l) {\n      fail(position);\n    }\n    listener.handleNull();\n    return position + 4;\n  }\n\n  int parseString(int position) {\n    // Format: '\"'([^\\x00-\\x1f\\\\\\\"]|'\\\\'[bfnrt/\\\\\"])*'\"'\n    // Initial position is right after first '\"'.\n    int start = position;\n    int char;\n    do {\n      if (position == source.length) {\n        fail(start - 1, \"Unterminated string\");\n      }\n      char = source.codeUnitAt(position);\n      if (char == QUOTE) {\n        listener.handleString(source.substring(start, position));\n        return position + 1;\n      }\n      if (char < SPACE) {\n        fail(position, \"Control character in string\");\n      }\n      position++;\n    } while (char != BACKSLASH);\n    // Backslash escape detected. Collect character codes for rest of string.\n    int firstEscape = position - 1;\n    List<int> chars = <int>[];\n    while (true) {\n      if (position == source.length) {\n        fail(start - 1, \"Unterminated string\");\n      }\n      char = source.codeUnitAt(position);\n      switch (char) {\n        case CHAR_b: char = BACKSPACE; break;\n        case CHAR_f: char = FORM_FEED; break;\n        case CHAR_n: char = NEWLINE; break;\n        case CHAR_r: char = CARRIAGE_RETURN; break;\n        case CHAR_t: char = TAB; break;\n        case SLASH:\n        case BACKSLASH:\n        case QUOTE:\n          break;\n        case CHAR_u:\n          int hexStart = position - 1;\n          int value = 0;\n          for (int i = 0; i < 4; i++) {\n            position++;\n            if (position == source.length) {\n              fail(start - 1, \"Unterminated string\");\n            }\n            char = source.codeUnitAt(position);\n            char -= 0x30;\n            if (char < 0) fail(hexStart, \"Invalid unicode escape\");\n            if (char < 10) {\n              value = value * 16 + char;\n            } else {\n              char = (char | 0x20) - 0x31;\n              if (char < 0 || char > 5) {\n                fail(hexStart, \"Invalid unicode escape\");\n              }\n              value = value * 16 + char + 10;\n            }\n          }\n          char = value;\n          break;\n        default:\n          if (char < SPACE) fail(position, \"Control character in string\");\n          fail(position, \"Unrecognized string escape\");\n      }\n      do {\n        chars.add(char);\n        position++;\n        if (position == source.length) fail(start - 1, \"Unterminated string\");\n        char = source.codeUnitAt(position);\n        if (char == QUOTE) {\n          String result = new String.fromCharCodes(chars);\n          if (start < firstEscape) {\n            result = \"${source.substring(start, firstEscape)}$result\";\n          }\n          listener.handleString(result);\n          return position + 1;\n        }\n        if (char < SPACE) {\n          fail(position, \"Control character in string\");\n        }\n      } while (char != BACKSLASH);\n      position++;\n    }\n  }\n\n  int _handleLiteral(start, position, isDouble) {\n    String literal = source.substring(start, position);\n    // This correctly creates -0 for doubles.\n    num value = (isDouble ? double.parse(literal) : int.parse(literal));\n    listener.handleNumber(value);\n    return position;\n  }\n\n  int parseNumber(int char, int position) {\n    // Format:\n    //  '-'?('0'|[1-9][0-9]*)('.'[0-9]+)?([eE][+-]?[0-9]+)?\n    int start = position;\n    int length = source.length;\n    bool isDouble = false;\n    if (char == MINUS) {\n      position++;\n      if (position == length) fail(position, \"Missing expected digit\");\n      char = source.codeUnitAt(position);\n    }\n    if (char < CHAR_0 || char > CHAR_9) {\n      fail(position, \"Missing expected digit\");\n    }\n    if (char == CHAR_0) {\n      position++;\n      if (position == length) return _handleLiteral(start, position, false);\n      char = source.codeUnitAt(position);\n      if (CHAR_0 <= char && char <= CHAR_9) {\n        fail(position);\n      }\n    } else {\n      do {\n        position++;\n        if (position == length) return _handleLiteral(start, position, false);\n        char = source.codeUnitAt(position);\n      } while (CHAR_0 <= char && char <= CHAR_9);\n    }\n    if (char == DECIMALPOINT) {\n      isDouble = true;\n      position++;\n      if (position == length) fail(position, \"Missing expected digit\");\n      char = source.codeUnitAt(position);\n      if (char < CHAR_0 || char > CHAR_9) fail(position);\n      do {\n        position++;\n        if (position == length) return _handleLiteral(start, position, true);\n        char = source.codeUnitAt(position);\n      } while (CHAR_0 <= char && char <= CHAR_9);\n    }\n    if (char == CHAR_e || char == CHAR_E) {\n      isDouble = true;\n      position++;\n      if (position == length) fail(position, \"Missing expected digit\");\n      char = source.codeUnitAt(position);\n      if (char == PLUS || char == MINUS) {\n        position++;\n        if (position == length) fail(position, \"Missing expected digit\");\n        char = source.codeUnitAt(position);\n      }\n      if (char < CHAR_0 || char > CHAR_9) {\n        fail(position, \"Missing expected digit\");\n      }\n      do {\n        position++;\n        if (position == length) return _handleLiteral(start, position, true);\n        char = source.codeUnitAt(position);\n      } while (CHAR_0 <= char && char <= CHAR_9);\n    }\n    return _handleLiteral(start, position, isDouble);\n  }\n\n  void fail(int position, [String message]) {\n    if (message == null) message = \"Unexpected character\";\n    listener.fail(source, position, message);\n    // If the listener didn't throw, do it here.\n    String slice;\n    int sliceEnd = position + 20;\n    if (sliceEnd > source.length) {\n      slice = \"'${source.substring(position)}'\";\n    } else {\n      slice = \"'${source.substring(position, sliceEnd)}...'\";\n    }\n    throw new FormatException(\"Unexpected character at $position: $slice\");\n  }\n}\n\n\nclass _JsonStringifier {\n  StringBuffer sb;\n  List<Object> seen;  // TODO: that should be identity set.\n\n  _JsonStringifier(this.sb) : seen = [];\n\n  static String stringify(final object) {\n    StringBuffer output = new StringBuffer();\n    _JsonStringifier stringifier = new _JsonStringifier(output);\n    stringifier.stringifyValue(object);\n    return output.toString();\n  }\n\n  static void printOn(final object, StringBuffer output) {\n    _JsonStringifier stringifier = new _JsonStringifier(output);\n    stringifier.stringifyValue(object);\n  }\n\n  static String numberToString(num x) {\n    return x.toString();\n  }\n\n  // ('0' + x) or ('a' + x - 10)\n  static int hexDigit(int x) => x < 10 ? 48 + x : 87 + x;\n\n  static void escape(StringBuffer sb, String s) {\n    final int length = s.length;\n    bool needsEscape = false;\n    final charCodes = new List<int>();\n    for (int i = 0; i < length; i++) {\n      int charCode = s.codeUnitAt(i);\n      if (charCode < 32) {\n        needsEscape = true;\n        charCodes.add(JsonParser.BACKSLASH);\n        switch (charCode) {\n        case JsonParser.BACKSPACE:\n          charCodes.add(JsonParser.CHAR_b);\n          break;\n        case JsonParser.TAB:\n          charCodes.add(JsonParser.CHAR_t);\n          break;\n        case JsonParser.NEWLINE:\n          charCodes.add(JsonParser.CHAR_n);\n          break;\n        case JsonParser.FORM_FEED:\n          charCodes.add(JsonParser.CHAR_f);\n          break;\n        case JsonParser.CARRIAGE_RETURN:\n          charCodes.add(JsonParser.CHAR_r);\n          break;\n        default:\n          charCodes.add(JsonParser.CHAR_u);\n          charCodes.add(hexDigit((charCode >> 12) & 0xf));\n          charCodes.add(hexDigit((charCode >> 8) & 0xf));\n          charCodes.add(hexDigit((charCode >> 4) & 0xf));\n          charCodes.add(hexDigit(charCode & 0xf));\n          break;\n        }\n      } else if (charCode == JsonParser.QUOTE ||\n          charCode == JsonParser.BACKSLASH) {\n        needsEscape = true;\n        charCodes.add(JsonParser.BACKSLASH);\n        charCodes.add(charCode);\n      } else {\n        charCodes.add(charCode);\n      }\n    }\n    sb.write(needsEscape ? new String.fromCharCodes(charCodes) : s);\n  }\n\n  void checkCycle(final object) {\n    // TODO: use Iterables.\n    for (int i = 0; i < seen.length; i++) {\n      if (identical(seen[i], object)) {\n        throw new JsonCyclicError(object);\n      }\n    }\n    seen.add(object);\n  }\n\n  void stringifyValue(final object) {\n    // Tries stringifying object directly. If it's not a simple value, List or\n    // Map, call toJson() to get a custom representation and try serializing\n    // that.\n    if (!stringifyJsonValue(object)) {\n      checkCycle(object);\n      try {\n        var customJson = object.toJson();\n        if (!stringifyJsonValue(customJson)) {\n          throw new JsonUnsupportedObjectError(object);\n        }\n        seen.removeLast();\n      } catch (e) {\n        throw new JsonUnsupportedObjectError(object, cause: e);\n      }\n    }\n  }\n\n  /**\n   * Serializes a [num], [String], [bool], [Null], [List] or [Map] value.\n   *\n   * Returns true if the value is one of these types, and false if not.\n   * If a value is both a [List] and a [Map], it's serialized as a [List].\n   */\n  bool stringifyJsonValue(final object) {\n    if (object is num) {\n      // TODO: use writeOn.\n      sb.write(numberToString(object));\n      return true;\n    } else if (identical(object, true)) {\n      sb.write('true');\n      return true;\n    } else if (identical(object, false)) {\n      sb.write('false');\n       return true;\n    } else if (object == null) {\n      sb.write('null');\n      return true;\n    } else if (object is String) {\n      sb.write('\"');\n      escape(sb, object);\n      sb.write('\"');\n      return true;\n    } else if (object is List) {\n      checkCycle(object);\n      List a = object;\n      sb.write('[');\n      if (a.length > 0) {\n        stringifyValue(a[0]);\n        // TODO: switch to Iterables.\n        for (int i = 1; i < a.length; i++) {\n          sb.write(',');\n          stringifyValue(a[i]);\n        }\n      }\n      sb.write(']');\n      seen.removeLast();\n      return true;\n    } else if (object is Map) {\n      checkCycle(object);\n      Map<String, Object> m = object;\n      sb.write('{');\n      bool first = true;\n      m.forEach((String key, Object value) {\n        if (!first) {\n          sb.write(',\"');\n        } else {\n          sb.write('\"');\n        }\n        escape(sb, key);\n        sb.write('\":');\n        stringifyValue(value);\n        first = false;\n      });\n      sb.write('}');\n      seen.removeLast();\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n","sdk/lib/math/math.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart.math;\n\npart \"random.dart\";\n\n/**\n * Base of the natural logarithms.\n *\n * Typically written as \"e\".\n */\nconst double E = 2.718281828459045;\n\n/**\n * Natural logarithm of 10.\n */\nconst double LN10 =  2.302585092994046;\n\n/**\n * Natural logarithm of 2.\n */\nconst double LN2 =  0.6931471805599453;\n\n/**\n * Base-2 logarithm of [E].\n */\nconst double LOG2E = 1.4426950408889634;\n\n/**\n * Base-10 logarithm of [E].\n */\nconst double LOG10E = 0.4342944819032518;\n\n/**\n * The PI constant.\n */\nconst double PI = 3.1415926535897932;\n\n/**\n * Square root of 1/2.\n */\nconst double SQRT1_2 = 0.7071067811865476;\n\n/**\n * Square root of 2.\n */\nconst double SQRT2 = 1.4142135623730951;\n\n/**\n  * Returns the lesser of two numbers.\n  *\n  * Returns NaN if either argument is NaN.\n  * The lesser of [:-0.0:] and [:0.0:] is [:-0.0:].\n  * If the arguments are otherwise equal (including int and doubles with the\n  * same mathematical value) then it is unspecified which of the two arguments\n  * is returned.\n  */\nnum min(num a, num b) {\n  if (a is num) {\n    // TODO(floitsch): merge this if into the previous one, once dart2js\n    // correctly propagates types for logical ands.\n    if (b is num) {\n      if (a > b) return b;\n      if (a < b) return a;\n      if (b is double) {\n        // Special case for NaN and -0.0. If one argument is NaN return NaN.\n        // [min] must also distinguish between -0.0 and 0.0.\n        if (a is double) {\n          if (a == 0.0) {\n            // a is either 0.0 or -0.0. b is either 0.0, -0.0 or NaN.\n            // The following returns -0.0 if either a or b is -0.0, and it\n            // returns NaN if b is NaN.\n            return (a + b) * a * b;\n          }\n        }\n        // Check for NaN and b == -0.0.\n        if (a == 0 && b.isNegative || b.isNaN) return b;\n        return a;\n      }\n      return a;\n    }\n    throw new ArgumentError(b);\n  }\n  throw new ArgumentError(a);\n}\n\n/**\n  * Returns the larger of two numbers.\n  *\n  * Returns NaN if either argument is NaN.\n  * The larger of [:-0.0:] and [:0.0:] is [:0.0:]. If the arguments are\n  * otherwise equal (including int and doubles with the same mathematical value)\n  * then it is unspecified which of the two arguments is returned.\n  */\nnum max(num a, num b) {\n  if (a is num) {\n    // TODO(floitsch): merge this if into the previous one, once dart2js\n    // correctly propagates types for logical ands.\n    if (b is num) {\n      if (a > b) return a;\n      if (a < b) return b;\n      if (b is double) {\n        // Special case for NaN and -0.0. If one argument is NaN return NaN.\n        // [max] must also distinguish between -0.0 and 0.0.\n        if (a is double) {\n          if (a == 0.0) {\n            // a is either 0.0 or -0.0. b is either 0.0, -0.0, or NaN.\n            // The following returns 0.0 if either a or b is 0.0, and it\n            // returns NaN if b is NaN.\n            return a + b;\n          }\n        }\n        // Check for NaN.\n        if (b.isNaN) return b;\n        return a;\n      }\n      // max(-0.0, 0) must return 0.\n      if (b == 0 && a.isNegative) return b;\n      return a;\n    }\n    throw new ArgumentError(b);\n  }\n  throw new ArgumentError(a);\n}\n\n/**\n * A variant of [atan].\n *\n * Converts both arguments to doubles.\n *\n * Returns the angle between the positive x-axis and the vector ([b],[a]).\n * The result, in radians, is in the range -PI..PI.\n *\n * If [b] is positive, this is the same as [:atan(b/a):].\n *\n * The result is negative when [a] is negative (including when [a] is the\n * double -0.0).\n *\n * If [a] is equal to zero, the vector ([b],[a]) is considered parallel to\n * the x-axis, even if [b] is also equal to zero. The sign of [b] determines\n * the direction of the vector along the x-axis.\n *\n * Returns NaN if either argument is NaN.\n */\nexternal double atan2(num a, num b);\n\n/**\n * Returns [x] to the power of [exponent].\n *\n * If [x] is an [int] and [exponent] is a non-negative [int], the result is\n * an [int], otherwise the result it is a [double].\n *\n * Notice that an [int] result cannot overflow, but a [double] result might\n * be [double.INFINITY].\n */\nexternal num pow(num x, num exponent);\n\n/**\n * Converts [x] to a double and returns the sine of the value.\n *\n * If [x] is not a finite number, the result is NaN.\n */\nexternal double sin(num x);\n\n/**\n * Converts [x] to a double and returns the cosine of the value.\n *\n * If [x] is not a finite number, the result is NaN.\n */\nexternal double cos(num x);\n\n/**\n * Converts [x] to a double and returns the tangent of the value.\n *\n * The tangent function is equivalent to [:sin(x)/cos(x):] and may be\n * infinite (positive or negative) when [:cos(x):] is equal to zero.\n * If [x] is not a finite number, the result is NaN.\n */\nexternal double tan(num x);\n\n/**\n * Converts [x] to a double and returns the arc cosine of the value.\n *\n * Returns a value in the range -PI..PI, or NaN if [x] is outside\n * the range -1..1.\n */\nexternal double acos(num x);\n\n/**\n * Converts [x] to a double and returns the arc sine of the value.\n * Returns a value in the range -PI..PI, or  NaN if [x] is outside\n * the range -1..1.\n */\nexternal double asin(num x);\n\n/**\n * Converts [x] to a dobule and returns the arc tangent of the vlaue.\n * Returns a value in the range -PI/2..PI/2, or NaN if [x] is NaN.\n */\nexternal double atan(num x);\n\n/**\n * Converts [x] to a double and returns the positive square root of the value.\n *\n * Returns -0.0 if [x] is -0.0, and NaN if [x] is otherwise negative or NaN.\n */\nexternal double sqrt(num x);\n\n/**\n * Converts [x] to a double and returns the natural exponent, [E],\n * to the power [x].\n * Returns NaN if [x] is NaN.\n */\nexternal double exp(num x);\n\n/**\n * Converts [x] to a double and returns the natural logarithm of the value.\n * Returns negative infinity if [x] is equal to zero.\n * Returns NaN if [x] is NaN or less than zero.\n */\nexternal double log(num x);\n","sdk/lib/math/random.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.math;\n\n/**\n * A random number generator. The default implementation supplies a stream of\n * pseudo-random bits which is not suitable for cryptographic purposes.\n */\nabstract class Random {\n  /**\n   * Creates a random-number generator. The optional parameter [seed] is used\n   * to initialize the internal state of the generator. The implementation of\n   * the random stream can change between releases of the library.\n   *\n   * Implementation note: The default implementation uses up to 64-bits of seed.\n   */\n  external factory Random([int seed]);\n\n  /**\n   * Generates a positive random integer uniformly distributed on the range\n   * from 0, inclusive, to [max], exclusive.\n   *\n   * Implementation note: The default implementation supports [max] values\n   * between 1 and ((1<<32) - 1) inclusive.\n   */\n  int nextInt(int max);\n\n  /**\n   * Generates a positive random floating point value uniformly distributed on\n   * the range from 0.0, inclusive, to 1.0, exclusive.\n   */\n  double nextDouble();\n\n  /**\n   * Generates a random boolean value.\n   */\n  bool nextBool();\n}\n","sdk/lib/mirrors/mirrors.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// For the purposes of the mirrors library, we adopt a naming\n// convention with respect to getters and setters.  Specifically, for\n// some variable or field...\n//\n//   var myField;\n//\n// ...the getter is named 'myField' and the setter is named\n// 'myField='.  This allows us to assign unique names to getters and\n// setters for the purposes of member lookup.\n\nlibrary dart.mirrors;\n\nimport 'dart:async';\nimport 'dart:isolate';\nimport 'dart:uri';\n\n/**\n * A [MirrorSystem] is the main interface used to reflect on a set of\n * associated libraries.\n *\n * At runtime each running isolate has a distinct [MirrorSystem].\n *\n * It is also possible to have a [MirrorSystem] which represents a set\n * of libraries which are not running -- perhaps at compile-time.  In\n * this case, all available reflective functionality would be\n * supported, but runtime functionality (such as invoking a function\n * or inspecting the contents of a variable) would fail dynamically.\n */\nabstract class MirrorSystem {\n  /**\n   * An immutable map from from library names to mirrors for all\n   * libraries known to this mirror system.\n   */\n  Map<Uri, LibraryMirror> get libraries;\n\n  /**\n   * Returns an iterable of all libraries in the mirror system whose library\n   * name is [libraryName].\n   */\n  Iterable<LibraryMirror> findLibrary(Symbol libraryName) {\n    return libraries.values.where(\n        (library) => library.simpleName == libraryName);\n  }\n\n  /**\n   * A mirror on the isolate associated with this [MirrorSystem].\n   * This may be null if this mirror system is not running.\n   */\n  IsolateMirror get isolate;\n\n  /**\n   * A mirror on the [:dynamic:] type.\n   */\n  TypeMirror get dynamicType;\n\n  /**\n   * A mirror on the [:void:] type.\n   */\n  TypeMirror get voidType;\n\n  external static String getName(Symbol symbol);\n}\n\n/**\n * Returns a [MirrorSystem] for the current isolate.\n */\nexternal MirrorSystem currentMirrorSystem();\n\n/**\n * Creates a [MirrorSystem] for the isolate which is listening on\n * the [SendPort].\n */\nexternal Future<MirrorSystem> mirrorSystemOf(SendPort port);\n\n/**\n * Returns an [InstanceMirror] for some Dart language object.\n *\n * This only works if this mirror system is associated with the\n * current running isolate.\n */\nexternal InstanceMirror reflect(Object reflectee);\n\n/**\n * Returns a [ClassMirror] for the class represented by a Dart\n * Type object.\n *\n * This only works with objects local to the current isolate.\n */\nexternal ClassMirror reflectClass(Type key);\n\n/**\n * A [Mirror] reflects some Dart language entity.\n *\n * Every [Mirror] originates from some [MirrorSystem].\n */\nabstract class Mirror {\n  /**\n   * The [MirrorSystem] that contains this mirror.\n   */\n  MirrorSystem get mirrors;\n}\n\n/**\n * An [IsolateMirror] reflects an isolate.\n */\nabstract class IsolateMirror implements Mirror {\n  /**\n   * A unique name used to refer to an isolate in debugging messages.\n   */\n  String get debugName;\n\n  /**\n   * Does this mirror reflect the currently running isolate?\n   */\n  bool get isCurrent;\n\n  /**\n   * A mirror on the root library for this isolate.\n   */\n  LibraryMirror get rootLibrary;\n}\n\n/**\n * A [DeclarationMirror] reflects some entity declared in a Dart program.\n */\nabstract class DeclarationMirror implements Mirror {\n  /**\n   * The simple name for this Dart language entity.\n   *\n   * The simple name is in most cases the the identifier name of the\n   * entity, such as 'method' for a method [:void method() {...}:] or\n   * 'mylibrary' for a [:#library('mylibrary');:] declaration.\n   */\n  Symbol get simpleName;\n\n  /**\n   * The fully-qualified name for this Dart language entity.\n   *\n   * This name is qualified by the name of the owner. For instance,\n   * the qualified name of a method 'method' in class 'Class' in\n   * library 'library' is 'library.Class.method'.\n   *\n   * TODO(turnidge): Specify whether this name is unique.  Currently\n   * this is a gray area due to lack of clarity over whether library\n   * names are unique.\n   */\n  Symbol get qualifiedName;\n\n  /**\n   * A mirror on the owner of this function.  This is the declaration\n   * immediately surrounding the reflectee.\n   *\n   * Note that for libraries, the owner will be [:null:].\n   */\n  DeclarationMirror get owner;\n\n  /**\n   * Is this declaration private?\n   *\n   * Note that for libraries, this will be [:false:].\n   */\n  bool get isPrivate;\n\n  /**\n   * Is this declaration top-level?\n   *\n   * This is defined to be equivalent to:\n   *    [:mirror.owner != null && mirror.owner is LibraryMirror:]\n   */\n  bool get isTopLevel;\n\n  /**\n   * The source location of this Dart language entity.\n   */\n  SourceLocation get location;\n}\n\n/**\n * An [ObjectMirror] is a common superinterface of [InstanceMirror],\n * [ClassMirror], and [LibraryMirror] that represents their shared\n * functionality.\n *\n * For the purposes of the mirrors library, these types are all\n * object-like, in that they support method invocation and field\n * access.  Real Dart objects are represented by the [InstanceMirror]\n * type.\n *\n * See [InstanceMirror], [ClassMirror], and [LibraryMirror].\n */\nabstract class ObjectMirror implements Mirror {\n\n  /**\n   * Invokes the named function and returns a mirror on the result.\n   * The arguments are objects local to the current isolate.\n   */\n  /* TODO(turnidge): Properly document.\n   * TODO(turnidge): Handle ambiguous names.\n   * TODO(turnidge): Handle optional & named arguments.\n   */\n  InstanceMirror invoke(Symbol memberName,\n                        List positionalArguments,\n                        [Map<Symbol,dynamic> namedArguments]);\n\n  /**\n   * Invokes a getter and returns a mirror on the result. The getter\n   * can be the implicit getter for a field or a user-defined getter\n   * method.\n   */\n  /* TODO(turnidge): Handle ambiguous names.*/\n  InstanceMirror getField(Symbol fieldName);\n\n  /**\n   * Invokes a setter and returns a mirror on the result. The setter\n   * may be either the implicit setter for a non-final field or a\n   * user-defined setter method.\n   * The argument is an object local to the current isolate.\n   */\n  /* TODO(turnidge): Handle ambiguous names.*/\n  InstanceMirror setField(Symbol fieldName, Object arg);\n\n  /**\n   * Invokes the named function and returns a mirror on the result.\n   * The arguments must be instances of [InstanceMirror], [num],\n   * [String], or [bool].\n   */\n  /* TODO(turnidge): Properly document.\n   * TODO(turnidge): Handle ambiguous names.\n   * TODO(turnidge): Handle optional & named arguments.\n   */\n  Future<InstanceMirror> invokeAsync(Symbol memberName,\n                                     List<Object> positionalArguments,\n                                     [Map<Symbol, Object> namedArguments]);\n\n  /**\n   * Invokes a getter and returns a mirror on the result. The getter\n   * can be the implicit getter for a field or a user-defined getter\n   * method.\n   */\n  /* TODO(turnidge): Handle ambiguous names.*/\n  Future<InstanceMirror> getFieldAsync(Symbol fieldName);\n\n  /**\n   * Invokes a setter and returns a mirror on the result. The setter\n   * may be either the implicit setter for a non-final field or a\n   * user-defined setter method.\n   * The argument must be an instance of either [InstanceMirror], [num],\n   * [String], or [bool].\n   */\n  /* TODO(turnidge): Handle ambiguous names.*/\n  Future<InstanceMirror> setFieldAsync(Symbol fieldName, Object value);\n}\n\n/**\n * An [InstanceMirror] reflects an instance of a Dart language object.\n */\nabstract class InstanceMirror implements ObjectMirror {\n  /**\n   * A mirror on the type of the reflectee.\n   */\n  ClassMirror get type;\n\n  /**\n   * Does [reflectee] contain the instance reflected by this mirror?\n   * This will always be true in the local case (reflecting instances\n   * in the same isolate), but only true in the remote case if this\n   * mirror reflects a simple value.\n   *\n   * A value is simple if one of the following holds:\n   *  - the value is null\n   *  - the value is of type [num]\n   *  - the value is of type [bool]\n   *  - the value is of type [String]\n   */\n  bool get hasReflectee;\n\n  /**\n   * If the [InstanceMirror] reflects an instance it is meaningful to\n   * have a local reference to, we provide access to the actual\n   * instance here.\n   *\n   * If you access [reflectee] when [hasReflectee] is false, an\n   * exception is thrown.\n   */\n  get reflectee;\n\n  /**\n   * Perform [invocation] on [reflectee].\n   *\n   * If [reflectee] doesn't support the invocation, its [noSuchMethod]\n   * method will be called with either [invocation] or another\n   * equivalent instance of [Invocation].\n   */\n  delegate(Invocation invocation);\n}\n\n/**\n * A [ClosureMirror] reflects a closure.\n *\n * A [ClosureMirror] provides access to its captured variables and\n * provides the ability to execute its reflectee.\n */\nabstract class ClosureMirror implements InstanceMirror {\n  /**\n   * A mirror on the function associated with this closure.\n   */\n  MethodMirror get function;\n\n  /**\n   * The source code for this closure, if available.  Otherwise null.\n   *\n   * TODO(turnidge): Would this just be available in function?\n   */\n  String get source;\n\n  /**\n   * Executes the closure.\n   * The arguments are objects local to the current isolate. \n   */\n  InstanceMirror apply(List<Object> positionalArguments,\n                       [Map<Symbol,Object> namedArguments]);\n\n  /**\n   * Executes the closure.\n   * The arguments must be instances of [InstanceMirror], [num],\n   * [String], or [bool].\n   */\n  Future<InstanceMirror> applyAsync(List<Object> positionalArguments,\n                                    [Map<Symbol, Object> namedArguments]);\n\n  /**\n   * Looks up the value of a name in the scope of the closure. The\n   * result is a mirror on that value.\n   */\n  Future<InstanceMirror> findInContext(Symbol name);\n}\n\n/**\n * A [LibraryMirror] reflects a Dart language library, providing\n * access to the variables, functions, and classes of the\n * library.\n */\nabstract class LibraryMirror implements DeclarationMirror, ObjectMirror {\n  /**\n   * The absolute uri of the library.\n   */\n  Uri get uri;\n\n  /**\n   * An immutable map from from names to mirrors for all members in\n   * this library.\n   *\n   * The members of a library are its top-level classes,\n   * functions, variables, getters, and setters.\n   */\n  Map<Symbol, Mirror> get members;\n\n  /**\n   * An immutable map from names to mirrors for all class\n   * declarations in this library.\n   */\n  Map<Symbol, ClassMirror> get classes;\n\n  /**\n   * An immutable map from names to mirrors for all function, getter,\n   * and setter declarations in this library.\n   */\n  Map<Symbol, MethodMirror> get functions;\n\n  /**\n   * An immutable map from names to mirrors for all getter\n   * declarations in this library.\n   */\n  Map<Symbol, MethodMirror> get getters;\n\n  /**\n   * An immutable map from names to mirrors for all setter\n   * declarations in this library.\n   */\n  Map<Symbol, MethodMirror> get setters;\n\n  /**\n   * An immutable map from names to mirrors for all variable\n   * declarations in this library.\n   */\n  Map<Symbol, VariableMirror> get variables;\n}\n\n/**\n * A [TypeMirror] reflects a Dart language class, typedef,\n * or type variable.\n */\nabstract class TypeMirror implements DeclarationMirror {\n}\n\n/**\n * A [ClassMirror] reflects a Dart language class.\n */\nabstract class ClassMirror implements TypeMirror, ObjectMirror {\n  /**\n   * A mirror on the superclass on the reflectee.\n   *\n   * If this type is [:Object:] or a typedef, the superClass will be\n   * null.\n   */\n  ClassMirror get superclass;\n\n  /**\n   * A list of mirrors on the superinterfaces of the reflectee.\n   */\n  List<ClassMirror> get superinterfaces;\n\n  /**\n   * An immutable map from from names to mirrors for all members of\n   * this type.\n   *\n   * The members of a type are its methods, fields, getters, and\n   * setters.  Note that constructors and type variables are not\n   * considered to be members of a type.\n   *\n   * This does not include inherited members.\n   */\n  Map<Symbol, Mirror> get members;\n\n  /**\n   * An immutable map from names to mirrors for all method,\n   * declarations for this type.  This does not include getters and\n   * setters.\n   */\n  Map<Symbol, MethodMirror> get methods;\n\n  /**\n   * An immutable map from names to mirrors for all getter\n   * declarations for this type.\n   */\n  Map<Symbol, MethodMirror> get getters;\n\n  /**\n   * An immutable map from names to mirrors for all setter\n   * declarations for this type.\n   */\n  Map<Symbol, MethodMirror> get setters;\n\n  /**\n   * An immutable map from names to mirrors for all variable\n   * declarations for this type.\n   */\n  Map<Symbol, VariableMirror> get variables;\n\n  /**\n   * An immutable map from names to mirrors for all constructor\n   * declarations for this type.\n   */\n   Map<Symbol, MethodMirror> get constructors;\n\n  /**\n   * An immutable map from names to mirrors for all type variables for\n   * this type.\n   *\n   * This map preserves the order of declaration of the type variables.\n   */\n   Map<Symbol, TypeVariableMirror> get typeVariables;\n\n  /**\n   * An immutable map from names to mirrors for all type arguments for\n   * this type.\n   *\n   * This map preserves the order of declaration of the type variables.\n   */\n  Map<Symbol, TypeMirror> get typeArguments;\n\n  /**\n   * Is this the original declaration of this type?\n   *\n   * For most classes, they are their own original declaration.  For\n   * generic classes, however, there is a distinction between the\n   * original class declaration, which has unbound type variables, and\n   * the instantiations of generic classes, which have bound type\n   * variables.\n   */\n  bool get isOriginalDeclaration;\n\n  /**\n   * A mirror on the original declaration of this type.\n   *\n   * For most classes, they are their own original declaration.  For\n   * generic classes, however, there is a distinction between the\n   * original class declaration, which has unbound type variables, and\n   * the instantiations of generic classes, which have bound type\n   * variables.\n   */\n  ClassMirror get originalDeclaration;\n\n  /**\n   * Invokes the named constructor and returns a mirror on the result.\n   * The arguments are objects local to the current isolate \n   */\n  /* TODO(turnidge): Properly document.*/\n  InstanceMirror newInstance(Symbol constructorName,\n                             List positionalArguments,\n                             [Map<Symbol,dynamic> namedArguments]);\n\n  /**\n   * Invokes the named constructor and returns a mirror on the result.\n   * The arguments must be instances of [InstanceMirror], [num],\n   * [String] or [bool].\n   */\n  /* TODO(turnidge): Properly document.*/\n  Future<InstanceMirror> newInstanceAsync(Symbol constructorName,\n                                          List<Object> positionalArguments,\n                                          [Map<Symbol, Object> namedArguments]);\n\n  /**\n   * Does this mirror represent a class?\n   *\n   * TODO(turnidge): This functions goes away after the\n   * class/interface changes.\n   */\n  bool get isClass;\n\n  /**\n   * A mirror on the default factory class or null if there is none.\n   *\n   * TODO(turnidge): This functions goes away after the\n   * class/interface changes.\n   */\n  ClassMirror get defaultFactory;\n}\n\n/**\n * A [FunctionTypeMirror] represents the type of a function in the\n * Dart language.\n */\nabstract class FunctionTypeMirror implements ClassMirror {\n  /**\n   * The return type of the reflectee.\n   */\n  TypeMirror get returnType;\n\n  /**\n   * A list of the parameter types of the reflectee.\n   */\n  List<ParameterMirror> get parameters;\n\n  /**\n   * A mirror on the [:call:] method for the reflectee.\n   *\n   * TODO(turnidge): What is this and what is it for?\n   */\n  MethodMirror get callMethod;\n}\n\n/**\n * A [TypeVariableMirror] represents a type parameter of a generic\n * type.\n */\nabstract class TypeVariableMirror extends TypeMirror {\n  /**\n   * A mirror on the type that is the upper bound of this type variable.\n   */\n  TypeMirror get upperBound;\n}\n\n/**\n * A [TypedefMirror] represents a typedef in a Dart language program.\n */\nabstract class TypedefMirror implements ClassMirror {\n  /**\n   * The defining type for this typedef.\n   *\n   * For instance [:void f(int):] is the value for [:typedef void f(int):].\n   */\n  TypeMirror get value;\n}\n\n/**\n * A [MethodMirror] reflects a Dart language function, method,\n * constructor, getter, or setter.\n */\nabstract class MethodMirror implements DeclarationMirror {\n  /**\n   * A mirror on the return type for the reflectee.\n   */\n  TypeMirror get returnType;\n\n  /**\n   * A list of mirrors on the parameters for the reflectee.\n   */\n  List<ParameterMirror> get parameters;\n\n  /**\n   * Is the reflectee static?\n   *\n   * For the purposes of the mirrors library, a top-level function is\n   * considered static.\n   */\n  bool get isStatic;\n\n  /**\n   * Is the reflectee abstract?\n   */\n  bool get isAbstract;\n\n  /**\n   * Is the reflectee a regular function or method?\n   *\n   * A function or method is regular if it is not a getter, setter, or\n   * constructor.  Note that operators, by this definition, are\n   * regular methods.\n   */\n  bool get isRegularMethod;\n\n  /**\n   * Is the reflectee an operator?\n   */\n  bool get isOperator;\n\n  /**\n   * Is the reflectee a getter?\n   */\n  bool get isGetter;\n\n  /**\n   * Is the reflectee a setter?\n   */\n  bool get isSetter;\n\n  /**\n   * Is the reflectee a constructor?\n   */\n  bool get isConstructor;\n\n  /**\n   * The constructor name for named constructors and factory methods.\n   *\n   * For unnamed constructors, this is the empty string.  For\n   * non-constructors, this is the empty string.\n   *\n   * For example, [:'bar':] is the constructor name for constructor\n   * [:Foo.bar:] of type [:Foo:].\n   */\n  Symbol get constructorName;\n\n  /**\n   * Is the reflectee a const constructor?\n   */\n  bool get isConstConstructor;\n\n  /**\n   * Is the reflectee a generative constructor?\n   */\n  bool get isGenerativeConstructor;\n\n  /**\n   * Is the reflectee a redirecting constructor?\n   */\n  bool get isRedirectingConstructor;\n\n  /**\n   * Is the reflectee a factory constructor?\n   */\n  bool get isFactoryConstructor;\n}\n\n/**\n * A [VariableMirror] reflects a Dart language variable declaration.\n */\nabstract class VariableMirror implements DeclarationMirror {\n  /**\n   * A mirror on the type of the reflectee.\n   */\n  TypeMirror get type;\n\n  /**\n   * Is the reflectee a static variable?\n   *\n   * For the purposes of the mirror library, top-level variables are\n   * implicitly declared static.\n   */\n  bool get isStatic;\n\n  /**\n   * Is the reflectee a final variable?\n   */\n  bool get isFinal;\n}\n\n/**\n * A [ParameterMirror] reflects a Dart formal parameter declaration.\n */\nabstract class ParameterMirror implements VariableMirror {\n  /**\n   * A mirror on the type of this parameter.\n   */\n  TypeMirror get type;\n\n  /**\n   * Is this parameter optional?\n   */\n  bool get isOptional;\n\n  /**\n   * Is this parameter named?\n   */\n  bool get isNamed;\n\n  /**\n   * Does this parameter have a default value?\n   */\n  bool get hasDefaultValue;\n\n  /**\n   * A mirror on the default value for this parameter, if it exists.\n   */\n  // TODO(ahe): This should return an InstanceMirror.\n  String get defaultValue;\n}\n\n/**\n * A [SourceLocation] describes the span of an entity in Dart source code.\n */\nabstract class SourceLocation {\n}\n\n/**\n * When an error occurs during the mirrored execution of code, a\n * [MirroredError] is thrown.\n *\n * In general, there are three main classes of failure that can happen\n * during mirrored execution of code in some isolate:\n *\n * - An exception is thrown but not caught.  This is caught by the\n *   mirrors framework and a [MirroredUncaughtExceptionError] is\n *   created and thrown.\n *\n * - A compile-time error occurs, such as a syntax error.  This is\n *   suppressed by the mirrors framework and a\n *   [MirroredCompilationError] is created and thrown.\n *\n * - A truly fatal error occurs, causing the isolate to be exited.  If\n *   the reflector and reflectee share the same isolate, then they\n *   will both suffer.  If the reflector and reflectee are in distinct\n *   isolates, then we hope to provide some information about the\n *   isolate death, but this has yet to be implemented.\n *\n * TODO(turnidge): Specify the behavior for remote fatal errors.\n */\nabstract class MirroredError implements Exception {\n}\n\n/**\n * When an uncaught exception occurs during the mirrored execution\n * of code, a [MirroredUncaughtExceptionError] is thrown.\n *\n * This exception contains a mirror on the original exception object.\n * It also contains an object which can be used to recover the\n * stacktrace.\n */\nclass MirroredUncaughtExceptionError extends MirroredError {\n  MirroredUncaughtExceptionError(this.exception_mirror,\n                                 this.exception_string,\n                                 this.stacktrace) {}\n\n  /** A mirror on the exception object. */\n  final InstanceMirror exception_mirror;\n\n  /** The result of toString() for the exception object. */\n  final String exception_string;\n\n  /** A stacktrace object for the uncaught exception. */\n  final Object stacktrace;\n\n  String toString() {\n    return\n        \"Uncaught exception during mirrored execution: <${exception_string}>\";\n  }\n}\n\n/**\n * When a compile-time error occurs during the mirrored execution\n * of code, a [MirroredCompilationError] is thrown.\n *\n * This exception includes the compile-time error message that would\n * have been displayed to the user, if the function had not been\n * invoked via mirror.\n */\nclass MirroredCompilationError extends MirroredError {\n  MirroredCompilationError(this.message) {}\n\n  final String message;\n\n  String toString() {\n    return \"Compile-time error during mirrored execution: <$message>\";\n  }\n}\n\n/**\n * A [MirrorException] is used to indicate errors within the mirrors\n * framework.\n */\nclass MirrorException implements Exception {\n  const MirrorException(String this._message);\n  String toString() => \"MirrorException: '$_message'\";\n  final String _message;\n}\n\n/**\n * Class used for encoding comments as metadata annotations.\n */\nclass Comment {\n  /**\n   * The comment text as written in the source text.\n   */\n  final String text;\n\n  /**\n   * The comment text without the start, end, and padding text.\n   *\n   * For example, if [text] is [: /** Comment text. */ :] then the [trimmedText]\n   * is [: Comment text. :].\n   */\n  final String trimmedText;\n\n  /**\n   * Is [:true:] if this comment is a documentation comment.\n   *\n   * That is, that the comment is either enclosed in [: /** ... */ :] or starts\n   * with [: /// :].\n   */\n  final bool isDocComment;\n\n  const Comment(this.text, this.trimmedText, this.isDocComment);\n}\n","sdk/lib/svg/dart2js/svg_dart2js.dart":"library dart.dom.svg;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:_collection-dev';\nimport 'dart:html';\nimport 'dart:html_common';\nimport 'dart:_js_helper' show Creates, Returns, JavaScriptIndexingBehavior, JSName;\nimport 'dart:_foreign_helper' show JS;\n// DO NOT EDIT - unless you are editing documentation as per:\n// https://code.google.com/p/dart/wiki/ContributingHTMLDocumentation\n// Auto-generated dart:svg library.\n\n\n\n\n\n\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nfinal _START_TAG_REGEXP = new RegExp('<(\\\\w+)');\n\nclass _SvgElementFactoryProvider {\n  static SvgElement createSvgElement_tag(String tag) {\n    final Element temp =\n      document.$dom_createElementNS(\"http://www.w3.org/2000/svg\", tag);\n    return temp;\n  }\n\n  static SvgElement createSvgElement_svg(String svg) {\n    Element parentTag;\n    final match = _START_TAG_REGEXP.firstMatch(svg);\n    if (match != null && match.group(1).toLowerCase() == 'svg') {\n      parentTag = new Element.tag('div');\n    } else {\n      parentTag = new SvgSvgElement();\n    }\n\n    parentTag.innerHtml = svg;\n    if (parentTag.children.length == 1) return parentTag.children.removeLast();\n\n    throw new ArgumentError(\n        'SVG had ${parentTag.children.length} '\n        'top-level children but 1 expected');\n  }\n}\n\nclass _SvgSvgElementFactoryProvider {\n  static SvgSvgElement createSvgSvgElement() {\n    final el = new SvgElement.tag(\"svg\");\n    // The SVG spec requires the version attribute to match the spec version\n    el.attributes['version'] = \"1.1\";\n    return el;\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAElement')\nclass AElement extends StyledElement implements UriReference, Tests, Transformable, ExternalResourcesRequired, LangSpace native \"SVGAElement\" {\n\n  @DomName('SVGAElement.SVGAElement')\n  @DocsEditable\n  factory AElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"a\");\n\n  @DomName('SVGAElement.target')\n  @DocsEditable\n  final AnimatedString target;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGAElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGAElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGAElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGAElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGAElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGAElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGAElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGAElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGAElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGAElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGAElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGAElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGAElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGAElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n\n  // From SVGURIReference\n\n  @DomName('SVGAElement.href')\n  @DocsEditable\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAltGlyphElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass AltGlyphElement extends TextPositioningElement implements UriReference native \"SVGAltGlyphElement\" {\n\n  @DomName('SVGAltGlyphElement.SVGAltGlyphElement')\n  @DocsEditable\n  factory AltGlyphElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"altGlyph\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('altGlyph') && (new SvgElement.tag('altGlyph') is AltGlyphElement);\n\n  @DomName('SVGAltGlyphElement.format')\n  @DocsEditable\n  String format;\n\n  @DomName('SVGAltGlyphElement.glyphRef')\n  @DocsEditable\n  String glyphRef;\n\n  // From SVGURIReference\n\n  @DomName('SVGAltGlyphElement.href')\n  @DocsEditable\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAngle')\nclass Angle native \"SVGAngle\" {\n\n  static const int SVG_ANGLETYPE_DEG = 2;\n\n  static const int SVG_ANGLETYPE_GRAD = 4;\n\n  static const int SVG_ANGLETYPE_RAD = 3;\n\n  static const int SVG_ANGLETYPE_UNKNOWN = 0;\n\n  static const int SVG_ANGLETYPE_UNSPECIFIED = 1;\n\n  @DomName('SVGAngle.unitType')\n  @DocsEditable\n  final int unitType;\n\n  @DomName('SVGAngle.value')\n  @DocsEditable\n  num value;\n\n  @DomName('SVGAngle.valueAsString')\n  @DocsEditable\n  String valueAsString;\n\n  @DomName('SVGAngle.valueInSpecifiedUnits')\n  @DocsEditable\n  num valueInSpecifiedUnits;\n\n  @DomName('SVGAngle.convertToSpecifiedUnits')\n  @DocsEditable\n  void convertToSpecifiedUnits(int unitType) native;\n\n  @DomName('SVGAngle.newValueSpecifiedUnits')\n  @DocsEditable\n  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimateElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass AnimateElement extends AnimationElement native \"SVGAnimateElement\" {\n\n  @DomName('SVGAnimateElement.SVGAnimateElement')\n  @DocsEditable\n  factory AnimateElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"animate\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('animate') && (new SvgElement.tag('animate') is AnimateElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimateMotionElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass AnimateMotionElement extends AnimationElement native \"SVGAnimateMotionElement\" {\n\n  @DomName('SVGAnimateMotionElement.SVGAnimateMotionElement')\n  @DocsEditable\n  factory AnimateMotionElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"animateMotion\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('animateMotion') && (new SvgElement.tag('animateMotion') is AnimateMotionElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimateTransformElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass AnimateTransformElement extends AnimationElement native \"SVGAnimateTransformElement\" {\n\n  @DomName('SVGAnimateTransformElement.SVGAnimateTransformElement')\n  @DocsEditable\n  factory AnimateTransformElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"animateTransform\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('animateTransform') && (new SvgElement.tag('animateTransform') is AnimateTransformElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimatedAngle')\nclass AnimatedAngle native \"SVGAnimatedAngle\" {\n\n  @DomName('SVGAnimatedAngle.animVal')\n  @DocsEditable\n  final Angle animVal;\n\n  @DomName('SVGAnimatedAngle.baseVal')\n  @DocsEditable\n  final Angle baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimatedBoolean')\nclass AnimatedBoolean native \"SVGAnimatedBoolean\" {\n\n  @DomName('SVGAnimatedBoolean.animVal')\n  @DocsEditable\n  final bool animVal;\n\n  @DomName('SVGAnimatedBoolean.baseVal')\n  @DocsEditable\n  bool baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimatedEnumeration')\nclass AnimatedEnumeration native \"SVGAnimatedEnumeration\" {\n\n  @DomName('SVGAnimatedEnumeration.animVal')\n  @DocsEditable\n  final int animVal;\n\n  @DomName('SVGAnimatedEnumeration.baseVal')\n  @DocsEditable\n  int baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimatedInteger')\nclass AnimatedInteger native \"SVGAnimatedInteger\" {\n\n  @DomName('SVGAnimatedInteger.animVal')\n  @DocsEditable\n  final int animVal;\n\n  @DomName('SVGAnimatedInteger.baseVal')\n  @DocsEditable\n  int baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimatedLength')\nclass AnimatedLength native \"SVGAnimatedLength\" {\n\n  @DomName('SVGAnimatedLength.animVal')\n  @DocsEditable\n  final Length animVal;\n\n  @DomName('SVGAnimatedLength.baseVal')\n  @DocsEditable\n  final Length baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimatedLengthList')\nclass AnimatedLengthList native \"SVGAnimatedLengthList\" {\n\n  @DomName('SVGAnimatedLengthList.animVal')\n  @DocsEditable\n  final LengthList animVal;\n\n  @DomName('SVGAnimatedLengthList.baseVal')\n  @DocsEditable\n  final LengthList baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimatedNumber')\nclass AnimatedNumber native \"SVGAnimatedNumber\" {\n\n  @DomName('SVGAnimatedNumber.animVal')\n  @DocsEditable\n  final num animVal;\n\n  @DomName('SVGAnimatedNumber.baseVal')\n  @DocsEditable\n  num baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimatedNumberList')\nclass AnimatedNumberList native \"SVGAnimatedNumberList\" {\n\n  @DomName('SVGAnimatedNumberList.animVal')\n  @DocsEditable\n  final NumberList animVal;\n\n  @DomName('SVGAnimatedNumberList.baseVal')\n  @DocsEditable\n  final NumberList baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimatedPreserveAspectRatio')\nclass AnimatedPreserveAspectRatio native \"SVGAnimatedPreserveAspectRatio\" {\n\n  @DomName('SVGAnimatedPreserveAspectRatio.animVal')\n  @DocsEditable\n  final PreserveAspectRatio animVal;\n\n  @DomName('SVGAnimatedPreserveAspectRatio.baseVal')\n  @DocsEditable\n  final PreserveAspectRatio baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimatedRect')\nclass AnimatedRect native \"SVGAnimatedRect\" {\n\n  @DomName('SVGAnimatedRect.animVal')\n  @DocsEditable\n  final Rect animVal;\n\n  @DomName('SVGAnimatedRect.baseVal')\n  @DocsEditable\n  final Rect baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimatedString')\nclass AnimatedString native \"SVGAnimatedString\" {\n\n  @DomName('SVGAnimatedString.animVal')\n  @DocsEditable\n  final String animVal;\n\n  @DomName('SVGAnimatedString.baseVal')\n  @DocsEditable\n  String baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimatedTransformList')\nclass AnimatedTransformList native \"SVGAnimatedTransformList\" {\n\n  @DomName('SVGAnimatedTransformList.animVal')\n  @DocsEditable\n  final TransformList animVal;\n\n  @DomName('SVGAnimatedTransformList.baseVal')\n  @DocsEditable\n  final TransformList baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimationElement')\nclass AnimationElement extends SvgElement implements Tests, ElementTimeControl, ExternalResourcesRequired native \"SVGAnimationElement\" {\n\n  @DomName('SVGAnimationElement.SVGAnimationElement')\n  @DocsEditable\n  factory AnimationElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"animation\");\n\n  @DomName('SVGAnimationElement.targetElement')\n  @DocsEditable\n  final SvgElement targetElement;\n\n  @DomName('SVGAnimationElement.getCurrentTime')\n  @DocsEditable\n  num getCurrentTime() native;\n\n  @DomName('SVGAnimationElement.getSimpleDuration')\n  @DocsEditable\n  num getSimpleDuration() native;\n\n  @DomName('SVGAnimationElement.getStartTime')\n  @DocsEditable\n  num getStartTime() native;\n\n  // From ElementTimeControl\n\n  @DomName('SVGAnimationElement.beginElement')\n  @DocsEditable\n  void beginElement() native;\n\n  @DomName('SVGAnimationElement.beginElementAt')\n  @DocsEditable\n  void beginElementAt(num offset) native;\n\n  @DomName('SVGAnimationElement.endElement')\n  @DocsEditable\n  void endElement() native;\n\n  @DomName('SVGAnimationElement.endElementAt')\n  @DocsEditable\n  void endElementAt(num offset) native;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGAnimationElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGTests\n\n  @DomName('SVGAnimationElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGAnimationElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGAnimationElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGAnimationElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGCircleElement')\nclass CircleElement extends StyledElement implements Transformable, Tests, ExternalResourcesRequired, LangSpace native \"SVGCircleElement\" {\n\n  @DomName('SVGCircleElement.SVGCircleElement')\n  @DocsEditable\n  factory CircleElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"circle\");\n\n  @DomName('SVGCircleElement.cx')\n  @DocsEditable\n  final AnimatedLength cx;\n\n  @DomName('SVGCircleElement.cy')\n  @DocsEditable\n  final AnimatedLength cy;\n\n  @DomName('SVGCircleElement.r')\n  @DocsEditable\n  final AnimatedLength r;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGCircleElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGCircleElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGCircleElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGCircleElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGCircleElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGCircleElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGCircleElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGCircleElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGCircleElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGCircleElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGCircleElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGCircleElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGCircleElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGCircleElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGClipPathElement')\nclass ClipPathElement extends StyledElement implements Transformable, Tests, ExternalResourcesRequired, LangSpace native \"SVGClipPathElement\" {\n\n  @DomName('SVGClipPathElement.SVGClipPathElement')\n  @DocsEditable\n  factory ClipPathElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"clipPath\");\n\n  @DomName('SVGClipPathElement.clipPathUnits')\n  @DocsEditable\n  final AnimatedEnumeration clipPathUnits;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGClipPathElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGClipPathElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGClipPathElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGClipPathElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGClipPathElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGClipPathElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGClipPathElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGClipPathElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGClipPathElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGClipPathElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGClipPathElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGClipPathElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGClipPathElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGClipPathElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGDefsElement')\nclass DefsElement extends StyledElement implements Transformable, Tests, ExternalResourcesRequired, LangSpace native \"SVGDefsElement\" {\n\n  @DomName('SVGDefsElement.SVGDefsElement')\n  @DocsEditable\n  factory DefsElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"defs\");\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGDefsElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGDefsElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGDefsElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGDefsElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGDefsElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGDefsElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGDefsElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGDefsElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGDefsElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGDefsElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGDefsElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGDefsElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGDefsElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGDefsElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGDescElement')\nclass DescElement extends StyledElement implements LangSpace native \"SVGDescElement\" {\n\n  @DomName('SVGDescElement.SVGDescElement')\n  @DocsEditable\n  factory DescElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"desc\");\n\n  // From SVGLangSpace\n\n  @DomName('SVGDescElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGDescElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGElementInstance')\nclass ElementInstance extends EventTarget native \"SVGElementInstance\" {\n\n  @DomName('SVGElementInstance.abortEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> abortEvent = const EventStreamProvider<Event>('abort');\n\n  @DomName('SVGElementInstance.beforecopyEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> beforeCopyEvent = const EventStreamProvider<Event>('beforecopy');\n\n  @DomName('SVGElementInstance.beforecutEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> beforeCutEvent = const EventStreamProvider<Event>('beforecut');\n\n  @DomName('SVGElementInstance.beforepasteEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> beforePasteEvent = const EventStreamProvider<Event>('beforepaste');\n\n  @DomName('SVGElementInstance.blurEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> blurEvent = const EventStreamProvider<Event>('blur');\n\n  @DomName('SVGElementInstance.changeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> changeEvent = const EventStreamProvider<Event>('change');\n\n  @DomName('SVGElementInstance.clickEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> clickEvent = const EventStreamProvider<MouseEvent>('click');\n\n  @DomName('SVGElementInstance.contextmenuEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> contextMenuEvent = const EventStreamProvider<MouseEvent>('contextmenu');\n\n  @DomName('SVGElementInstance.copyEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> copyEvent = const EventStreamProvider<Event>('copy');\n\n  @DomName('SVGElementInstance.cutEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> cutEvent = const EventStreamProvider<Event>('cut');\n\n  @DomName('SVGElementInstance.dblclickEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> doubleClickEvent = const EventStreamProvider<Event>('dblclick');\n\n  @DomName('SVGElementInstance.dragEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> dragEvent = const EventStreamProvider<MouseEvent>('drag');\n\n  @DomName('SVGElementInstance.dragendEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> dragEndEvent = const EventStreamProvider<MouseEvent>('dragend');\n\n  @DomName('SVGElementInstance.dragenterEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> dragEnterEvent = const EventStreamProvider<MouseEvent>('dragenter');\n\n  @DomName('SVGElementInstance.dragleaveEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> dragLeaveEvent = const EventStreamProvider<MouseEvent>('dragleave');\n\n  @DomName('SVGElementInstance.dragoverEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> dragOverEvent = const EventStreamProvider<MouseEvent>('dragover');\n\n  @DomName('SVGElementInstance.dragstartEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> dragStartEvent = const EventStreamProvider<MouseEvent>('dragstart');\n\n  @DomName('SVGElementInstance.dropEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> dropEvent = const EventStreamProvider<MouseEvent>('drop');\n\n  @DomName('SVGElementInstance.errorEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('SVGElementInstance.focusEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> focusEvent = const EventStreamProvider<Event>('focus');\n\n  @DomName('SVGElementInstance.inputEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> inputEvent = const EventStreamProvider<Event>('input');\n\n  @DomName('SVGElementInstance.keydownEvent')\n  @DocsEditable\n  static const EventStreamProvider<KeyboardEvent> keyDownEvent = const EventStreamProvider<KeyboardEvent>('keydown');\n\n  @DomName('SVGElementInstance.keypressEvent')\n  @DocsEditable\n  static const EventStreamProvider<KeyboardEvent> keyPressEvent = const EventStreamProvider<KeyboardEvent>('keypress');\n\n  @DomName('SVGElementInstance.keyupEvent')\n  @DocsEditable\n  static const EventStreamProvider<KeyboardEvent> keyUpEvent = const EventStreamProvider<KeyboardEvent>('keyup');\n\n  @DomName('SVGElementInstance.loadEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> loadEvent = const EventStreamProvider<Event>('load');\n\n  @DomName('SVGElementInstance.mousedownEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> mouseDownEvent = const EventStreamProvider<MouseEvent>('mousedown');\n\n  @DomName('SVGElementInstance.mousemoveEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> mouseMoveEvent = const EventStreamProvider<MouseEvent>('mousemove');\n\n  @DomName('SVGElementInstance.mouseoutEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> mouseOutEvent = const EventStreamProvider<MouseEvent>('mouseout');\n\n  @DomName('SVGElementInstance.mouseoverEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> mouseOverEvent = const EventStreamProvider<MouseEvent>('mouseover');\n\n  @DomName('SVGElementInstance.mouseupEvent')\n  @DocsEditable\n  static const EventStreamProvider<MouseEvent> mouseUpEvent = const EventStreamProvider<MouseEvent>('mouseup');\n\n  @DomName('SVGElementInstance.mousewheelEvent')\n  @DocsEditable\n  static const EventStreamProvider<WheelEvent> mouseWheelEvent = const EventStreamProvider<WheelEvent>('mousewheel');\n\n  @DomName('SVGElementInstance.pasteEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> pasteEvent = const EventStreamProvider<Event>('paste');\n\n  @DomName('SVGElementInstance.resetEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> resetEvent = const EventStreamProvider<Event>('reset');\n\n  @DomName('SVGElementInstance.resizeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> resizeEvent = const EventStreamProvider<Event>('resize');\n\n  @DomName('SVGElementInstance.scrollEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> scrollEvent = const EventStreamProvider<Event>('scroll');\n\n  @DomName('SVGElementInstance.searchEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> searchEvent = const EventStreamProvider<Event>('search');\n\n  @DomName('SVGElementInstance.selectEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> selectEvent = const EventStreamProvider<Event>('select');\n\n  @DomName('SVGElementInstance.selectstartEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> selectStartEvent = const EventStreamProvider<Event>('selectstart');\n\n  @DomName('SVGElementInstance.submitEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> submitEvent = const EventStreamProvider<Event>('submit');\n\n  @DomName('SVGElementInstance.unloadEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> unloadEvent = const EventStreamProvider<Event>('unload');\n\n  @DomName('SVGElementInstance.childNodes')\n  @DocsEditable\n  @Returns('_ElementInstanceList')\n  @Creates('_ElementInstanceList')\n  final List<ElementInstance> childNodes;\n\n  @DomName('SVGElementInstance.correspondingElement')\n  @DocsEditable\n  final SvgElement correspondingElement;\n\n  @DomName('SVGElementInstance.correspondingUseElement')\n  @DocsEditable\n  final UseElement correspondingUseElement;\n\n  @DomName('SVGElementInstance.firstChild')\n  @DocsEditable\n  final ElementInstance firstChild;\n\n  @DomName('SVGElementInstance.lastChild')\n  @DocsEditable\n  final ElementInstance lastChild;\n\n  @DomName('SVGElementInstance.nextSibling')\n  @DocsEditable\n  final ElementInstance nextSibling;\n\n  @DomName('SVGElementInstance.parentNode')\n  @DocsEditable\n  final ElementInstance parentNode;\n\n  @DomName('SVGElementInstance.previousSibling')\n  @DocsEditable\n  final ElementInstance previousSibling;\n\n  @DomName('SVGElementInstance.onabort')\n  @DocsEditable\n  Stream<Event> get onAbort => abortEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onbeforecopy')\n  @DocsEditable\n  Stream<Event> get onBeforeCopy => beforeCopyEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onbeforecut')\n  @DocsEditable\n  Stream<Event> get onBeforeCut => beforeCutEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onbeforepaste')\n  @DocsEditable\n  Stream<Event> get onBeforePaste => beforePasteEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onblur')\n  @DocsEditable\n  Stream<Event> get onBlur => blurEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onchange')\n  @DocsEditable\n  Stream<Event> get onChange => changeEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onclick')\n  @DocsEditable\n  Stream<MouseEvent> get onClick => clickEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.oncontextmenu')\n  @DocsEditable\n  Stream<MouseEvent> get onContextMenu => contextMenuEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.oncopy')\n  @DocsEditable\n  Stream<Event> get onCopy => copyEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.oncut')\n  @DocsEditable\n  Stream<Event> get onCut => cutEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.ondblclick')\n  @DocsEditable\n  Stream<Event> get onDoubleClick => doubleClickEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.ondrag')\n  @DocsEditable\n  Stream<MouseEvent> get onDrag => dragEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.ondragend')\n  @DocsEditable\n  Stream<MouseEvent> get onDragEnd => dragEndEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.ondragenter')\n  @DocsEditable\n  Stream<MouseEvent> get onDragEnter => dragEnterEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.ondragleave')\n  @DocsEditable\n  Stream<MouseEvent> get onDragLeave => dragLeaveEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.ondragover')\n  @DocsEditable\n  Stream<MouseEvent> get onDragOver => dragOverEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.ondragstart')\n  @DocsEditable\n  Stream<MouseEvent> get onDragStart => dragStartEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.ondrop')\n  @DocsEditable\n  Stream<MouseEvent> get onDrop => dropEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onerror')\n  @DocsEditable\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onfocus')\n  @DocsEditable\n  Stream<Event> get onFocus => focusEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.oninput')\n  @DocsEditable\n  Stream<Event> get onInput => inputEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onkeydown')\n  @DocsEditable\n  Stream<KeyboardEvent> get onKeyDown => keyDownEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onkeypress')\n  @DocsEditable\n  Stream<KeyboardEvent> get onKeyPress => keyPressEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onkeyup')\n  @DocsEditable\n  Stream<KeyboardEvent> get onKeyUp => keyUpEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onload')\n  @DocsEditable\n  Stream<Event> get onLoad => loadEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onmousedown')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseDown => mouseDownEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onmousemove')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseMove => mouseMoveEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onmouseout')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseOut => mouseOutEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onmouseover')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseOver => mouseOverEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onmouseup')\n  @DocsEditable\n  Stream<MouseEvent> get onMouseUp => mouseUpEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onmousewheel')\n  @DocsEditable\n  Stream<WheelEvent> get onMouseWheel => mouseWheelEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onpaste')\n  @DocsEditable\n  Stream<Event> get onPaste => pasteEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onreset')\n  @DocsEditable\n  Stream<Event> get onReset => resetEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onresize')\n  @DocsEditable\n  Stream<Event> get onResize => resizeEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onscroll')\n  @DocsEditable\n  Stream<Event> get onScroll => scrollEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onsearch')\n  @DocsEditable\n  Stream<Event> get onSearch => searchEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onselect')\n  @DocsEditable\n  Stream<Event> get onSelect => selectEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onselectstart')\n  @DocsEditable\n  Stream<Event> get onSelectStart => selectStartEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onsubmit')\n  @DocsEditable\n  Stream<Event> get onSubmit => submitEvent.forTarget(this);\n\n  @DomName('SVGElementInstance.onunload')\n  @DocsEditable\n  Stream<Event> get onUnload => unloadEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('ElementTimeControl')\nabstract class ElementTimeControl {\n\n  void beginElement();\n\n  void beginElementAt(num offset);\n\n  void endElement();\n\n  void endElementAt(num offset);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGEllipseElement')\nclass EllipseElement extends StyledElement implements Transformable, Tests, ExternalResourcesRequired, LangSpace native \"SVGEllipseElement\" {\n\n  @DomName('SVGEllipseElement.SVGEllipseElement')\n  @DocsEditable\n  factory EllipseElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"ellipse\");\n\n  @DomName('SVGEllipseElement.cx')\n  @DocsEditable\n  final AnimatedLength cx;\n\n  @DomName('SVGEllipseElement.cy')\n  @DocsEditable\n  final AnimatedLength cy;\n\n  @DomName('SVGEllipseElement.rx')\n  @DocsEditable\n  final AnimatedLength rx;\n\n  @DomName('SVGEllipseElement.ry')\n  @DocsEditable\n  final AnimatedLength ry;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGEllipseElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGEllipseElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGEllipseElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGEllipseElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGEllipseElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGEllipseElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGEllipseElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGEllipseElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGEllipseElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGEllipseElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGEllipseElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGEllipseElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGEllipseElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGEllipseElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('SVGExternalResourcesRequired')\nabstract class ExternalResourcesRequired {\n\n  /// Checks if this type is supported on the current platform.\n  static bool supported(SvgElement element) => JS('bool', '#.externalResourcesRequired !== undefined && #.externalResourcesRequired.animVal !== undefined', element, element);\n\n  AnimatedBoolean externalResourcesRequired;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEBlendElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEBlendElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFEBlendElement\" {\n\n  @DomName('SVGFEBlendElement.SVGFEBlendElement')\n  @DocsEditable\n  factory FEBlendElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feBlend\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feBlend') && (new SvgElement.tag('feBlend') is FEBlendElement);\n\n  static const int SVG_FEBLEND_MODE_DARKEN = 4;\n\n  static const int SVG_FEBLEND_MODE_LIGHTEN = 5;\n\n  static const int SVG_FEBLEND_MODE_MULTIPLY = 2;\n\n  static const int SVG_FEBLEND_MODE_NORMAL = 1;\n\n  static const int SVG_FEBLEND_MODE_SCREEN = 3;\n\n  static const int SVG_FEBLEND_MODE_UNKNOWN = 0;\n\n  @DomName('SVGFEBlendElement.in1')\n  @DocsEditable\n  final AnimatedString in1;\n\n  @DomName('SVGFEBlendElement.in2')\n  @DocsEditable\n  final AnimatedString in2;\n\n  @DomName('SVGFEBlendElement.mode')\n  @DocsEditable\n  final AnimatedEnumeration mode;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEBlendElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFEBlendElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFEBlendElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFEBlendElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFEBlendElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEColorMatrixElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEColorMatrixElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFEColorMatrixElement\" {\n\n  @DomName('SVGFEColorMatrixElement.SVGFEColorMatrixElement')\n  @DocsEditable\n  factory FEColorMatrixElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feColorMatrix\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feColorMatrix') && (new SvgElement.tag('feColorMatrix') is FEColorMatrixElement);\n\n  static const int SVG_FECOLORMATRIX_TYPE_HUEROTATE = 3;\n\n  static const int SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA = 4;\n\n  static const int SVG_FECOLORMATRIX_TYPE_MATRIX = 1;\n\n  static const int SVG_FECOLORMATRIX_TYPE_SATURATE = 2;\n\n  static const int SVG_FECOLORMATRIX_TYPE_UNKNOWN = 0;\n\n  @DomName('SVGFEColorMatrixElement.in1')\n  @DocsEditable\n  final AnimatedString in1;\n\n  @DomName('SVGFEColorMatrixElement.type')\n  @DocsEditable\n  final AnimatedEnumeration type;\n\n  @DomName('SVGFEColorMatrixElement.values')\n  @DocsEditable\n  final AnimatedNumberList values;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEColorMatrixElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFEColorMatrixElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFEColorMatrixElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFEColorMatrixElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFEColorMatrixElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEComponentTransferElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEComponentTransferElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFEComponentTransferElement\" {\n\n  @DomName('SVGFEComponentTransferElement.SVGFEComponentTransferElement')\n  @DocsEditable\n  factory FEComponentTransferElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feComponentTransfer\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feComponentTransfer') && (new SvgElement.tag('feComponentTransfer') is FEComponentTransferElement);\n\n  @DomName('SVGFEComponentTransferElement.in1')\n  @DocsEditable\n  final AnimatedString in1;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEComponentTransferElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFEComponentTransferElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFEComponentTransferElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFEComponentTransferElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFEComponentTransferElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFECompositeElement')\nclass FECompositeElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFECompositeElement\" {\n\n  static const int SVG_FECOMPOSITE_OPERATOR_ARITHMETIC = 6;\n\n  static const int SVG_FECOMPOSITE_OPERATOR_ATOP = 4;\n\n  static const int SVG_FECOMPOSITE_OPERATOR_IN = 2;\n\n  static const int SVG_FECOMPOSITE_OPERATOR_OUT = 3;\n\n  static const int SVG_FECOMPOSITE_OPERATOR_OVER = 1;\n\n  static const int SVG_FECOMPOSITE_OPERATOR_UNKNOWN = 0;\n\n  static const int SVG_FECOMPOSITE_OPERATOR_XOR = 5;\n\n  @DomName('SVGFECompositeElement.in1')\n  @DocsEditable\n  final AnimatedString in1;\n\n  @DomName('SVGFECompositeElement.in2')\n  @DocsEditable\n  final AnimatedString in2;\n\n  @DomName('SVGFECompositeElement.k1')\n  @DocsEditable\n  final AnimatedNumber k1;\n\n  @DomName('SVGFECompositeElement.k2')\n  @DocsEditable\n  final AnimatedNumber k2;\n\n  @DomName('SVGFECompositeElement.k3')\n  @DocsEditable\n  final AnimatedNumber k3;\n\n  @DomName('SVGFECompositeElement.k4')\n  @DocsEditable\n  final AnimatedNumber k4;\n\n  @DomName('SVGFECompositeElement.operator')\n  @DocsEditable\n  final AnimatedEnumeration operator;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFECompositeElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFECompositeElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFECompositeElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFECompositeElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFECompositeElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEConvolveMatrixElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEConvolveMatrixElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFEConvolveMatrixElement\" {\n\n  @DomName('SVGFEConvolveMatrixElement.SVGFEConvolveMatrixElement')\n  @DocsEditable\n  factory FEConvolveMatrixElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feConvolveMatrix\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feConvolveMatrix') && (new SvgElement.tag('feConvolveMatrix') is FEConvolveMatrixElement);\n\n  static const int SVG_EDGEMODE_DUPLICATE = 1;\n\n  static const int SVG_EDGEMODE_NONE = 3;\n\n  static const int SVG_EDGEMODE_UNKNOWN = 0;\n\n  static const int SVG_EDGEMODE_WRAP = 2;\n\n  @DomName('SVGFEConvolveMatrixElement.bias')\n  @DocsEditable\n  final AnimatedNumber bias;\n\n  @DomName('SVGFEConvolveMatrixElement.divisor')\n  @DocsEditable\n  final AnimatedNumber divisor;\n\n  @DomName('SVGFEConvolveMatrixElement.edgeMode')\n  @DocsEditable\n  final AnimatedEnumeration edgeMode;\n\n  @DomName('SVGFEConvolveMatrixElement.in1')\n  @DocsEditable\n  final AnimatedString in1;\n\n  @DomName('SVGFEConvolveMatrixElement.kernelMatrix')\n  @DocsEditable\n  final AnimatedNumberList kernelMatrix;\n\n  @DomName('SVGFEConvolveMatrixElement.kernelUnitLengthX')\n  @DocsEditable\n  final AnimatedNumber kernelUnitLengthX;\n\n  @DomName('SVGFEConvolveMatrixElement.kernelUnitLengthY')\n  @DocsEditable\n  final AnimatedNumber kernelUnitLengthY;\n\n  @DomName('SVGFEConvolveMatrixElement.orderX')\n  @DocsEditable\n  final AnimatedInteger orderX;\n\n  @DomName('SVGFEConvolveMatrixElement.orderY')\n  @DocsEditable\n  final AnimatedInteger orderY;\n\n  @DomName('SVGFEConvolveMatrixElement.preserveAlpha')\n  @DocsEditable\n  final AnimatedBoolean preserveAlpha;\n\n  @DomName('SVGFEConvolveMatrixElement.targetX')\n  @DocsEditable\n  final AnimatedInteger targetX;\n\n  @DomName('SVGFEConvolveMatrixElement.targetY')\n  @DocsEditable\n  final AnimatedInteger targetY;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEConvolveMatrixElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFEConvolveMatrixElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFEConvolveMatrixElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFEConvolveMatrixElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFEConvolveMatrixElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEDiffuseLightingElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEDiffuseLightingElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFEDiffuseLightingElement\" {\n\n  @DomName('SVGFEDiffuseLightingElement.SVGFEDiffuseLightingElement')\n  @DocsEditable\n  factory FEDiffuseLightingElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feDiffuseLighting\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feDiffuseLighting') && (new SvgElement.tag('feDiffuseLighting') is FEDiffuseLightingElement);\n\n  @DomName('SVGFEDiffuseLightingElement.diffuseConstant')\n  @DocsEditable\n  final AnimatedNumber diffuseConstant;\n\n  @DomName('SVGFEDiffuseLightingElement.in1')\n  @DocsEditable\n  final AnimatedString in1;\n\n  @DomName('SVGFEDiffuseLightingElement.kernelUnitLengthX')\n  @DocsEditable\n  final AnimatedNumber kernelUnitLengthX;\n\n  @DomName('SVGFEDiffuseLightingElement.kernelUnitLengthY')\n  @DocsEditable\n  final AnimatedNumber kernelUnitLengthY;\n\n  @DomName('SVGFEDiffuseLightingElement.surfaceScale')\n  @DocsEditable\n  final AnimatedNumber surfaceScale;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEDiffuseLightingElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFEDiffuseLightingElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFEDiffuseLightingElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFEDiffuseLightingElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFEDiffuseLightingElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEDisplacementMapElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEDisplacementMapElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFEDisplacementMapElement\" {\n\n  @DomName('SVGFEDisplacementMapElement.SVGFEDisplacementMapElement')\n  @DocsEditable\n  factory FEDisplacementMapElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feDisplacementMap\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feDisplacementMap') && (new SvgElement.tag('feDisplacementMap') is FEDisplacementMapElement);\n\n  static const int SVG_CHANNEL_A = 4;\n\n  static const int SVG_CHANNEL_B = 3;\n\n  static const int SVG_CHANNEL_G = 2;\n\n  static const int SVG_CHANNEL_R = 1;\n\n  static const int SVG_CHANNEL_UNKNOWN = 0;\n\n  @DomName('SVGFEDisplacementMapElement.in1')\n  @DocsEditable\n  final AnimatedString in1;\n\n  @DomName('SVGFEDisplacementMapElement.in2')\n  @DocsEditable\n  final AnimatedString in2;\n\n  @DomName('SVGFEDisplacementMapElement.scale')\n  @DocsEditable\n  final AnimatedNumber scale;\n\n  @DomName('SVGFEDisplacementMapElement.xChannelSelector')\n  @DocsEditable\n  final AnimatedEnumeration xChannelSelector;\n\n  @DomName('SVGFEDisplacementMapElement.yChannelSelector')\n  @DocsEditable\n  final AnimatedEnumeration yChannelSelector;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEDisplacementMapElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFEDisplacementMapElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFEDisplacementMapElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFEDisplacementMapElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFEDisplacementMapElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEDistantLightElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEDistantLightElement extends SvgElement native \"SVGFEDistantLightElement\" {\n\n  @DomName('SVGFEDistantLightElement.SVGFEDistantLightElement')\n  @DocsEditable\n  factory FEDistantLightElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feDistantLight\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feDistantLight') && (new SvgElement.tag('feDistantLight') is FEDistantLightElement);\n\n  @DomName('SVGFEDistantLightElement.azimuth')\n  @DocsEditable\n  final AnimatedNumber azimuth;\n\n  @DomName('SVGFEDistantLightElement.elevation')\n  @DocsEditable\n  final AnimatedNumber elevation;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEFloodElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEFloodElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFEFloodElement\" {\n\n  @DomName('SVGFEFloodElement.SVGFEFloodElement')\n  @DocsEditable\n  factory FEFloodElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feFlood\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feFlood') && (new SvgElement.tag('feFlood') is FEFloodElement);\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEFloodElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFEFloodElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFEFloodElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFEFloodElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFEFloodElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEFuncAElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEFuncAElement extends _SVGComponentTransferFunctionElement native \"SVGFEFuncAElement\" {\n\n  @DomName('SVGFEFuncAElement.SVGFEFuncAElement')\n  @DocsEditable\n  factory FEFuncAElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feFuncA\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feFuncA') && (new SvgElement.tag('feFuncA') is FEFuncAElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEFuncBElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEFuncBElement extends _SVGComponentTransferFunctionElement native \"SVGFEFuncBElement\" {\n\n  @DomName('SVGFEFuncBElement.SVGFEFuncBElement')\n  @DocsEditable\n  factory FEFuncBElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feFuncB\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feFuncB') && (new SvgElement.tag('feFuncB') is FEFuncBElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEFuncGElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEFuncGElement extends _SVGComponentTransferFunctionElement native \"SVGFEFuncGElement\" {\n\n  @DomName('SVGFEFuncGElement.SVGFEFuncGElement')\n  @DocsEditable\n  factory FEFuncGElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feFuncG\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feFuncG') && (new SvgElement.tag('feFuncG') is FEFuncGElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEFuncRElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEFuncRElement extends _SVGComponentTransferFunctionElement native \"SVGFEFuncRElement\" {\n\n  @DomName('SVGFEFuncRElement.SVGFEFuncRElement')\n  @DocsEditable\n  factory FEFuncRElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feFuncR\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feFuncR') && (new SvgElement.tag('feFuncR') is FEFuncRElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEGaussianBlurElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEGaussianBlurElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFEGaussianBlurElement\" {\n\n  @DomName('SVGFEGaussianBlurElement.SVGFEGaussianBlurElement')\n  @DocsEditable\n  factory FEGaussianBlurElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feGaussianBlur\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feGaussianBlur') && (new SvgElement.tag('feGaussianBlur') is FEGaussianBlurElement);\n\n  @DomName('SVGFEGaussianBlurElement.in1')\n  @DocsEditable\n  final AnimatedString in1;\n\n  @DomName('SVGFEGaussianBlurElement.stdDeviationX')\n  @DocsEditable\n  final AnimatedNumber stdDeviationX;\n\n  @DomName('SVGFEGaussianBlurElement.stdDeviationY')\n  @DocsEditable\n  final AnimatedNumber stdDeviationY;\n\n  @DomName('SVGFEGaussianBlurElement.setStdDeviation')\n  @DocsEditable\n  void setStdDeviation(num stdDeviationX, num stdDeviationY) native;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEGaussianBlurElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFEGaussianBlurElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFEGaussianBlurElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFEGaussianBlurElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFEGaussianBlurElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEImageElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEImageElement extends StyledElement implements FilterPrimitiveStandardAttributes, UriReference, ExternalResourcesRequired, LangSpace native \"SVGFEImageElement\" {\n\n  @DomName('SVGFEImageElement.SVGFEImageElement')\n  @DocsEditable\n  factory FEImageElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feImage\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feImage') && (new SvgElement.tag('feImage') is FEImageElement);\n\n  @DomName('SVGFEImageElement.preserveAspectRatio')\n  @DocsEditable\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGFEImageElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEImageElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFEImageElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFEImageElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFEImageElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFEImageElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n\n  // From SVGLangSpace\n\n  @DomName('SVGFEImageElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGFEImageElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGURIReference\n\n  @DomName('SVGFEImageElement.href')\n  @DocsEditable\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEMergeElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEMergeElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFEMergeElement\" {\n\n  @DomName('SVGFEMergeElement.SVGFEMergeElement')\n  @DocsEditable\n  factory FEMergeElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feMerge\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feMerge') && (new SvgElement.tag('feMerge') is FEMergeElement);\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEMergeElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFEMergeElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFEMergeElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFEMergeElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFEMergeElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEMergeNodeElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEMergeNodeElement extends SvgElement native \"SVGFEMergeNodeElement\" {\n\n  @DomName('SVGFEMergeNodeElement.SVGFEMergeNodeElement')\n  @DocsEditable\n  factory FEMergeNodeElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feMergeNode\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feMergeNode') && (new SvgElement.tag('feMergeNode') is FEMergeNodeElement);\n\n  @DomName('SVGFEMergeNodeElement.in1')\n  @DocsEditable\n  final AnimatedString in1;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEMorphologyElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEMorphologyElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFEMorphologyElement\" {\n\n  static const int SVG_MORPHOLOGY_OPERATOR_DILATE = 2;\n\n  static const int SVG_MORPHOLOGY_OPERATOR_ERODE = 1;\n\n  static const int SVG_MORPHOLOGY_OPERATOR_UNKNOWN = 0;\n\n  @DomName('SVGFEMorphologyElement.in1')\n  @DocsEditable\n  final AnimatedString in1;\n\n  @DomName('SVGFEMorphologyElement.operator')\n  @DocsEditable\n  final AnimatedEnumeration operator;\n\n  @DomName('SVGFEMorphologyElement.radiusX')\n  @DocsEditable\n  final AnimatedNumber radiusX;\n\n  @DomName('SVGFEMorphologyElement.radiusY')\n  @DocsEditable\n  final AnimatedNumber radiusY;\n\n  @DomName('SVGFEMorphologyElement.setRadius')\n  @DocsEditable\n  void setRadius(num radiusX, num radiusY) native;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEMorphologyElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFEMorphologyElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFEMorphologyElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFEMorphologyElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFEMorphologyElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEOffsetElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEOffsetElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFEOffsetElement\" {\n\n  @DomName('SVGFEOffsetElement.SVGFEOffsetElement')\n  @DocsEditable\n  factory FEOffsetElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feOffset\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feOffset') && (new SvgElement.tag('feOffset') is FEOffsetElement);\n\n  @DomName('SVGFEOffsetElement.dx')\n  @DocsEditable\n  final AnimatedNumber dx;\n\n  @DomName('SVGFEOffsetElement.dy')\n  @DocsEditable\n  final AnimatedNumber dy;\n\n  @DomName('SVGFEOffsetElement.in1')\n  @DocsEditable\n  final AnimatedString in1;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEOffsetElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFEOffsetElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFEOffsetElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFEOffsetElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFEOffsetElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEPointLightElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FEPointLightElement extends SvgElement native \"SVGFEPointLightElement\" {\n\n  @DomName('SVGFEPointLightElement.SVGFEPointLightElement')\n  @DocsEditable\n  factory FEPointLightElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"fePointLight\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('fePointLight') && (new SvgElement.tag('fePointLight') is FEPointLightElement);\n\n  @DomName('SVGFEPointLightElement.x')\n  @DocsEditable\n  final AnimatedNumber x;\n\n  @DomName('SVGFEPointLightElement.y')\n  @DocsEditable\n  final AnimatedNumber y;\n\n  @DomName('SVGFEPointLightElement.z')\n  @DocsEditable\n  final AnimatedNumber z;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFESpecularLightingElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FESpecularLightingElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFESpecularLightingElement\" {\n\n  @DomName('SVGFESpecularLightingElement.SVGFESpecularLightingElement')\n  @DocsEditable\n  factory FESpecularLightingElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feSpecularLighting\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feSpecularLighting') && (new SvgElement.tag('feSpecularLighting') is FESpecularLightingElement);\n\n  @DomName('SVGFESpecularLightingElement.in1')\n  @DocsEditable\n  final AnimatedString in1;\n\n  @DomName('SVGFESpecularLightingElement.specularConstant')\n  @DocsEditable\n  final AnimatedNumber specularConstant;\n\n  @DomName('SVGFESpecularLightingElement.specularExponent')\n  @DocsEditable\n  final AnimatedNumber specularExponent;\n\n  @DomName('SVGFESpecularLightingElement.surfaceScale')\n  @DocsEditable\n  final AnimatedNumber surfaceScale;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFESpecularLightingElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFESpecularLightingElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFESpecularLightingElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFESpecularLightingElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFESpecularLightingElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFESpotLightElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FESpotLightElement extends SvgElement native \"SVGFESpotLightElement\" {\n\n  @DomName('SVGFESpotLightElement.SVGFESpotLightElement')\n  @DocsEditable\n  factory FESpotLightElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feSpotLight\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feSpotLight') && (new SvgElement.tag('feSpotLight') is FESpotLightElement);\n\n  @DomName('SVGFESpotLightElement.limitingConeAngle')\n  @DocsEditable\n  final AnimatedNumber limitingConeAngle;\n\n  @DomName('SVGFESpotLightElement.pointsAtX')\n  @DocsEditable\n  final AnimatedNumber pointsAtX;\n\n  @DomName('SVGFESpotLightElement.pointsAtY')\n  @DocsEditable\n  final AnimatedNumber pointsAtY;\n\n  @DomName('SVGFESpotLightElement.pointsAtZ')\n  @DocsEditable\n  final AnimatedNumber pointsAtZ;\n\n  @DomName('SVGFESpotLightElement.specularExponent')\n  @DocsEditable\n  final AnimatedNumber specularExponent;\n\n  @DomName('SVGFESpotLightElement.x')\n  @DocsEditable\n  final AnimatedNumber x;\n\n  @DomName('SVGFESpotLightElement.y')\n  @DocsEditable\n  final AnimatedNumber y;\n\n  @DomName('SVGFESpotLightElement.z')\n  @DocsEditable\n  final AnimatedNumber z;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFETileElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FETileElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFETileElement\" {\n\n  @DomName('SVGFETileElement.SVGFETileElement')\n  @DocsEditable\n  factory FETileElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feTile\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feTile') && (new SvgElement.tag('feTile') is FETileElement);\n\n  @DomName('SVGFETileElement.in1')\n  @DocsEditable\n  final AnimatedString in1;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFETileElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFETileElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFETileElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFETileElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFETileElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFETurbulenceElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FETurbulenceElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFETurbulenceElement\" {\n\n  @DomName('SVGFETurbulenceElement.SVGFETurbulenceElement')\n  @DocsEditable\n  factory FETurbulenceElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feTurbulence\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feTurbulence') && (new SvgElement.tag('feTurbulence') is FETurbulenceElement);\n\n  static const int SVG_STITCHTYPE_NOSTITCH = 2;\n\n  static const int SVG_STITCHTYPE_STITCH = 1;\n\n  static const int SVG_STITCHTYPE_UNKNOWN = 0;\n\n  static const int SVG_TURBULENCE_TYPE_FRACTALNOISE = 1;\n\n  static const int SVG_TURBULENCE_TYPE_TURBULENCE = 2;\n\n  static const int SVG_TURBULENCE_TYPE_UNKNOWN = 0;\n\n  @DomName('SVGFETurbulenceElement.baseFrequencyX')\n  @DocsEditable\n  final AnimatedNumber baseFrequencyX;\n\n  @DomName('SVGFETurbulenceElement.baseFrequencyY')\n  @DocsEditable\n  final AnimatedNumber baseFrequencyY;\n\n  @DomName('SVGFETurbulenceElement.numOctaves')\n  @DocsEditable\n  final AnimatedInteger numOctaves;\n\n  @DomName('SVGFETurbulenceElement.seed')\n  @DocsEditable\n  final AnimatedNumber seed;\n\n  @DomName('SVGFETurbulenceElement.stitchTiles')\n  @DocsEditable\n  final AnimatedEnumeration stitchTiles;\n\n  @DomName('SVGFETurbulenceElement.type')\n  @DocsEditable\n  final AnimatedEnumeration type;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFETurbulenceElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFETurbulenceElement.result')\n  @DocsEditable\n  final AnimatedString result;\n\n  @DomName('SVGFETurbulenceElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFETurbulenceElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFETurbulenceElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFilterElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass FilterElement extends StyledElement implements UriReference, ExternalResourcesRequired, LangSpace native \"SVGFilterElement\" {\n\n  @DomName('SVGFilterElement.SVGFilterElement')\n  @DocsEditable\n  factory FilterElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"filter\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('filter') && (new SvgElement.tag('filter') is FilterElement);\n\n  @DomName('SVGFilterElement.filterResX')\n  @DocsEditable\n  final AnimatedInteger filterResX;\n\n  @DomName('SVGFilterElement.filterResY')\n  @DocsEditable\n  final AnimatedInteger filterResY;\n\n  @DomName('SVGFilterElement.filterUnits')\n  @DocsEditable\n  final AnimatedEnumeration filterUnits;\n\n  @DomName('SVGFilterElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGFilterElement.primitiveUnits')\n  @DocsEditable\n  final AnimatedEnumeration primitiveUnits;\n\n  @DomName('SVGFilterElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGFilterElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGFilterElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n\n  @DomName('SVGFilterElement.setFilterRes')\n  @DocsEditable\n  void setFilterRes(int filterResX, int filterResY) native;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGFilterElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGFilterElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGFilterElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGURIReference\n\n  @DomName('SVGFilterElement.href')\n  @DocsEditable\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('SVGFilterPrimitiveStandardAttributes')\nabstract class FilterPrimitiveStandardAttributes {\n\n  AnimatedLength height;\n\n  AnimatedString result;\n\n  AnimatedLength width;\n\n  AnimatedLength x;\n\n  AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('SVGFitToViewBox')\nabstract class FitToViewBox {\n\n  AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  AnimatedRect viewBox;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGForeignObjectElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass ForeignObjectElement extends StyledElement implements Transformable, Tests, ExternalResourcesRequired, LangSpace native \"SVGForeignObjectElement\" {\n\n  @DomName('SVGForeignObjectElement.SVGForeignObjectElement')\n  @DocsEditable\n  factory ForeignObjectElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"foreignObject\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('foreignObject') && (new SvgElement.tag('foreignObject') is ForeignObjectElement);\n\n  @DomName('SVGForeignObjectElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGForeignObjectElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGForeignObjectElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGForeignObjectElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGForeignObjectElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGForeignObjectElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGForeignObjectElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGForeignObjectElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGForeignObjectElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGForeignObjectElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGForeignObjectElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGForeignObjectElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGForeignObjectElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGForeignObjectElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGForeignObjectElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGForeignObjectElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGForeignObjectElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGForeignObjectElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGGElement')\nclass GElement extends StyledElement implements Transformable, Tests, ExternalResourcesRequired, LangSpace native \"SVGGElement\" {\n\n  @DomName('SVGGElement.SVGGElement')\n  @DocsEditable\n  factory GElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"g\");\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGGElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGGElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGGElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGGElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGGElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGGElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGGElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGGElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGGElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGGElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGGElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGGElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGGElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGGElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGImageElement')\nclass ImageElement extends StyledElement implements UriReference, Tests, Transformable, ExternalResourcesRequired, LangSpace native \"SVGImageElement\" {\n\n  @DomName('SVGImageElement.SVGImageElement')\n  @DocsEditable\n  factory ImageElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"image\");\n\n  @DomName('SVGImageElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGImageElement.preserveAspectRatio')\n  @DocsEditable\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  @DomName('SVGImageElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGImageElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGImageElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGImageElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGImageElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGImageElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGImageElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGImageElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGImageElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGImageElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGImageElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGImageElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGImageElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGImageElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGImageElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGImageElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGImageElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n\n  // From SVGURIReference\n\n  @DomName('SVGImageElement.href')\n  @DocsEditable\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('SVGLangSpace')\nabstract class LangSpace {\n\n  /// Checks if this type is supported on the current platform.\n  static bool supported(SvgElement element) => JS('bool', '#.xmlspace !== undefined && #.xmllang !== undefined', element, element);\n\n  String xmllang;\n\n  String xmlspace;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGLength')\nclass Length native \"SVGLength\" {\n\n  static const int SVG_LENGTHTYPE_CM = 6;\n\n  static const int SVG_LENGTHTYPE_EMS = 3;\n\n  static const int SVG_LENGTHTYPE_EXS = 4;\n\n  static const int SVG_LENGTHTYPE_IN = 8;\n\n  static const int SVG_LENGTHTYPE_MM = 7;\n\n  static const int SVG_LENGTHTYPE_NUMBER = 1;\n\n  static const int SVG_LENGTHTYPE_PC = 10;\n\n  static const int SVG_LENGTHTYPE_PERCENTAGE = 2;\n\n  static const int SVG_LENGTHTYPE_PT = 9;\n\n  static const int SVG_LENGTHTYPE_PX = 5;\n\n  static const int SVG_LENGTHTYPE_UNKNOWN = 0;\n\n  @DomName('SVGLength.unitType')\n  @DocsEditable\n  final int unitType;\n\n  @DomName('SVGLength.value')\n  @DocsEditable\n  num value;\n\n  @DomName('SVGLength.valueAsString')\n  @DocsEditable\n  String valueAsString;\n\n  @DomName('SVGLength.valueInSpecifiedUnits')\n  @DocsEditable\n  num valueInSpecifiedUnits;\n\n  @DomName('SVGLength.convertToSpecifiedUnits')\n  @DocsEditable\n  void convertToSpecifiedUnits(int unitType) native;\n\n  @DomName('SVGLength.newValueSpecifiedUnits')\n  @DocsEditable\n  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGLengthList')\nclass LengthList implements JavaScriptIndexingBehavior, List<Length> native \"SVGLengthList\" {\n\n  @DomName('SVGLengthList.numberOfItems')\n  @DocsEditable\n  final int numberOfItems;\n\n  Length operator[](int index) => this.getItem(index);\n\n  void operator[]=(int index, Length value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Length> mixins.\n  // Length is the element type.\n\n  // From Iterable<Length>:\n\n  Iterator<Length> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<Length>(this);\n  }\n\n  // SVG Collections expose numberOfItems rather than length.\n  int get length => numberOfItems;\n  Length reduce(Length combine(Length value, Length element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, Length element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(Length element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(Length element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(Length element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<Length> where(bool f(Length element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(Length element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(Length element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(Length element)) => IterableMixinWorkaround.any(this, f);\n\n  List<Length> toList({ bool growable: true }) =>\n      new List<Length>.from(this, growable: growable);\n\n  Set<Length> toSet() => new Set<Length>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<Length> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<Length> takeWhile(bool test(Length value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<Length> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<Length> skipWhile(bool test(Length value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  Length firstWhere(bool test(Length value), { Length orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  Length lastWhere(bool test(Length value), {Length orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  Length singleWhere(bool test(Length value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  Length elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<Length>:\n\n  void add(Length value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<Length> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<Length>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  // clear() defined by IDL.\n\n  Iterable<Length> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(Length a, Length b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(Length element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(Length element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  Length get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  Length get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  Length get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, Length element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<Length> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<Length> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Length removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  Length removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(Length element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(Length element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<Length> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<Length> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [Length fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<Length> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<Length> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <Length>[]);\n  }\n\n  Map<int, Length> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<Length> mixins.\n\n  @DomName('SVGLengthList.appendItem')\n  @DocsEditable\n  Length appendItem(Length item) native;\n\n  @DomName('SVGLengthList.clear')\n  @DocsEditable\n  void clear() native;\n\n  @DomName('SVGLengthList.getItem')\n  @DocsEditable\n  Length getItem(int index) native;\n\n  @DomName('SVGLengthList.initialize')\n  @DocsEditable\n  Length initialize(Length item) native;\n\n  @DomName('SVGLengthList.insertItemBefore')\n  @DocsEditable\n  Length insertItemBefore(Length item, int index) native;\n\n  @DomName('SVGLengthList.removeItem')\n  @DocsEditable\n  Length removeItem(int index) native;\n\n  @DomName('SVGLengthList.replaceItem')\n  @DocsEditable\n  Length replaceItem(Length item, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGLineElement')\nclass LineElement extends StyledElement implements Transformable, Tests, ExternalResourcesRequired, LangSpace native \"SVGLineElement\" {\n\n  @DomName('SVGLineElement.SVGLineElement')\n  @DocsEditable\n  factory LineElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"line\");\n\n  @DomName('SVGLineElement.x1')\n  @DocsEditable\n  final AnimatedLength x1;\n\n  @DomName('SVGLineElement.x2')\n  @DocsEditable\n  final AnimatedLength x2;\n\n  @DomName('SVGLineElement.y1')\n  @DocsEditable\n  final AnimatedLength y1;\n\n  @DomName('SVGLineElement.y2')\n  @DocsEditable\n  final AnimatedLength y2;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGLineElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGLineElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGLineElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGLineElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGLineElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGLineElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGLineElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGLineElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGLineElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGLineElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGLineElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGLineElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGLineElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGLineElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGLinearGradientElement')\nclass LinearGradientElement extends _GradientElement native \"SVGLinearGradientElement\" {\n\n  @DomName('SVGLinearGradientElement.SVGLinearGradientElement')\n  @DocsEditable\n  factory LinearGradientElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"linearGradient\");\n\n  @DomName('SVGLinearGradientElement.x1')\n  @DocsEditable\n  final AnimatedLength x1;\n\n  @DomName('SVGLinearGradientElement.x2')\n  @DocsEditable\n  final AnimatedLength x2;\n\n  @DomName('SVGLinearGradientElement.y1')\n  @DocsEditable\n  final AnimatedLength y1;\n\n  @DomName('SVGLinearGradientElement.y2')\n  @DocsEditable\n  final AnimatedLength y2;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('SVGLocatable')\nabstract class Locatable {\n\n  SvgElement farthestViewportElement;\n\n  SvgElement nearestViewportElement;\n\n  Rect getBBox();\n\n  Matrix getCTM();\n\n  Matrix getScreenCTM();\n\n  Matrix getTransformToElement(SvgElement element);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGMarkerElement')\nclass MarkerElement extends StyledElement implements FitToViewBox, ExternalResourcesRequired, LangSpace native \"SVGMarkerElement\" {\n\n  @DomName('SVGMarkerElement.SVGMarkerElement')\n  @DocsEditable\n  factory MarkerElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"marker\");\n\n  static const int SVG_MARKERUNITS_STROKEWIDTH = 2;\n\n  static const int SVG_MARKERUNITS_UNKNOWN = 0;\n\n  static const int SVG_MARKERUNITS_USERSPACEONUSE = 1;\n\n  static const int SVG_MARKER_ORIENT_ANGLE = 2;\n\n  static const int SVG_MARKER_ORIENT_AUTO = 1;\n\n  static const int SVG_MARKER_ORIENT_UNKNOWN = 0;\n\n  @DomName('SVGMarkerElement.markerHeight')\n  @DocsEditable\n  final AnimatedLength markerHeight;\n\n  @DomName('SVGMarkerElement.markerUnits')\n  @DocsEditable\n  final AnimatedEnumeration markerUnits;\n\n  @DomName('SVGMarkerElement.markerWidth')\n  @DocsEditable\n  final AnimatedLength markerWidth;\n\n  @DomName('SVGMarkerElement.orientAngle')\n  @DocsEditable\n  final AnimatedAngle orientAngle;\n\n  @DomName('SVGMarkerElement.orientType')\n  @DocsEditable\n  final AnimatedEnumeration orientType;\n\n  @DomName('SVGMarkerElement.refX')\n  @DocsEditable\n  final AnimatedLength refX;\n\n  @DomName('SVGMarkerElement.refY')\n  @DocsEditable\n  final AnimatedLength refY;\n\n  @DomName('SVGMarkerElement.setOrientToAngle')\n  @DocsEditable\n  void setOrientToAngle(Angle angle) native;\n\n  @DomName('SVGMarkerElement.setOrientToAuto')\n  @DocsEditable\n  void setOrientToAuto() native;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGMarkerElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGFitToViewBox\n\n  @DomName('SVGMarkerElement.preserveAspectRatio')\n  @DocsEditable\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  @DomName('SVGMarkerElement.viewBox')\n  @DocsEditable\n  final AnimatedRect viewBox;\n\n  // From SVGLangSpace\n\n  @DomName('SVGMarkerElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGMarkerElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGMaskElement')\nclass MaskElement extends StyledElement implements Tests, ExternalResourcesRequired, LangSpace native \"SVGMaskElement\" {\n\n  @DomName('SVGMaskElement.SVGMaskElement')\n  @DocsEditable\n  factory MaskElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"mask\");\n\n  @DomName('SVGMaskElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGMaskElement.maskContentUnits')\n  @DocsEditable\n  final AnimatedEnumeration maskContentUnits;\n\n  @DomName('SVGMaskElement.maskUnits')\n  @DocsEditable\n  final AnimatedEnumeration maskUnits;\n\n  @DomName('SVGMaskElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGMaskElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGMaskElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGMaskElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGMaskElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGMaskElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGTests\n\n  @DomName('SVGMaskElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGMaskElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGMaskElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGMaskElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGMatrix')\nclass Matrix native \"SVGMatrix\" {\n\n  @DomName('SVGMatrix.a')\n  @DocsEditable\n  num a;\n\n  @DomName('SVGMatrix.b')\n  @DocsEditable\n  num b;\n\n  @DomName('SVGMatrix.c')\n  @DocsEditable\n  num c;\n\n  @DomName('SVGMatrix.d')\n  @DocsEditable\n  num d;\n\n  @DomName('SVGMatrix.e')\n  @DocsEditable\n  num e;\n\n  @DomName('SVGMatrix.f')\n  @DocsEditable\n  num f;\n\n  @DomName('SVGMatrix.flipX')\n  @DocsEditable\n  Matrix flipX() native;\n\n  @DomName('SVGMatrix.flipY')\n  @DocsEditable\n  Matrix flipY() native;\n\n  @DomName('SVGMatrix.inverse')\n  @DocsEditable\n  Matrix inverse() native;\n\n  @DomName('SVGMatrix.multiply')\n  @DocsEditable\n  Matrix multiply(Matrix secondMatrix) native;\n\n  @DomName('SVGMatrix.rotate')\n  @DocsEditable\n  Matrix rotate(num angle) native;\n\n  @DomName('SVGMatrix.rotateFromVector')\n  @DocsEditable\n  Matrix rotateFromVector(num x, num y) native;\n\n  @DomName('SVGMatrix.scale')\n  @DocsEditable\n  Matrix scale(num scaleFactor) native;\n\n  @DomName('SVGMatrix.scaleNonUniform')\n  @DocsEditable\n  Matrix scaleNonUniform(num scaleFactorX, num scaleFactorY) native;\n\n  @DomName('SVGMatrix.skewX')\n  @DocsEditable\n  Matrix skewX(num angle) native;\n\n  @DomName('SVGMatrix.skewY')\n  @DocsEditable\n  Matrix skewY(num angle) native;\n\n  @DomName('SVGMatrix.translate')\n  @DocsEditable\n  Matrix translate(num x, num y) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGMetadataElement')\nclass MetadataElement extends SvgElement native \"SVGMetadataElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGNumber')\nclass Number native \"SVGNumber\" {\n\n  @DomName('SVGNumber.value')\n  @DocsEditable\n  num value;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGNumberList')\nclass NumberList implements JavaScriptIndexingBehavior, List<Number> native \"SVGNumberList\" {\n\n  @DomName('SVGNumberList.numberOfItems')\n  @DocsEditable\n  final int numberOfItems;\n\n  Number operator[](int index) => this.getItem(index);\n\n  void operator[]=(int index, Number value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Number> mixins.\n  // Number is the element type.\n\n  // From Iterable<Number>:\n\n  Iterator<Number> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<Number>(this);\n  }\n\n  // SVG Collections expose numberOfItems rather than length.\n  int get length => numberOfItems;\n  Number reduce(Number combine(Number value, Number element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, Number element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(Number element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(Number element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(Number element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<Number> where(bool f(Number element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(Number element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(Number element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(Number element)) => IterableMixinWorkaround.any(this, f);\n\n  List<Number> toList({ bool growable: true }) =>\n      new List<Number>.from(this, growable: growable);\n\n  Set<Number> toSet() => new Set<Number>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<Number> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<Number> takeWhile(bool test(Number value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<Number> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<Number> skipWhile(bool test(Number value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  Number firstWhere(bool test(Number value), { Number orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  Number lastWhere(bool test(Number value), {Number orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  Number singleWhere(bool test(Number value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  Number elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<Number>:\n\n  void add(Number value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<Number> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<Number>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  // clear() defined by IDL.\n\n  Iterable<Number> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(Number a, Number b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(Number element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(Number element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  Number get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  Number get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  Number get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, Number element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<Number> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<Number> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Number removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  Number removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(Number element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(Number element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<Number> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<Number> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [Number fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<Number> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<Number> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <Number>[]);\n  }\n\n  Map<int, Number> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<Number> mixins.\n\n  @DomName('SVGNumberList.appendItem')\n  @DocsEditable\n  Number appendItem(Number item) native;\n\n  @DomName('SVGNumberList.clear')\n  @DocsEditable\n  void clear() native;\n\n  @DomName('SVGNumberList.getItem')\n  @DocsEditable\n  Number getItem(int index) native;\n\n  @DomName('SVGNumberList.initialize')\n  @DocsEditable\n  Number initialize(Number item) native;\n\n  @DomName('SVGNumberList.insertItemBefore')\n  @DocsEditable\n  Number insertItemBefore(Number item, int index) native;\n\n  @DomName('SVGNumberList.removeItem')\n  @DocsEditable\n  Number removeItem(int index) native;\n\n  @DomName('SVGNumberList.replaceItem')\n  @DocsEditable\n  Number replaceItem(Number item, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathElement')\nclass PathElement extends StyledElement implements Transformable, Tests, ExternalResourcesRequired, LangSpace native \"SVGPathElement\" {\n\n  @DomName('SVGPathElement.SVGPathElement')\n  @DocsEditable\n  factory PathElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"path\");\n\n  @DomName('SVGPathElement.animatedNormalizedPathSegList')\n  @DocsEditable\n  final PathSegList animatedNormalizedPathSegList;\n\n  @DomName('SVGPathElement.animatedPathSegList')\n  @DocsEditable\n  final PathSegList animatedPathSegList;\n\n  @DomName('SVGPathElement.normalizedPathSegList')\n  @DocsEditable\n  final PathSegList normalizedPathSegList;\n\n  @DomName('SVGPathElement.pathLength')\n  @DocsEditable\n  final AnimatedNumber pathLength;\n\n  @DomName('SVGPathElement.pathSegList')\n  @DocsEditable\n  final PathSegList pathSegList;\n\n  @JSName('createSVGPathSegArcAbs')\n  @DomName('SVGPathElement.createSVGPathSegArcAbs')\n  @DocsEditable\n  PathSegArcAbs createSvgPathSegArcAbs(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) native;\n\n  @JSName('createSVGPathSegArcRel')\n  @DomName('SVGPathElement.createSVGPathSegArcRel')\n  @DocsEditable\n  PathSegArcRel createSvgPathSegArcRel(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) native;\n\n  @JSName('createSVGPathSegClosePath')\n  @DomName('SVGPathElement.createSVGPathSegClosePath')\n  @DocsEditable\n  PathSegClosePath createSvgPathSegClosePath() native;\n\n  @JSName('createSVGPathSegCurvetoCubicAbs')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoCubicAbs')\n  @DocsEditable\n  PathSegCurvetoCubicAbs createSvgPathSegCurvetoCubicAbs(num x, num y, num x1, num y1, num x2, num y2) native;\n\n  @JSName('createSVGPathSegCurvetoCubicRel')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoCubicRel')\n  @DocsEditable\n  PathSegCurvetoCubicRel createSvgPathSegCurvetoCubicRel(num x, num y, num x1, num y1, num x2, num y2) native;\n\n  @JSName('createSVGPathSegCurvetoCubicSmoothAbs')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoCubicSmoothAbs')\n  @DocsEditable\n  PathSegCurvetoCubicSmoothAbs createSvgPathSegCurvetoCubicSmoothAbs(num x, num y, num x2, num y2) native;\n\n  @JSName('createSVGPathSegCurvetoCubicSmoothRel')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoCubicSmoothRel')\n  @DocsEditable\n  PathSegCurvetoCubicSmoothRel createSvgPathSegCurvetoCubicSmoothRel(num x, num y, num x2, num y2) native;\n\n  @JSName('createSVGPathSegCurvetoQuadraticAbs')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoQuadraticAbs')\n  @DocsEditable\n  PathSegCurvetoQuadraticAbs createSvgPathSegCurvetoQuadraticAbs(num x, num y, num x1, num y1) native;\n\n  @JSName('createSVGPathSegCurvetoQuadraticRel')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoQuadraticRel')\n  @DocsEditable\n  PathSegCurvetoQuadraticRel createSvgPathSegCurvetoQuadraticRel(num x, num y, num x1, num y1) native;\n\n  @JSName('createSVGPathSegCurvetoQuadraticSmoothAbs')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoQuadraticSmoothAbs')\n  @DocsEditable\n  PathSegCurvetoQuadraticSmoothAbs createSvgPathSegCurvetoQuadraticSmoothAbs(num x, num y) native;\n\n  @JSName('createSVGPathSegCurvetoQuadraticSmoothRel')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoQuadraticSmoothRel')\n  @DocsEditable\n  PathSegCurvetoQuadraticSmoothRel createSvgPathSegCurvetoQuadraticSmoothRel(num x, num y) native;\n\n  @JSName('createSVGPathSegLinetoAbs')\n  @DomName('SVGPathElement.createSVGPathSegLinetoAbs')\n  @DocsEditable\n  PathSegLinetoAbs createSvgPathSegLinetoAbs(num x, num y) native;\n\n  @JSName('createSVGPathSegLinetoHorizontalAbs')\n  @DomName('SVGPathElement.createSVGPathSegLinetoHorizontalAbs')\n  @DocsEditable\n  PathSegLinetoHorizontalAbs createSvgPathSegLinetoHorizontalAbs(num x) native;\n\n  @JSName('createSVGPathSegLinetoHorizontalRel')\n  @DomName('SVGPathElement.createSVGPathSegLinetoHorizontalRel')\n  @DocsEditable\n  PathSegLinetoHorizontalRel createSvgPathSegLinetoHorizontalRel(num x) native;\n\n  @JSName('createSVGPathSegLinetoRel')\n  @DomName('SVGPathElement.createSVGPathSegLinetoRel')\n  @DocsEditable\n  PathSegLinetoRel createSvgPathSegLinetoRel(num x, num y) native;\n\n  @JSName('createSVGPathSegLinetoVerticalAbs')\n  @DomName('SVGPathElement.createSVGPathSegLinetoVerticalAbs')\n  @DocsEditable\n  PathSegLinetoVerticalAbs createSvgPathSegLinetoVerticalAbs(num y) native;\n\n  @JSName('createSVGPathSegLinetoVerticalRel')\n  @DomName('SVGPathElement.createSVGPathSegLinetoVerticalRel')\n  @DocsEditable\n  PathSegLinetoVerticalRel createSvgPathSegLinetoVerticalRel(num y) native;\n\n  @JSName('createSVGPathSegMovetoAbs')\n  @DomName('SVGPathElement.createSVGPathSegMovetoAbs')\n  @DocsEditable\n  PathSegMovetoAbs createSvgPathSegMovetoAbs(num x, num y) native;\n\n  @JSName('createSVGPathSegMovetoRel')\n  @DomName('SVGPathElement.createSVGPathSegMovetoRel')\n  @DocsEditable\n  PathSegMovetoRel createSvgPathSegMovetoRel(num x, num y) native;\n\n  @DomName('SVGPathElement.getPathSegAtLength')\n  @DocsEditable\n  int getPathSegAtLength(num distance) native;\n\n  @DomName('SVGPathElement.getPointAtLength')\n  @DocsEditable\n  Point getPointAtLength(num distance) native;\n\n  @DomName('SVGPathElement.getTotalLength')\n  @DocsEditable\n  num getTotalLength() native;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGPathElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGPathElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGPathElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGPathElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGPathElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGPathElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGPathElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGPathElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGPathElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGPathElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGPathElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGPathElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGPathElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGPathElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSeg')\nclass PathSeg native \"SVGPathSeg\" {\n\n  static const int PATHSEG_ARC_ABS = 10;\n\n  static const int PATHSEG_ARC_REL = 11;\n\n  static const int PATHSEG_CLOSEPATH = 1;\n\n  static const int PATHSEG_CURVETO_CUBIC_ABS = 6;\n\n  static const int PATHSEG_CURVETO_CUBIC_REL = 7;\n\n  static const int PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;\n\n  static const int PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;\n\n  static const int PATHSEG_CURVETO_QUADRATIC_ABS = 8;\n\n  static const int PATHSEG_CURVETO_QUADRATIC_REL = 9;\n\n  static const int PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;\n\n  static const int PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;\n\n  static const int PATHSEG_LINETO_ABS = 4;\n\n  static const int PATHSEG_LINETO_HORIZONTAL_ABS = 12;\n\n  static const int PATHSEG_LINETO_HORIZONTAL_REL = 13;\n\n  static const int PATHSEG_LINETO_REL = 5;\n\n  static const int PATHSEG_LINETO_VERTICAL_ABS = 14;\n\n  static const int PATHSEG_LINETO_VERTICAL_REL = 15;\n\n  static const int PATHSEG_MOVETO_ABS = 2;\n\n  static const int PATHSEG_MOVETO_REL = 3;\n\n  static const int PATHSEG_UNKNOWN = 0;\n\n  @DomName('SVGPathSeg.pathSegType')\n  @DocsEditable\n  final int pathSegType;\n\n  @DomName('SVGPathSeg.pathSegTypeAsLetter')\n  @DocsEditable\n  final String pathSegTypeAsLetter;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegArcAbs')\nclass PathSegArcAbs extends PathSeg native \"SVGPathSegArcAbs\" {\n\n  @DomName('SVGPathSegArcAbs.angle')\n  @DocsEditable\n  num angle;\n\n  @DomName('SVGPathSegArcAbs.largeArcFlag')\n  @DocsEditable\n  bool largeArcFlag;\n\n  @DomName('SVGPathSegArcAbs.r1')\n  @DocsEditable\n  num r1;\n\n  @DomName('SVGPathSegArcAbs.r2')\n  @DocsEditable\n  num r2;\n\n  @DomName('SVGPathSegArcAbs.sweepFlag')\n  @DocsEditable\n  bool sweepFlag;\n\n  @DomName('SVGPathSegArcAbs.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGPathSegArcAbs.y')\n  @DocsEditable\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegArcRel')\nclass PathSegArcRel extends PathSeg native \"SVGPathSegArcRel\" {\n\n  @DomName('SVGPathSegArcRel.angle')\n  @DocsEditable\n  num angle;\n\n  @DomName('SVGPathSegArcRel.largeArcFlag')\n  @DocsEditable\n  bool largeArcFlag;\n\n  @DomName('SVGPathSegArcRel.r1')\n  @DocsEditable\n  num r1;\n\n  @DomName('SVGPathSegArcRel.r2')\n  @DocsEditable\n  num r2;\n\n  @DomName('SVGPathSegArcRel.sweepFlag')\n  @DocsEditable\n  bool sweepFlag;\n\n  @DomName('SVGPathSegArcRel.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGPathSegArcRel.y')\n  @DocsEditable\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegClosePath')\nclass PathSegClosePath extends PathSeg native \"SVGPathSegClosePath\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegCurvetoCubicAbs')\nclass PathSegCurvetoCubicAbs extends PathSeg native \"SVGPathSegCurvetoCubicAbs\" {\n\n  @DomName('SVGPathSegCurvetoCubicAbs.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGPathSegCurvetoCubicAbs.x1')\n  @DocsEditable\n  num x1;\n\n  @DomName('SVGPathSegCurvetoCubicAbs.x2')\n  @DocsEditable\n  num x2;\n\n  @DomName('SVGPathSegCurvetoCubicAbs.y')\n  @DocsEditable\n  num y;\n\n  @DomName('SVGPathSegCurvetoCubicAbs.y1')\n  @DocsEditable\n  num y1;\n\n  @DomName('SVGPathSegCurvetoCubicAbs.y2')\n  @DocsEditable\n  num y2;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegCurvetoCubicRel')\nclass PathSegCurvetoCubicRel extends PathSeg native \"SVGPathSegCurvetoCubicRel\" {\n\n  @DomName('SVGPathSegCurvetoCubicRel.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGPathSegCurvetoCubicRel.x1')\n  @DocsEditable\n  num x1;\n\n  @DomName('SVGPathSegCurvetoCubicRel.x2')\n  @DocsEditable\n  num x2;\n\n  @DomName('SVGPathSegCurvetoCubicRel.y')\n  @DocsEditable\n  num y;\n\n  @DomName('SVGPathSegCurvetoCubicRel.y1')\n  @DocsEditable\n  num y1;\n\n  @DomName('SVGPathSegCurvetoCubicRel.y2')\n  @DocsEditable\n  num y2;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegCurvetoCubicSmoothAbs')\nclass PathSegCurvetoCubicSmoothAbs extends PathSeg native \"SVGPathSegCurvetoCubicSmoothAbs\" {\n\n  @DomName('SVGPathSegCurvetoCubicSmoothAbs.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGPathSegCurvetoCubicSmoothAbs.x2')\n  @DocsEditable\n  num x2;\n\n  @DomName('SVGPathSegCurvetoCubicSmoothAbs.y')\n  @DocsEditable\n  num y;\n\n  @DomName('SVGPathSegCurvetoCubicSmoothAbs.y2')\n  @DocsEditable\n  num y2;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegCurvetoCubicSmoothRel')\nclass PathSegCurvetoCubicSmoothRel extends PathSeg native \"SVGPathSegCurvetoCubicSmoothRel\" {\n\n  @DomName('SVGPathSegCurvetoCubicSmoothRel.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGPathSegCurvetoCubicSmoothRel.x2')\n  @DocsEditable\n  num x2;\n\n  @DomName('SVGPathSegCurvetoCubicSmoothRel.y')\n  @DocsEditable\n  num y;\n\n  @DomName('SVGPathSegCurvetoCubicSmoothRel.y2')\n  @DocsEditable\n  num y2;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegCurvetoQuadraticAbs')\nclass PathSegCurvetoQuadraticAbs extends PathSeg native \"SVGPathSegCurvetoQuadraticAbs\" {\n\n  @DomName('SVGPathSegCurvetoQuadraticAbs.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGPathSegCurvetoQuadraticAbs.x1')\n  @DocsEditable\n  num x1;\n\n  @DomName('SVGPathSegCurvetoQuadraticAbs.y')\n  @DocsEditable\n  num y;\n\n  @DomName('SVGPathSegCurvetoQuadraticAbs.y1')\n  @DocsEditable\n  num y1;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegCurvetoQuadraticRel')\nclass PathSegCurvetoQuadraticRel extends PathSeg native \"SVGPathSegCurvetoQuadraticRel\" {\n\n  @DomName('SVGPathSegCurvetoQuadraticRel.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGPathSegCurvetoQuadraticRel.x1')\n  @DocsEditable\n  num x1;\n\n  @DomName('SVGPathSegCurvetoQuadraticRel.y')\n  @DocsEditable\n  num y;\n\n  @DomName('SVGPathSegCurvetoQuadraticRel.y1')\n  @DocsEditable\n  num y1;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegCurvetoQuadraticSmoothAbs')\nclass PathSegCurvetoQuadraticSmoothAbs extends PathSeg native \"SVGPathSegCurvetoQuadraticSmoothAbs\" {\n\n  @DomName('SVGPathSegCurvetoQuadraticSmoothAbs.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGPathSegCurvetoQuadraticSmoothAbs.y')\n  @DocsEditable\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegCurvetoQuadraticSmoothRel')\nclass PathSegCurvetoQuadraticSmoothRel extends PathSeg native \"SVGPathSegCurvetoQuadraticSmoothRel\" {\n\n  @DomName('SVGPathSegCurvetoQuadraticSmoothRel.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGPathSegCurvetoQuadraticSmoothRel.y')\n  @DocsEditable\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegLinetoAbs')\nclass PathSegLinetoAbs extends PathSeg native \"SVGPathSegLinetoAbs\" {\n\n  @DomName('SVGPathSegLinetoAbs.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGPathSegLinetoAbs.y')\n  @DocsEditable\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegLinetoHorizontalAbs')\nclass PathSegLinetoHorizontalAbs extends PathSeg native \"SVGPathSegLinetoHorizontalAbs\" {\n\n  @DomName('SVGPathSegLinetoHorizontalAbs.x')\n  @DocsEditable\n  num x;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegLinetoHorizontalRel')\nclass PathSegLinetoHorizontalRel extends PathSeg native \"SVGPathSegLinetoHorizontalRel\" {\n\n  @DomName('SVGPathSegLinetoHorizontalRel.x')\n  @DocsEditable\n  num x;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegLinetoRel')\nclass PathSegLinetoRel extends PathSeg native \"SVGPathSegLinetoRel\" {\n\n  @DomName('SVGPathSegLinetoRel.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGPathSegLinetoRel.y')\n  @DocsEditable\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegLinetoVerticalAbs')\nclass PathSegLinetoVerticalAbs extends PathSeg native \"SVGPathSegLinetoVerticalAbs\" {\n\n  @DomName('SVGPathSegLinetoVerticalAbs.y')\n  @DocsEditable\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegLinetoVerticalRel')\nclass PathSegLinetoVerticalRel extends PathSeg native \"SVGPathSegLinetoVerticalRel\" {\n\n  @DomName('SVGPathSegLinetoVerticalRel.y')\n  @DocsEditable\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegList')\nclass PathSegList implements JavaScriptIndexingBehavior, List<PathSeg> native \"SVGPathSegList\" {\n\n  @DomName('SVGPathSegList.numberOfItems')\n  @DocsEditable\n  final int numberOfItems;\n\n  PathSeg operator[](int index) => this.getItem(index);\n\n  void operator[]=(int index, PathSeg value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<PathSeg> mixins.\n  // PathSeg is the element type.\n\n  // From Iterable<PathSeg>:\n\n  Iterator<PathSeg> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<PathSeg>(this);\n  }\n\n  // SVG Collections expose numberOfItems rather than length.\n  int get length => numberOfItems;\n  PathSeg reduce(PathSeg combine(PathSeg value, PathSeg element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, PathSeg element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(PathSeg element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(PathSeg element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(PathSeg element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<PathSeg> where(bool f(PathSeg element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(PathSeg element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(PathSeg element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(PathSeg element)) => IterableMixinWorkaround.any(this, f);\n\n  List<PathSeg> toList({ bool growable: true }) =>\n      new List<PathSeg>.from(this, growable: growable);\n\n  Set<PathSeg> toSet() => new Set<PathSeg>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<PathSeg> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<PathSeg> takeWhile(bool test(PathSeg value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<PathSeg> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<PathSeg> skipWhile(bool test(PathSeg value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  PathSeg firstWhere(bool test(PathSeg value), { PathSeg orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  PathSeg lastWhere(bool test(PathSeg value), {PathSeg orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  PathSeg singleWhere(bool test(PathSeg value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  PathSeg elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<PathSeg>:\n\n  void add(PathSeg value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<PathSeg> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<PathSeg>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  // clear() defined by IDL.\n\n  Iterable<PathSeg> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(PathSeg a, PathSeg b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(PathSeg element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(PathSeg element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  PathSeg get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  PathSeg get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  PathSeg get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, PathSeg element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<PathSeg> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<PathSeg> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  PathSeg removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  PathSeg removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(PathSeg element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(PathSeg element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<PathSeg> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<PathSeg> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [PathSeg fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<PathSeg> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<PathSeg> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <PathSeg>[]);\n  }\n\n  Map<int, PathSeg> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<PathSeg> mixins.\n\n  @DomName('SVGPathSegList.appendItem')\n  @DocsEditable\n  PathSeg appendItem(PathSeg newItem) native;\n\n  @DomName('SVGPathSegList.clear')\n  @DocsEditable\n  void clear() native;\n\n  @DomName('SVGPathSegList.getItem')\n  @DocsEditable\n  PathSeg getItem(int index) native;\n\n  @DomName('SVGPathSegList.initialize')\n  @DocsEditable\n  PathSeg initialize(PathSeg newItem) native;\n\n  @DomName('SVGPathSegList.insertItemBefore')\n  @DocsEditable\n  PathSeg insertItemBefore(PathSeg newItem, int index) native;\n\n  @DomName('SVGPathSegList.removeItem')\n  @DocsEditable\n  PathSeg removeItem(int index) native;\n\n  @DomName('SVGPathSegList.replaceItem')\n  @DocsEditable\n  PathSeg replaceItem(PathSeg newItem, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegMovetoAbs')\nclass PathSegMovetoAbs extends PathSeg native \"SVGPathSegMovetoAbs\" {\n\n  @DomName('SVGPathSegMovetoAbs.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGPathSegMovetoAbs.y')\n  @DocsEditable\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPathSegMovetoRel')\nclass PathSegMovetoRel extends PathSeg native \"SVGPathSegMovetoRel\" {\n\n  @DomName('SVGPathSegMovetoRel.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGPathSegMovetoRel.y')\n  @DocsEditable\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPatternElement')\nclass PatternElement extends StyledElement implements FitToViewBox, UriReference, Tests, ExternalResourcesRequired, LangSpace native \"SVGPatternElement\" {\n\n  @DomName('SVGPatternElement.SVGPatternElement')\n  @DocsEditable\n  factory PatternElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"pattern\");\n\n  @DomName('SVGPatternElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGPatternElement.patternContentUnits')\n  @DocsEditable\n  final AnimatedEnumeration patternContentUnits;\n\n  @DomName('SVGPatternElement.patternTransform')\n  @DocsEditable\n  final AnimatedTransformList patternTransform;\n\n  @DomName('SVGPatternElement.patternUnits')\n  @DocsEditable\n  final AnimatedEnumeration patternUnits;\n\n  @DomName('SVGPatternElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGPatternElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGPatternElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGPatternElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGFitToViewBox\n\n  @DomName('SVGPatternElement.preserveAspectRatio')\n  @DocsEditable\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  @DomName('SVGPatternElement.viewBox')\n  @DocsEditable\n  final AnimatedRect viewBox;\n\n  // From SVGLangSpace\n\n  @DomName('SVGPatternElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGPatternElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGTests\n\n  @DomName('SVGPatternElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGPatternElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGPatternElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGPatternElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGURIReference\n\n  @DomName('SVGPatternElement.href')\n  @DocsEditable\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPoint')\nclass Point native \"SVGPoint\" {\n\n  @DomName('SVGPoint.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGPoint.y')\n  @DocsEditable\n  num y;\n\n  @DomName('SVGPoint.matrixTransform')\n  @DocsEditable\n  Point matrixTransform(Matrix matrix) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPointList')\nclass PointList native \"SVGPointList\" {\n\n  @DomName('SVGPointList.numberOfItems')\n  @DocsEditable\n  final int numberOfItems;\n\n  @DomName('SVGPointList.appendItem')\n  @DocsEditable\n  Point appendItem(Point item) native;\n\n  @DomName('SVGPointList.clear')\n  @DocsEditable\n  void clear() native;\n\n  @DomName('SVGPointList.getItem')\n  @DocsEditable\n  Point getItem(int index) native;\n\n  @DomName('SVGPointList.initialize')\n  @DocsEditable\n  Point initialize(Point item) native;\n\n  @DomName('SVGPointList.insertItemBefore')\n  @DocsEditable\n  Point insertItemBefore(Point item, int index) native;\n\n  @DomName('SVGPointList.removeItem')\n  @DocsEditable\n  Point removeItem(int index) native;\n\n  @DomName('SVGPointList.replaceItem')\n  @DocsEditable\n  Point replaceItem(Point item, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPolygonElement')\nclass PolygonElement extends StyledElement implements Transformable, Tests, ExternalResourcesRequired, LangSpace native \"SVGPolygonElement\" {\n\n  @DomName('SVGPolygonElement.SVGPolygonElement')\n  @DocsEditable\n  factory PolygonElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"polygon\");\n\n  @DomName('SVGPolygonElement.animatedPoints')\n  @DocsEditable\n  final PointList animatedPoints;\n\n  @DomName('SVGPolygonElement.points')\n  @DocsEditable\n  final PointList points;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGPolygonElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGPolygonElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGPolygonElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGPolygonElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGPolygonElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGPolygonElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGPolygonElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGPolygonElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGPolygonElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGPolygonElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGPolygonElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGPolygonElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGPolygonElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGPolygonElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPolylineElement')\nclass PolylineElement extends StyledElement implements Transformable, Tests, ExternalResourcesRequired, LangSpace native \"SVGPolylineElement\" {\n\n  @DomName('SVGPolylineElement.SVGPolylineElement')\n  @DocsEditable\n  factory PolylineElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"polyline\");\n\n  @DomName('SVGPolylineElement.animatedPoints')\n  @DocsEditable\n  final PointList animatedPoints;\n\n  @DomName('SVGPolylineElement.points')\n  @DocsEditable\n  final PointList points;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGPolylineElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGPolylineElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGPolylineElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGPolylineElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGPolylineElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGPolylineElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGPolylineElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGPolylineElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGPolylineElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGPolylineElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGPolylineElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGPolylineElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGPolylineElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGPolylineElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPreserveAspectRatio')\nclass PreserveAspectRatio native \"SVGPreserveAspectRatio\" {\n\n  static const int SVG_MEETORSLICE_MEET = 1;\n\n  static const int SVG_MEETORSLICE_SLICE = 2;\n\n  static const int SVG_MEETORSLICE_UNKNOWN = 0;\n\n  static const int SVG_PRESERVEASPECTRATIO_NONE = 1;\n\n  static const int SVG_PRESERVEASPECTRATIO_UNKNOWN = 0;\n\n  static const int SVG_PRESERVEASPECTRATIO_XMAXYMAX = 10;\n\n  static const int SVG_PRESERVEASPECTRATIO_XMAXYMID = 7;\n\n  static const int SVG_PRESERVEASPECTRATIO_XMAXYMIN = 4;\n\n  static const int SVG_PRESERVEASPECTRATIO_XMIDYMAX = 9;\n\n  static const int SVG_PRESERVEASPECTRATIO_XMIDYMID = 6;\n\n  static const int SVG_PRESERVEASPECTRATIO_XMIDYMIN = 3;\n\n  static const int SVG_PRESERVEASPECTRATIO_XMINYMAX = 8;\n\n  static const int SVG_PRESERVEASPECTRATIO_XMINYMID = 5;\n\n  static const int SVG_PRESERVEASPECTRATIO_XMINYMIN = 2;\n\n  @DomName('SVGPreserveAspectRatio.align')\n  @DocsEditable\n  int align;\n\n  @DomName('SVGPreserveAspectRatio.meetOrSlice')\n  @DocsEditable\n  int meetOrSlice;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGRadialGradientElement')\nclass RadialGradientElement extends _GradientElement native \"SVGRadialGradientElement\" {\n\n  @DomName('SVGRadialGradientElement.SVGRadialGradientElement')\n  @DocsEditable\n  factory RadialGradientElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"radialGradient\");\n\n  @DomName('SVGRadialGradientElement.cx')\n  @DocsEditable\n  final AnimatedLength cx;\n\n  @DomName('SVGRadialGradientElement.cy')\n  @DocsEditable\n  final AnimatedLength cy;\n\n  @DomName('SVGRadialGradientElement.fr')\n  @DocsEditable\n  final AnimatedLength fr;\n\n  @DomName('SVGRadialGradientElement.fx')\n  @DocsEditable\n  final AnimatedLength fx;\n\n  @DomName('SVGRadialGradientElement.fy')\n  @DocsEditable\n  final AnimatedLength fy;\n\n  @DomName('SVGRadialGradientElement.r')\n  @DocsEditable\n  final AnimatedLength r;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGRect')\nclass Rect native \"SVGRect\" {\n\n  @DomName('SVGRect.height')\n  @DocsEditable\n  num height;\n\n  @DomName('SVGRect.width')\n  @DocsEditable\n  num width;\n\n  @DomName('SVGRect.x')\n  @DocsEditable\n  num x;\n\n  @DomName('SVGRect.y')\n  @DocsEditable\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGRectElement')\nclass RectElement extends StyledElement implements Transformable, Tests, ExternalResourcesRequired, LangSpace native \"SVGRectElement\" {\n\n  @DomName('SVGRectElement.SVGRectElement')\n  @DocsEditable\n  factory RectElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"rect\");\n\n  @DomName('SVGRectElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGRectElement.rx')\n  @DocsEditable\n  final AnimatedLength rx;\n\n  @DomName('SVGRectElement.ry')\n  @DocsEditable\n  final AnimatedLength ry;\n\n  @DomName('SVGRectElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGRectElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGRectElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGRectElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGRectElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGRectElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGRectElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGRectElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGRectElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGRectElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGRectElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGRectElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGRectElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGRectElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGRectElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGRectElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGRectElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGRenderingIntent')\nclass RenderingIntent native \"SVGRenderingIntent\" {\n\n  static const int RENDERING_INTENT_ABSOLUTE_COLORIMETRIC = 5;\n\n  static const int RENDERING_INTENT_AUTO = 1;\n\n  static const int RENDERING_INTENT_PERCEPTUAL = 2;\n\n  static const int RENDERING_INTENT_RELATIVE_COLORIMETRIC = 3;\n\n  static const int RENDERING_INTENT_SATURATION = 4;\n\n  static const int RENDERING_INTENT_UNKNOWN = 0;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGScriptElement')\nclass ScriptElement extends SvgElement implements UriReference, ExternalResourcesRequired native \"SVGScriptElement\" {\n\n  @DomName('SVGScriptElement.SVGScriptElement')\n  @DocsEditable\n  factory ScriptElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"script\");\n\n  @DomName('SVGScriptElement.type')\n  @DocsEditable\n  String type;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGScriptElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGURIReference\n\n  @DomName('SVGScriptElement.href')\n  @DocsEditable\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGSetElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass SetElement extends AnimationElement native \"SVGSetElement\" {\n\n  @DomName('SVGSetElement.SVGSetElement')\n  @DocsEditable\n  factory SetElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"set\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('set') && (new SvgElement.tag('set') is SetElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGStopElement')\nclass StopElement extends StyledElement native \"SVGStopElement\" {\n\n  @DomName('SVGStopElement.SVGStopElement')\n  @DocsEditable\n  factory StopElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"stop\");\n\n  @JSName('offset')\n  @DomName('SVGStopElement.offset')\n  @DocsEditable\n  final AnimatedNumber gradientOffset;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGStringList')\nclass StringList implements JavaScriptIndexingBehavior, List<String> native \"SVGStringList\" {\n\n  @DomName('SVGStringList.numberOfItems')\n  @DocsEditable\n  final int numberOfItems;\n\n  String operator[](int index) => this.getItem(index);\n\n  void operator[]=(int index, String value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<String> mixins.\n  // String is the element type.\n\n  // From Iterable<String>:\n\n  Iterator<String> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<String>(this);\n  }\n\n  // SVG Collections expose numberOfItems rather than length.\n  int get length => numberOfItems;\n  String reduce(String combine(String value, String element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, String element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(String element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(String element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(String element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<String> where(bool f(String element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(String element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(String element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(String element)) => IterableMixinWorkaround.any(this, f);\n\n  List<String> toList({ bool growable: true }) =>\n      new List<String>.from(this, growable: growable);\n\n  Set<String> toSet() => new Set<String>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<String> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<String> takeWhile(bool test(String value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<String> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<String> skipWhile(bool test(String value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  String firstWhere(bool test(String value), { String orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  String lastWhere(bool test(String value), {String orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  String singleWhere(bool test(String value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  String elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<String>:\n\n  void add(String value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<String> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<String>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  // clear() defined by IDL.\n\n  Iterable<String> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(String a, String b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(String element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(String element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  String get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  String get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  String get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, String element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<String> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<String> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  String removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  String removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(String element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(String element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<String> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<String> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [String fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<String> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<String> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <String>[]);\n  }\n\n  Map<int, String> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<String> mixins.\n\n  @DomName('SVGStringList.appendItem')\n  @DocsEditable\n  String appendItem(String item) native;\n\n  @DomName('SVGStringList.clear')\n  @DocsEditable\n  void clear() native;\n\n  @DomName('SVGStringList.getItem')\n  @DocsEditable\n  String getItem(int index) native;\n\n  @DomName('SVGStringList.initialize')\n  @DocsEditable\n  String initialize(String item) native;\n\n  @DomName('SVGStringList.insertItemBefore')\n  @DocsEditable\n  String insertItemBefore(String item, int index) native;\n\n  @DomName('SVGStringList.removeItem')\n  @DocsEditable\n  String removeItem(int index) native;\n\n  @DomName('SVGStringList.replaceItem')\n  @DocsEditable\n  String replaceItem(String item, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGStyleElement')\nclass StyleElement extends SvgElement implements LangSpace native \"SVGStyleElement\" {\n\n  @DomName('SVGStyleElement.SVGStyleElement')\n  @DocsEditable\n  factory StyleElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"style\");\n\n  @DomName('SVGStyleElement.disabled')\n  @DocsEditable\n  bool disabled;\n\n  @DomName('SVGStyleElement.media')\n  @DocsEditable\n  String media;\n\n  // Shadowing definition.\n  String get title => JS(\"String\", \"#.title\", this);\n\n  void set title(String value) {\n    JS(\"void\", \"#.title = #\", this, value);\n  }\n\n  @DomName('SVGStyleElement.type')\n  @DocsEditable\n  String type;\n\n  // From SVGLangSpace\n\n  @DomName('SVGStyleElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGStyleElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGStyledElement')\nclass StyledElement extends SvgElement native \"SVGStyledElement\" {\n\n  // Shadowing definition.\n  AnimatedString get $dom_svgClassName => JS(\"AnimatedString\", \"#.className\", this);\n\n  // Use implementation from Element.\n  // final CssStyleDeclaration style;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGDocument')\nclass SvgDocument extends Document native \"SVGDocument\" {\n\n  @DomName('SVGDocument.rootElement')\n  @DocsEditable\n  final SvgSvgElement rootElement;\n\n  @JSName('createEvent')\n  @DomName('SVGDocument.createEvent')\n  @DocsEditable\n  Event $dom_createEvent(String eventType) native;\n}\n// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nclass _AttributeClassSet extends CssClassSet {\n  final Element _element;\n\n  _AttributeClassSet(this._element);\n\n  Set<String> readClasses() {\n    var classname = _element.attributes['class'];\n\n    Set<String> s = new LinkedHashSet<String>();\n    if (classname == null) {\n      return s;\n    }\n    for (String name in classname.split(' ')) {\n      String trimmed = name.trim();\n      if (!trimmed.isEmpty) {\n        s.add(trimmed);\n      }\n    }\n    return s;\n  }\n\n  void writeClasses(Set s) {\n    _element.attributes['class'] = s.join(' ');\n  }\n}\n\n@DomName('SVGElement')\nclass SvgElement extends Element native \"SVGElement\" {\n  factory SvgElement.tag(String tag) =>\n      _SvgElementFactoryProvider.createSvgElement_tag(tag);\n  factory SvgElement.svg(String svg) =>\n      _SvgElementFactoryProvider.createSvgElement_svg(svg);\n\n  _AttributeClassSet _cssClassSet;\n  CssClassSet get classes {\n    if (_cssClassSet == null) {\n      _cssClassSet = new _AttributeClassSet(this);\n    }\n    return _cssClassSet;\n  }\n\n  List<Element> get children => new FilteredElementList(this);\n\n  void set children(List<Element> value) {\n    final children = this.children;\n    children.clear();\n    children.addAll(value);\n  }\n\n  String get outerHtml {\n    final container = new Element.tag(\"div\");\n    final SvgElement cloned = this.clone(true);\n    container.children.add(cloned);\n    return container.innerHtml;\n  }\n\n  String get innerHtml {\n    final container = new Element.tag(\"div\");\n    final SvgElement cloned = this.clone(true);\n    container.children.addAll(cloned.children);\n    return container.innerHtml;\n  }\n\n  void set innerHtml(String svg) {\n    final container = new Element.tag(\"div\");\n    // Wrap the SVG string in <svg> so that SvgElements are created, rather than\n    // HTMLElements.\n    container.innerHtml = '<svg version=\"1.1\">$svg</svg>';\n    this.children = container.children[0].children;\n  }\n\n  // Unsupported methods inherited from Element.\n\n  @DomName('Element.insertAdjacentText')\n  void insertAdjacentText(String where, String text) {\n    throw new UnsupportedError(\"Cannot invoke insertAdjacentText on SVG.\");\n  }\n\n  @DomName('Element.insertAdjacentHTML')\n  void insertAdjacentHtml(String where, String text) {\n    throw new UnsupportedError(\"Cannot invoke insertAdjacentHtml on SVG.\");\n  }\n\n  @DomName('Element.insertAdjacentHTML')\n  Element insertAdjacentElement(String where, Element element) {\n    throw new UnsupportedError(\"Cannot invoke insertAdjacentElement on SVG.\");\n  }\n\n  HtmlCollection get $dom_children {\n    throw new UnsupportedError(\"Cannot get dom_children on SVG.\");\n  }\n\n  bool get isContentEditable => false;\n  void click() {\n    throw new UnsupportedError(\"Cannot invoke click SVG.\");\n  }\n\n  /**\n   * Checks to see if the SVG element type is supported by the current platform.\n   *\n   * The tag should be a valid SVG element tag name.\n   */\n  static bool isTagSupported(String tag) {\n    var e = new SvgElement.tag(tag);\n    return e is SvgElement && !(e is UnknownElement);\n  }\n\n  // Shadowing definition.\n  String get id => JS(\"String\", \"#.id\", this);\n\n  void set id(String value) {\n    JS(\"void\", \"#.id = #\", this, value);\n  }\n\n  @JSName('ownerSVGElement')\n  @DomName('SVGElement.ownerSVGElement')\n  @DocsEditable\n  final SvgSvgElement ownerSvgElement;\n\n  @DomName('SVGElement.viewportElement')\n  @DocsEditable\n  final SvgElement viewportElement;\n\n  @DomName('SVGElement.xmlbase')\n  @DocsEditable\n  String xmlbase;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGException')\nclass SvgException native \"SVGException\" {\n\n  static const int SVG_INVALID_VALUE_ERR = 1;\n\n  static const int SVG_MATRIX_NOT_INVERTABLE = 2;\n\n  static const int SVG_WRONG_TYPE_ERR = 0;\n\n  @DomName('SVGException.code')\n  @DocsEditable\n  final int code;\n\n  @DomName('SVGException.message')\n  @DocsEditable\n  final String message;\n\n  @DomName('SVGException.name')\n  @DocsEditable\n  final String name;\n\n  @DomName('SVGException.toString')\n  @DocsEditable\n  String toString() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('SVGSVGElement')\nclass SvgSvgElement extends StyledElement implements FitToViewBox, Transformable, Tests, ExternalResourcesRequired, ZoomAndPan, LangSpace native \"SVGSVGElement\" {\n  factory SvgSvgElement() => _SvgSvgElementFactoryProvider.createSvgSvgElement();\n\n\n  @DomName('SVGSVGElement.contentScriptType')\n  @DocsEditable\n  String contentScriptType;\n\n  @DomName('SVGSVGElement.contentStyleType')\n  @DocsEditable\n  String contentStyleType;\n\n  @DomName('SVGSVGElement.currentScale')\n  @DocsEditable\n  num currentScale;\n\n  @DomName('SVGSVGElement.currentTranslate')\n  @DocsEditable\n  final Point currentTranslate;\n\n  @DomName('SVGSVGElement.currentView')\n  @DocsEditable\n  final ViewSpec currentView;\n\n  @DomName('SVGSVGElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGSVGElement.pixelUnitToMillimeterX')\n  @DocsEditable\n  final num pixelUnitToMillimeterX;\n\n  @DomName('SVGSVGElement.pixelUnitToMillimeterY')\n  @DocsEditable\n  final num pixelUnitToMillimeterY;\n\n  @DomName('SVGSVGElement.screenPixelToMillimeterX')\n  @DocsEditable\n  final num screenPixelToMillimeterX;\n\n  @DomName('SVGSVGElement.screenPixelToMillimeterY')\n  @DocsEditable\n  final num screenPixelToMillimeterY;\n\n  @DomName('SVGSVGElement.useCurrentView')\n  @DocsEditable\n  final bool useCurrentView;\n\n  @DomName('SVGSVGElement.viewport')\n  @DocsEditable\n  final Rect viewport;\n\n  @DomName('SVGSVGElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGSVGElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGSVGElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n\n  @DomName('SVGSVGElement.animationsPaused')\n  @DocsEditable\n  bool animationsPaused() native;\n\n  @DomName('SVGSVGElement.checkEnclosure')\n  @DocsEditable\n  bool checkEnclosure(SvgElement element, Rect rect) native;\n\n  @DomName('SVGSVGElement.checkIntersection')\n  @DocsEditable\n  bool checkIntersection(SvgElement element, Rect rect) native;\n\n  @JSName('createSVGAngle')\n  @DomName('SVGSVGElement.createSVGAngle')\n  @DocsEditable\n  Angle createSvgAngle() native;\n\n  @JSName('createSVGLength')\n  @DomName('SVGSVGElement.createSVGLength')\n  @DocsEditable\n  Length createSvgLength() native;\n\n  @JSName('createSVGMatrix')\n  @DomName('SVGSVGElement.createSVGMatrix')\n  @DocsEditable\n  Matrix createSvgMatrix() native;\n\n  @JSName('createSVGNumber')\n  @DomName('SVGSVGElement.createSVGNumber')\n  @DocsEditable\n  Number createSvgNumber() native;\n\n  @JSName('createSVGPoint')\n  @DomName('SVGSVGElement.createSVGPoint')\n  @DocsEditable\n  Point createSvgPoint() native;\n\n  @JSName('createSVGRect')\n  @DomName('SVGSVGElement.createSVGRect')\n  @DocsEditable\n  Rect createSvgRect() native;\n\n  @JSName('createSVGTransform')\n  @DomName('SVGSVGElement.createSVGTransform')\n  @DocsEditable\n  Transform createSvgTransform() native;\n\n  @JSName('createSVGTransformFromMatrix')\n  @DomName('SVGSVGElement.createSVGTransformFromMatrix')\n  @DocsEditable\n  Transform createSvgTransformFromMatrix(Matrix matrix) native;\n\n  @DomName('SVGSVGElement.deselectAll')\n  @DocsEditable\n  void deselectAll() native;\n\n  @DomName('SVGSVGElement.forceRedraw')\n  @DocsEditable\n  void forceRedraw() native;\n\n  @DomName('SVGSVGElement.getCurrentTime')\n  @DocsEditable\n  num getCurrentTime() native;\n\n  @DomName('SVGSVGElement.getElementById')\n  @DocsEditable\n  Element getElementById(String elementId) native;\n\n  @DomName('SVGSVGElement.getEnclosureList')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getEnclosureList(Rect rect, SvgElement referenceElement) native;\n\n  @DomName('SVGSVGElement.getIntersectionList')\n  @DocsEditable\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getIntersectionList(Rect rect, SvgElement referenceElement) native;\n\n  @DomName('SVGSVGElement.pauseAnimations')\n  @DocsEditable\n  void pauseAnimations() native;\n\n  @DomName('SVGSVGElement.setCurrentTime')\n  @DocsEditable\n  void setCurrentTime(num seconds) native;\n\n  @DomName('SVGSVGElement.suspendRedraw')\n  @DocsEditable\n  int suspendRedraw(int maxWaitMilliseconds) native;\n\n  @DomName('SVGSVGElement.unpauseAnimations')\n  @DocsEditable\n  void unpauseAnimations() native;\n\n  @DomName('SVGSVGElement.unsuspendRedraw')\n  @DocsEditable\n  void unsuspendRedraw(int suspendHandleId) native;\n\n  @DomName('SVGSVGElement.unsuspendRedrawAll')\n  @DocsEditable\n  void unsuspendRedrawAll() native;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGSVGElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGFitToViewBox\n\n  @DomName('SVGSVGElement.preserveAspectRatio')\n  @DocsEditable\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  @DomName('SVGSVGElement.viewBox')\n  @DocsEditable\n  final AnimatedRect viewBox;\n\n  // From SVGLangSpace\n\n  @DomName('SVGSVGElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGSVGElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGSVGElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGSVGElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGSVGElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGSVGElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGSVGElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGSVGElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGSVGElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGSVGElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGSVGElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGSVGElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGSVGElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n\n  // From SVGZoomAndPan\n\n  @DomName('SVGSVGElement.zoomAndPan')\n  @DocsEditable\n  int zoomAndPan;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGSwitchElement')\nclass SwitchElement extends StyledElement implements Transformable, Tests, ExternalResourcesRequired, LangSpace native \"SVGSwitchElement\" {\n\n  @DomName('SVGSwitchElement.SVGSwitchElement')\n  @DocsEditable\n  factory SwitchElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"switch\");\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGSwitchElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGSwitchElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGSwitchElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGSwitchElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGSwitchElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGSwitchElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGSwitchElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGSwitchElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGSwitchElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGSwitchElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGSwitchElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGSwitchElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGSwitchElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGSwitchElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGSymbolElement')\nclass SymbolElement extends StyledElement implements FitToViewBox, ExternalResourcesRequired, LangSpace native \"SVGSymbolElement\" {\n\n  @DomName('SVGSymbolElement.SVGSymbolElement')\n  @DocsEditable\n  factory SymbolElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"symbol\");\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGSymbolElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGFitToViewBox\n\n  @DomName('SVGSymbolElement.preserveAspectRatio')\n  @DocsEditable\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  @DomName('SVGSymbolElement.viewBox')\n  @DocsEditable\n  final AnimatedRect viewBox;\n\n  // From SVGLangSpace\n\n  @DomName('SVGSymbolElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGSymbolElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGTSpanElement')\nclass TSpanElement extends TextPositioningElement native \"SVGTSpanElement\" {\n\n  @DomName('SVGTSpanElement.SVGTSpanElement')\n  @DocsEditable\n  factory TSpanElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"tspan\");\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('SVGTests')\nabstract class Tests {\n\n  StringList requiredExtensions;\n\n  StringList requiredFeatures;\n\n  StringList systemLanguage;\n\n  bool hasExtension(String extension);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGTextContentElement')\nclass TextContentElement extends StyledElement implements Tests, ExternalResourcesRequired, LangSpace native \"SVGTextContentElement\" {\n\n  static const int LENGTHADJUST_SPACING = 1;\n\n  static const int LENGTHADJUST_SPACINGANDGLYPHS = 2;\n\n  static const int LENGTHADJUST_UNKNOWN = 0;\n\n  @DomName('SVGTextContentElement.lengthAdjust')\n  @DocsEditable\n  final AnimatedEnumeration lengthAdjust;\n\n  @DomName('SVGTextContentElement.textLength')\n  @DocsEditable\n  final AnimatedLength textLength;\n\n  @DomName('SVGTextContentElement.getCharNumAtPosition')\n  @DocsEditable\n  int getCharNumAtPosition(Point point) native;\n\n  @DomName('SVGTextContentElement.getComputedTextLength')\n  @DocsEditable\n  num getComputedTextLength() native;\n\n  @DomName('SVGTextContentElement.getEndPositionOfChar')\n  @DocsEditable\n  Point getEndPositionOfChar(int offset) native;\n\n  @DomName('SVGTextContentElement.getExtentOfChar')\n  @DocsEditable\n  Rect getExtentOfChar(int offset) native;\n\n  @DomName('SVGTextContentElement.getNumberOfChars')\n  @DocsEditable\n  int getNumberOfChars() native;\n\n  @DomName('SVGTextContentElement.getRotationOfChar')\n  @DocsEditable\n  num getRotationOfChar(int offset) native;\n\n  @DomName('SVGTextContentElement.getStartPositionOfChar')\n  @DocsEditable\n  Point getStartPositionOfChar(int offset) native;\n\n  @DomName('SVGTextContentElement.getSubStringLength')\n  @DocsEditable\n  num getSubStringLength(int offset, int length) native;\n\n  @DomName('SVGTextContentElement.selectSubString')\n  @DocsEditable\n  void selectSubString(int offset, int length) native;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGTextContentElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGTextContentElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGTextContentElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGTests\n\n  @DomName('SVGTextContentElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGTextContentElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGTextContentElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGTextContentElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGTextElement')\nclass TextElement extends TextPositioningElement implements Transformable native \"SVGTextElement\" {\n\n  @DomName('SVGTextElement.SVGTextElement')\n  @DocsEditable\n  factory TextElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"text\");\n\n  // From SVGLocatable\n\n  @DomName('SVGTextElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGTextElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGTextElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGTextElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGTextElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGTextElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGTextElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGTextPathElement')\nclass TextPathElement extends TextContentElement implements UriReference native \"SVGTextPathElement\" {\n\n  static const int TEXTPATH_METHODTYPE_ALIGN = 1;\n\n  static const int TEXTPATH_METHODTYPE_STRETCH = 2;\n\n  static const int TEXTPATH_METHODTYPE_UNKNOWN = 0;\n\n  static const int TEXTPATH_SPACINGTYPE_AUTO = 1;\n\n  static const int TEXTPATH_SPACINGTYPE_EXACT = 2;\n\n  static const int TEXTPATH_SPACINGTYPE_UNKNOWN = 0;\n\n  @DomName('SVGTextPathElement.method')\n  @DocsEditable\n  final AnimatedEnumeration method;\n\n  @DomName('SVGTextPathElement.spacing')\n  @DocsEditable\n  final AnimatedEnumeration spacing;\n\n  @DomName('SVGTextPathElement.startOffset')\n  @DocsEditable\n  final AnimatedLength startOffset;\n\n  // From SVGURIReference\n\n  @DomName('SVGTextPathElement.href')\n  @DocsEditable\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGTextPositioningElement')\nclass TextPositioningElement extends TextContentElement native \"SVGTextPositioningElement\" {\n\n  @DomName('SVGTextPositioningElement.dx')\n  @DocsEditable\n  final AnimatedLengthList dx;\n\n  @DomName('SVGTextPositioningElement.dy')\n  @DocsEditable\n  final AnimatedLengthList dy;\n\n  @DomName('SVGTextPositioningElement.rotate')\n  @DocsEditable\n  final AnimatedNumberList rotate;\n\n  @DomName('SVGTextPositioningElement.x')\n  @DocsEditable\n  final AnimatedLengthList x;\n\n  @DomName('SVGTextPositioningElement.y')\n  @DocsEditable\n  final AnimatedLengthList y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGTitleElement')\nclass TitleElement extends StyledElement implements LangSpace native \"SVGTitleElement\" {\n\n  @DomName('SVGTitleElement.SVGTitleElement')\n  @DocsEditable\n  factory TitleElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"title\");\n\n  // From SVGLangSpace\n\n  @DomName('SVGTitleElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGTitleElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGTransform')\nclass Transform native \"SVGTransform\" {\n\n  static const int SVG_TRANSFORM_MATRIX = 1;\n\n  static const int SVG_TRANSFORM_ROTATE = 4;\n\n  static const int SVG_TRANSFORM_SCALE = 3;\n\n  static const int SVG_TRANSFORM_SKEWX = 5;\n\n  static const int SVG_TRANSFORM_SKEWY = 6;\n\n  static const int SVG_TRANSFORM_TRANSLATE = 2;\n\n  static const int SVG_TRANSFORM_UNKNOWN = 0;\n\n  @DomName('SVGTransform.angle')\n  @DocsEditable\n  final num angle;\n\n  @DomName('SVGTransform.matrix')\n  @DocsEditable\n  final Matrix matrix;\n\n  @DomName('SVGTransform.type')\n  @DocsEditable\n  final int type;\n\n  @DomName('SVGTransform.setMatrix')\n  @DocsEditable\n  void setMatrix(Matrix matrix) native;\n\n  @DomName('SVGTransform.setRotate')\n  @DocsEditable\n  void setRotate(num angle, num cx, num cy) native;\n\n  @DomName('SVGTransform.setScale')\n  @DocsEditable\n  void setScale(num sx, num sy) native;\n\n  @DomName('SVGTransform.setSkewX')\n  @DocsEditable\n  void setSkewX(num angle) native;\n\n  @DomName('SVGTransform.setSkewY')\n  @DocsEditable\n  void setSkewY(num angle) native;\n\n  @DomName('SVGTransform.setTranslate')\n  @DocsEditable\n  void setTranslate(num tx, num ty) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGTransformList')\nclass TransformList implements List<Transform>, JavaScriptIndexingBehavior native \"SVGTransformList\" {\n\n  @DomName('SVGTransformList.numberOfItems')\n  @DocsEditable\n  final int numberOfItems;\n\n  Transform operator[](int index) => this.getItem(index);\n\n  void operator[]=(int index, Transform value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Transform> mixins.\n  // Transform is the element type.\n\n  // From Iterable<Transform>:\n\n  Iterator<Transform> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<Transform>(this);\n  }\n\n  // SVG Collections expose numberOfItems rather than length.\n  int get length => numberOfItems;\n  Transform reduce(Transform combine(Transform value, Transform element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, Transform element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(Transform element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(Transform element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(Transform element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<Transform> where(bool f(Transform element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(Transform element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(Transform element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(Transform element)) => IterableMixinWorkaround.any(this, f);\n\n  List<Transform> toList({ bool growable: true }) =>\n      new List<Transform>.from(this, growable: growable);\n\n  Set<Transform> toSet() => new Set<Transform>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<Transform> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<Transform> takeWhile(bool test(Transform value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<Transform> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<Transform> skipWhile(bool test(Transform value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  Transform firstWhere(bool test(Transform value), { Transform orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  Transform lastWhere(bool test(Transform value), {Transform orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  Transform singleWhere(bool test(Transform value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  Transform elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<Transform>:\n\n  void add(Transform value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<Transform> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<Transform>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  // clear() defined by IDL.\n\n  Iterable<Transform> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(Transform a, Transform b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(Transform element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(Transform element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  Transform get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  Transform get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  Transform get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, Transform element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<Transform> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<Transform> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Transform removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  Transform removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(Transform element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(Transform element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<Transform> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<Transform> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [Transform fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<Transform> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<Transform> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <Transform>[]);\n  }\n\n  Map<int, Transform> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<Transform> mixins.\n\n  @DomName('SVGTransformList.appendItem')\n  @DocsEditable\n  Transform appendItem(Transform item) native;\n\n  @DomName('SVGTransformList.clear')\n  @DocsEditable\n  void clear() native;\n\n  @DomName('SVGTransformList.consolidate')\n  @DocsEditable\n  Transform consolidate() native;\n\n  @JSName('createSVGTransformFromMatrix')\n  @DomName('SVGTransformList.createSVGTransformFromMatrix')\n  @DocsEditable\n  Transform createSvgTransformFromMatrix(Matrix matrix) native;\n\n  @DomName('SVGTransformList.getItem')\n  @DocsEditable\n  Transform getItem(int index) native;\n\n  @DomName('SVGTransformList.initialize')\n  @DocsEditable\n  Transform initialize(Transform item) native;\n\n  @DomName('SVGTransformList.insertItemBefore')\n  @DocsEditable\n  Transform insertItemBefore(Transform item, int index) native;\n\n  @DomName('SVGTransformList.removeItem')\n  @DocsEditable\n  Transform removeItem(int index) native;\n\n  @DomName('SVGTransformList.replaceItem')\n  @DocsEditable\n  Transform replaceItem(Transform item, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('SVGTransformable')\nabstract class Transformable implements Locatable {\n\n  AnimatedTransformList transform;\n\n  // From SVGLocatable\n\n  SvgElement farthestViewportElement;\n\n  SvgElement nearestViewportElement;\n\n  Rect getBBox();\n\n  Matrix getCTM();\n\n  Matrix getScreenCTM();\n\n  Matrix getTransformToElement(SvgElement element);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGUnitTypes')\nclass UnitTypes native \"SVGUnitTypes\" {\n\n  static const int SVG_UNIT_TYPE_OBJECTBOUNDINGBOX = 2;\n\n  static const int SVG_UNIT_TYPE_UNKNOWN = 0;\n\n  static const int SVG_UNIT_TYPE_USERSPACEONUSE = 1;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('SVGURIReference')\nabstract class UriReference {\n\n  AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGUseElement')\nclass UseElement extends StyledElement implements UriReference, Tests, Transformable, ExternalResourcesRequired, LangSpace native \"SVGUseElement\" {\n\n  @DomName('SVGUseElement.SVGUseElement')\n  @DocsEditable\n  factory UseElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"use\");\n\n  @DomName('SVGUseElement.animatedInstanceRoot')\n  @DocsEditable\n  final ElementInstance animatedInstanceRoot;\n\n  @DomName('SVGUseElement.height')\n  @DocsEditable\n  final AnimatedLength height;\n\n  @DomName('SVGUseElement.instanceRoot')\n  @DocsEditable\n  final ElementInstance instanceRoot;\n\n  @DomName('SVGUseElement.width')\n  @DocsEditable\n  final AnimatedLength width;\n\n  @DomName('SVGUseElement.x')\n  @DocsEditable\n  final AnimatedLength x;\n\n  @DomName('SVGUseElement.y')\n  @DocsEditable\n  final AnimatedLength y;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGUseElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGLangSpace\n\n  @DomName('SVGUseElement.xmllang')\n  @DocsEditable\n  String xmllang;\n\n  @DomName('SVGUseElement.xmlspace')\n  @DocsEditable\n  String xmlspace;\n\n  // From SVGLocatable\n\n  @DomName('SVGUseElement.farthestViewportElement')\n  @DocsEditable\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGUseElement.nearestViewportElement')\n  @DocsEditable\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGUseElement.getBBox')\n  @DocsEditable\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGUseElement.getCTM')\n  @DocsEditable\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGUseElement.getScreenCTM')\n  @DocsEditable\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGUseElement.getTransformToElement')\n  @DocsEditable\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGUseElement.requiredExtensions')\n  @DocsEditable\n  final StringList requiredExtensions;\n\n  @DomName('SVGUseElement.requiredFeatures')\n  @DocsEditable\n  final StringList requiredFeatures;\n\n  @DomName('SVGUseElement.systemLanguage')\n  @DocsEditable\n  final StringList systemLanguage;\n\n  @DomName('SVGUseElement.hasExtension')\n  @DocsEditable\n  bool hasExtension(String extension) native;\n\n  // From SVGTransformable\n\n  @DomName('SVGUseElement.transform')\n  @DocsEditable\n  final AnimatedTransformList transform;\n\n  // From SVGURIReference\n\n  @DomName('SVGUseElement.href')\n  @DocsEditable\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGViewElement')\nclass ViewElement extends SvgElement implements FitToViewBox, ExternalResourcesRequired, ZoomAndPan native \"SVGViewElement\" {\n\n  @DomName('SVGViewElement.SVGViewElement')\n  @DocsEditable\n  factory ViewElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"view\");\n\n  @DomName('SVGViewElement.viewTarget')\n  @DocsEditable\n  final StringList viewTarget;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGViewElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGFitToViewBox\n\n  @DomName('SVGViewElement.preserveAspectRatio')\n  @DocsEditable\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  @DomName('SVGViewElement.viewBox')\n  @DocsEditable\n  final AnimatedRect viewBox;\n\n  // From SVGZoomAndPan\n\n  @DomName('SVGViewElement.zoomAndPan')\n  @DocsEditable\n  int zoomAndPan;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGViewSpec')\nclass ViewSpec native \"SVGViewSpec\" {\n\n  @DomName('SVGViewSpec.preserveAspectRatio')\n  @DocsEditable\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  @DomName('SVGViewSpec.preserveAspectRatioString')\n  @DocsEditable\n  final String preserveAspectRatioString;\n\n  @DomName('SVGViewSpec.transform')\n  @DocsEditable\n  final TransformList transform;\n\n  @DomName('SVGViewSpec.transformString')\n  @DocsEditable\n  final String transformString;\n\n  @DomName('SVGViewSpec.viewBox')\n  @DocsEditable\n  final AnimatedRect viewBox;\n\n  @DomName('SVGViewSpec.viewBoxString')\n  @DocsEditable\n  final String viewBoxString;\n\n  @DomName('SVGViewSpec.viewTarget')\n  @DocsEditable\n  final SvgElement viewTarget;\n\n  @DomName('SVGViewSpec.viewTargetString')\n  @DocsEditable\n  final String viewTargetString;\n\n  @DomName('SVGViewSpec.zoomAndPan')\n  @DocsEditable\n  int zoomAndPan;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('SVGZoomAndPan')\nabstract class ZoomAndPan {\n\n  static const int SVG_ZOOMANDPAN_DISABLE = 1;\n\n  static const int SVG_ZOOMANDPAN_MAGNIFY = 2;\n\n  static const int SVG_ZOOMANDPAN_UNKNOWN = 0;\n\n  int zoomAndPan;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGZoomEvent')\nclass ZoomEvent extends UIEvent native \"SVGZoomEvent\" {\n\n  @DomName('SVGZoomEvent.newScale')\n  @DocsEditable\n  final num newScale;\n\n  @DomName('SVGZoomEvent.newTranslate')\n  @DocsEditable\n  final Point newTranslate;\n\n  @DomName('SVGZoomEvent.previousScale')\n  @DocsEditable\n  final num previousScale;\n\n  @DomName('SVGZoomEvent.previousTranslate')\n  @DocsEditable\n  final Point previousTranslate;\n\n  @DomName('SVGZoomEvent.zoomRectScreen')\n  @DocsEditable\n  final Rect zoomRectScreen;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGElementInstanceList')\nclass _ElementInstanceList implements JavaScriptIndexingBehavior, List<ElementInstance> native \"SVGElementInstanceList\" {\n\n  @DomName('SVGElementInstanceList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  ElementInstance operator[](int index) => this.item(index);\n\n  void operator[]=(int index, ElementInstance value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<ElementInstance> mixins.\n  // ElementInstance is the element type.\n\n  // From Iterable<ElementInstance>:\n\n  Iterator<ElementInstance> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<ElementInstance>(this);\n  }\n\n  ElementInstance reduce(ElementInstance combine(ElementInstance value, ElementInstance element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, ElementInstance element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(ElementInstance element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(ElementInstance element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(ElementInstance element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<ElementInstance> where(bool f(ElementInstance element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(ElementInstance element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(ElementInstance element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(ElementInstance element)) => IterableMixinWorkaround.any(this, f);\n\n  List<ElementInstance> toList({ bool growable: true }) =>\n      new List<ElementInstance>.from(this, growable: growable);\n\n  Set<ElementInstance> toSet() => new Set<ElementInstance>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<ElementInstance> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<ElementInstance> takeWhile(bool test(ElementInstance value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<ElementInstance> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<ElementInstance> skipWhile(bool test(ElementInstance value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  ElementInstance firstWhere(bool test(ElementInstance value), { ElementInstance orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  ElementInstance lastWhere(bool test(ElementInstance value), {ElementInstance orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  ElementInstance singleWhere(bool test(ElementInstance value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  ElementInstance elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<ElementInstance>:\n\n  void add(ElementInstance value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<ElementInstance> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<ElementInstance>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<ElementInstance> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(ElementInstance a, ElementInstance b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(ElementInstance element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(ElementInstance element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  ElementInstance get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  ElementInstance get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  ElementInstance get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, ElementInstance element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<ElementInstance> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<ElementInstance> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  ElementInstance removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  ElementInstance removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(ElementInstance element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(ElementInstance element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<ElementInstance> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<ElementInstance> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [ElementInstance fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<ElementInstance> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<ElementInstance> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <ElementInstance>[]);\n  }\n\n  Map<int, ElementInstance> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<ElementInstance> mixins.\n\n  @DomName('SVGElementInstanceList.item')\n  @DocsEditable\n  ElementInstance item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGGradientElement')\nclass _GradientElement extends StyledElement implements UriReference, ExternalResourcesRequired native \"SVGGradientElement\" {\n\n  static const int SVG_SPREADMETHOD_PAD = 1;\n\n  static const int SVG_SPREADMETHOD_REFLECT = 2;\n\n  static const int SVG_SPREADMETHOD_REPEAT = 3;\n\n  static const int SVG_SPREADMETHOD_UNKNOWN = 0;\n\n  @DomName('SVGGradientElement.gradientTransform')\n  @DocsEditable\n  final AnimatedTransformList gradientTransform;\n\n  @DomName('SVGGradientElement.gradientUnits')\n  @DocsEditable\n  final AnimatedEnumeration gradientUnits;\n\n  @DomName('SVGGradientElement.spreadMethod')\n  @DocsEditable\n  final AnimatedEnumeration spreadMethod;\n\n  // From SVGExternalResourcesRequired\n\n  @DomName('SVGGradientElement.externalResourcesRequired')\n  @DocsEditable\n  final AnimatedBoolean externalResourcesRequired;\n\n  // From SVGURIReference\n\n  @DomName('SVGGradientElement.href')\n  @DocsEditable\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAltGlyphDefElement')\nabstract class _SVGAltGlyphDefElement extends SvgElement native \"SVGAltGlyphDefElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAltGlyphItemElement')\nabstract class _SVGAltGlyphItemElement extends SvgElement native \"SVGAltGlyphItemElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGAnimateColorElement')\nabstract class _SVGAnimateColorElement extends AnimationElement native \"SVGAnimateColorElement\" {\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n// Hack because the baseclass is private in dart:html, and we want to omit this\n// type entirely but can't.\n@DocsEditable\n@DomName('SVGColor')\nclass _SVGColor native \"SVGColor\" {\n  _SVGColor.internal();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGComponentTransferFunctionElement')\nabstract class _SVGComponentTransferFunctionElement extends SvgElement native \"SVGComponentTransferFunctionElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGCursorElement')\nabstract class _SVGCursorElement extends SvgElement implements UriReference, Tests, ExternalResourcesRequired native \"SVGCursorElement\" {\n\n  @DomName('SVGCursorElement.SVGCursorElement')\n  @DocsEditable\n  factory _SVGCursorElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"cursor\");\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('cursor') && (new SvgElement.tag('cursor') is _SVGCursorElement);\n\n  // From SVGExternalResourcesRequired\n\n  // From SVGTests\n\n  // From SVGURIReference\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFEDropShadowElement')\nabstract class _SVGFEDropShadowElement extends StyledElement implements FilterPrimitiveStandardAttributes native \"SVGFEDropShadowElement\" {\n\n  // From SVGFilterPrimitiveStandardAttributes\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFontElement')\nabstract class _SVGFontElement extends SvgElement native \"SVGFontElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFontFaceElement')\nabstract class _SVGFontFaceElement extends SvgElement native \"SVGFontFaceElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFontFaceFormatElement')\nabstract class _SVGFontFaceFormatElement extends SvgElement native \"SVGFontFaceFormatElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFontFaceNameElement')\nabstract class _SVGFontFaceNameElement extends SvgElement native \"SVGFontFaceNameElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFontFaceSrcElement')\nabstract class _SVGFontFaceSrcElement extends SvgElement native \"SVGFontFaceSrcElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGFontFaceUriElement')\nabstract class _SVGFontFaceUriElement extends SvgElement native \"SVGFontFaceUriElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGGlyphElement')\nabstract class _SVGGlyphElement extends SvgElement native \"SVGGlyphElement\" {\n\n  @DomName('SVGGlyphElement.SVGGlyphElement')\n  @DocsEditable\n  factory _SVGGlyphElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"glyph\");\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGGlyphRefElement')\nabstract class _SVGGlyphRefElement extends StyledElement implements UriReference native \"SVGGlyphRefElement\" {\n\n  // From SVGURIReference\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGHKernElement')\nabstract class _SVGHKernElement extends SvgElement native \"SVGHKernElement\" {\n\n  @DomName('SVGHKernElement.SVGHKernElement')\n  @DocsEditable\n  factory _SVGHKernElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"hkern\");\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGMPathElement')\nabstract class _SVGMPathElement extends SvgElement implements UriReference, ExternalResourcesRequired native \"SVGMPathElement\" {\n\n  @DomName('SVGMPathElement.SVGMPathElement')\n  @DocsEditable\n  factory _SVGMPathElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"mpath\");\n\n  // From SVGExternalResourcesRequired\n\n  // From SVGURIReference\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGMissingGlyphElement')\nabstract class _SVGMissingGlyphElement extends StyledElement native \"SVGMissingGlyphElement\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGPaint')\nabstract class _SVGPaint extends _SVGColor native \"SVGPaint\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGTRefElement')\nabstract class _SVGTRefElement extends TextPositioningElement implements UriReference native \"SVGTRefElement\" {\n\n  @DomName('SVGTRefElement.SVGTRefElement')\n  @DocsEditable\n  factory _SVGTRefElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"tref\");\n\n  // From SVGURIReference\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SVGVKernElement')\nabstract class _SVGVKernElement extends SvgElement native \"SVGVKernElement\" {\n\n  @DomName('SVGVKernElement.SVGVKernElement')\n  @DocsEditable\n  factory _SVGVKernElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"vkern\");\n}\n","sdk/lib/typed_data/dart2js/typed_data_dart2js.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/// The Dart TypedData library.\nlibrary dart.typed_data;\n\nimport 'dart:collection';\nimport 'dart:_collection-dev';\nimport 'dart:html';\nimport 'dart:html_common';\nimport 'dart:_js_helper' show convertDartClosureToJS, Creates, JavaScriptIndexingBehavior, JSName, Null, Returns;\nimport 'dart:_foreign_helper' show JS;\n\n/**\n * Describes endianness to be used when accessing a sequence of bytes.\n */\nclass Endianness {\n  const Endianness(this._littleEndian);\n\n  static const Endianness BIG_ENDIAN = const Endianness(false);\n  static const Endianness LITTLE_ENDIAN = const Endianness(true);\n  static final Endianness HOST_ENDIAN =\n    (new ByteData.view(new Int16List.fromList([1]).buffer)).getInt8(0) == 1 ?\n    LITTLE_ENDIAN : BIG_ENDIAN;\n\n  final bool _littleEndian;\n}\n\n@DocsEditable\n@DomName('ArrayBuffer')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass ByteBuffer native \"ArrayBuffer\" {\n  @JSName('byteLength')\n  @DomName('ArrayBuffer.byteLength')\n  @DocsEditable\n  final int lengthInBytes;\n}\n\n@DomName('ArrayBufferView')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nclass TypedData native \"ArrayBufferView\" {\n  @DomName('ArrayBufferView.buffer')\n  @DocsEditable\n  @Creates('ByteBuffer')\n  @Returns('ByteBuffer|Null')\n  final ByteBuffer buffer;\n\n  @JSName('byteLength')\n  @DomName('ArrayBufferView.byteLength')\n  @DocsEditable\n  final int lengthInBytes;\n\n  @JSName('byteOffset')\n  @DomName('ArrayBufferView.byteOffset')\n  @DocsEditable\n  final int offsetInBytes;\n\n  @JSName('BYTES_PER_ELEMENT')\n  final int elementSizeInBytes;\n}\n\n@DocsEditable\n@DomName('DataView')\nclass ByteData extends TypedData native \"DataView\" {\n  @DomName('DataView.DataView')\n  @DocsEditable\n  factory ByteData(int length) => JS('ByteData', 'new DataView(#)', length);\n\n  @DomName('DataView.DataView')\n  @DocsEditable\n  factory ByteData.view(ByteBuffer buffer, [int byteOffset, int byteLength]) {\n    if (?byteLength) {\n      return ByteData._create_1(buffer, byteOffset, byteLength);\n    }\n    if (?byteOffset) {\n      return ByteData._create_2(buffer, byteOffset);\n    }\n    return ByteData._create_3(buffer);\n  }\n\n  static ByteData _create_1(buffer, byteOffset, byteLength) =>\n    JS('ByteData', 'new DataView(#,#,#)', buffer, byteOffset, byteLength);\n  static ByteData _create_2(buffer, byteOffset) => JS('ByteData', 'new DataView(#,#)', buffer, byteOffset);\n  static ByteData _create_3(buffer) => JS('ByteData', 'new DataView(#)', buffer);\n\n  @DomName('DataView.getFloat32')\n  @DocsEditable\n  num getFloat32(int byteOffset, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _getFloat32(byteOffset, endian._littleEndian);\n\n  @JSName('getFloat32')\n  @Returns('num')\n  num _getFloat32(int byteOffset, [bool littleEndian]) native;\n\n  @DomName('DataView.getFloat64')\n  @DocsEditable\n  num getFloat64(int byteOffset, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _getFloat64(byteOffset, endian._littleEndian);\n\n  @JSName('getFloat64')\n  @Returns('num')\n  num _getFloat64(int byteOffset, [bool littleEndian]) native;\n\n  @DomName('DataView.getInt16')\n  @DocsEditable\n  int getInt16(int byteOffset, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _getInt16(byteOffset, endian._littleEndian);\n\n  @JSName('getInt16')\n  @Returns('int')\n  int _getInt16(int byteOffset, [bool littleEndian]) native;\n\n  @DomName('DataView.getInt32')\n  @DocsEditable\n  int getInt32(int byteOffset, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _getInt32(byteOffset, endian._littleEndian);\n\n  @JSName('getInt32')\n  @Returns('int')\n  int _getInt32(int byteOffset, [bool littleEndian]) native;\n\n  @DomName('DataView.getInt8')\n  @DocsEditable\n  int getInt8(int byteOffset) native;\n\n  @DomName('DataView.getUint16')\n  @DocsEditable\n  int getUint16(int byteOffset, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _getUint16(byteOffset, endian._littleEndian);\n\n  @JSName('getUint16')\n  @Returns('int')\n  int _getUint16(int byteOffset, [bool littleEndian]) native;\n\n  @DomName('DataView.getUint32')\n  @DocsEditable\n  int getUint32(int byteOffset, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _getUint32(byteOffset, endian._littleEndian);\n\n  @JSName('getUint32')\n  @Returns('int')\n  int _getUint32(int byteOffset, [bool littleEndian]) native;\n\n  @DomName('DataView.getUint8')\n  @DocsEditable\n  int getUint8(int byteOffset) native;\n\n  @DomName('DataView.setFloat32')\n  @DocsEditable\n  void setFloat32(int byteOffset, num value, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _setFloat32(byteOffset, value, endian._littleEndian);\n\n  @JSName('setFloat32')\n  void _setFloat32(int byteOffset, num value, [bool littleEndian]) native;\n\n  @DomName('DataView.setFloat64')\n  @DocsEditable\n  void setFloat64(int byteOffset, num value, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _setFloat64(byteOffset, value, endian._littleEndian);\n\n  @JSName('setFloat64')\n  void _setFloat64(int byteOffset, num value, [bool littleEndian]) native;\n\n  @DomName('DataView.setInt16')\n  @DocsEditable\n  void setInt16(int byteOffset, int value, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _setInt16(byteOffset, value, endian._littleEndian);\n\n  @JSName('setInt16')\n  void _setInt16(int byteOffset, int value, [bool littleEndian]) native;\n\n  @DomName('DataView.setInt32')\n  @DocsEditable\n  void setInt32(int byteOffset, int value, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _setInt32(byteOffset, value, endian._littleEndian);\n\n  @JSName('setInt32')\n  void _setInt32(int byteOffset, int value, [bool littleEndian]) native;\n\n  @DomName('DataView.setInt8')\n  @DocsEditable\n  void setInt8(int byteOffset, int value) native;\n\n  @DomName('DataView.setUint16')\n  @DocsEditable\n  void setUint16(int byteOffset, int value, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _setUint16(byteOffset, value, endian._littleEndian);\n\n  @JSName('setUint16')\n  void _setUint16(int byteOffset, int value, [bool littleEndian]) native;\n\n  @DomName('DataView.setUint32')\n  @DocsEditable\n  void setUint32(int byteOffset, int value, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _setUint32(byteOffset, value, endian._littleEndian);\n\n  @JSName('setUint32')\n  void _setUint32(int byteOffset, int value, [bool littleEndian]) native;\n\n  @DomName('DataView.setUint8')\n  @DocsEditable\n  void setUint8(int byteOffset, int value) native;\n}\n\n@DocsEditable\n@DomName('Float32Array')\nclass Float32List extends TypedData implements JavaScriptIndexingBehavior, List<double> native \"Float32Array\" {\n  @DomName('Float32Array.Float32Array')\n  @DocsEditable\n  factory Float32List(int length) =>\n    _TypedArrayFactoryProvider.createFloat32List(length);\n\n  @DomName('Float32Array.fromList')\n  @DocsEditable\n  factory Float32List.fromList(List<num> list) =>\n    _TypedArrayFactoryProvider.createFloat32List_fromList(list);\n\n  @DomName('Float32Array.fromBuffer')\n  @DocsEditable\n  factory Float32List.view(ByteBuffer buffer, [int byteOffset, int length]) => \n    _TypedArrayFactoryProvider.createFloat32List_fromBuffer(buffer, byteOffset, length);\n\n  static const int BYTES_PER_ELEMENT = 4;\n\n  @DomName('Float32Array.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  num operator[](int index) => JS(\"num\", \"#[#]\", this, index);\n\n  void operator[]=(int index, num value) { JS(\"void\", \"#[#] = #\", this, index, value); }\n  // -- start List<num> mixins.\n  // num is the element type.\n\n  // From Iterable<num>:\n\n  Iterator<num> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<num>(this);\n  }\n\n  num reduce(num combine(num value, num element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, num element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(num element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(num element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(num element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<num> where(bool f(num element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(num element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(num element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(num element)) => IterableMixinWorkaround.any(this, f);\n\n  List<num> toList({ bool growable: true }) =>\n      new List<num>.from(this, growable: growable);\n\n  Set<num> toSet() => new Set<num>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<num> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<num> takeWhile(bool test(num value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<num> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<num> skipWhile(bool test(num value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  num firstWhere(bool test(num value), { num orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  num lastWhere(bool test(num value), {num orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  num singleWhere(bool test(num value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  num elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<num>:\n\n  void add(num value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<num> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<num>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<num> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(num a, num b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(num element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(num element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  num get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  num get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  num get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, num element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<num> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<num> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  num removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  num removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(num element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(num element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<num> iterable, [int skipCount=0]) {\n    IterableMixinWorkaround.setRangeList(this, start, end, iterable, skipCount);\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<num> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [num fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<num> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<num> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <num>[]);\n  }\n\n  Map<int, num> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<num> mixins.\n}\n\n@DocsEditable\n@DomName('Float64Array')\nclass Float64List extends TypedData implements JavaScriptIndexingBehavior, List<double> native \"Float64Array\" {\n\n  @DomName('Float64Array.Float64Array')\n  @DocsEditable\n  factory Float64List(int length) =>\n    _TypedArrayFactoryProvider.createFloat64List(length);\n\n  @DomName('Float64Array.fromList')\n  @DocsEditable\n  factory Float64List.fromList(List<num> list) =>\n    _TypedArrayFactoryProvider.createFloat64List_fromList(list);\n\n  @DomName('Float64Array.fromBuffer')\n  @DocsEditable\n  factory Float64List.view(ByteBuffer buffer, [int byteOffset, int length]) => \n    _TypedArrayFactoryProvider.createFloat64List_fromBuffer(buffer, byteOffset, length);\n\n  static const int BYTES_PER_ELEMENT = 8;\n\n  @DomName('Float64Array.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  num operator[](int index) => JS(\"num\", \"#[#]\", this, index);\n\n  void operator[]=(int index, num value) { JS(\"void\", \"#[#] = #\", this, index, value); }\n  // -- start List<num> mixins.\n  // num is the element type.\n\n  // From Iterable<num>:\n\n  Iterator<num> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<num>(this);\n  }\n\n  num reduce(num combine(num value, num element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, num element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(num element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(num element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(num element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<num> where(bool f(num element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(num element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(num element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(num element)) => IterableMixinWorkaround.any(this, f);\n\n  List<num> toList({ bool growable: true }) =>\n      new List<num>.from(this, growable: growable);\n\n  Set<num> toSet() => new Set<num>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<num> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<num> takeWhile(bool test(num value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<num> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<num> skipWhile(bool test(num value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  num firstWhere(bool test(num value), { num orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  num lastWhere(bool test(num value), {num orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  num singleWhere(bool test(num value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  num elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<num>:\n\n  void add(num value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<num> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<num>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<num> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(num a, num b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(num element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(num element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  num get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  num get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  num get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, num element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<num> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<num> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  num removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  num removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(num element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(num element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<num> iterable, [int skipCount=0]) {\n    IterableMixinWorkaround.setRangeList(this, start, end, iterable, skipCount);\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<num> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [num fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<num> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<num> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <num>[]);\n  }\n\n  Map<int, num> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<num> mixins.\n}\n\n@DocsEditable\n@DomName('Int16Array')\nclass Int16List extends TypedData implements JavaScriptIndexingBehavior, List<int> native \"Int16Array\" {\n\n  @DomName('Int16Array.Int16Array')\n  @DocsEditable\n  factory Int16List(int length) =>\n    _TypedArrayFactoryProvider.createInt16List(length);\n\n  @DomName('Int16Array.fromList')\n  @DocsEditable\n  factory Int16List.fromList(List<int> list) =>\n    _TypedArrayFactoryProvider.createInt16List_fromList(list);\n\n  @DomName('Int16Array.fromBuffer')\n  @DocsEditable\n  factory Int16List.view(ByteBuffer buffer, [int byteOffset, int length]) => \n    _TypedArrayFactoryProvider.createInt16List_fromBuffer(buffer, byteOffset, length);\n\n  static const int BYTES_PER_ELEMENT = 2;\n\n  @DomName('Int16Array.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  int operator[](int index) => JS(\"int\", \"#[#]\", this, index);\n\n  void operator[]=(int index, int value) { JS(\"void\", \"#[#] = #\", this, index, value); }  // -- start List<int> mixins.\n  // int is the element type.\n\n  // From Iterable<int>:\n\n  Iterator<int> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<int>(this);\n  }\n\n  int reduce(int combine(int value, int element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, int element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(int element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(int element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(int element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<int> where(bool f(int element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(int element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(int element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(int element)) => IterableMixinWorkaround.any(this, f);\n\n  List<int> toList({ bool growable: true }) =>\n      new List<int>.from(this, growable: growable);\n\n  Set<int> toSet() => new Set<int>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<int> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<int> takeWhile(bool test(int value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<int> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<int> skipWhile(bool test(int value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  int firstWhere(bool test(int value), { int orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  int lastWhere(bool test(int value), {int orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  int singleWhere(bool test(int value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  int elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<int>:\n\n  void add(int value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<int>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<int> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(int a, int b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(int element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(int element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  int get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  int get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  int get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, int element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  int removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  int removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(int element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(int element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<int> iterable, [int skipCount=0]) {\n    IterableMixinWorkaround.setRangeList(this, start, end, iterable, skipCount);\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [int fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<int> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<int> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <int>[]);\n  }\n\n  Map<int, int> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<int> mixins.\n}\n\n@DocsEditable\n@DomName('Int32Array')\nclass Int32List extends TypedData implements JavaScriptIndexingBehavior, List<int> native \"Int32Array\" {\n\n  @DomName('Int32Array.Int32Array')\n  @DocsEditable\n  factory Int32List(int length) =>\n    _TypedArrayFactoryProvider.createInt32List(length);\n\n  @DomName('Int32Array.fromList')\n  @DocsEditable\n  factory Int32List.fromList(List<int> list) =>\n    _TypedArrayFactoryProvider.createInt32List_fromList(list);\n\n  @DomName('Int32Array.fromBuffer')\n  @DocsEditable\n  factory Int32List.view(ByteBuffer buffer, [int byteOffset, int length]) => \n    _TypedArrayFactoryProvider.createInt32List_fromBuffer(buffer, byteOffset, length);\n\n  static const int BYTES_PER_ELEMENT = 4;\n\n  @DomName('Int32Array.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  int operator[](int index) => JS(\"int\", \"#[#]\", this, index);\n\n  void operator[]=(int index, int value) { JS(\"void\", \"#[#] = #\", this, index, value); }  // -- start List<int> mixins.\n  // int is the element type.\n\n  // From Iterable<int>:\n\n  Iterator<int> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<int>(this);\n  }\n\n  int reduce(int combine(int value, int element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, int element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(int element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(int element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(int element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<int> where(bool f(int element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(int element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(int element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(int element)) => IterableMixinWorkaround.any(this, f);\n\n  List<int> toList({ bool growable: true }) =>\n      new List<int>.from(this, growable: growable);\n\n  Set<int> toSet() => new Set<int>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<int> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<int> takeWhile(bool test(int value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<int> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<int> skipWhile(bool test(int value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  int firstWhere(bool test(int value), { int orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  int lastWhere(bool test(int value), {int orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  int singleWhere(bool test(int value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  int elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<int>:\n\n  void add(int value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<int>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<int> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(int a, int b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(int element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(int element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  int get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  int get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  int get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, int element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  int removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  int removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(int element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(int element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<int> iterable, [int skipCount=0]) {\n    IterableMixinWorkaround.setRangeList(this, start, end, iterable, skipCount);\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [int fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<int> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<int> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <int>[]);\n  }\n\n  Map<int, int> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<int> mixins.\n}\n\n@DocsEditable\n@DomName('Int8Array')\nclass Int8List extends TypedData implements JavaScriptIndexingBehavior, List<int> native \"Int8Array\" {\n\n  @DomName('Int8Array.Int8Array')\n  @DocsEditable\n  factory Int8List(int length) =>\n    _TypedArrayFactoryProvider.createInt8List(length);\n\n  @DomName('Int8Array.fromList')\n  @DocsEditable\n  factory Int8List.fromList(List<int> list) =>\n    _TypedArrayFactoryProvider.createInt8List_fromList(list);\n\n  @DomName('Int8Array.fromBuffer')\n  @DocsEditable\n  factory Int8List.view(ByteBuffer buffer, [int byteOffset, int length]) => \n    _TypedArrayFactoryProvider.createInt8List_fromBuffer(buffer, byteOffset, length);\n\n  static const int BYTES_PER_ELEMENT = 1;\n\n  @DomName('Int8Array.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  int operator[](int index) => JS(\"int\", \"#[#]\", this, index);\n\n  void operator[]=(int index, int value) { JS(\"void\", \"#[#] = #\", this, index, value); }  // -- start List<int> mixins.\n  // int is the element type.\n\n  // From Iterable<int>:\n\n  Iterator<int> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<int>(this);\n  }\n\n  int reduce(int combine(int value, int element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, int element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(int element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(int element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(int element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<int> where(bool f(int element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(int element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(int element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(int element)) => IterableMixinWorkaround.any(this, f);\n\n  List<int> toList({ bool growable: true }) =>\n      new List<int>.from(this, growable: growable);\n\n  Set<int> toSet() => new Set<int>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<int> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<int> takeWhile(bool test(int value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<int> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<int> skipWhile(bool test(int value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  int firstWhere(bool test(int value), { int orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  int lastWhere(bool test(int value), {int orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  int singleWhere(bool test(int value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  int elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<int>:\n\n  void add(int value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<int>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<int> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(int a, int b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(int element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(int element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  int get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  int get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  int get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, int element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  int removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  int removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(int element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(int element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<int> iterable, [int skipCount=0]) {\n    IterableMixinWorkaround.setRangeList(this, start, end, iterable, skipCount);\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [int fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<int> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<int> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <int>[]);\n  }\n\n  Map<int, int> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<int> mixins.\n}\n\n@DocsEditable\n@DomName('Uint16Array')\nclass Uint16List extends TypedData implements JavaScriptIndexingBehavior, List<int> native \"Uint16Array\" {\n\n  @DomName('Uint16Array.Uint16Array')\n  @DocsEditable\n  factory Uint16List(int length) =>\n    _TypedArrayFactoryProvider.createUint16List(length);\n\n  @DomName('Uint16Array.fromList')\n  @DocsEditable\n  factory Uint16List.fromList(List<int> list) =>\n    _TypedArrayFactoryProvider.createUint16List_fromList(list);\n\n  @DomName('Uint16Array.fromBuffer')\n  @DocsEditable\n  factory Uint16List.view(ByteBuffer buffer, [int byteOffset, int length]) => \n    _TypedArrayFactoryProvider.createUint16List_fromBuffer(buffer, byteOffset, length);\n\n  static const int BYTES_PER_ELEMENT = 2;\n\n  @DomName('Uint16Array.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  int operator[](int index) => JS(\"int\", \"#[#]\", this, index);\n\n  void operator[]=(int index, int value) { JS(\"void\", \"#[#] = #\", this, index, value); }  // -- start List<int> mixins.\n  // int is the element type.\n\n  // From Iterable<int>:\n\n  Iterator<int> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<int>(this);\n  }\n\n  int reduce(int combine(int value, int element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, int element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(int element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(int element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(int element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<int> where(bool f(int element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(int element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(int element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(int element)) => IterableMixinWorkaround.any(this, f);\n\n  List<int> toList({ bool growable: true }) =>\n      new List<int>.from(this, growable: growable);\n\n  Set<int> toSet() => new Set<int>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<int> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<int> takeWhile(bool test(int value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<int> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<int> skipWhile(bool test(int value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  int firstWhere(bool test(int value), { int orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  int lastWhere(bool test(int value), {int orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  int singleWhere(bool test(int value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  int elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<int>:\n\n  void add(int value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<int>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<int> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(int a, int b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(int element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(int element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  int get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  int get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  int get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, int element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  int removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  int removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(int element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(int element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<int> iterable, [int skipCount=0]) {\n    IterableMixinWorkaround.setRangeList(this, start, end, iterable, skipCount);\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [int fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<int> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<int> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <int>[]);\n  }\n\n  Map<int, int> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<int> mixins.\n}\n\n@DocsEditable\n@DomName('Uint32Array')\nclass Uint32List extends TypedData implements JavaScriptIndexingBehavior, List<int> native \"Uint32Array\" {\n\n  @DomName('Uint32Array.Uint32Array')\n  @DocsEditable\n  factory Uint32List(int length) =>\n    _TypedArrayFactoryProvider.createUint32List(length);\n\n  @DomName('Uint32Array.fromList')\n  @DocsEditable\n  factory Uint32List.fromList(List<int> list) =>\n    _TypedArrayFactoryProvider.createUint32List_fromList(list);\n\n  @DomName('Uint32Array.fromBuffer')\n  @DocsEditable\n  factory Uint32List.view(ByteBuffer buffer, [int byteOffset, int length]) => \n    _TypedArrayFactoryProvider.createUint32List_fromBuffer(buffer, byteOffset, length);\n\n  static const int BYTES_PER_ELEMENT = 4;\n\n  @DomName('Uint32Array.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  int operator[](int index) => JS(\"int\", \"#[#]\", this, index);\n\n  void operator[]=(int index, int value) { JS(\"void\", \"#[#] = #\", this, index, value); }  // -- start List<int> mixins.\n  // int is the element type.\n\n  // From Iterable<int>:\n\n  Iterator<int> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<int>(this);\n  }\n\n  int reduce(int combine(int value, int element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, int element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(int element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(int element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(int element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<int> where(bool f(int element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(int element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(int element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(int element)) => IterableMixinWorkaround.any(this, f);\n\n  List<int> toList({ bool growable: true }) =>\n      new List<int>.from(this, growable: growable);\n\n  Set<int> toSet() => new Set<int>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<int> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<int> takeWhile(bool test(int value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<int> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<int> skipWhile(bool test(int value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  int firstWhere(bool test(int value), { int orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  int lastWhere(bool test(int value), {int orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  int singleWhere(bool test(int value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  int elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<int>:\n\n  void add(int value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<int>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<int> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(int a, int b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(int element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(int element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  int get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  int get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  int get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, int element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  int removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  int removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(int element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(int element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<int> iterable, [int skipCount=0]) {\n    IterableMixinWorkaround.setRangeList(this, start, end, iterable, skipCount);\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [int fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<int> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<int> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <int>[]);\n  }\n\n  Map<int, int> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<int> mixins.\n}\n\n@DocsEditable\n@DomName('Uint8ClampedArray')\nclass Uint8ClampedList extends Uint8List implements JavaScriptIndexingBehavior, List<int> native \"Uint8ClampedArray\" {\n\n  @DomName('Uint8ClampedArray.Uint8ClampedArray')\n  @DocsEditable\n  factory Uint8ClampedList(int length) =>\n    _TypedArrayFactoryProvider.createUint8ClampedList(length);\n\n  @DomName('Uint8ClampedArray.fromList')\n  @DocsEditable\n  factory Uint8ClampedList.fromList(List<int> list) =>\n    _TypedArrayFactoryProvider.createUint8ClampedList_fromList(list);\n\n  @DomName('Uint8ClampedArray.fromBuffer')\n  @DocsEditable\n  factory Uint8ClampedList.view(ByteBuffer buffer, [int byteOffset, int length]) => \n    _TypedArrayFactoryProvider.createUint8ClampedList_fromBuffer(buffer, byteOffset, length);\n\n  // Use implementation from Uint8Array.\n  // final int length;\n\n  int operator[](int index) => JS(\"int\", \"#[#]\", this, index);\n\n  void operator[]=(int index, int value) { JS(\"void\", \"#[#] = #\", this, index, value); }  // -- start List<int> mixins.\n  // int is the element type.\n\n  // From Iterable<int>:\n\n  Iterator<int> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<int>(this);\n  }\n\n  int reduce(int combine(int value, int element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, int element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(int element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(int element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(int element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<int> where(bool f(int element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(int element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(int element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(int element)) => IterableMixinWorkaround.any(this, f);\n\n  List<int> toList({ bool growable: true }) =>\n      new List<int>.from(this, growable: growable);\n\n  Set<int> toSet() => new Set<int>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<int> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<int> takeWhile(bool test(int value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<int> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<int> skipWhile(bool test(int value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  int firstWhere(bool test(int value), { int orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  int lastWhere(bool test(int value), {int orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  int singleWhere(bool test(int value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  int elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<int>:\n\n  void add(int value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<int>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<int> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(int a, int b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(int element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(int element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  int get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  int get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  int get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, int element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  int removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  int removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(int element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(int element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<int> iterable, [int skipCount=0]) {\n    IterableMixinWorkaround.setRangeList(this, start, end, iterable, skipCount);\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [int fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<int> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<int> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <int>[]);\n  }\n\n  Map<int, int> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<int> mixins.\n}\n\n@DocsEditable\n@DomName('Uint8Array')\nclass Uint8List extends TypedData implements JavaScriptIndexingBehavior, List<int> native \"Uint8Array\" {\n\n  @DomName('Uint8Array.Uint8Array')\n  @DocsEditable\n  factory Uint8List(int length) =>\n    _TypedArrayFactoryProvider.createUint8List(length);\n\n  @DomName('Uint8Array.fromList')\n  @DocsEditable\n  factory Uint8List.fromList(List<int> list) =>\n    _TypedArrayFactoryProvider.createUint8List_fromList(list);\n\n  @DomName('Uint8Array.fromBuffer')\n  @DocsEditable\n  factory Uint8List.view(ByteBuffer buffer, [int byteOffset, int length]) => \n    _TypedArrayFactoryProvider.createUint8List_fromBuffer(buffer, byteOffset, length);\n\n  static const int BYTES_PER_ELEMENT = 1;\n\n  @DomName('Uint8Array.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  int operator[](int index) => JS(\"int\", \"#[#]\", this, index);\n\n  void operator[]=(int index, int value) { JS(\"void\", \"#[#] = #\", this, index, value); }  // -- start List<int> mixins.\n  // int is the element type.\n\n  // From Iterable<int>:\n\n  Iterator<int> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<int>(this);\n  }\n\n  int reduce(int combine(int value, int element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, int element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(int element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(int element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(int element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<int> where(bool f(int element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(int element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(int element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(int element)) => IterableMixinWorkaround.any(this, f);\n\n  List<int> toList({ bool growable: true }) =>\n      new List<int>.from(this, growable: growable);\n\n  Set<int> toSet() => new Set<int>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<int> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<int> takeWhile(bool test(int value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<int> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<int> skipWhile(bool test(int value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  int firstWhere(bool test(int value), { int orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  int lastWhere(bool test(int value), {int orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  int singleWhere(bool test(int value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  int elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<int>:\n\n  void add(int value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<int>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<int> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(int a, int b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(int element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(int element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  int get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  int get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  int get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, int element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  int removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  int removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(int element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(int element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<int> iterable, [int skipCount=0]) {\n    IterableMixinWorkaround.setRangeList(this, start, end, iterable, skipCount);\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<int> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [int fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<int> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<int> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <int>[]);\n  }\n\n  Map<int, int> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<int> mixins.\n}\n\n\nclass Int64List extends TypedData implements JavaScriptIndexingBehavior, List<int> {\n  factory Int64List(int length) {\n    throw new UnsupportedError(\"Int64List not supported by dart2js.\");\n  }\n\n  factory Int64List.fromList(List<int> list) {\n    throw new UnsupportedError(\"Int64List not supported by dart2js.\");\n  }\n\n  factory Int64List.view(ByteBuffer buffer, [int byteOffset, int length]) {\n    throw new UnsupportedError(\"Int64List not supported by dart2js.\");\n  }\n\n  static const int BYTES_PER_ELEMENT = 8;\n}\n\n\nclass Uint64List extends TypedData implements JavaScriptIndexingBehavior, List<int> {\n  factory Int64List(int length) {\n    throw new UnsupportedError(\"Int64List not supported by dart2js.\");\n  }\n\n  factory Int64List.fromList(List<int> list) {\n    throw new UnsupportedError(\"Int64List not supported by dart2js.\");\n  }\n\n  factory Int64List.view(ByteBuffer buffer, [int byteOffset, int length]) {\n    throw new UnsupportedError(\"Int64List not supported by dart2js.\");\n  }\n\n  static const int BYTES_PER_ELEMENT = 8;\n}\n\n\n// TODO(vsm): Eliminate this class and just inline into above.\nclass _TypedArrayFactoryProvider {\n  static ByteData createByteData(int length) => _B8(length);\n  static ByteData createByteData_fromBuffer(ByteBuffer buffer,\n                                  [int byteOffset = 0, int length]) {\n    if (length == null) return _B8_2(buffer, byteOffset);\n    return _B8_3(buffer, byteOffset, length);\n  }\n\n  static Float32List createFloat32List(int length) => _F32(length);\n  static Float32List createFloat32List_fromList(List<num> list) =>\n      _F32(ensureNative(list));\n  static Float32List createFloat32List_fromBuffer(ByteBuffer buffer,\n                                  [int byteOffset = 0, int length]) {\n    if (length == null) return _F32_2(buffer, byteOffset);\n    return _F32_3(buffer, byteOffset, length);\n  }\n\n  static Float64List createFloat64List(int length) => _F64(length);\n  static Float64List createFloat64List_fromList(List<num> list) =>\n      _F64(ensureNative(list));\n  static Float64List createFloat64List_fromBuffer(ByteBuffer buffer,\n      [int byteOffset = 0, int length]) {\n    if (length == null) return _F64_2(buffer, byteOffset);\n    return _F64_3(buffer, byteOffset, length);\n  }\n\n  static Int8List createInt8List(int length) => _I8(length);\n  static Int8List createInt8List_fromList(List<num> list) =>\n      _I8(ensureNative(list));\n  static Int8List createInt8List_fromBuffer(ByteBuffer buffer,\n      [int byteOffset = 0, int length]) {\n    if (length == null) return _I8_2(buffer, byteOffset);\n    return _I8_3(buffer, byteOffset, length);\n  }\n\n  static Int16List createInt16List(int length) => _I16(length);\n  static Int16List createInt16List_fromList(List<num> list) =>\n      _I16(ensureNative(list));\n  static Int16List createInt16List_fromBuffer(ByteBuffer buffer,\n      [int byteOffset = 0, int length]) {\n    if (length == null) return _I16_2(buffer, byteOffset);\n    return _I16_3(buffer, byteOffset, length);\n  }\n\n  static Int32List createInt32List(int length) => _I32(length);\n  static Int32List createInt32List_fromList(List<num> list) =>\n      _I32(ensureNative(list));\n  static Int32List createInt32List_fromBuffer(ByteBuffer buffer,\n      [int byteOffset = 0, int length]) {\n    if (length == null) return _I32_2(buffer, byteOffset);\n    return _I32_3(buffer, byteOffset, length);\n  }\n\n  static Uint8List createUint8List(int length) => _U8(length);\n  static Uint8List createUint8List_fromList(List<num> list) =>\n      _U8(ensureNative(list));\n  static Uint8List createUint8List_fromBuffer(ByteBuffer buffer,\n      [int byteOffset = 0, int length]) {\n    if (length == null) return _U8_2(buffer, byteOffset);\n    return _U8_3(buffer, byteOffset, length);\n  }\n\n  static Uint16List createUint16List(int length) => _U16(length);\n  static Uint16List createUint16List_fromList(List<num> list) =>\n      _U16(ensureNative(list));\n  static Uint16List createUint16List_fromBuffer(ByteBuffer buffer,\n      [int byteOffset = 0, int length]) {\n    if (length == null) return _U16_2(buffer, byteOffset);\n    return _U16_3(buffer, byteOffset, length);\n  }\n\n  static Uint32List createUint32List(int length) => _U32(length);\n  static Uint32List createUint32List_fromList(List<num> list) =>\n      _U32(ensureNative(list));\n  static Uint32List createUint32List_fromBuffer(ByteBuffer buffer,\n      [int byteOffset = 0, int length]) {\n    if (length == null) return _U32_2(buffer, byteOffset);\n    return _U32_3(buffer, byteOffset, length);\n  }\n\n  static Uint8ClampedList createUint8ClampedList(int length) => _U8C(length);\n  static Uint8ClampedList createUint8ClampedList_fromList(List<num> list) =>\n      _U8C(ensureNative(list));\n  static Uint8ClampedList createUint8ClampedList_fromBuffer(\n        ByteBuffer buffer, [int byteOffset = 0, int length]) {\n    if (length == null) return _U8C_2(buffer, byteOffset);\n    return _U8C_3(buffer, byteOffset, length);\n  }\n\n  static ByteData _B8(arg) =>\n      JS('ByteData', 'new DataView(new ArrayBuffer(#))', arg);\n  static Float32List _F32(arg) =>\n      JS('Float32List', 'new Float32Array(#)', arg);\n  static Float64List _F64(arg) =>\n      JS('Float64List', 'new Float64Array(#)', arg);\n  static Int8List _I8(arg) =>\n      JS('Int8List', 'new Int8Array(#)', arg);\n  static Int16List _I16(arg) =>\n      JS('Int16List', 'new Int16Array(#)', arg);\n  static Int32List _I32(arg) =>\n      JS('Int32List', 'new Int32Array(#)', arg);\n  static Uint8List _U8(arg) =>\n      JS('Uint8List', 'new Uint8Array(#)', arg);\n  static Uint16List _U16(arg) =>\n      JS('Uint16List', 'new Uint16Array(#)', arg);\n  static Uint32List _U32(arg) =>\n      JS('Uint32List', 'new Uint32Array(#)', arg);\n  static Uint8ClampedList _U8C(arg) =>\n      JS('Uint8ClampedList', 'new Uint8ClampedArray(#)', arg);\n\n  static ByteData _B8_2(arg1, arg2) =>\n      JS('ByteData', 'new DataView(#, #)', arg1, arg2);\n  static Float32List _F32_2(arg1, arg2) =>\n      JS('Float32List', 'new Float32Array(#, #)', arg1, arg2);\n  static Float64List _F64_2(arg1, arg2) =>\n      JS('Float64List', 'new Float64Array(#, #)', arg1, arg2);\n  static Int8List _I8_2(arg1, arg2) =>\n      JS('Int8List', 'new Int8Array(#, #)', arg1, arg2);\n  static Int16List _I16_2(arg1, arg2) =>\n      JS('Int16List', 'new Int16Array(#, #)', arg1, arg2);\n  static Int32List _I32_2(arg1, arg2) =>\n      JS('Int32List', 'new Int32Array(#, #)', arg1, arg2);\n  static Uint8List _U8_2(arg1, arg2) =>\n      JS('Uint8List', 'new Uint8Array(#, #)', arg1, arg2);\n  static Uint16List _U16_2(arg1, arg2) =>\n      JS('Uint16List', 'new Uint16Array(#, #)', arg1, arg2);\n  static Uint32List _U32_2(arg1, arg2) =>\n      JS('Uint32List', 'new Uint32Array(#, #)', arg1, arg2);\n  static Uint8ClampedList _U8C_2(arg1, arg2) =>\n      JS('Uint8ClampedList', 'new Uint8ClampedArray(#, #)', arg1, arg2);\n\n  static ByteData _B8_3(arg1, arg2, arg3) =>\n      JS('ByteData', 'new DataView(#, #, #)', arg1, arg2, arg3);\n  static Float32List _F32_3(arg1, arg2, arg3) =>\n      JS('Float32List', 'new Float32Array(#, #, #)', arg1, arg2, arg3);\n  static Float64List _F64_3(arg1, arg2, arg3) =>\n      JS('Float64List', 'new Float64Array(#, #, #)', arg1, arg2, arg3);\n  static Int8List _I8_3(arg1, arg2, arg3) =>\n      JS('Int8List', 'new Int8Array(#, #, #)', arg1, arg2, arg3);\n  static Int16List _I16_3(arg1, arg2, arg3) =>\n      JS('Int16List', 'new Int16Array(#, #, #)', arg1, arg2, arg3);\n  static Int32List _I32_3(arg1, arg2, arg3) =>\n      JS('Int32List', 'new Int32Array(#, #, #)', arg1, arg2, arg3);\n  static Uint8List _U8_3(arg1, arg2, arg3) =>\n      JS('Uint8List', 'new Uint8Array(#, #, #)', arg1, arg2, arg3);\n  static Uint16List _U16_3(arg1, arg2, arg3) =>\n      JS('Uint16List', 'new Uint16Array(#, #, #)', arg1, arg2, arg3);\n  static Uint32List _U32_3(arg1, arg2, arg3) =>\n      JS('Uint32List', 'new Uint32Array(#, #, #)', arg1, arg2, arg3);\n  static Uint8ClampedList _U8C_3(arg1, arg2, arg3) =>\n      JS('Uint8ClampedList', 'new Uint8ClampedArray(#, #, #)', arg1, arg2, arg3);\n\n\n  // Ensures that [list] is a JavaScript Array or a typed array.  If necessary,\n  // copies the list.\n  static ensureNative(List list) => list;  // TODO: make sure.\n}\n","sdk/lib/typed_data/typed_data.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart.typed_data;\n\nimport 'dart:collection';\nimport 'dart:_collection-dev';\n\n/**\n * A sequence of bytes underlying a typed data object.\n * Used to process large quantities of binary or numerical data\n * more efficiently using a typed view.\n */\nabstract class ByteBuffer {\n  /**\n   * Returns the length of this byte buffer, in bytes.\n   */\n  int get lengthInBytes;\n\n}\n\n\n/**\n * A typed view of a sequence of bytes.\n */\nabstract class TypedData {\n  /**\n   * Returns the number of bytes in the representation of each element in this\n   * list.\n   */\n  int get elementSizeInBytes;\n\n  /**\n   * Returns the offset in bytes into the underlying byte buffer of this view.\n   */\n  int get offsetInBytes;\n\n  /**\n   * Returns the length of this view, in bytes.\n   */\n  int get lengthInBytes;\n\n  /**\n   * Returns the byte buffer associated with this object.\n   */\n  ByteBuffer get buffer;\n}\n\n\n/**\n * Describes endianness to be used when accessing or updating a\n * sequence of bytes.\n */\nclass Endianness {\n  const Endianness._(this._littleEndian);\n\n  static const Endianness BIG_ENDIAN = const Endianness._(false);\n  static const Endianness LITTLE_ENDIAN = const Endianness._(true);\n  static final Endianness HOST_ENDIAN =\n    (new ByteData.view(new Uint16List.fromList([1]).buffer)).getInt8(0) == 1 ?\n    LITTLE_ENDIAN : BIG_ENDIAN;\n\n  final bool _littleEndian;\n}\n\n\n/**\n * A fixed-length, random-access sequence of bytes that also provides random\n * and unaligned access to the fixed-width integers and floating point\n * numbers represented by those bytes.\n * ByteData may be used to pack and unpack data from external sources\n * (such as networks or files systems), and to process large quantities\n * of numerical data more efficiently than would be possible\n * with ordinary [List] implementations. ByteData can save space, by\n * eliminating the need for object headers, and time, by eliminating the\n * need for data copies. Finally, ByteData may be used to intentionally\n * reinterpret the bytes representing one arithmetic type as another.\n * For example this code fragment determine what 32-bit signed integer\n * is represented by the bytes of a 32-bit floating point number:\n *\n *     var buffer = new Uint8List(8).buffer;\n *     var bdata = new ByteData.view(buffer);\n *     bdata.setFloat32(0, 3.04);\n *     int huh = bdata.getInt32(0);\n */\nabstract class ByteData implements TypedData {\n  /**\n   * Creates a [ByteData] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory ByteData(int length);\n\n  /**\n   * Creates an [ByteData] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [ByteData] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   */\n  external factory ByteData.view(ByteBuffer buffer,\n                                 [int offsetInBytes = 0, int length]);\n\n  /**\n   * Returns the (possibly negative) integer represented by the byte at the\n   * specified [byteOffset] in this object, in two's complement binary\n   * representation. The return value will be between -128 and 127, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * greater than or equal to the length of this object.\n   */\n  int getInt8(int byteOffset);\n\n  /**\n   * Sets the byte at the specified [byteOffset] in this object to the\n   * two's complement binary representation of the specified [value], which\n   * must fit in a single byte. In other words, [value] must be between\n   * -128 and 127, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * greater than or equal to the length of this object.\n   */\n  void setInt8(int byteOffset, int value);\n\n  /**\n   * Returns the positive integer represented by the byte at the specified\n   * [byteOffset] in this object, in unsigned binary form. The\n   * return value will be between 0 and 255, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * greater than or equal to the length of this object.\n   */\n  int getUint8(int byteOffset);\n\n  /**\n   * Sets the byte at the specified [byteOffset] in this object to the\n   * unsigned binary representation of the specified [value], which must fit\n   * in a single byte. in other words, [value] must be between 0 and 255,\n   * inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative,\n   * or greater than or equal to the length of this object.\n   */\n  void setUint8(int byteOffset, int value);\n\n  /**\n   * Returns the (possibly negative) integer represented by the two bytes at\n   * the specified [byteOffset] in this object, in two's complement binary\n   * form.\n   * The return value will be between 2<sup>15</sup> and 2<sup>15</sup> - 1,\n   * inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 2` is greater than the length of this object.\n   */\n  int getInt16(int byteOffset, [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the two bytes starting at the specified [byteOffset] in this\n   * object to the two's complement binary representation of the specified\n   * [value], which must fit in two bytes. In other words, [value] must lie\n   * between 2<sup>15</sup> and 2<sup>15</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 2` is greater than the length of this object.\n   */\n  void setInt16(int byteOffset,\n                int value,\n                [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Returns the positive integer represented by the two bytes starting\n   * at the specified [byteOffset] in this object, in unsigned binary\n   * form.\n   * The return value will be between 0 and  2<sup>16</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 2` is greater than the length of this object.\n   */\n  int getUint16(int byteOffset, [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the two bytes starting at the specified [byteOffset] in this object\n   * to the unsigned binary representation of the specified [value],\n   * which must fit in two bytes. in other words, [value] must be between\n   * 0 and 2<sup>16</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 2` is greater than the length of this object.\n   */\n  void setUint16(int byteOffset,\n                 int value,\n                 [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Returns the (possibly negative) integer represented by the four bytes at\n   * the specified [byteOffset] in this object, in two's complement binary\n   * form.\n   * The return value will be between 2<sup>31</sup> and 2<sup>31</sup> - 1,\n   * inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  int getInt32(int byteOffset, [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the four bytes starting at the specified [byteOffset] in this\n   * object to the two's complement binary representation of the specified\n   * [value], which must fit in four bytes. In other words, [value] must lie\n   * between 2<sup>31</sup> and 2<sup>31</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  void setInt32(int byteOffset,\n                int value,\n                [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Returns the positive integer represented by the four bytes starting\n   * at the specified [byteOffset] in this object, in unsigned binary\n   * form.\n   * The return value will be between 0 and  2<sup>32</sup> - 1, inclusive.\n   *\n   */\n  int getUint32(int byteOffset, [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the four bytes starting at the specified [byteOffset] in this object\n   * to the unsigned binary representation of the specified [value],\n   * which must fit in four bytes. in other words, [value] must be between\n   * 0 and 2<sup>32</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  void setUint32(int byteOffset,\n                 int value,\n                 [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Returns the (possibly negative) integer represented by the eight bytes at\n   * the specified [byteOffset] in this object, in two's complement binary\n   * form.\n   * The return value will be between 2<sup>63</sup> and 2<sup>63</sup> - 1,\n   * inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  int getInt64(int byteOffset, [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the eight bytes starting at the specified [byteOffset] in this\n   * object to the two's complement binary representation of the specified\n   * [value], which must fit in eight bytes. In other words, [value] must lie\n   * between 2<sup>63</sup> and 2<sup>63</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  void setInt64(int byteOffset,\n                int value,\n                [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Returns the positive integer represented by the eight bytes starting\n   * at the specified [byteOffset] in this object, in unsigned binary\n   * form.\n   * The return value will be between 0 and  2<sup>64</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  int getUint64(int byteOffset, [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the eight bytes starting at the specified [byteOffset] in this object\n   * to the unsigned binary representation of the specified [value],\n   * which must fit in eight bytes. in other words, [value] must be between\n   * 0 and 2<sup>64</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  void setUint64(int byteOffset,\n                 int value,\n                 [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Returns the floating point number represented by the four bytes at\n   * the specified [byteOffset] in this object, in IEEE 754\n   * single-precision binary floating-point format (binary32).\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  double getFloat32(int byteOffset,\n                    [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the four bytes starting at the specified [byteOffset] in this\n   * object to the IEEE 754 single-precision binary floating-point\n   * (binary32) representation of the specified [value].\n   *\n   * **Note that this method can lose precision.** The input [value] is\n   * a 64-bit floating point value, which will be converted to 32-bit\n   * floating point value by IEEE 754 rounding rules before it is stored.\n   * If [value] cannot be represented exactly as a binary32, it will be\n   * converted to the nearest binary32 value.  If two binary32 values are\n   * equally close, the one whose least significant bit is zero will be used.\n   * Note that finite (but large) values can be converted to infinity, and\n   * small non-zero values can be converted to zero.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  void setFloat32(int byteOffset,\n                  double value,\n                  [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Returns the floating point number represented by the eight bytes at\n   * the specified [byteOffset] in this object, in IEEE 754\n   * double-precision binary floating-point format (binary64).\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  double getFloat64(int byteOffset,\n                    [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the eight bytes starting at the specified [byteOffset] in this\n   * object to the IEEE 754 double-precision binary floating-point\n   * (binary64) representation of the specified [value].\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  void setFloat64(int byteOffset,\n                  double value,\n                  [Endianness endian = Endianness.BIG_ENDIAN]);\n}\n\n\n/**\n * A fixed-length list of 8-bit signed integers.\n * For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Int8List implements List<int>, TypedData {\n  /**\n   * Creates an [Int8List] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Int8List(int length);\n\n  /**\n   * Creates a [Int8List] with the same size as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Int8List.fromList(List<int> elements);\n\n  /**\n   * Creates an [Int8List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Int8List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   */\n  external factory Int8List.view(ByteBuffer buffer,\n                                 [int offsetInBytes = 0, int length]);\n\n  static const int BYTES_PER_ELEMENT = 1;\n}\n\n\n/**\n * A fixed-length list of 8-bit unsigned integers.\n * For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Uint8List implements List<int>, TypedData {\n  /**\n   * Creates a [Uint8List] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Uint8List(int length);\n\n  /**\n   * Creates a [Uint8List] with the same size as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Uint8List.fromList(List<int> elements);\n\n  /**\n   * Creates a [Uint8List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Uint8List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   */\n  external factory Uint8List.view(ByteBuffer buffer,\n                                  [int offsetInBytes = 0, int length]);\n\n  static const int BYTES_PER_ELEMENT = 1;\n}\n\n\n/**\n * A fixed-length list of 8-bit unsigned integers.\n * For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n * Indexed store clamps the value to range 0..0xFF.\n */\nabstract class Uint8ClampedList implements List<int>, TypedData {\n  /**\n   * Creates a [Uint8ClampedList] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Uint8ClampedList(int length);\n\n  /**\n   * Creates a [Uint8ClampedList] of the same size as the [elements]\n   * list and copies over the values clamping when needed.\n   */\n  external factory Uint8ClampedList.fromList(List<int> elements);\n\n  /**\n   * Creates a [Uint8ClampedList] _view_ of the specified region in the\n   * specified byte [buffer]. Changes in the [Uint8List] will be visible in the\n   * byte buffer and vice versa. If the [offsetInBytes] index of the region is\n   * not specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates that\n   * the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   */\n  external factory Uint8ClampedList.view(ByteBuffer buffer,\n                                         [int offsetInBytes = 0, int length]);\n\n  static const int BYTES_PER_ELEMENT = 1;\n}\n\n\n/**\n * A fixed-length list of 16-bit signed integers that is viewable as a\n * [TypedData]. For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Int16List implements List<int>, TypedData {\n  /**\n   * Creates an [Int16List] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Int16List(int length);\n\n  /**\n   * Creates a [Int16List] with the same size as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Int16List.fromList(List<int> elements);\n\n  /**\n   * Creates an [Int16List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Int16List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * BYTES_PER_ELEMENT.\n   */\n  external factory Int16List.view(ByteBuffer buffer,\n                                  [int offsetInBytes = 0, int length]);\n\n  static const int BYTES_PER_ELEMENT = 2;\n}\n\n\n/**\n * A fixed-length list of 16-bit unsigned integers that is viewable as a\n * [TypedData]. For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Uint16List implements List<int>, TypedData {\n  /**\n   * Creates a [Uint16List] of the specified length (in elements), all\n   * of whose elements are initially zero.\n   */\n  external factory Uint16List(int length);\n\n  /**\n   * Creates a [Uint16List] with the same size as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Uint16List.fromList(List<int> elements);\n\n  /**\n   * Creates a [Uint16List] _view_ of the specified region in\n   * the specified byte buffer. Changes in the [Uint16List] will be\n   * visible in the byte buffer and vice versa. If the [offsetInBytes] index\n   * of the region is not specified, it defaults to zero (the first byte in\n   * the byte buffer). If the length is not specified, it defaults to null,\n   * which indicates that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * BYTES_PER_ELEMENT.\n   */\n  external factory Uint16List.view(ByteBuffer buffer,\n                                   [int offsetInBytes = 0, int length]);\n\n  static const int BYTES_PER_ELEMENT = 2;\n}\n\n\n/**\n * A fixed-length list of 32-bit signed integers that is viewable as a\n * [TypedData]. For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Int32List implements List<int>, TypedData {\n  /**\n   * Creates an [Int32List] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Int32List(int length);\n\n  /**\n   * Creates a [Int32List] with the same size as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Int32List.fromList(List<int> elements);\n\n  /**\n   * Creates an [Int32List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Int32List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * BYTES_PER_ELEMENT.\n   */\n  external factory Int32List.view(ByteBuffer buffer,\n                                  [int offsetInBytes = 0, int length]);\n\n  static const int BYTES_PER_ELEMENT = 4;\n}\n\n\n/**\n * A fixed-length list of 32-bit unsigned integers that is viewable as a\n * [TypedData]. For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Uint32List implements List<int>, TypedData {\n  /**\n   * Creates a [Uint32List] of the specified length (in elements), all\n   * of whose elements are initially zero.\n   */\n  external factory Uint32List(int length);\n\n  /**\n   * Creates a [Uint32List] with the same size as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Uint32List.fromList(List<int> elements);\n\n  /**\n   * Creates a [Uint32List] _view_ of the specified region in\n   * the specified byte buffer. Changes in the [Uint32] will be\n   * visible in the byte buffer and vice versa. If the [offsetInBytes] index\n   * of the region is not specified, it defaults to zero (the first byte in\n   * the byte buffer). If the length is not specified, it defaults to null,\n   * which indicates that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * BYTES_PER_ELEMENT.\n   */\n  external factory Uint32List.view(ByteBuffer buffer,\n                                   [int offsetInBytes = 0, int length]);\n\n  static const int BYTES_PER_ELEMENT = 4;\n}\n\n\n/**\n * A fixed-length list of 64-bit signed integers that is viewable as a\n * [TypedData]. For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Int64List implements List<int>, TypedData {\n  /**\n   * Creates an [Int64List] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Int64List(int length);\n\n  /**\n   * Creates a [Int64List] with the same size as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Int64List.fromList(List<int> elements);\n\n  /**\n   * Creates an [Int64List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Int64List] will be visible in the byte buffer\n   * and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates that\n   * the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * BYTES_PER_ELEMENT.\n   */\n  external factory Int64List.view(ByteBuffer buffer,\n                                  [int offsetInBytes = 0, int length]);\n\n  static const int BYTES_PER_ELEMENT = 8;\n}\n\n\n/**\n * A fixed-length list of 64-bit unsigned integers that is viewable as a\n * [TypedData]. For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Uint64List implements List<int>, TypedData {\n  /**\n   * Creates a [Uint64List] of the specified length (in elements), all\n   * of whose elements are initially zero.\n   */\n  external factory Uint64List(int length);\n\n  /**\n   * Creates a [Uint64List] with the same size as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Uint64List.fromList(List<int> elements);\n\n  /**\n   * Creates an [Uint64List] _view_ of the specified region in\n   * the specified byte buffer. Changes in the [Uint64List] will be\n   * visible in the byte buffer and vice versa. If the [offsetInBytes]\n   * index of the region is not specified, it defaults to zero (the first\n   * byte in the byte buffer). If the length is not specified, it defaults\n   * to null, which indicates that the view extends to the end of the byte\n   * buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * BYTES_PER_ELEMENT.\n   */\n  external factory Uint64List.view(ByteBuffer buffer,\n                                   [int offsetInBytes = 0, int length]);\n\n  static const int BYTES_PER_ELEMENT = 8;\n}\n\n\n/**\n * A fixed-length list of IEEE 754 single-precision binary floating-point\n * numbers  that is viewable as a [TypedData]. For long lists, this\n * implementation can be considerably more space- and time-efficient than\n * the default [List] implementation.\n */\nabstract class Float32List implements List<double>, TypedData {\n  /**\n   * Creates a [Float32List] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Float32List(int length);\n\n  /**\n   * Creates a [Float32List] with the same size as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Float32List.fromList(List<double> elements);\n\n  /**\n   * Creates a [Float32List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Float32List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * BYTES_PER_ELEMENT.\n   */\n  external factory Float32List.view(ByteBuffer buffer,\n                                    [int offsetInBytes = 0, int length]);\n\n  static const int BYTES_PER_ELEMENT = 4;\n}\n\n\n/**\n * A fixed-length list of IEEE 754 double-precision binary floating-point\n * numbers  that is viewable as a [TypedData]. For long lists, this\n * implementation can be considerably more space- and time-efficient than\n * the default [List] implementation.\n */\nabstract class Float64List implements List<double>, TypedData {\n  /**\n   * Creates a [Float64List] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Float64List(int length);\n\n  /**\n   * Creates a [Float64List] with the same size as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Float64List.fromList(List<double> elements);\n\n  /**\n   * Creates a [Float64List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Float64List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * BYTES_PER_ELEMENT.\n   */\n  external factory Float64List.view(ByteBuffer buffer,\n                                    [int offsetInBytes = 0, int length]);\n\n  static const int BYTES_PER_ELEMENT = 8;\n}\n\n\n/**\n * A fixed-length list of Float32x4 numbers that is viewable as a\n * [TypedData]. For long lists, this implementation will be considerably more\n * space- and time-efficient than the default [List] implementation.\n */\nabstract class Float32x4List implements List<Float32x4>, TypedData {\n  /**\n   * Creates a [Float32x4List] of the specified length (in elements),\n   * all of whose elements are initially zero.\n   */\n  external factory Float32x4List(int length);\n\n  /**\n   * Creates a [Float32x4List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Float32x4List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * BYTES_PER_ELEMENT.\n   */\n  external factory Float32x4List.view(ByteBuffer buffer,\n                                      [int offsetInBytes = 0, int length]);\n\n  static const int BYTES_PER_ELEMENT = 16;\n}\n\n\n/**\n * Interface of Dart Float32x4 immutable value type and operations.\n * Float32x4 stores 4 32-bit floating point values in \"lanes\".\n * The lanes are \"x\", \"y\", \"z\", and \"w\" respectively.\n */\nabstract class Float32x4 {\n  external factory Float32x4(double x, double y, double z, double w);\n  external factory Float32x4.zero();\n\n  /// Addition operator.\n  Float32x4 operator+(Float32x4 other);\n  /// Negate operator.\n  Float32x4 operator-();\n  /// Subtraction operator.\n  Float32x4 operator-(Float32x4 other);\n  /// Multiplication operator.\n  Float32x4 operator*(Float32x4 other);\n  /// Division operator.\n  Float32x4 operator/(Float32x4 other);\n\n  /// Relational less than.\n  Uint32x4 lessThan(Float32x4 other);\n  /// Relational less than or equal.\n  Uint32x4 lessThanOrEqual(Float32x4 other);\n  /// Relational greater than.\n  Uint32x4 greaterThan(Float32x4 other);\n  /// Relational greater than or equal.\n  Uint32x4 greaterThanOrEqual(Float32x4 other);\n  /// Relational equal.\n  Uint32x4 equal(Float32x4 other);\n  /// Relational not-equal.\n  Uint32x4 notEqual(Float32x4 other);\n\n  /// Returns a copy of [this] each lane being scaled by [s].\n  Float32x4 scale(double s);\n  /// Returns the absolute value of this [Float32x4].\n  Float32x4 abs();\n  /// Clamps [this] to be in the range [lowerLimit]-[upperLimit].\n  Float32x4 clamp(Float32x4 lowerLimit,\n                         Float32x4 upperLimit);\n\n  /// Extracted x value.\n  double get x;\n  /// Extracted y value.\n  double get y;\n  /// Extracted z value.\n  double get z;\n  /// Extracted w value.\n  double get w;\n\n  /// Returns a new [Float32x4] with [this]' x value in all four lanes.\n  Float32x4 get xxxx;\n  /// Returns a new [Float32x4] with [this]' y value in all four lanes.\n  Float32x4 get yyyy;\n  /// Returns a new [Float32x4] with [this]' z value in all four lanes.\n  Float32x4 get zzzz;\n  /// Returns a new [Float32x4] with [this]' w value in all four lanes.\n  Float32x4 get wwww;\n  // TODO(johnmccutchan): Add all 256 possible combinations.\n\n  /// Returns a new [Float32x4] copied from [this] with a new x value.\n  Float32x4 withX(double x);\n  /// Returns a new [Float32x4] copied from [this] with a new y value.\n  Float32x4 withY(double y);\n  /// Returns a new [Float32x4] copied from [this] with a new z value.\n  Float32x4 withZ(double z);\n  /// Returns a new [Float32x4] copied from [this] with a new w value.\n  Float32x4 withW(double w);\n\n  /// Returns the lane-wise minimum value in [this] or [other].\n  Float32x4 min(Float32x4 other);\n\n  /// Returns the lane-wise maximum value in [this] or [other].\n  Float32x4 max(Float32x4 other);\n\n  /// Returns the square root of [this].\n  Float32x4 sqrt();\n\n  /// Returns the reciprocal of [this].\n  Float32x4 reciprocal();\n\n  /// Returns the square root of the reciprocal of [this].\n  Float32x4 reciprocalSqrt();\n\n  /// Returns a bit-wise copy of [this] as a [Uint32x4].\n  Uint32x4 toUint32x4();\n}\n\n\n/**\n * Interface of Dart Uint32x4 and operations.\n * Uint32x4 stores 4 32-bit bit-masks in \"lanes\".\n * The lanes are \"x\", \"y\", \"z\", and \"w\" respectively.\n */\nabstract class Uint32x4 {\n  external factory Uint32x4(int x, int y, int z, int w);\n  external factory Uint32x4.bool(bool x, bool y, bool z, bool w);\n\n  /// The bit-wise or operator.\n  Uint32x4 operator|(Uint32x4 other);\n  /// The bit-wise and operator.\n  Uint32x4 operator&(Uint32x4 other);\n  /// The bit-wise xor operator.\n  Uint32x4 operator^(Uint32x4 other);\n\n  /// Extract 32-bit mask from x lane.\n  int get x;\n  /// Extract 32-bit mask from y lane.\n  int get y;\n  /// Extract 32-bit mask from z lane.\n  int get z;\n  /// Extract 32-bit mask from w lane.\n  int get w;\n\n  /// Returns a new [Uint32x4] copied from [this] with a new x value.\n  Uint32x4 withX(int x);\n  /// Returns a new [Uint32x4] copied from [this] with a new y value.\n  Uint32x4 withY(int y);\n  /// Returns a new [Uint32x4] copied from [this] with a new z value.\n  Uint32x4 withZ(int z);\n  /// Returns a new [Uint32x4] copied from [this] with a new w value.\n  Uint32x4 withW(int w);\n\n  /// Extracted x value. Returns false for 0, true for any other value.\n  bool get flagX;\n  /// Extracted y value. Returns false for 0, true for any other value.\n  bool get flagY;\n  /// Extracted z value. Returns false for 0, true for any other value.\n  bool get flagZ;\n  /// Extracted w value. Returns false for 0, true for any other value.\n  bool get flagW;\n\n  /// Returns a new [Uint32x4] copied from [this] with a new x value.\n  Uint32x4 withFlagX(bool x);\n  /// Returns a new [Uint32x4] copied from [this] with a new y value.\n  Uint32x4 withFlagY(bool y);\n  /// Returns a new [Uint32x4] copied from [this] with a new z value.\n  Uint32x4 withFlagZ(bool z);\n  /// Returns a new [Uint32x4] copied from [this] with a new w value.\n  Uint32x4 withFlagW(bool w);\n\n  /// Merge [trueValue] and [falseValue] based on [this]' bit mask:\n  /// Select bit from [trueValue] when bit in [this] is on.\n  /// Select bit from [falseValue] when bit in [this] is off.\n  Float32x4 select(Float32x4 trueValue, Float32x4 falseValue);\n\n  /// Returns a bit-wise copy of [this] as a [Float32x4].\n  Float32x4 toFloat32x4();\n}\n","sdk/lib/uri/encode_decode.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.uri;\n\n/**\n * Javascript-like URI encode/decode functions.\n * The documentation here borrows heavily from the original Javascript\n * doumentation on MDN at:\n * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects\n */\n\n/**\n * A JavaScript-like URI encoder. Encodes Uniform Resource Identifier [uri]\n * by replacing each instance of certain characters by one, two, three, or four\n * escape sequences representing the UTF-8 encoding of the character (will\n * only be four escape sequences for characters composed of two \"surrogate\"\n * characters). This assumes that [uri] is a complete URI, so does not encode\n * reserved characters that have special meaning in the URI: [:#;,/?:@&=+\\$:]\n * It returns the escaped URI.\n */\nString encodeUri(String uri) {\n  // Bit vector of 128 bits where each bit indicate whether a\n  // character code on the 0-127 needs to be escaped or not.\n  const canonicalTable = const [\n                //             LSB            MSB\n                //              |              |\n      0x0000,   // 0x00 - 0x0f  0000000000000000\n      0x0000,   // 0x10 - 0x1f  0000000000000000\n                //               ! #$ &'()*+,-./\n      0xf7da,   // 0x20 - 0x2f  0101101111101111\n                //              0123456789:; = ?\n      0xafff,   // 0x30 - 0x3f  1111111111110101\n                //              @ABCDEFGHIJKLMNO\n      0xffff,   // 0x40 - 0x4f  1111111111111111\n                //              PQRSTUVWXYZ    _\n      0x87ff,   // 0x50 - 0x5f  1111111111100001\n                //               abcdefghijklmno\n      0xfffe,   // 0x60 - 0x6f  0111111111111111\n                //              pqrstuvwxyz   ~\n      0x47ff];  // 0x70 - 0x7f  1111111111100010\n  return _uriEncode(canonicalTable, uri);\n}\n\n/**\n * An implementation of JavaScript's decodeURIComponent function.\n * Decodes a Uniform Resource Identifier [uri] previously created by\n * encodeURI or by a similar routine. It replaces each escape sequence\n * in [uri] with the character that it represents. It does not decode\n * escape sequences that could not have been introduced by encodeURI.\n * It returns the unescaped URI.\n */\nString decodeUri(String uri) {\n  return _uriDecode(uri);\n}\n\n/**\n * A javaScript-like URI component encoder, this encodes a URI\n * [component] by replacing each instance of certain characters by one,\n * two, three, or four escape sequences representing the UTF-8 encoding of\n * the character (will only be four escape sequences for characters composed\n * of two \"surrogate\" characters).\n * To avoid unexpected requests to the server, you should call\n * encodeURIComponent on any user-entered parameters that will be passed as\n * part of a URI. For example, a user could type \"Thyme &time=again\" for a\n * variable comment. Not using encodeURIComponent on this variable will give\n * comment=Thyme%20&time=again. Note that the ampersand and the equal sign\n * mark a new key and value pair. So instead of having a POST comment key\n * equal to \"Thyme &time=again\", you have two POST keys, one equal to \"Thyme \"\n * and another (time) equal to again.\n * It returns the escaped string.\n */\nString encodeUriComponent(String component) {\n  // Bit vector of 128 bits where each bit indicate whether a\n  // character code on the 0-127 needs to be escaped or not.\n  const canonicalTable = const [\n                //             LSB            MSB\n                //              |              |\n      0x0000,   // 0x00 - 0x0f  0000000000000000\n      0x0000,   // 0x10 - 0x1f  0000000000000000\n                //               !     '()*  -.\n      0x6782,   // 0x20 - 0x2f  0100000111100110\n                //              0123456789\n      0x03ff,   // 0x30 - 0x3f  1111111111000000\n                //              @ABCDEFGHIJKLMNO\n      0xfffe,   // 0x40 - 0x4f  0111111111111111\n                //              PQRSTUVWXYZ    _\n      0x87ff,   // 0x50 - 0x5f  1111111111100001\n                //               abcdefghijklmno\n      0xfffe,   // 0x60 - 0x6f  0111111111111111\n                //              pqrstuvwxyz   ~\n      0x47ff];  // 0x70 - 0x7f  1111111111100010\n  return _uriEncode(canonicalTable, component);\n}\n\n/**\n * An implementation of JavaScript's decodeURIComponent function.\n * Decodes a Uniform Resource Identifier (URI) [component] previously\n * created by encodeURIComponent or by a similar routine.\n * It returns the unescaped string.\n */\nString decodeUriComponent(String encodedComponent) {\n  return _uriDecode(encodedComponent);\n}\n\n/**\n * This is the internal implementation of JavaScript's encodeURI function.\n * It encodes all characters in the string [text] except for those\n * that appear in [canonicalTable], and returns the escaped string.\n */\nString _uriEncode(List<int> canonicalTable, String text) {\n  final String hex = '0123456789ABCDEF';\n  var byteToHex = (int v) => '%${hex[v >> 4]}${hex[v & 0x0f]}';\n  StringBuffer result = new StringBuffer();\n  for (int i = 0; i < text.length; i++) {\n    int ch = text.codeUnitAt(i);\n    if (ch < 128 && ((canonicalTable[ch >> 4] & (1 << (ch & 0x0f))) != 0)) {\n      result.write(text[i]);\n    } else if (text[i] == \" \") {\n      result.write(\"+\");\n    } else {\n      if (ch >= 0xD800 && ch < 0xDC00) {\n        // Low surrogate. We expect a next char high surrogate.\n        ++i;\n        int nextCh = text.length == i ? 0 : text.codeUnitAt(i);\n        if (nextCh >= 0xDC00 && nextCh < 0xE000) {\n          // convert the pair to a U+10000 codepoint\n          ch = 0x10000 + ((ch - 0xD800) << 10) + (nextCh - 0xDC00);\n        } else {\n          throw new ArgumentError('Malformed URI');\n        }\n      }\n      for (int codepoint in codepointsToUtf8([ch])) {\n        result.write(byteToHex(codepoint));\n      }\n    }\n  }\n  return result.toString();\n}\n\n/**\n * Convert a byte (2 character hex sequence) in string [s] starting\n * at position [pos] to its ordinal value\n */\nint _hexCharPairToByte(String s, int pos) {\n  int byte = 0;\n  for (int i = 0; i < 2; i++) {\n    var charCode = s.codeUnitAt(pos + i);\n    if (0x30 <= charCode && charCode <= 0x39) {\n      byte = byte * 16 + charCode - 0x30;\n    } else {\n      // Check ranges A-F (0x41-0x46) and a-f (0x61-0x66).\n      charCode |= 0x20;\n      if (0x61 <= charCode && charCode <= 0x66) {\n        byte = byte * 16 + charCode - 0x57;\n      } else {\n        throw new ArgumentError(\"Invalid URL encoding\");\n      }\n    }\n  }\n  return byte;\n}\n\n/**\n * A JavaScript-like decodeURI function. It unescapes the string [text] and\n * returns the unescaped string.\n */\nString _uriDecode(String text) {\n  StringBuffer result = new StringBuffer();\n  List<int> codepoints = new List<int>();\n  for (int i = 0; i < text.length;) {\n    String ch = text[i];\n    if (ch != '%') {\n      if (ch == '+') {\n        result.write(\" \");\n      } else {\n        result.write(ch);\n      }\n      i++;\n    } else {\n      codepoints.clear();\n      while (ch == '%') {\n        if (++i > text.length - 2) {\n          throw new ArgumentError('Truncated URI');\n        }\n        codepoints.add(_hexCharPairToByte(text, i));\n        i += 2;\n        if (i == text.length)\n          break;\n        ch = text[i];\n      }\n      result.write(decodeUtf8(codepoints));\n    }\n  }\n  return result.toString();\n}\n\n","sdk/lib/uri/helpers.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.uri;\n\nString merge(String base, String reference) {\n  if (base == \"\") return \"/$reference\";\n  return \"${base.substring(0, base.lastIndexOf(\"/\") + 1)}$reference\";\n}\n\nString removeDotSegments(String path) {\n  List<String> output = [];\n  bool appendSlash = false;\n  for (String segment in path.split(\"/\")) {\n    appendSlash = false;\n    if (segment == \"..\") {\n      if (!output.isEmpty &&\n          ((output.length != 1) || (output[0] != \"\"))) output.removeLast();\n      appendSlash = true;\n    } else if (\".\" == segment) {\n      appendSlash = true;\n    } else {\n      output.add(segment);\n    }\n  }\n  if (appendSlash) output.add(\"\");\n  return output.join(\"/\");\n}\n","sdk/lib/uri/uri.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart.uri;\n\nimport 'dart:math';\nimport 'dart:utf';\n\npart 'encode_decode.dart';\npart 'helpers.dart';\n\n/**\n * A parsed URI, inspired by Closure's [URI][] class. Implements [RFC-3986][].\n * [uri]: http://closure-library.googlecode.com/svn/docs/class_goog_Uri.html\n * [RFC-3986]: http://tools.ietf.org/html/rfc3986#section-4.3)\n */\nclass Uri {\n  final String scheme;\n  final String userInfo;\n  final String domain;\n  final int port;\n  final String path;\n  final String query;\n  final String fragment;\n\n  /**\n   * Deprecated. Please use [parse] instead.\n   */\n  Uri.fromString(String uri) : this._fromMatch(_splitRe.firstMatch(uri));\n\n  static Uri parse(String uri) => new Uri._fromMatch(_splitRe.firstMatch(uri));\n\n  Uri._fromMatch(Match m) :\n    this.fromComponents(scheme: _emptyIfNull(m[_COMPONENT_SCHEME]),\n                        userInfo: _emptyIfNull(m[_COMPONENT_USER_INFO]),\n                        domain: _emptyIfNull(m[_COMPONENT_DOMAIN]),\n                        port: _parseIntOrZero(m[_COMPONENT_PORT]),\n                        path: _emptyIfNull(m[_COMPONENT_PATH]),\n                        query: _emptyIfNull(m[_COMPONENT_QUERY_DATA]),\n                        fragment: _emptyIfNull(m[_COMPONENT_FRAGMENT]));\n\n  const Uri.fromComponents({this.scheme: \"\",\n                            this.userInfo: \"\",\n                            this.domain: \"\",\n                            this.port: 0,\n                            this.path: \"\",\n                            this.query: \"\",\n                            this.fragment: \"\"});\n\n  Uri(String uri) : this.fromString(uri);\n\n  static String _emptyIfNull(String val) => val != null ? val : '';\n\n  static int _parseIntOrZero(String val) {\n    if (val != null && val != '') {\n      return int.parse(val);\n    } else {\n      return 0;\n    }\n  }\n\n  // NOTE: This code was ported from: closure-library/closure/goog/uri/utils.js\n  static final RegExp _splitRe = new RegExp(\n      '^'\n      '(?:'\n        '([^:/?#.]+)'                   // scheme - ignore special characters\n                                        // used by other URL parts such as :,\n                                        // ?, /, #, and .\n      ':)?'\n      '(?://'\n        '(?:([^/?#]*)@)?'               // userInfo\n        '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)'\n                                        // domain - restrict to letters,\n                                        // digits, dashes, dots, percent\n                                        // escapes, and unicode characters.\n        '(?::([0-9]+))?'                // port\n      ')?'\n      '([^?#]+)?'                       // path\n      '(?:\\\\?([^#]*))?'                 // query\n      '(?:#(.*))?'                      // fragment\n      '\\$');\n\n  static const _COMPONENT_SCHEME = 1;\n  static const _COMPONENT_USER_INFO = 2;\n  static const _COMPONENT_DOMAIN = 3;\n  static const _COMPONENT_PORT = 4;\n  static const _COMPONENT_PATH = 5;\n  static const _COMPONENT_QUERY_DATA = 6;\n  static const _COMPONENT_FRAGMENT = 7;\n\n  /**\n   * Returns `true` if the URI is absolute.\n   */\n  bool get isAbsolute {\n    if (\"\" == scheme) return false;\n    if (\"\" != fragment) return false;\n    return true;\n\n    /* absolute-URI  = scheme \":\" hier-part [ \"?\" query ]\n     * hier-part   = \"//\" authority path-abempty\n     *             / path-absolute\n     *             / path-rootless\n     *             / path-empty\n     *\n     * path          = path-abempty    ; begins with \"/\" or is empty\n     *               / path-absolute   ; begins with \"/\" but not \"//\"\n     *               / path-noscheme   ; begins with a non-colon segment\n     *               / path-rootless   ; begins with a segment\n     *               / path-empty      ; zero characters\n     *\n     * path-abempty  = *( \"/\" segment )\n     * path-absolute = \"/\" [ segment-nz *( \"/\" segment ) ]\n     * path-noscheme = segment-nz-nc *( \"/\" segment )\n     * path-rootless = segment-nz *( \"/\" segment )\n     * path-empty    = 0<pchar>\n     * segment       = *pchar\n     * segment-nz    = 1*pchar\n     * segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / \"@\" )\n     *               ; non-zero-length segment without any colon \":\"\n     *\n     * pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n     */\n  }\n\n  Uri resolve(String uri) {\n    return resolveUri(Uri.parse(uri));\n  }\n\n  Uri resolveUri(Uri reference) {\n    // From RFC 3986.\n    String targetScheme;\n    String targetUserInfo;\n    String targetDomain;\n    int targetPort;\n    String targetPath;\n    String targetQuery;\n    if (reference.scheme != \"\") {\n      targetScheme = reference.scheme;\n      targetUserInfo = reference.userInfo;\n      targetDomain = reference.domain;\n      targetPort = reference.port;\n      targetPath = removeDotSegments(reference.path);\n      targetQuery = reference.query;\n    } else {\n      if (reference.hasAuthority) {\n        targetUserInfo = reference.userInfo;\n        targetDomain = reference.domain;\n        targetPort = reference.port;\n        targetPath = removeDotSegments(reference.path);\n        targetQuery = reference.query;\n      } else {\n        if (reference.path == \"\") {\n          targetPath = this.path;\n          if (reference.query != \"\") {\n            targetQuery = reference.query;\n          } else {\n            targetQuery = this.query;\n          }\n        } else {\n          if (reference.path.startsWith(\"/\")) {\n            targetPath = removeDotSegments(reference.path);\n          } else {\n            targetPath = removeDotSegments(merge(this.path, reference.path));\n          }\n          targetQuery = reference.query;\n        }\n        targetUserInfo = this.userInfo;\n        targetDomain = this.domain;\n        targetPort = this.port;\n      }\n      targetScheme = this.scheme;\n    }\n    return new Uri.fromComponents(scheme: targetScheme,\n                                  userInfo: targetUserInfo,\n                                  domain: targetDomain,\n                                  port: targetPort,\n                                  path: targetPath,\n                                  query: targetQuery,\n                                  fragment: reference.fragment);\n  }\n\n  bool get hasAuthority {\n    return (userInfo != \"\") || (domain != \"\") || (port != 0);\n  }\n\n  /**\n   * For http/https schemes returns URI's [origin][] - scheme://domain:port.\n   * For all other schemes throws ArgumentError.\n   * [origin]: http://www.w3.org/TR/2011/WD-html5-20110405/origin-0.html#origin\n   */\n  String get origin {\n    if (scheme == \"\") {\n      // TODO(aprelev@gmail.com): Use StateException instead\n      throw new ArgumentError(\"Cannot use origin without a scheme\");\n    }\n    if (scheme != \"http\" && scheme != \"https\") {\n      // TODO(aprelev@gmail.com): Use StateException instead\n      throw new ArgumentError(\n        \"origin is applicable to http/https schemes only. Not \\'$scheme\\'\");\n    }\n    StringBuffer sb = new StringBuffer();\n    sb.write(scheme);\n    sb.write(\":\");\n    if (domain == null || domain == \"\") {\n      // TODO(aprelev@gmail.com): Use StateException instead\n      throw new ArgumentError(\"Cannot use origin without a domain\");\n    }\n\n    sb.write(\"//\");\n    sb.write(domain);\n    if (port != 0) {\n      sb.write(\":\");\n      sb.write(port);\n    }\n    return sb.toString();\n  }\n\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    _addIfNonEmpty(sb, scheme, scheme, ':');\n    if (hasAuthority || (scheme == \"file\")) {\n      sb.write(\"//\");\n      _addIfNonEmpty(sb, userInfo, userInfo, \"@\");\n      sb.write(domain == null ? \"null\" : domain);\n      if (port != 0) {\n        sb.write(\":\");\n        sb.write(port.toString());\n      }\n    }\n    sb.write(path == null ? \"null\" : path);\n    _addIfNonEmpty(sb, query, \"?\", query);\n    _addIfNonEmpty(sb, fragment, \"#\", fragment);\n    return sb.toString();\n  }\n\n  bool operator==(other) {\n    if (other is! Uri) return false;\n    Uri uri = other;\n    return scheme == uri.scheme &&\n        userInfo == uri.userInfo &&\n        domain == uri.domain &&\n        port == uri.port &&\n        path == uri.path &&\n        query == uri.query &&\n        fragment == uri.fragment;\n  }\n\n  int get hashCode {\n    int combine(part, current) {\n      // The sum is truncated to 30 bits to make sure it fits into a Smi.\n      return (current * 31 + part.hashCode) & 0x3FFFFFFF;\n    }\n    return combine(scheme, combine(userInfo, combine(domain, combine(port,\n        combine(path, combine(query, combine(fragment, 1)))))));\n  }\n\n  static void _addIfNonEmpty(StringBuffer sb, String test,\n                             String first, String second) {\n    if (\"\" != test) {\n      sb.write(first == null ? \"null\" : first);\n      sb.write(second == null ? \"null\" : second);\n    }\n  }\n}\n","sdk/lib/utf/utf.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart.utf;\nimport \"dart:async\";\nimport \"dart:collection\";\npart \"utf_stream.dart\";\npart \"utf8.dart\";\npart \"utf16.dart\";\npart \"utf32.dart\";\n\n// TODO(jmesserly): would be nice to have this on String (dartbug.com/6501).\n/**\n * Provide a list of Unicode codepoints for a given string.\n */\nList<int> stringToCodepoints(String str) {\n  // Note: str.codeUnits gives us 16-bit code units on all Dart implementations.\n  // So we need to convert.\n  return _utf16CodeUnitsToCodepoints(str.codeUnits);\n}\n\n/**\n * Generate a string from the provided Unicode codepoints.\n *\n * *Deprecated* Use [String.fromCharCodes] instead.\n */\nString codepointsToString(List<int> codepoints) {\n  return new String.fromCharCodes(codepoints);\n}\n\n/**\n * Invalid codepoints or encodings may be substituted with the value U+fffd.\n */\nconst int UNICODE_REPLACEMENT_CHARACTER_CODEPOINT = 0xfffd;\nconst int UNICODE_BOM = 0xfeff;\nconst int UNICODE_UTF_BOM_LO = 0xff;\nconst int UNICODE_UTF_BOM_HI = 0xfe;\n\nconst int UNICODE_BYTE_ZERO_MASK = 0xff;\nconst int UNICODE_BYTE_ONE_MASK = 0xff00;\nconst int UNICODE_VALID_RANGE_MAX = 0x10ffff;\nconst int UNICODE_PLANE_ONE_MAX = 0xffff;\nconst int UNICODE_UTF16_RESERVED_LO = 0xd800;\nconst int UNICODE_UTF16_RESERVED_HI = 0xdfff;\nconst int UNICODE_UTF16_OFFSET = 0x10000;\nconst int UNICODE_UTF16_SURROGATE_UNIT_0_BASE = 0xd800;\nconst int UNICODE_UTF16_SURROGATE_UNIT_1_BASE = 0xdc00;\nconst int UNICODE_UTF16_HI_MASK = 0xffc00;\nconst int UNICODE_UTF16_LO_MASK = 0x3ff;\n\n/**\n * Encode code points as UTF16 code units.\n */\nList<int> _codepointsToUtf16CodeUnits(\n    List<int> codepoints,\n    [int offset = 0,\n     int length,\n     int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n\n  _ListRange listRange = new _ListRange(codepoints, offset, length);\n  int encodedLength = 0;\n  for (int value in listRange) {\n    if ((value >= 0 && value < UNICODE_UTF16_RESERVED_LO) ||\n        (value > UNICODE_UTF16_RESERVED_HI && value <= UNICODE_PLANE_ONE_MAX)) {\n      encodedLength++;\n    } else if (value > UNICODE_PLANE_ONE_MAX &&\n        value <= UNICODE_VALID_RANGE_MAX) {\n      encodedLength += 2;\n    } else {\n      encodedLength++;\n    }\n  }\n\n  List<int> codeUnitsBuffer = new List<int>(encodedLength);\n  int j = 0;\n  for (int value in listRange) {\n    if ((value >= 0 && value < UNICODE_UTF16_RESERVED_LO) ||\n        (value > UNICODE_UTF16_RESERVED_HI && value <= UNICODE_PLANE_ONE_MAX)) {\n      codeUnitsBuffer[j++] = value;\n    } else if (value > UNICODE_PLANE_ONE_MAX &&\n        value <= UNICODE_VALID_RANGE_MAX) {\n      int base = value - UNICODE_UTF16_OFFSET;\n      codeUnitsBuffer[j++] = UNICODE_UTF16_SURROGATE_UNIT_0_BASE +\n          ((base & UNICODE_UTF16_HI_MASK) >> 10);\n      codeUnitsBuffer[j++] = UNICODE_UTF16_SURROGATE_UNIT_1_BASE +\n          (base & UNICODE_UTF16_LO_MASK);\n    } else if (replacementCodepoint != null) {\n      codeUnitsBuffer[j++] = replacementCodepoint;\n    } else {\n      throw new ArgumentError(\"Invalid encoding\");\n    }\n  }\n  return codeUnitsBuffer;\n}\n\n/**\n * Decodes the utf16 codeunits to codepoints.\n */\nList<int> _utf16CodeUnitsToCodepoints(\n    List<int> utf16CodeUnits, [int offset = 0, int length,\n    int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n  _ListRangeIterator source =\n      (new _ListRange(utf16CodeUnits, offset, length)).iterator;\n  Utf16CodeUnitDecoder decoder = new Utf16CodeUnitDecoder\n      .fromListRangeIterator(source, replacementCodepoint);\n  List<int> codepoints = new List<int>(source.remaining);\n  int i = 0;\n  while (decoder.moveNext()) {\n    codepoints[i++] = decoder.current;\n  }\n  if (i == codepoints.length) {\n    return codepoints;\n  } else {\n    List<int> codepointTrunc = new List<int>(i);\n    codepointTrunc.setRange(0, i, codepoints);\n    return codepointTrunc;\n  }\n}\n\n/**\n * An Iterator<int> of codepoints built on an Iterator of UTF-16 code units.\n * The parameters can override the default Unicode replacement character. Set\n * the replacementCharacter to null to throw an ArgumentError\n * rather than replace the bad value.\n */\nclass Utf16CodeUnitDecoder implements Iterator<int> {\n  final _ListRangeIterator utf16CodeUnitIterator;\n  final int replacementCodepoint;\n  int _current = null;\n\n  Utf16CodeUnitDecoder(List<int> utf16CodeUnits, [int offset = 0, int length,\n      int this.replacementCodepoint =\n      UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) :\n      utf16CodeUnitIterator =\n          (new _ListRange(utf16CodeUnits, offset, length)).iterator;\n\n  Utf16CodeUnitDecoder.fromListRangeIterator(\n      _ListRangeIterator this.utf16CodeUnitIterator,\n      int this.replacementCodepoint);\n\n  Iterator<int> get iterator => this;\n\n  int get current => _current;\n\n  bool moveNext() {\n    _current = null;\n    if (!utf16CodeUnitIterator.moveNext()) return false;\n\n    int value = utf16CodeUnitIterator.current;\n    if (value < 0) {\n      if (replacementCodepoint != null) {\n        _current = replacementCodepoint;\n      } else {\n        throw new ArgumentError(\n            \"Invalid UTF16 at ${utf16CodeUnitIterator.position}\");\n      }\n    } else if (value < UNICODE_UTF16_RESERVED_LO ||\n        (value > UNICODE_UTF16_RESERVED_HI && value <= UNICODE_PLANE_ONE_MAX)) {\n      // transfer directly\n      _current = value;\n    } else if (value < UNICODE_UTF16_SURROGATE_UNIT_1_BASE &&\n        utf16CodeUnitIterator.moveNext()) {\n      // merge surrogate pair\n      int nextValue = utf16CodeUnitIterator.current;\n      if (nextValue >= UNICODE_UTF16_SURROGATE_UNIT_1_BASE &&\n          nextValue <= UNICODE_UTF16_RESERVED_HI) {\n        value = (value - UNICODE_UTF16_SURROGATE_UNIT_0_BASE) << 10;\n        value += UNICODE_UTF16_OFFSET +\n            (nextValue - UNICODE_UTF16_SURROGATE_UNIT_1_BASE);\n        _current = value;\n      } else {\n        if (nextValue >= UNICODE_UTF16_SURROGATE_UNIT_0_BASE &&\n           nextValue < UNICODE_UTF16_SURROGATE_UNIT_1_BASE) {\n          utf16CodeUnitIterator.backup();\n        }\n        if (replacementCodepoint != null) {\n          _current = replacementCodepoint;\n        } else {\n          throw new ArgumentError(\n              \"Invalid UTF16 at ${utf16CodeUnitIterator.position}\");\n        }\n      }\n    } else if (replacementCodepoint != null) {\n      _current = replacementCodepoint;\n    } else {\n      throw new ArgumentError(\n          \"Invalid UTF16 at ${utf16CodeUnitIterator.position}\");\n    }\n    return true;\n  }\n}\n\n/**\n * _ListRange in an internal type used to create a lightweight Interable on a\n * range within a source list. DO NOT MODIFY the underlying list while\n * iterating over it. The results of doing so are undefined.\n */\n// TODO(floitsch): Consider removing the extend and switch to implements since\n// that's cheaper to allocate.\nclass _ListRange extends IterableBase {\n  final List _source;\n  final int _offset;\n  final int _length;\n\n  _ListRange(source, [offset = 0, length]) :\n      this._source = source,\n      this._offset = offset,\n      this._length = (length == null ? source.length - offset : length) {\n    if (_offset < 0 || _offset > _source.length) {\n      throw new RangeError.value(_offset);\n    }\n    if (_length != null && (_length < 0)) {\n      throw new RangeError.value(_length);\n    }\n    if (_length + _offset > _source.length) {\n      throw new RangeError.value(_length + _offset);\n    }\n  }\n\n  _ListRangeIterator get iterator =>\n      new _ListRangeIteratorImpl(_source, _offset, _offset + _length);\n\n  int get length => _length;\n}\n\n/**\n * The _ListRangeIterator provides more capabilities than a standard iterator,\n * including the ability to get the current position, count remaining items,\n * and move forward/backward within the iterator.\n */\nabstract class _ListRangeIterator implements Iterator<int> {\n  bool moveNext();\n  int get current;\n  int get position;\n  void backup([by]);\n  int get remaining;\n  void skip([count]);\n}\n\nclass _ListRangeIteratorImpl implements _ListRangeIterator {\n  final List<int> _source;\n  int _offset;\n  final int _end;\n\n  _ListRangeIteratorImpl(this._source, int offset, this._end)\n      : _offset = offset - 1;\n\n  int get current => _source[_offset];\n\n  bool moveNext() => ++_offset < _end;\n\n  int get position => _offset;\n\n  void backup([int by = 1]) {\n    _offset -= by;\n  }\n\n  int get remaining => _end - _offset - 1;\n\n  void skip([int count = 1]) {\n    _offset += count;\n  }\n}\n\n","sdk/lib/utf/utf16.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.utf;\n\n/**\n * Decodes the UTF-16 bytes as an iterable. Thus, the consumer can only convert\n * as much of the input as needed. Determines the byte order from the BOM,\n * or uses big-endian as a default. This method always strips a leading BOM.\n * Set the [replacementCodepoint] to null to throw an ArgumentError\n * rather than replace the bad value. The default value for\n * [replacementCodepoint] is U+FFFD.\n */\nIterableUtf16Decoder decodeUtf16AsIterable(List<int> bytes, [int offset = 0,\n    int length, int replacementCodepoint =\n    UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n  return new IterableUtf16Decoder._(\n      () => new Utf16BytesToCodeUnitsDecoder(bytes, offset, length,\n      replacementCodepoint), replacementCodepoint);\n}\n\n/**\n * Decodes the UTF-16BE bytes as an iterable. Thus, the consumer can only\n * convert as much of the input as needed. This method strips a leading BOM by\n * default, but can be overridden by setting the optional parameter [stripBom]\n * to false. Set the [replacementCodepoint] to null to throw an\n * ArgumentError rather than replace the bad value. The default\n * value for the [replacementCodepoint] is U+FFFD.\n */\nIterableUtf16Decoder decodeUtf16beAsIterable(List<int> bytes, [int offset = 0,\n    int length, bool stripBom = true, int replacementCodepoint =\n    UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n  return new IterableUtf16Decoder._(\n      () => new Utf16beBytesToCodeUnitsDecoder(bytes, offset, length, stripBom,\n      replacementCodepoint), replacementCodepoint);\n}\n\n/**\n * Decodes the UTF-16LE bytes as an iterable. Thus, the consumer can only\n * convert as much of the input as needed. This method strips a leading BOM by\n * default, but can be overridden by setting the optional parameter [stripBom]\n * to false. Set the [replacementCodepoint] to null to throw an\n * ArgumentError rather than replace the bad value. The default\n * value for the [replacementCodepoint] is U+FFFD.\n */\nIterableUtf16Decoder decodeUtf16leAsIterable(List<int> bytes, [int offset = 0,\n    int length, bool stripBom = true, int replacementCodepoint =\n    UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n  return new IterableUtf16Decoder._(\n      () => new Utf16leBytesToCodeUnitsDecoder(bytes, offset, length, stripBom,\n      replacementCodepoint), replacementCodepoint);\n}\n\n/**\n * Produce a String from a sequence of UTF-16 encoded bytes. This method always\n * strips a leading BOM. Set the [replacementCodepoint] to null to throw  an\n * ArgumentError rather than replace the bad value. The default\n * value for the [replacementCodepoint] is U+FFFD.\n */\nString decodeUtf16(List<int> bytes, [int offset = 0, int length,\n    int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n  Utf16BytesToCodeUnitsDecoder decoder = new Utf16BytesToCodeUnitsDecoder(bytes,\n      offset, length, replacementCodepoint);\n  List<int> codeunits = decoder.decodeRest();\n  return new String.fromCharCodes(\n      _utf16CodeUnitsToCodepoints(codeunits, 0, null, replacementCodepoint));\n}\n\n/**\n * Produce a String from a sequence of UTF-16BE encoded bytes. This method\n * strips a leading BOM by default, but can be overridden by setting the\n * optional parameter [stripBom] to false. Set the [replacementCodepoint] to\n * null to throw an ArgumentError rather than replace the bad value.\n * The default value for the [replacementCodepoint] is U+FFFD.\n */\nString decodeUtf16be(List<int> bytes, [int offset = 0, int length,\n    bool stripBom = true,\n    int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n  List<int> codeunits = (new Utf16beBytesToCodeUnitsDecoder(bytes, offset,\n      length, stripBom, replacementCodepoint)).decodeRest();\n  return new String.fromCharCodes(\n      _utf16CodeUnitsToCodepoints(codeunits, 0, null, replacementCodepoint));\n}\n\n/**\n * Produce a String from a sequence of UTF-16LE encoded bytes. This method\n * strips a leading BOM by default, but can be overridden by setting the\n * optional parameter [stripBom] to false. Set the [replacementCodepoint] to\n * null to throw an ArgumentError rather than replace the bad value.\n * The default value for the [replacementCodepoint] is U+FFFD.\n */\nString decodeUtf16le(List<int> bytes, [int offset = 0, int length,\n    bool stripBom = true,\n    int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n  List<int> codeunits = (new Utf16leBytesToCodeUnitsDecoder(bytes, offset,\n      length, stripBom, replacementCodepoint)).decodeRest();\n  return new String.fromCharCodes(\n      _utf16CodeUnitsToCodepoints(codeunits, 0, null, replacementCodepoint));\n}\n\n/**\n * Produce a list of UTF-16 encoded bytes. This method prefixes the resulting\n * bytes with a big-endian byte-order-marker.\n */\nList<int> encodeUtf16(String str) =>\n    encodeUtf16be(str, true);\n\n/**\n * Produce a list of UTF-16BE encoded bytes. By default, this method produces\n * UTF-16BE bytes with no BOM.\n */\nList<int> encodeUtf16be(String str, [bool writeBOM = false]) {\n  List<int> utf16CodeUnits = _stringToUtf16CodeUnits(str);\n  List<int> encoding =\n      new List<int>(2 * utf16CodeUnits.length + (writeBOM ? 2 : 0));\n  int i = 0;\n  if (writeBOM) {\n    encoding[i++] = UNICODE_UTF_BOM_HI;\n    encoding[i++] = UNICODE_UTF_BOM_LO;\n  }\n  for (int unit in utf16CodeUnits) {\n    encoding[i++] = (unit & UNICODE_BYTE_ONE_MASK) >> 8;\n    encoding[i++] = unit & UNICODE_BYTE_ZERO_MASK;\n  }\n  return encoding;\n}\n\n/**\n * Produce a list of UTF-16LE encoded bytes. By default, this method produces\n * UTF-16LE bytes with no BOM.\n */\nList<int> encodeUtf16le(String str, [bool writeBOM = false]) {\n  List<int> utf16CodeUnits = _stringToUtf16CodeUnits(str);\n  List<int> encoding =\n      new List<int>(2 * utf16CodeUnits.length + (writeBOM ? 2 : 0));\n  int i = 0;\n  if (writeBOM) {\n    encoding[i++] = UNICODE_UTF_BOM_LO;\n    encoding[i++] = UNICODE_UTF_BOM_HI;\n  }\n  for (int unit in utf16CodeUnits) {\n    encoding[i++] = unit & UNICODE_BYTE_ZERO_MASK;\n    encoding[i++] = (unit & UNICODE_BYTE_ONE_MASK) >> 8;\n  }\n  return encoding;\n}\n\n/**\n * Identifies whether a List of bytes starts (based on offset) with a\n * byte-order marker (BOM).\n */\nbool hasUtf16Bom(List<int> utf32EncodedBytes, [int offset = 0, int length]) {\n  return hasUtf16beBom(utf32EncodedBytes, offset, length) ||\n      hasUtf16leBom(utf32EncodedBytes, offset, length);\n}\n\n/**\n * Identifies whether a List of bytes starts (based on offset) with a\n * big-endian byte-order marker (BOM).\n */\nbool hasUtf16beBom(List<int> utf16EncodedBytes, [int offset = 0, int length]) {\n  int end = length != null ? offset + length : utf16EncodedBytes.length;\n  return (offset + 2) <= end &&\n      utf16EncodedBytes[offset] == UNICODE_UTF_BOM_HI &&\n      utf16EncodedBytes[offset + 1] == UNICODE_UTF_BOM_LO;\n}\n\n/**\n * Identifies whether a List of bytes starts (based on offset) with a\n * little-endian byte-order marker (BOM).\n */\nbool hasUtf16leBom(List<int> utf16EncodedBytes, [int offset = 0, int length]) {\n  int end = length != null ? offset + length : utf16EncodedBytes.length;\n  return (offset + 2) <= end &&\n      utf16EncodedBytes[offset] == UNICODE_UTF_BOM_LO &&\n      utf16EncodedBytes[offset + 1] == UNICODE_UTF_BOM_HI;\n}\n\nList<int> _stringToUtf16CodeUnits(String str) {\n  return _codepointsToUtf16CodeUnits(str.codeUnits);\n}\n\ntypedef _ListRangeIterator _CodeUnitsProvider();\n\n/**\n * Return type of [decodeUtf16AsIterable] and variants. The Iterable type\n * provides an iterator on demand and the iterator will only translate bytes\n * as requested by the user of the iterator. (Note: results are not cached.)\n */\n// TODO(floitsch): Consider removing the extend and switch to implements since\n// that's cheaper to allocate.\nclass IterableUtf16Decoder extends IterableBase<int> {\n  final _CodeUnitsProvider codeunitsProvider;\n  final int replacementCodepoint;\n\n  IterableUtf16Decoder._(this.codeunitsProvider, this.replacementCodepoint);\n\n  Utf16CodeUnitDecoder get iterator =>\n      new Utf16CodeUnitDecoder.fromListRangeIterator(codeunitsProvider(),\n          replacementCodepoint);\n}\n\n/**\n * Convert UTF-16 encoded bytes to UTF-16 code units by grouping 1-2 bytes\n * to produce the code unit (0-(2^16)-1). Relies on BOM to determine\n * endian-ness, and defaults to BE.\n */\nabstract class Utf16BytesToCodeUnitsDecoder implements _ListRangeIterator {\n  final _ListRangeIterator utf16EncodedBytesIterator;\n  final int replacementCodepoint;\n  int _current = null;\n\n  Utf16BytesToCodeUnitsDecoder._fromListRangeIterator(\n      this.utf16EncodedBytesIterator, this.replacementCodepoint);\n\n  factory Utf16BytesToCodeUnitsDecoder(List<int> utf16EncodedBytes, [\n      int offset = 0, int length,\n      int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n    if (length == null) {\n      length = utf16EncodedBytes.length - offset;\n    }\n    if (hasUtf16beBom(utf16EncodedBytes, offset, length)) {\n      return new Utf16beBytesToCodeUnitsDecoder(utf16EncodedBytes, offset + 2,\n          length - 2, false, replacementCodepoint);\n    } else if (hasUtf16leBom(utf16EncodedBytes, offset, length)) {\n      return new Utf16leBytesToCodeUnitsDecoder(utf16EncodedBytes, offset + 2,\n          length - 2, false, replacementCodepoint);\n    } else {\n      return new Utf16beBytesToCodeUnitsDecoder(utf16EncodedBytes, offset,\n          length, false, replacementCodepoint);\n    }\n  }\n\n  /**\n   * Provides a fast way to decode the rest of the source bytes in a single\n   * call. This method trades memory for improved speed in that it potentially\n   * over-allocates the List containing results.\n   */\n  List<int> decodeRest() {\n    List<int> codeunits = new List<int>(remaining);\n    int i = 0;\n    while (moveNext()) {\n      codeunits[i++] = current;\n    }\n    if (i == codeunits.length) {\n      return codeunits;\n    } else {\n      List<int> truncCodeunits = new List<int>(i);\n      truncCodeunits.setRange(0, i, codeunits);\n      return truncCodeunits;\n    }\n  }\n\n  int get current => _current;\n\n  bool moveNext() {\n    _current = null;\n    if (utf16EncodedBytesIterator.remaining < 2) {\n      utf16EncodedBytesIterator.moveNext();\n      if (replacementCodepoint != null) {\n        _current = replacementCodepoint;\n        return true;\n      } else {\n        throw new ArgumentError(\n            \"Invalid UTF16 at ${utf16EncodedBytesIterator.position}\");\n      }\n    } else {\n      _current = decode();\n      return true;\n    }\n  }\n\n  int get position => utf16EncodedBytesIterator.position ~/ 2;\n\n  void backup([int by = 1]) {\n    utf16EncodedBytesIterator.backup(2 * by);\n  }\n\n  int get remaining => (utf16EncodedBytesIterator.remaining + 1) ~/ 2;\n\n  void skip([int count = 1]) {\n    utf16EncodedBytesIterator.skip(2 * count);\n  }\n\n  int decode();\n}\n\n/**\n * Convert UTF-16BE encoded bytes to utf16 code units by grouping 1-2 bytes\n * to produce the code unit (0-(2^16)-1).\n */\nclass Utf16beBytesToCodeUnitsDecoder extends Utf16BytesToCodeUnitsDecoder {\n  Utf16beBytesToCodeUnitsDecoder(List<int> utf16EncodedBytes, [\n      int offset = 0, int length, bool stripBom = true,\n      int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) :\n      super._fromListRangeIterator(\n          (new _ListRange(utf16EncodedBytes, offset, length)).iterator,\n          replacementCodepoint) {\n    if (stripBom && hasUtf16beBom(utf16EncodedBytes, offset, length)) {\n      skip();\n    }\n  }\n\n  int decode() {\n    utf16EncodedBytesIterator.moveNext();\n    int hi = utf16EncodedBytesIterator.current;\n    utf16EncodedBytesIterator.moveNext();\n    int lo = utf16EncodedBytesIterator.current;\n    return (hi << 8) + lo;\n  }\n}\n\n/**\n * Convert UTF-16LE encoded bytes to utf16 code units by grouping 1-2 bytes\n * to produce the code unit (0-(2^16)-1).\n */\nclass Utf16leBytesToCodeUnitsDecoder extends Utf16BytesToCodeUnitsDecoder {\n  Utf16leBytesToCodeUnitsDecoder(List<int> utf16EncodedBytes, [\n      int offset = 0, int length, bool stripBom = true,\n      int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) :\n      super._fromListRangeIterator(\n          (new _ListRange(utf16EncodedBytes, offset, length)).iterator,\n          replacementCodepoint) {\n    if (stripBom && hasUtf16leBom(utf16EncodedBytes, offset, length)) {\n      skip();\n    }\n  }\n\n  int decode() {\n    utf16EncodedBytesIterator.moveNext();\n    int lo = utf16EncodedBytesIterator.current;\n    utf16EncodedBytesIterator.moveNext();\n    int hi = utf16EncodedBytesIterator.current;\n    return (hi << 8) + lo;\n  }\n}\n","sdk/lib/utf/utf32.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.utf;\n\n/**\n * Decodes the UTF-32 bytes as an iterable. Thus, the consumer can only convert\n * as much of the input as needed. Determines the byte order from the BOM,\n * or uses big-endian as a default. This method always strips a leading BOM.\n * Set the replacementCharacter to null to throw an ArgumentError\n * rather than replace the bad value.\n */\nIterableUtf32Decoder decodeUtf32AsIterable(List<int> bytes, [\n    int offset = 0, int length,\n    int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n  return new IterableUtf32Decoder._(\n      () => new Utf32BytesDecoder(bytes, offset, length, replacementCodepoint));\n}\n\n/**\n * Decodes the UTF-32BE bytes as an iterable. Thus, the consumer can only convert\n * as much of the input as needed. This method strips a leading BOM by default,\n * but can be overridden by setting the optional parameter [stripBom] to false.\n * Set the replacementCharacter to null to throw an ArgumentError\n * rather than replace the bad value.\n */\nIterableUtf32Decoder decodeUtf32beAsIterable(List<int> bytes, [\n    int offset = 0, int length, bool stripBom = true,\n    int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n  return new IterableUtf32Decoder._(\n      () => new Utf32beBytesDecoder(bytes, offset, length, stripBom,\n          replacementCodepoint));\n}\n\n/**\n * Decodes the UTF-32LE bytes as an iterable. Thus, the consumer can only convert\n * as much of the input as needed. This method strips a leading BOM by default,\n * but can be overridden by setting the optional parameter [stripBom] to false.\n * Set the replacementCharacter to null to throw an ArgumentError\n * rather than replace the bad value.\n */\nIterableUtf32Decoder decodeUtf32leAsIterable(List<int> bytes, [\n    int offset = 0, int length, bool stripBom = true,\n    int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n  return new IterableUtf32Decoder._(\n      () => new Utf32leBytesDecoder(bytes, offset, length, stripBom,\n          replacementCodepoint));\n}\n\n/**\n * Produce a String from a sequence of UTF-32 encoded bytes. The parameters\n * allow an offset into a list of bytes (as int), limiting the length of the\n * values be decoded and the ability of override the default Unicode\n * replacement character. Set the replacementCharacter to null to throw an\n * ArgumentError rather than replace the bad value.\n */\nString decodeUtf32(List<int> bytes, [int offset = 0, int length,\n    int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n  return new String.fromCharCodes((new Utf32BytesDecoder(bytes, offset, length,\n      replacementCodepoint)).decodeRest());\n}\n/**\n * Produce a String from a sequence of UTF-32BE encoded bytes. The parameters\n * allow an offset into a list of bytes (as int), limiting the length of the\n * values be decoded and the ability of override the default Unicode\n * replacement character. Set the replacementCharacter to null to throw an\n * ArgumentError rather than replace the bad value.\n */\nString decodeUtf32be(\n    List<int> bytes, [int offset = 0, int length, bool stripBom = true,\n    int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) =>\n  new String.fromCharCodes((new Utf32beBytesDecoder(bytes, offset, length, \n    stripBom, replacementCodepoint)).decodeRest());\n\n/**\n * Produce a String from a sequence of UTF-32LE encoded bytes. The parameters\n * allow an offset into a list of bytes (as int), limiting the length of the\n * values be decoded and the ability of override the default Unicode\n * replacement character. Set the replacementCharacter to null to throw an\n * ArgumentError rather than replace the bad value.\n */\nString decodeUtf32le(\n    List<int> bytes, [int offset = 0, int length, bool stripBom = true,\n    int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) =>\n    new String.fromCharCodes((new Utf32leBytesDecoder(bytes, offset, length,\n      stripBom, replacementCodepoint)).decodeRest());\n\n/**\n * Produce a list of UTF-32 encoded bytes. This method prefixes the resulting\n * bytes with a big-endian byte-order-marker.\n */\nList<int> encodeUtf32(String str) =>\n    encodeUtf32be(str, true);\n\n/**\n * Produce a list of UTF-32BE encoded bytes. By default, this method produces\n * UTF-32BE bytes with no BOM.\n */\nList<int> encodeUtf32be(String str, [bool writeBOM = false]) {\n  List<int> utf32CodeUnits = stringToCodepoints(str);\n  List<int> encoding = new List<int>(4 * utf32CodeUnits.length +\n      (writeBOM ? 4 : 0));\n  int i = 0;\n  if (writeBOM) {\n    encoding[i++] = 0;\n    encoding[i++] = 0;\n    encoding[i++] = UNICODE_UTF_BOM_HI;\n    encoding[i++] = UNICODE_UTF_BOM_LO;\n  }\n  for (int unit in utf32CodeUnits) {\n    encoding[i++] = (unit >> 24) & UNICODE_BYTE_ZERO_MASK;\n    encoding[i++] = (unit >> 16) & UNICODE_BYTE_ZERO_MASK;\n    encoding[i++] = (unit >> 8) & UNICODE_BYTE_ZERO_MASK;\n    encoding[i++] = unit & UNICODE_BYTE_ZERO_MASK;\n  }\n  return encoding;\n}\n\n/**\n * Produce a list of UTF-32LE encoded bytes. By default, this method produces\n * UTF-32BE bytes with no BOM.\n */\nList<int> encodeUtf32le(String str, [bool writeBOM = false]) {\n  List<int> utf32CodeUnits = stringToCodepoints(str);\n  List<int> encoding = new List<int>(4 * utf32CodeUnits.length +\n      (writeBOM ? 4 : 0));\n  int i = 0;\n  if (writeBOM) {\n    encoding[i++] = UNICODE_UTF_BOM_LO;\n    encoding[i++] = UNICODE_UTF_BOM_HI;\n    encoding[i++] = 0;\n    encoding[i++] = 0;\n  }\n  for (int unit in utf32CodeUnits) {\n    encoding[i++] = unit & UNICODE_BYTE_ZERO_MASK;\n    encoding[i++] = (unit >> 8) & UNICODE_BYTE_ZERO_MASK;\n    encoding[i++] = (unit >> 16) & UNICODE_BYTE_ZERO_MASK;\n    encoding[i++] = (unit >> 24) & UNICODE_BYTE_ZERO_MASK;\n  }\n  return encoding;\n}\n\n/**\n * Identifies whether a List of bytes starts (based on offset) with a\n * byte-order marker (BOM).\n */\nbool hasUtf32Bom(\n    List<int> utf32EncodedBytes, [int offset = 0, int length]) {\n  return hasUtf32beBom(utf32EncodedBytes, offset, length) ||\n      hasUtf32leBom(utf32EncodedBytes, offset, length);\n}\n\n/**\n * Identifies whether a List of bytes starts (based on offset) with a\n * big-endian byte-order marker (BOM).\n */\nbool hasUtf32beBom(List<int> utf32EncodedBytes, [int offset = 0, int length]) {\n  int end = length != null ? offset + length : utf32EncodedBytes.length;\n  return (offset + 4) <= end &&\n      utf32EncodedBytes[offset] == 0 && utf32EncodedBytes[offset + 1] == 0 &&\n      utf32EncodedBytes[offset + 2] == UNICODE_UTF_BOM_HI &&\n      utf32EncodedBytes[offset + 3] == UNICODE_UTF_BOM_LO;\n}\n\n/**\n * Identifies whether a List of bytes starts (based on offset) with a\n * little-endian byte-order marker (BOM).\n */\nbool hasUtf32leBom(List<int> utf32EncodedBytes, [int offset = 0, int length]) {\n  int end = length != null ? offset + length : utf32EncodedBytes.length;\n  return (offset + 4) <= end &&\n      utf32EncodedBytes[offset] == UNICODE_UTF_BOM_LO &&\n      utf32EncodedBytes[offset + 1] == UNICODE_UTF_BOM_HI &&\n      utf32EncodedBytes[offset + 2] == 0 && utf32EncodedBytes[offset + 3] == 0;\n}\n\ntypedef Utf32BytesDecoder Utf32BytesDecoderProvider();\n\n/**\n * Return type of [decodeUtf32AsIterable] and variants. The Iterable type\n * provides an iterator on demand and the iterator will only translate bytes\n * as requested by the user of the iterator. (Note: results are not cached.)\n */\n// TODO(floitsch): Consider removing the extend and switch to implements since\n// that's cheaper to allocate.\nclass IterableUtf32Decoder extends IterableBase<int> {\n  final Utf32BytesDecoderProvider codeunitsProvider;\n\n  IterableUtf32Decoder._(this.codeunitsProvider);\n\n  Utf32BytesDecoder get iterator => codeunitsProvider();\n}\n\n/**\n * Abstrace parent class converts encoded bytes to codepoints.\n */\nabstract class Utf32BytesDecoder implements _ListRangeIterator {\n  final _ListRangeIterator utf32EncodedBytesIterator;\n  final int replacementCodepoint;\n  int _current = null;\n\n  Utf32BytesDecoder._fromListRangeIterator(\n      this.utf32EncodedBytesIterator, this.replacementCodepoint);\n\n  factory Utf32BytesDecoder(List<int> utf32EncodedBytes, [\n      int offset = 0, int length,\n      int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n    if (length == null) {\n      length = utf32EncodedBytes.length - offset;\n    }\n    if (hasUtf32beBom(utf32EncodedBytes, offset, length)) {\n      return new Utf32beBytesDecoder(utf32EncodedBytes, offset + 4, length - 4,\n          false, replacementCodepoint);\n    } else if (hasUtf32leBom(utf32EncodedBytes, offset, length)) {\n      return new Utf32leBytesDecoder(utf32EncodedBytes, offset + 4, length - 4,\n          false, replacementCodepoint);\n    } else {\n      return new Utf32beBytesDecoder(utf32EncodedBytes, offset, length, false,\n          replacementCodepoint);\n    }\n  }\n\n  List<int> decodeRest() {\n    List<int> codeunits = new List<int>(remaining);\n    int i = 0;\n    while (moveNext()) {\n      codeunits[i++] = current;\n    }\n    return codeunits;\n  }\n\n  int get current => _current;\n\n  bool moveNext() {\n    _current = null;\n    if (utf32EncodedBytesIterator.remaining < 4) {\n      utf32EncodedBytesIterator.skip(utf32EncodedBytesIterator.remaining);\n      if (replacementCodepoint != null) {\n          _current = replacementCodepoint;\n          return true;\n      } else {\n        throw new ArgumentError(\n            \"Invalid UTF32 at ${utf32EncodedBytesIterator.position}\");\n      }\n    } else {\n      int codepoint = decode();\n      if (_validCodepoint(codepoint)) {\n        _current = codepoint;\n        return true;\n      } else if (replacementCodepoint != null) {\n        _current = replacementCodepoint;\n        return true;\n      } else {\n        throw new ArgumentError(\n            \"Invalid UTF32 at ${utf32EncodedBytesIterator.position}\");\n      }\n    }\n  }\n\n  int get position => utf32EncodedBytesIterator.position ~/ 4;\n\n  void backup([int by = 1]) {\n    utf32EncodedBytesIterator.backup(4 * by);\n  }\n\n  int get remaining => (utf32EncodedBytesIterator.remaining + 3) ~/ 4;\n\n  void skip([int count = 1]) {\n    utf32EncodedBytesIterator.skip(4 * count);\n  }\n\n  int decode();\n}\n\n/**\n * Convert UTF-32BE encoded bytes to codepoints by grouping 4 bytes\n * to produce the unicode codepoint.\n */\nclass Utf32beBytesDecoder extends Utf32BytesDecoder {\n  Utf32beBytesDecoder(List<int> utf32EncodedBytes, [int offset = 0,\n      int length, bool stripBom = true,\n      int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) :\n      super._fromListRangeIterator(\n          (new _ListRange(utf32EncodedBytes, offset, length)).iterator,\n          replacementCodepoint) {\n    if (stripBom && hasUtf32beBom(utf32EncodedBytes, offset, length)) {\n      skip();\n    }\n  }\n\n  int decode() {\n    utf32EncodedBytesIterator.moveNext();\n    int value = utf32EncodedBytesIterator.current;\n    utf32EncodedBytesIterator.moveNext();\n    value = (value << 8) + utf32EncodedBytesIterator.current;\n    utf32EncodedBytesIterator.moveNext();\n    value = (value << 8) + utf32EncodedBytesIterator.current;\n    utf32EncodedBytesIterator.moveNext();\n    value = (value << 8) + utf32EncodedBytesIterator.current;\n    return value;\n  }\n}\n\n/**\n * Convert UTF-32BE encoded bytes to codepoints by grouping 4 bytes\n * to produce the unicode codepoint.\n */\nclass Utf32leBytesDecoder extends Utf32BytesDecoder {\n  Utf32leBytesDecoder(List<int> utf32EncodedBytes, [int offset = 0,\n      int length, bool stripBom = true,\n      int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) :\n      super._fromListRangeIterator(\n          (new _ListRange(utf32EncodedBytes, offset, length)).iterator,\n          replacementCodepoint) {\n    if (stripBom && hasUtf32leBom(utf32EncodedBytes, offset, length)) {\n      skip();\n    }\n  }\n\n  int decode() {\n    utf32EncodedBytesIterator.moveNext();\n    int value = utf32EncodedBytesIterator.current;\n    utf32EncodedBytesIterator.moveNext();\n    value += (utf32EncodedBytesIterator.current << 8);\n    utf32EncodedBytesIterator.moveNext();\n    value += (utf32EncodedBytesIterator.current << 16);\n    utf32EncodedBytesIterator.moveNext();\n    value += (utf32EncodedBytesIterator.current << 24);\n    return value;\n  }\n}\n\nbool _validCodepoint(int codepoint) {\n  return (codepoint >= 0 && codepoint < UNICODE_UTF16_RESERVED_LO) ||\n      (codepoint > UNICODE_UTF16_RESERVED_HI &&\n      codepoint < UNICODE_VALID_RANGE_MAX);\n}\n","sdk/lib/utf/utf8.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.utf;\n\nconst int _UTF8_ONE_BYTE_MAX = 0x7f;\nconst int _UTF8_TWO_BYTE_MAX = 0x7ff;\nconst int _UTF8_THREE_BYTE_MAX = 0xffff;\n\nconst int _UTF8_LO_SIX_BIT_MASK = 0x3f;\n\nconst int _UTF8_FIRST_BYTE_OF_TWO_BASE = 0xc0;\nconst int _UTF8_FIRST_BYTE_OF_THREE_BASE = 0xe0;\nconst int _UTF8_FIRST_BYTE_OF_FOUR_BASE = 0xf0;\nconst int _UTF8_FIRST_BYTE_OF_FIVE_BASE = 0xf8;\nconst int _UTF8_FIRST_BYTE_OF_SIX_BASE = 0xfc;\n\nconst int _UTF8_FIRST_BYTE_OF_TWO_MASK = 0x1f;\nconst int _UTF8_FIRST_BYTE_OF_THREE_MASK = 0xf;\nconst int _UTF8_FIRST_BYTE_OF_FOUR_MASK = 0x7;\n\nconst int _UTF8_FIRST_BYTE_BOUND_EXCL = 0xfe;\nconst int _UTF8_SUBSEQUENT_BYTE_BASE = 0x80;\n\n/**\n * Decodes the UTF-8 bytes as an iterable. Thus, the consumer can only convert\n * as much of the input as needed. Set the replacementCharacter to null to\n * throw an ArgumentError rather than replace the bad value.\n */\nIterableUtf8Decoder decodeUtf8AsIterable(List<int> bytes, [int offset = 0,\n    int length,\n    int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n  return new IterableUtf8Decoder(bytes, offset, length, replacementCodepoint);\n}\n\n/**\n * Produce a String from a List of UTF-8 encoded bytes. The parameters\n * can set an offset into a list of bytes (as int), limit the length of the\n * values to be decoded, and override the default Unicode replacement character.\n * Set the replacementCharacter to null to throw an ArgumentError\n * rather than replace the bad value.\n */\nString decodeUtf8(List<int> bytes, [int offset = 0, int length,\n    int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n  return new String.fromCharCodes(\n      (new Utf8Decoder(bytes, offset, length, replacementCodepoint))\n      .decodeRest());\n}\n\n/**\n * Produce a sequence of UTF-8 encoded bytes from the provided string.\n */\nList<int> encodeUtf8(String str) =>\n  codepointsToUtf8(stringToCodepoints(str));\n\nint _addToEncoding(int offset, int bytes, int value, List<int> buffer) {\n  while (bytes > 0) {\n    buffer[offset + bytes] = _UTF8_SUBSEQUENT_BYTE_BASE |\n        (value & _UTF8_LO_SIX_BIT_MASK);\n    value = value >> 6;\n    bytes--;\n  }\n  return value;\n}\n\n/**\n * Encode code points as UTF-8 code units.\n */\nList<int> codepointsToUtf8(\n    List<int> codepoints, [int offset = 0, int length]) {\n  _ListRange source = new _ListRange(codepoints, offset, length);\n\n  int encodedLength = 0;\n  for (int value in source) {\n    if (value < 0 || value > UNICODE_VALID_RANGE_MAX) {\n      encodedLength += 3;\n    } else if (value <= _UTF8_ONE_BYTE_MAX) {\n      encodedLength++;\n    } else if (value <= _UTF8_TWO_BYTE_MAX) {\n      encodedLength += 2;\n    } else if (value <= _UTF8_THREE_BYTE_MAX) {\n      encodedLength += 3;\n    } else if (value <= UNICODE_VALID_RANGE_MAX) {\n      encodedLength += 4;\n    }\n  }\n\n  List<int> encoded = new List<int>(encodedLength);\n  int insertAt = 0;\n  for (int value in source) {\n    if (value < 0 || value > UNICODE_VALID_RANGE_MAX) {\n      encoded.setRange(insertAt, insertAt + 3, [0xef, 0xbf, 0xbd]);\n      insertAt += 3;\n    } else if (value <= _UTF8_ONE_BYTE_MAX) {\n      encoded[insertAt] = value;\n      insertAt++;\n    } else if (value <= _UTF8_TWO_BYTE_MAX) {\n      encoded[insertAt] = _UTF8_FIRST_BYTE_OF_TWO_BASE | (\n          _UTF8_FIRST_BYTE_OF_TWO_MASK &\n          _addToEncoding(insertAt, 1, value, encoded));\n      insertAt += 2;\n    } else if (value <= _UTF8_THREE_BYTE_MAX) {\n      encoded[insertAt] = _UTF8_FIRST_BYTE_OF_THREE_BASE | (\n          _UTF8_FIRST_BYTE_OF_THREE_MASK &\n          _addToEncoding(insertAt, 2, value, encoded));\n      insertAt += 3;\n    } else if (value <= UNICODE_VALID_RANGE_MAX) {\n      encoded[insertAt] = _UTF8_FIRST_BYTE_OF_FOUR_BASE | (\n          _UTF8_FIRST_BYTE_OF_FOUR_MASK &\n          _addToEncoding(insertAt, 3, value, encoded));\n      insertAt += 4;\n    }\n  }\n  return encoded;\n}\n\n// Because UTF-8 specifies byte order, we do not have to follow the pattern\n// used by UTF-16 & UTF-32 regarding byte order.\nList<int> utf8ToCodepoints(\n    List<int> utf8EncodedBytes, [int offset = 0, int length,\n    int replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) {\n  return new Utf8Decoder(utf8EncodedBytes, offset, length,\n      replacementCodepoint).decodeRest();\n}\n\n/**\n * Return type of [decodeUtf8AsIterable] and variants. The Iterable type\n * provides an iterator on demand and the iterator will only translate bytes\n * as requested by the user of the iterator. (Note: results are not cached.)\n */\n// TODO(floitsch): Consider removing the extend and switch to implements since\n// that's cheaper to allocate.\nclass IterableUtf8Decoder extends IterableBase<int> {\n  final List<int> bytes;\n  final int offset;\n  final int length;\n  final int replacementCodepoint;\n\n  IterableUtf8Decoder(this.bytes, [this.offset = 0, this.length = null,\n      this.replacementCodepoint = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]);\n\n  Utf8Decoder get iterator =>\n      new Utf8Decoder(bytes, offset, length, replacementCodepoint);\n}\n\n/**\n * Provides an iterator of Unicode codepoints from UTF-8 encoded bytes. The\n * parameters can set an offset into a list of bytes (as int), limit the length\n * of the values to be decoded, and override the default Unicode replacement\n * character. Set the replacementCharacter to null to throw an\n * ArgumentError rather than replace the bad value. The return value\n * from this method can be used as an Iterable (e.g. in a for-loop).\n */\nclass Utf8Decoder implements Iterator<int> {\n  final _ListRangeIterator utf8EncodedBytesIterator;\n  final int replacementCodepoint;\n  int _current = null;\n\n  Utf8Decoder(List<int> utf8EncodedBytes, [int offset = 0, int length,\n      this.replacementCodepoint =\n      UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) :\n      utf8EncodedBytesIterator =\n          (new _ListRange(utf8EncodedBytes, offset, length)).iterator;\n\n\n  Utf8Decoder._fromListRangeIterator(_ListRange source, [\n      this.replacementCodepoint =\n      UNICODE_REPLACEMENT_CHARACTER_CODEPOINT]) :\n      utf8EncodedBytesIterator = source.iterator;\n\n  /** Decode the remaininder of the characters in this decoder\n    * into a [List<int>].\n    */\n  List<int> decodeRest() {\n    List<int> codepoints = new List<int>(utf8EncodedBytesIterator.remaining);\n    int i = 0;\n    while (moveNext()) {\n      codepoints[i++] = current;\n    }\n    if (i == codepoints.length) {\n      return codepoints;\n    } else {\n      List<int> truncCodepoints = new List<int>(i);\n      truncCodepoints.setRange(0, i, codepoints);\n      return truncCodepoints;\n    }\n  }\n\n  int get current => _current;\n\n  bool moveNext() {\n    _current = null;\n\n    if (!utf8EncodedBytesIterator.moveNext()) return false;\n\n    int value = utf8EncodedBytesIterator.current;\n    int additionalBytes = 0;\n\n    if (value < 0) {\n      if (replacementCodepoint != null) {\n        _current = replacementCodepoint;\n        return true;\n      } else {\n        throw new ArgumentError(\n            \"Invalid UTF8 at ${utf8EncodedBytesIterator.position}\");\n      }\n    } else if (value <= _UTF8_ONE_BYTE_MAX) {\n      _current = value;\n      return true;\n    } else if (value < _UTF8_FIRST_BYTE_OF_TWO_BASE) {\n      if (replacementCodepoint != null) {\n        _current = replacementCodepoint;\n        return true;\n      } else {\n        throw new ArgumentError(\n            \"Invalid UTF8 at ${utf8EncodedBytesIterator.position}\");\n      }\n    } else if (value < _UTF8_FIRST_BYTE_OF_THREE_BASE) {\n      value -= _UTF8_FIRST_BYTE_OF_TWO_BASE;\n      additionalBytes = 1;\n    } else if (value < _UTF8_FIRST_BYTE_OF_FOUR_BASE) {\n      value -= _UTF8_FIRST_BYTE_OF_THREE_BASE;\n      additionalBytes = 2;\n    } else if (value < _UTF8_FIRST_BYTE_OF_FIVE_BASE) {\n      value -= _UTF8_FIRST_BYTE_OF_FOUR_BASE;\n      additionalBytes = 3;\n    } else if (value < _UTF8_FIRST_BYTE_OF_SIX_BASE) {\n      value -= _UTF8_FIRST_BYTE_OF_FIVE_BASE;\n      additionalBytes = 4;\n    } else if (value < _UTF8_FIRST_BYTE_BOUND_EXCL) {\n      value -= _UTF8_FIRST_BYTE_OF_SIX_BASE;\n      additionalBytes = 5;\n    } else if (replacementCodepoint != null) {\n      _current = replacementCodepoint;\n      return true;\n    } else {\n      throw new ArgumentError(\n          \"Invalid UTF8 at ${utf8EncodedBytesIterator.position}\");\n    }\n    int j = 0;\n    while (j < additionalBytes && utf8EncodedBytesIterator.moveNext()) {\n      int nextValue = utf8EncodedBytesIterator.current;\n      if (nextValue > _UTF8_ONE_BYTE_MAX &&\n          nextValue < _UTF8_FIRST_BYTE_OF_TWO_BASE) {\n        value = ((value << 6) | (nextValue & _UTF8_LO_SIX_BIT_MASK));\n      } else {\n        // if sequence-starting code unit, reposition cursor to start here\n        if (nextValue >= _UTF8_FIRST_BYTE_OF_TWO_BASE) {\n          utf8EncodedBytesIterator.backup();\n        }\n        break;\n      }\n      j++;\n    }\n    bool validSequence = (j == additionalBytes && (\n        value < UNICODE_UTF16_RESERVED_LO ||\n        value > UNICODE_UTF16_RESERVED_HI));\n    bool nonOverlong =\n        (additionalBytes == 1 && value > _UTF8_ONE_BYTE_MAX) ||\n        (additionalBytes == 2 && value > _UTF8_TWO_BYTE_MAX) ||\n        (additionalBytes == 3 && value > _UTF8_THREE_BYTE_MAX);\n    bool inRange = value <= UNICODE_VALID_RANGE_MAX;\n    if (validSequence && nonOverlong && inRange) {\n      _current = value;\n      return true;\n    } else if (replacementCodepoint != null) {\n      _current = replacementCodepoint;\n      return true;\n    } else {\n      throw new ArgumentError(\n          \"Invalid UTF8 at ${utf8EncodedBytesIterator.position - j}\");\n    }\n  }\n}\n","sdk/lib/utf/utf_stream.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.utf;\n\nclass _HelperStreamController<T> extends StreamController<T> {\n  final Function onPauseChanged;\n\n  _HelperStreamController(this.onPauseChanged);\n\n  void onPauseStateChange() {\n    onPauseChanged();\n  }\n}\n\nabstract class _StringDecoder\n    extends StreamEventTransformer<List<int>, String> {\n  List<int> _carry;\n  List<int> _buffer;\n  int _replacementChar;\n\n  _StringDecoder(int this._replacementChar);\n\n  void handleData(List<int> bytes, EventSink<String> sink) {\n    _buffer = <int>[];\n    List<int> carry = _carry;\n    _carry = null;\n    int pos = 0;\n    int available = bytes.length;\n    // If we have carry-over data, start from negative index, indicating carry\n    // index.\n    int goodChars = 0;\n    if (carry != null) pos = -carry.length;\n    while (pos < available) {\n      int currentPos = pos;\n      int getNext() {\n        if (pos < 0) {\n          return carry[pos++ + carry.length];\n        } else if (pos < available) {\n          return bytes[pos++];\n        }\n        return null;\n      }\n      int consumed = _processBytes(getNext);\n      if (consumed > 0) {\n        goodChars = _buffer.length;\n      } else if (consumed == 0) {\n        _buffer.length = goodChars;\n        if (currentPos < 0) {\n          _carry = [];\n          _carry.addAll(carry);\n          _carry.addAll(bytes);\n        } else {\n          _carry = bytes.sublist(currentPos);\n        }\n        break;\n      } else {\n        // Invalid byte at position pos - 1\n        _buffer.length = goodChars;\n        _addChar(-1);\n        goodChars = _buffer.length;\n      }\n    }\n    if (_buffer.length > 0) {\n      // Limit to 'goodChars', if lower than actual charCodes in the buffer.\n      sink.add(new String.fromCharCodes(_buffer));\n    }\n    _buffer = null;\n  }\n\n  void handleDone(EventSink<String> sink) {\n    if (_carry != null) {\n      sink.add(new String.fromCharCodes(\n          new List.filled(_carry.length, _replacementChar)));\n    }\n    sink.close();\n  }\n\n  int _processBytes(int getNext());\n\n  void _addChar(int char) {\n    if (char > 0x10FFFF || char < 0) char = _replacementChar;\n    _buffer.add(char);\n  }\n}\n\n/**\n * StringTransformer that decodes a stream of UTF-8 encoded bytes.\n */\nclass Utf8DecoderTransformer extends _StringDecoder {\n  Utf8DecoderTransformer(\n      [int replacementChar = UNICODE_REPLACEMENT_CHARACTER_CODEPOINT])\n    : super(replacementChar);\n\n  int _processBytes(int getNext()) {\n    int value = getNext();\n    if ((value & 0xFF) != value) return -1;  // Not a byte.\n    if ((value & 0x80) == 0x80) {\n      int additionalBytes;\n      int min;\n      if ((value & 0xe0) == 0xc0) {  // 110xxxxx\n        value = value & 0x1F;\n        additionalBytes = 1;\n        min = 0x80;\n      } else if ((value & 0xf0) == 0xe0) {  // 1110xxxx\n        value = value & 0x0F;\n        additionalBytes = 2;\n        min = 0x800;\n      } else if ((value & 0xf8) == 0xf0) {  // 11110xxx\n        value = value & 0x07;\n        additionalBytes = 3;\n        min = 0x10000;\n      } else if ((value & 0xfc) == 0xf8) {  // 111110xx\n        value = value & 0x03;\n        additionalBytes = 4;\n        min = 0x200000;\n      } else if ((value & 0xfe) == 0xfc) {  // 1111110x\n        value = value & 0x01;\n        additionalBytes = 5;\n        min = 0x4000000;\n      } else {\n        return -1;\n      }\n      for (int i = 0; i < additionalBytes; i++) {\n        int next = getNext();\n        if (next == null) return 0;  // Not enough chars, reset.\n        if ((next & 0xc0) != 0x80 || (next & 0xff) != next) return -1;\n        value = value << 6 | (next & 0x3f);\n      }\n      // Invalid charCode if less then minimum expected.\n      if (value < min) value = -1;\n      _addChar(value);\n      return 1 + additionalBytes;\n    }\n    _addChar(value);\n    return 1;\n  }\n}\n\n\nabstract class _StringEncoder\n    extends StreamEventTransformer<String, List<int>> {\n\n  void handleData(String data, EventSink<List<int>> sink) {\n    sink.add(_processString(data));\n  }\n\n  List<int> _processString(String string);\n}\n\n/**\n * StringTransformer that UTF-8 encodes a stream of strings.\n */\nclass Utf8EncoderTransformer extends _StringEncoder {\n  List<int> _processString(String string) {\n    var bytes = [];\n    int pos = 0;\n    List<int> codepoints = _utf16CodeUnitsToCodepoints(string.codeUnits);\n    int length = codepoints.length;\n    for (int i = 0; i < length; i++) {\n      int additionalBytes;\n      int charCode = codepoints[i];\n      if (charCode <= 0x007F) {\n        additionalBytes = 0;\n        bytes.add(charCode);\n      } else if (charCode <= 0x07FF) {\n        // 110xxxxx (xxxxx is top 5 bits).\n        bytes.add(((charCode >> 6) & 0x1F) | 0xC0);\n        additionalBytes = 1;\n      } else if (charCode <= 0xFFFF) {\n        // 1110xxxx (xxxx is top 4 bits)\n        bytes.add(((charCode >> 12) & 0x0F)| 0xE0);\n        additionalBytes = 2;\n      } else {\n        // 11110xxx (xxx is top 3 bits)\n        bytes.add(((charCode >> 18) & 0x07) | 0xF0);\n        additionalBytes = 3;\n      }\n      for (int i = additionalBytes; i > 0; i--) {\n        // 10xxxxxx (xxxxxx is next 6 bits from the top).\n        bytes.add(((charCode >> (6 * (i - 1))) & 0x3F) | 0x80);\n      }\n      pos += additionalBytes + 1;\n    }\n    return bytes;\n  }\n}\n","sdk/lib/web_audio/dart2js/web_audio_dart2js.dart":"library dart.dom.web_audio;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:_collection-dev';\nimport 'dart:html';\nimport 'dart:html_common';\nimport 'dart:typed_data';\nimport 'dart:_js_helper' show Creates, Returns, convertDartClosureToJS;\nimport 'dart:_foreign_helper' show JS;\n// DO NOT EDIT - unless you are editing documentation as per:\n// https://code.google.com/p/dart/wiki/ContributingHTMLDocumentation\n// Auto-generated dart:audio library.\n\n\n\n\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('AnalyserNode')\nclass AnalyserNode extends AudioNode native \"AnalyserNode\" {\n\n  @DomName('AnalyserNode.fftSize')\n  @DocsEditable\n  int fftSize;\n\n  @DomName('AnalyserNode.frequencyBinCount')\n  @DocsEditable\n  final int frequencyBinCount;\n\n  @DomName('AnalyserNode.maxDecibels')\n  @DocsEditable\n  num maxDecibels;\n\n  @DomName('AnalyserNode.minDecibels')\n  @DocsEditable\n  num minDecibels;\n\n  @DomName('AnalyserNode.smoothingTimeConstant')\n  @DocsEditable\n  num smoothingTimeConstant;\n\n  @DomName('AnalyserNode.getByteFrequencyData')\n  @DocsEditable\n  void getByteFrequencyData(Uint8List array) native;\n\n  @DomName('AnalyserNode.getByteTimeDomainData')\n  @DocsEditable\n  void getByteTimeDomainData(Uint8List array) native;\n\n  @DomName('AnalyserNode.getFloatFrequencyData')\n  @DocsEditable\n  void getFloatFrequencyData(Float32List array) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('AudioBuffer')\nclass AudioBuffer native \"AudioBuffer\" {\n\n  @DomName('AudioBuffer.duration')\n  @DocsEditable\n  final num duration;\n\n  @DomName('AudioBuffer.gain')\n  @DocsEditable\n  num gain;\n\n  @DomName('AudioBuffer.length')\n  @DocsEditable\n  final int length;\n\n  @DomName('AudioBuffer.numberOfChannels')\n  @DocsEditable\n  final int numberOfChannels;\n\n  @DomName('AudioBuffer.sampleRate')\n  @DocsEditable\n  final num sampleRate;\n\n  @DomName('AudioBuffer.getChannelData')\n  @DocsEditable\n  @Returns('Float32List')\n  @Creates('Float32List')\n  List<double> getChannelData(int channelIndex) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void AudioBufferCallback(AudioBuffer audioBuffer);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('AudioBufferSourceNode')\nclass AudioBufferSourceNode extends AudioSourceNode native \"AudioBufferSourceNode\" {\n\n  // TODO(efortuna): Remove these methods when Chrome stable also uses start\n  // instead of noteOn.\n  void start(num when, [num grainOffset, num grainDuration]) {\n    if (JS('bool', '!!#.start', this)) {\n      if (?grainDuration) {\n        JS('void', '#.start(#, #, #)', this, when, grainOffset, grainDuration);\n      } else if (?grainOffset) {\n        JS('void', '#.start(#, #)', this, when, grainOffset);\n      } else {\n        JS('void', '#.start(#)', this, when);\n      }\n    } else {\n      if (?grainDuration) {\n        JS('void', '#.noteOn(#, #, #)', this, when, grainOffset, grainDuration);\n      } else if (?grainOffset) {\n        JS('void', '#.noteOn(#, #)', this, when, grainOffset);\n      } else {\n        JS('void', '#.noteOn(#)', this, when);\n      }\n    }\n  }\n\n  void stop(num when) {\n    if (JS('bool', '!!#.stop', this)) {\n      JS('void', '#.stop(#)', this, when);\n    } else {\n      JS('void', '#.noteOff(#)', this, when);\n    }\n  }\n\n  static const int FINISHED_STATE = 3;\n\n  static const int PLAYING_STATE = 2;\n\n  static const int SCHEDULED_STATE = 1;\n\n  static const int UNSCHEDULED_STATE = 0;\n\n  @DomName('AudioBufferSourceNode.buffer')\n  @DocsEditable\n  AudioBuffer buffer;\n\n  @DomName('AudioBufferSourceNode.gain')\n  @DocsEditable\n  final AudioParam gain;\n\n  @DomName('AudioBufferSourceNode.loop')\n  @DocsEditable\n  bool loop;\n\n  @DomName('AudioBufferSourceNode.loopEnd')\n  @DocsEditable\n  num loopEnd;\n\n  @DomName('AudioBufferSourceNode.loopStart')\n  @DocsEditable\n  num loopStart;\n\n  @DomName('AudioBufferSourceNode.playbackRate')\n  @DocsEditable\n  final AudioParam playbackRate;\n\n  @DomName('AudioBufferSourceNode.playbackState')\n  @DocsEditable\n  final int playbackState;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('AudioContext')\nclass AudioContext extends EventTarget native \"AudioContext\" {\n\n  @DomName('AudioContext.completeEvent')\n  @DocsEditable\n  static const EventStreamProvider<Event> completeEvent = const EventStreamProvider<Event>('complete');\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.AudioContext || window.webkitAudioContext)');\n\n  @DomName('AudioContext.activeSourceCount')\n  @DocsEditable\n  final int activeSourceCount;\n\n  @DomName('AudioContext.currentTime')\n  @DocsEditable\n  final num currentTime;\n\n  @DomName('AudioContext.destination')\n  @DocsEditable\n  final AudioDestinationNode destination;\n\n  @DomName('AudioContext.listener')\n  @DocsEditable\n  final AudioListener listener;\n\n  @DomName('AudioContext.sampleRate')\n  @DocsEditable\n  final num sampleRate;\n\n  @DomName('AudioContext.createAnalyser')\n  @DocsEditable\n  AnalyserNode createAnalyser() native;\n\n  @DomName('AudioContext.createBiquadFilter')\n  @DocsEditable\n  BiquadFilterNode createBiquadFilter() native;\n\n  @DomName('AudioContext.createBuffer')\n  @DocsEditable\n  AudioBuffer createBuffer(buffer_OR_numberOfChannels, mixToMono_OR_numberOfFrames, [num sampleRate]) native;\n\n  @DomName('AudioContext.createBufferSource')\n  @DocsEditable\n  AudioBufferSourceNode createBufferSource() native;\n\n  @DomName('AudioContext.createChannelMerger')\n  @DocsEditable\n  ChannelMergerNode createChannelMerger([int numberOfInputs]) native;\n\n  @DomName('AudioContext.createChannelSplitter')\n  @DocsEditable\n  ChannelSplitterNode createChannelSplitter([int numberOfOutputs]) native;\n\n  @DomName('AudioContext.createConvolver')\n  @DocsEditable\n  ConvolverNode createConvolver() native;\n\n  @DomName('AudioContext.createDelay')\n  @DocsEditable\n  DelayNode createDelay([num maxDelayTime]) native;\n\n  @DomName('AudioContext.createDynamicsCompressor')\n  @DocsEditable\n  DynamicsCompressorNode createDynamicsCompressor() native;\n\n  @DomName('AudioContext.createMediaElementSource')\n  @DocsEditable\n  MediaElementAudioSourceNode createMediaElementSource(MediaElement mediaElement) native;\n\n  @DomName('AudioContext.createMediaStreamDestination')\n  @DocsEditable\n  MediaStreamAudioDestinationNode createMediaStreamDestination() native;\n\n  @DomName('AudioContext.createMediaStreamSource')\n  @DocsEditable\n  MediaStreamAudioSourceNode createMediaStreamSource(MediaStream mediaStream) native;\n\n  @DomName('AudioContext.createOscillator')\n  @DocsEditable\n  OscillatorNode createOscillator() native;\n\n  @DomName('AudioContext.createPanner')\n  @DocsEditable\n  PannerNode createPanner() native;\n\n  @DomName('AudioContext.createWaveShaper')\n  @DocsEditable\n  WaveShaperNode createWaveShaper() native;\n\n  @DomName('AudioContext.createWaveTable')\n  @DocsEditable\n  WaveTable createWaveTable(Float32List real, Float32List imag) native;\n\n  @DomName('AudioContext.decodeAudioData')\n  @DocsEditable\n  void decodeAudioData(ByteBuffer audioData, AudioBufferCallback successCallback, [AudioBufferCallback errorCallback]) native;\n\n  @DomName('AudioContext.startRendering')\n  @DocsEditable\n  void startRendering() native;\n\n  @DomName('AudioContext.oncomplete')\n  @DocsEditable\n  Stream<Event> get onComplete => completeEvent.forTarget(this);\n\n  factory AudioContext() => JS('AudioContext',\n      'new (window.AudioContext || window.webkitAudioContext)()');\n\n  GainNode createGain() {\n    if (JS('bool', '#.createGain !== undefined', this)) {\n      return JS('GainNode', '#.createGain()', this);\n    } else {\n      return JS('GainNode', '#.createGainNode()', this);\n    }\n  }\n\n  ScriptProcessorNode createScriptProcessor(int bufferSize,\n      [int numberOfInputChannels, int numberOfOutputChannels]) {\n    var function = JS('dynamic', '#.createScriptProcessor || '\n        '#.createJavaScriptNode', this, this);\n    if (?numberOfOutputChannels) {\n      return JS('ScriptProcessorNode', '#.call(#, #, #, #)', function, this,\n          bufferSize, numberOfInputChannels, numberOfOutputChannels);\n    } else if (?numberOfInputChannels) {\n      return JS('ScriptProcessorNode', '#.call(#, #, #)', function, this,\n          bufferSize, numberOfInputChannels);\n    } else {\n      return JS('ScriptProcessorNode', '#.call(#, #)', function, this,\n          bufferSize);\n    }\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('AudioDestinationNode')\nclass AudioDestinationNode extends AudioNode native \"AudioDestinationNode\" {\n\n  @DomName('AudioDestinationNode.maxChannelCount')\n  @DocsEditable\n  final int maxChannelCount;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('AudioListener')\nclass AudioListener native \"AudioListener\" {\n\n  @DomName('AudioListener.dopplerFactor')\n  @DocsEditable\n  num dopplerFactor;\n\n  @DomName('AudioListener.speedOfSound')\n  @DocsEditable\n  num speedOfSound;\n\n  @DomName('AudioListener.setOrientation')\n  @DocsEditable\n  void setOrientation(num x, num y, num z, num xUp, num yUp, num zUp) native;\n\n  @DomName('AudioListener.setPosition')\n  @DocsEditable\n  void setPosition(num x, num y, num z) native;\n\n  @DomName('AudioListener.setVelocity')\n  @DocsEditable\n  void setVelocity(num x, num y, num z) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('AudioNode')\nclass AudioNode native \"AudioNode\" {\n\n  @DomName('AudioNode.channelCount')\n  @DocsEditable\n  int channelCount;\n\n  @DomName('AudioNode.channelCountMode')\n  @DocsEditable\n  String channelCountMode;\n\n  @DomName('AudioNode.channelInterpretation')\n  @DocsEditable\n  String channelInterpretation;\n\n  @DomName('AudioNode.context')\n  @DocsEditable\n  final AudioContext context;\n\n  @DomName('AudioNode.numberOfInputs')\n  @DocsEditable\n  final int numberOfInputs;\n\n  @DomName('AudioNode.numberOfOutputs')\n  @DocsEditable\n  final int numberOfOutputs;\n\n  @DomName('AudioNode.connect')\n  @DocsEditable\n  void connect(destination, int output, [int input]) native;\n\n  @DomName('AudioNode.disconnect')\n  @DocsEditable\n  void disconnect(int output) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('AudioParam')\nclass AudioParam native \"AudioParam\" {\n\n  @DomName('AudioParam.defaultValue')\n  @DocsEditable\n  final num defaultValue;\n\n  @DomName('AudioParam.maxValue')\n  @DocsEditable\n  final num maxValue;\n\n  @DomName('AudioParam.minValue')\n  @DocsEditable\n  final num minValue;\n\n  @DomName('AudioParam.name')\n  @DocsEditable\n  final String name;\n\n  @DomName('AudioParam.units')\n  @DocsEditable\n  final int units;\n\n  @DomName('AudioParam.value')\n  @DocsEditable\n  num value;\n\n  @DomName('AudioParam.cancelScheduledValues')\n  @DocsEditable\n  void cancelScheduledValues(num startTime) native;\n\n  @DomName('AudioParam.exponentialRampToValueAtTime')\n  @DocsEditable\n  void exponentialRampToValueAtTime(num value, num time) native;\n\n  @DomName('AudioParam.linearRampToValueAtTime')\n  @DocsEditable\n  void linearRampToValueAtTime(num value, num time) native;\n\n  @DomName('AudioParam.setTargetAtTime')\n  @DocsEditable\n  void setTargetAtTime(num target, num time, num timeConstant) native;\n\n  @DomName('AudioParam.setValueAtTime')\n  @DocsEditable\n  void setValueAtTime(num value, num time) native;\n\n  @DomName('AudioParam.setValueCurveAtTime')\n  @DocsEditable\n  void setValueCurveAtTime(Float32List values, num time, num duration) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('AudioProcessingEvent')\nclass AudioProcessingEvent extends Event native \"AudioProcessingEvent\" {\n\n  @DomName('AudioProcessingEvent.inputBuffer')\n  @DocsEditable\n  final AudioBuffer inputBuffer;\n\n  @DomName('AudioProcessingEvent.outputBuffer')\n  @DocsEditable\n  final AudioBuffer outputBuffer;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('AudioSourceNode')\nclass AudioSourceNode extends AudioNode native \"AudioSourceNode\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('BiquadFilterNode')\nclass BiquadFilterNode extends AudioNode native \"BiquadFilterNode\" {\n\n  static const int ALLPASS = 7;\n\n  static const int BANDPASS = 2;\n\n  static const int HIGHPASS = 1;\n\n  static const int HIGHSHELF = 4;\n\n  static const int LOWPASS = 0;\n\n  static const int LOWSHELF = 3;\n\n  static const int NOTCH = 6;\n\n  static const int PEAKING = 5;\n\n  @DomName('BiquadFilterNode.Q')\n  @DocsEditable\n  final AudioParam Q;\n\n  @DomName('BiquadFilterNode.detune')\n  @DocsEditable\n  final AudioParam detune;\n\n  @DomName('BiquadFilterNode.frequency')\n  @DocsEditable\n  final AudioParam frequency;\n\n  @DomName('BiquadFilterNode.gain')\n  @DocsEditable\n  final AudioParam gain;\n\n  @DomName('BiquadFilterNode.type')\n  @DocsEditable\n  String type;\n\n  @DomName('BiquadFilterNode.getFrequencyResponse')\n  @DocsEditable\n  void getFrequencyResponse(Float32List frequencyHz, Float32List magResponse, Float32List phaseResponse) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('ChannelMergerNode')\nclass ChannelMergerNode extends AudioNode native \"ChannelMergerNode\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('ChannelSplitterNode')\nclass ChannelSplitterNode extends AudioNode native \"ChannelSplitterNode\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('ConvolverNode')\nclass ConvolverNode extends AudioNode native \"ConvolverNode\" {\n\n  @DomName('ConvolverNode.buffer')\n  @DocsEditable\n  AudioBuffer buffer;\n\n  @DomName('ConvolverNode.normalize')\n  @DocsEditable\n  bool normalize;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DelayNode')\nclass DelayNode extends AudioNode native \"DelayNode\" {\n\n  @DomName('DelayNode.delayTime')\n  @DocsEditable\n  final AudioParam delayTime;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('DynamicsCompressorNode')\nclass DynamicsCompressorNode extends AudioNode native \"DynamicsCompressorNode\" {\n\n  @DomName('DynamicsCompressorNode.attack')\n  @DocsEditable\n  final AudioParam attack;\n\n  @DomName('DynamicsCompressorNode.knee')\n  @DocsEditable\n  final AudioParam knee;\n\n  @DomName('DynamicsCompressorNode.ratio')\n  @DocsEditable\n  final AudioParam ratio;\n\n  @DomName('DynamicsCompressorNode.reduction')\n  @DocsEditable\n  final AudioParam reduction;\n\n  @DomName('DynamicsCompressorNode.release')\n  @DocsEditable\n  final AudioParam release;\n\n  @DomName('DynamicsCompressorNode.threshold')\n  @DocsEditable\n  final AudioParam threshold;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('GainNode')\nclass GainNode extends AudioNode native \"GainNode\" {\n\n  @DomName('GainNode.gain')\n  @DocsEditable\n  final AudioParam gain;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MediaElementAudioSourceNode')\nclass MediaElementAudioSourceNode extends AudioSourceNode native \"MediaElementAudioSourceNode\" {\n\n  @DomName('MediaElementAudioSourceNode.mediaElement')\n  @DocsEditable\n  final MediaElement mediaElement;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MediaStreamAudioDestinationNode')\nclass MediaStreamAudioDestinationNode extends AudioSourceNode native \"MediaStreamAudioDestinationNode\" {\n\n  @DomName('MediaStreamAudioDestinationNode.stream')\n  @DocsEditable\n  final MediaStream stream;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('MediaStreamAudioSourceNode')\nclass MediaStreamAudioSourceNode extends AudioSourceNode native \"MediaStreamAudioSourceNode\" {\n\n  @DomName('MediaStreamAudioSourceNode.mediaStream')\n  @DocsEditable\n  final MediaStream mediaStream;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('OfflineAudioCompletionEvent')\nclass OfflineAudioCompletionEvent extends Event native \"OfflineAudioCompletionEvent\" {\n\n  @DomName('OfflineAudioCompletionEvent.renderedBuffer')\n  @DocsEditable\n  final AudioBuffer renderedBuffer;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('OfflineAudioContext')\nclass OfflineAudioContext extends AudioContext implements EventTarget native \"OfflineAudioContext\" {\n\n  @DomName('OfflineAudioContext.OfflineAudioContext')\n  @DocsEditable\n  factory OfflineAudioContext(int numberOfChannels, int numberOfFrames, num sampleRate) {\n    return OfflineAudioContext._create_1(numberOfChannels, numberOfFrames, sampleRate);\n  }\n  static OfflineAudioContext _create_1(numberOfChannels, numberOfFrames, sampleRate) => JS('OfflineAudioContext', 'new OfflineAudioContext(#,#,#)', numberOfChannels, numberOfFrames, sampleRate);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('OscillatorNode')\nclass OscillatorNode extends AudioSourceNode native \"OscillatorNode\" {\n\n  static const int CUSTOM = 4;\n\n  static const int FINISHED_STATE = 3;\n\n  static const int PLAYING_STATE = 2;\n\n  static const int SAWTOOTH = 2;\n\n  static const int SCHEDULED_STATE = 1;\n\n  static const int SINE = 0;\n\n  static const int SQUARE = 1;\n\n  static const int TRIANGLE = 3;\n\n  static const int UNSCHEDULED_STATE = 0;\n\n  @DomName('OscillatorNode.detune')\n  @DocsEditable\n  final AudioParam detune;\n\n  @DomName('OscillatorNode.frequency')\n  @DocsEditable\n  final AudioParam frequency;\n\n  @DomName('OscillatorNode.playbackState')\n  @DocsEditable\n  final int playbackState;\n\n  @DomName('OscillatorNode.type')\n  @DocsEditable\n  String type;\n\n  @DomName('OscillatorNode.setWaveTable')\n  @DocsEditable\n  void setWaveTable(WaveTable waveTable) native;\n\n  @DomName('OscillatorNode.start')\n  @DocsEditable\n  void start(num when) native;\n\n  @DomName('OscillatorNode.stop')\n  @DocsEditable\n  void stop(num when) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('PannerNode')\nclass PannerNode extends AudioNode native \"PannerNode\" {\n\n  static const int EQUALPOWER = 0;\n\n  static const int EXPONENTIAL_DISTANCE = 2;\n\n  static const int HRTF = 1;\n\n  static const int INVERSE_DISTANCE = 1;\n\n  static const int LINEAR_DISTANCE = 0;\n\n  static const int SOUNDFIELD = 2;\n\n  @DomName('PannerNode.coneInnerAngle')\n  @DocsEditable\n  num coneInnerAngle;\n\n  @DomName('PannerNode.coneOuterAngle')\n  @DocsEditable\n  num coneOuterAngle;\n\n  @DomName('PannerNode.coneOuterGain')\n  @DocsEditable\n  num coneOuterGain;\n\n  @DomName('PannerNode.distanceModel')\n  @DocsEditable\n  String distanceModel;\n\n  @DomName('PannerNode.maxDistance')\n  @DocsEditable\n  num maxDistance;\n\n  @DomName('PannerNode.panningModel')\n  @DocsEditable\n  String panningModel;\n\n  @DomName('PannerNode.refDistance')\n  @DocsEditable\n  num refDistance;\n\n  @DomName('PannerNode.rolloffFactor')\n  @DocsEditable\n  num rolloffFactor;\n\n  @DomName('PannerNode.setOrientation')\n  @DocsEditable\n  void setOrientation(num x, num y, num z) native;\n\n  @DomName('PannerNode.setPosition')\n  @DocsEditable\n  void setPosition(num x, num y, num z) native;\n\n  @DomName('PannerNode.setVelocity')\n  @DocsEditable\n  void setVelocity(num x, num y, num z) native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('ScriptProcessorNode')\nclass ScriptProcessorNode extends AudioNode native \"ScriptProcessorNode\" {\n  Stream<AudioProcessingEvent> _eventStream;\n\n  /**\n   * Get a Stream that fires events when AudioProcessingEvents occur.\n   * This particular stream is special in that it only allows one listener to a\n   * given stream. Converting the returned Stream [asBroadcast] will likely ruin\n   * the soft-real-time properties which which these events are fired and can\n   * be processed.\n   */\n  Stream<AudioProcessingEvent> get onAudioProcess {\n    if (_eventStream == null) {\n      var controller = new StreamController();\n      var callback = (audioData) { \n          if (controller.hasListener) {\n            // This stream is a strange combination of broadcast and single\n            // subscriber streams. We only allow one listener, but if there is\n            // no listener, we don't queue up events, we just drop them on the\n            // floor.\n            controller.add(audioData);\n          }\n        };\n      _setEventListener(callback);\n      _eventStream = controller.stream;\n    }\n    return _eventStream;\n  }\n\n    _setEventListener(callback) {\n      JS('void', '#.onaudioprocess = #', this,\n          convertDartClosureToJS(callback, 1));\n    }\n\n\n  @DomName('ScriptProcessorNode.bufferSize')\n  @DocsEditable\n  final int bufferSize;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WaveShaperNode')\nclass WaveShaperNode extends AudioNode native \"WaveShaperNode\" {\n\n  @DomName('WaveShaperNode.curve')\n  @DocsEditable\n  @Returns('Float32List')\n  @Creates('Float32List')\n  List<double> curve;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WaveTable')\nclass WaveTable native \"WaveTable\" {\n}\n","sdk/lib/web_gl/dart2js/web_gl_dart2js.dart":"library dart.dom.web_gl;\n\nimport 'dart:collection';\nimport 'dart:_collection-dev';\nimport 'dart:html';\nimport 'dart:html_common';\nimport 'dart:typed_data';\nimport 'dart:_js_helper' show Creates, JSName, Null, Returns, convertDartClosureToJS;\nimport 'dart:_foreign_helper' show JS;\n// DO NOT EDIT - unless you are editing documentation as per:\n// https://code.google.com/p/dart/wiki/ContributingHTMLDocumentation\n// Auto-generated dart:web_gl library.\n\n\n\n\n\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nconst int ACTIVE_ATTRIBUTES = RenderingContext.ACTIVE_ATTRIBUTES;\nconst int ACTIVE_TEXTURE = RenderingContext.ACTIVE_TEXTURE;\nconst int ACTIVE_UNIFORMS = RenderingContext.ACTIVE_UNIFORMS;\nconst int ALIASED_LINE_WIDTH_RANGE = RenderingContext.ALIASED_LINE_WIDTH_RANGE;\nconst int ALIASED_POINT_SIZE_RANGE = RenderingContext.ALIASED_POINT_SIZE_RANGE;\nconst int ALPHA = RenderingContext.ALPHA;\nconst int ALPHA_BITS = RenderingContext.ALPHA_BITS;\nconst int ALWAYS = RenderingContext.ALWAYS;\nconst int ARRAY_BUFFER = RenderingContext.ARRAY_BUFFER;\nconst int ARRAY_BUFFER_BINDING = RenderingContext.ARRAY_BUFFER_BINDING;\nconst int ATTACHED_SHADERS = RenderingContext.ATTACHED_SHADERS;\nconst int BACK = RenderingContext.BACK;\nconst int BLEND = RenderingContext.BLEND;\nconst int BLEND_COLOR = RenderingContext.BLEND_COLOR;\nconst int BLEND_DST_ALPHA = RenderingContext.BLEND_DST_ALPHA;\nconst int BLEND_DST_RGB = RenderingContext.BLEND_DST_RGB;\nconst int BLEND_EQUATION = RenderingContext.BLEND_EQUATION;\nconst int BLEND_EQUATION_ALPHA = RenderingContext.BLEND_EQUATION_ALPHA;\nconst int BLEND_EQUATION_RGB = RenderingContext.BLEND_EQUATION_RGB;\nconst int BLEND_SRC_ALPHA = RenderingContext.BLEND_SRC_ALPHA;\nconst int BLEND_SRC_RGB = RenderingContext.BLEND_SRC_RGB;\nconst int BLUE_BITS = RenderingContext.BLUE_BITS;\nconst int BOOL = RenderingContext.BOOL;\nconst int BOOL_VEC2 = RenderingContext.BOOL_VEC2;\nconst int BOOL_VEC3 = RenderingContext.BOOL_VEC3;\nconst int BOOL_VEC4 = RenderingContext.BOOL_VEC4;\nconst int BROWSER_DEFAULT_WEBGL = RenderingContext.BROWSER_DEFAULT_WEBGL;\nconst int BUFFER_SIZE = RenderingContext.BUFFER_SIZE;\nconst int BUFFER_USAGE = RenderingContext.BUFFER_USAGE;\nconst int BYTE = RenderingContext.BYTE;\nconst int CCW = RenderingContext.CCW;\nconst int CLAMP_TO_EDGE = RenderingContext.CLAMP_TO_EDGE;\nconst int COLOR_ATTACHMENT0 = RenderingContext.COLOR_ATTACHMENT0;\nconst int COLOR_BUFFER_BIT = RenderingContext.COLOR_BUFFER_BIT;\nconst int COLOR_CLEAR_VALUE = RenderingContext.COLOR_CLEAR_VALUE;\nconst int COLOR_WRITEMASK = RenderingContext.COLOR_WRITEMASK;\nconst int COMPILE_STATUS = RenderingContext.COMPILE_STATUS;\nconst int COMPRESSED_TEXTURE_FORMATS = RenderingContext.COMPRESSED_TEXTURE_FORMATS;\nconst int CONSTANT_ALPHA = RenderingContext.CONSTANT_ALPHA;\nconst int CONSTANT_COLOR = RenderingContext.CONSTANT_COLOR;\nconst int CONTEXT_LOST_WEBGL = RenderingContext.CONTEXT_LOST_WEBGL;\nconst int CULL_FACE = RenderingContext.CULL_FACE;\nconst int CULL_FACE_MODE = RenderingContext.CULL_FACE_MODE;\nconst int CURRENT_PROGRAM = RenderingContext.CURRENT_PROGRAM;\nconst int CURRENT_VERTEX_ATTRIB = RenderingContext.CURRENT_VERTEX_ATTRIB;\nconst int CW = RenderingContext.CW;\nconst int DECR = RenderingContext.DECR;\nconst int DECR_WRAP = RenderingContext.DECR_WRAP;\nconst int DELETE_STATUS = RenderingContext.DELETE_STATUS;\nconst int DEPTH_ATTACHMENT = RenderingContext.DEPTH_ATTACHMENT;\nconst int DEPTH_BITS = RenderingContext.DEPTH_BITS;\nconst int DEPTH_BUFFER_BIT = RenderingContext.DEPTH_BUFFER_BIT;\nconst int DEPTH_CLEAR_VALUE = RenderingContext.DEPTH_CLEAR_VALUE;\nconst int DEPTH_COMPONENT = RenderingContext.DEPTH_COMPONENT;\nconst int DEPTH_COMPONENT16 = RenderingContext.DEPTH_COMPONENT16;\nconst int DEPTH_FUNC = RenderingContext.DEPTH_FUNC;\nconst int DEPTH_RANGE = RenderingContext.DEPTH_RANGE;\nconst int DEPTH_STENCIL = RenderingContext.DEPTH_STENCIL;\nconst int DEPTH_STENCIL_ATTACHMENT = RenderingContext.DEPTH_STENCIL_ATTACHMENT;\nconst int DEPTH_TEST = RenderingContext.DEPTH_TEST;\nconst int DEPTH_WRITEMASK = RenderingContext.DEPTH_WRITEMASK;\nconst int DITHER = RenderingContext.DITHER;\nconst int DONT_CARE = RenderingContext.DONT_CARE;\nconst int DST_ALPHA = RenderingContext.DST_ALPHA;\nconst int DST_COLOR = RenderingContext.DST_COLOR;\nconst int DYNAMIC_DRAW = RenderingContext.DYNAMIC_DRAW;\nconst int ELEMENT_ARRAY_BUFFER = RenderingContext.ELEMENT_ARRAY_BUFFER;\nconst int ELEMENT_ARRAY_BUFFER_BINDING = RenderingContext.ELEMENT_ARRAY_BUFFER_BINDING;\nconst int EQUAL = RenderingContext.EQUAL;\nconst int FASTEST = RenderingContext.FASTEST;\nconst int FLOAT = RenderingContext.FLOAT;\nconst int FLOAT_MAT2 = RenderingContext.FLOAT_MAT2;\nconst int FLOAT_MAT3 = RenderingContext.FLOAT_MAT3;\nconst int FLOAT_MAT4 = RenderingContext.FLOAT_MAT4;\nconst int FLOAT_VEC2 = RenderingContext.FLOAT_VEC2;\nconst int FLOAT_VEC3 = RenderingContext.FLOAT_VEC3;\nconst int FLOAT_VEC4 = RenderingContext.FLOAT_VEC4;\nconst int FRAGMENT_SHADER = RenderingContext.FRAGMENT_SHADER;\nconst int FRAMEBUFFER = RenderingContext.FRAMEBUFFER;\nconst int FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = RenderingContext.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME;\nconst int FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = RenderingContext.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE;\nconst int FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = RenderingContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE;\nconst int FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = RenderingContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL;\nconst int FRAMEBUFFER_BINDING = RenderingContext.FRAMEBUFFER_BINDING;\nconst int FRAMEBUFFER_COMPLETE = RenderingContext.FRAMEBUFFER_COMPLETE;\nconst int FRAMEBUFFER_INCOMPLETE_ATTACHMENT = RenderingContext.FRAMEBUFFER_INCOMPLETE_ATTACHMENT;\nconst int FRAMEBUFFER_INCOMPLETE_DIMENSIONS = RenderingContext.FRAMEBUFFER_INCOMPLETE_DIMENSIONS;\nconst int FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = RenderingContext.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;\nconst int FRAMEBUFFER_UNSUPPORTED = RenderingContext.FRAMEBUFFER_UNSUPPORTED;\nconst int FRONT = RenderingContext.FRONT;\nconst int FRONT_AND_BACK = RenderingContext.FRONT_AND_BACK;\nconst int FRONT_FACE = RenderingContext.FRONT_FACE;\nconst int FUNC_ADD = RenderingContext.FUNC_ADD;\nconst int FUNC_REVERSE_SUBTRACT = RenderingContext.FUNC_REVERSE_SUBTRACT;\nconst int FUNC_SUBTRACT = RenderingContext.FUNC_SUBTRACT;\nconst int GENERATE_MIPMAP_HINT = RenderingContext.GENERATE_MIPMAP_HINT;\nconst int GEQUAL = RenderingContext.GEQUAL;\nconst int GREATER = RenderingContext.GREATER;\nconst int GREEN_BITS = RenderingContext.GREEN_BITS;\nconst int HALF_FLOAT_OES = RenderingContext.HALF_FLOAT_OES;\nconst int HIGH_FLOAT = RenderingContext.HIGH_FLOAT;\nconst int HIGH_INT = RenderingContext.HIGH_INT;\nconst int INCR = RenderingContext.INCR;\nconst int INCR_WRAP = RenderingContext.INCR_WRAP;\nconst int INT = RenderingContext.INT;\nconst int INT_VEC2 = RenderingContext.INT_VEC2;\nconst int INT_VEC3 = RenderingContext.INT_VEC3;\nconst int INT_VEC4 = RenderingContext.INT_VEC4;\nconst int INVALID_ENUM = RenderingContext.INVALID_ENUM;\nconst int INVALID_FRAMEBUFFER_OPERATION = RenderingContext.INVALID_FRAMEBUFFER_OPERATION;\nconst int INVALID_OPERATION = RenderingContext.INVALID_OPERATION;\nconst int INVALID_VALUE = RenderingContext.INVALID_VALUE;\nconst int INVERT = RenderingContext.INVERT;\nconst int KEEP = RenderingContext.KEEP;\nconst int LEQUAL = RenderingContext.LEQUAL;\nconst int LESS = RenderingContext.LESS;\nconst int LINEAR = RenderingContext.LINEAR;\nconst int LINEAR_MIPMAP_LINEAR = RenderingContext.LINEAR_MIPMAP_LINEAR;\nconst int LINEAR_MIPMAP_NEAREST = RenderingContext.LINEAR_MIPMAP_NEAREST;\nconst int LINES = RenderingContext.LINES;\nconst int LINE_LOOP = RenderingContext.LINE_LOOP;\nconst int LINE_STRIP = RenderingContext.LINE_STRIP;\nconst int LINE_WIDTH = RenderingContext.LINE_WIDTH;\nconst int LINK_STATUS = RenderingContext.LINK_STATUS;\nconst int LOW_FLOAT = RenderingContext.LOW_FLOAT;\nconst int LOW_INT = RenderingContext.LOW_INT;\nconst int LUMINANCE = RenderingContext.LUMINANCE;\nconst int LUMINANCE_ALPHA = RenderingContext.LUMINANCE_ALPHA;\nconst int MAX_COMBINED_TEXTURE_IMAGE_UNITS = RenderingContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS;\nconst int MAX_CUBE_MAP_TEXTURE_SIZE = RenderingContext.MAX_CUBE_MAP_TEXTURE_SIZE;\nconst int MAX_FRAGMENT_UNIFORM_VECTORS = RenderingContext.MAX_FRAGMENT_UNIFORM_VECTORS;\nconst int MAX_RENDERBUFFER_SIZE = RenderingContext.MAX_RENDERBUFFER_SIZE;\nconst int MAX_TEXTURE_IMAGE_UNITS = RenderingContext.MAX_TEXTURE_IMAGE_UNITS;\nconst int MAX_TEXTURE_SIZE = RenderingContext.MAX_TEXTURE_SIZE;\nconst int MAX_VARYING_VECTORS = RenderingContext.MAX_VARYING_VECTORS;\nconst int MAX_VERTEX_ATTRIBS = RenderingContext.MAX_VERTEX_ATTRIBS;\nconst int MAX_VERTEX_TEXTURE_IMAGE_UNITS = RenderingContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS;\nconst int MAX_VERTEX_UNIFORM_VECTORS = RenderingContext.MAX_VERTEX_UNIFORM_VECTORS;\nconst int MAX_VIEWPORT_DIMS = RenderingContext.MAX_VIEWPORT_DIMS;\nconst int MEDIUM_FLOAT = RenderingContext.MEDIUM_FLOAT;\nconst int MEDIUM_INT = RenderingContext.MEDIUM_INT;\nconst int MIRRORED_REPEAT = RenderingContext.MIRRORED_REPEAT;\nconst int NEAREST = RenderingContext.NEAREST;\nconst int NEAREST_MIPMAP_LINEAR = RenderingContext.NEAREST_MIPMAP_LINEAR;\nconst int NEAREST_MIPMAP_NEAREST = RenderingContext.NEAREST_MIPMAP_NEAREST;\nconst int NEVER = RenderingContext.NEVER;\nconst int NICEST = RenderingContext.NICEST;\nconst int NONE = RenderingContext.NONE;\nconst int NOTEQUAL = RenderingContext.NOTEQUAL;\nconst int NO_ERROR = RenderingContext.NO_ERROR;\nconst int ONE = RenderingContext.ONE;\nconst int ONE_MINUS_CONSTANT_ALPHA = RenderingContext.ONE_MINUS_CONSTANT_ALPHA;\nconst int ONE_MINUS_CONSTANT_COLOR = RenderingContext.ONE_MINUS_CONSTANT_COLOR;\nconst int ONE_MINUS_DST_ALPHA = RenderingContext.ONE_MINUS_DST_ALPHA;\nconst int ONE_MINUS_DST_COLOR = RenderingContext.ONE_MINUS_DST_COLOR;\nconst int ONE_MINUS_SRC_ALPHA = RenderingContext.ONE_MINUS_SRC_ALPHA;\nconst int ONE_MINUS_SRC_COLOR = RenderingContext.ONE_MINUS_SRC_COLOR;\nconst int OUT_OF_MEMORY = RenderingContext.OUT_OF_MEMORY;\nconst int PACK_ALIGNMENT = RenderingContext.PACK_ALIGNMENT;\nconst int POINTS = RenderingContext.POINTS;\nconst int POLYGON_OFFSET_FACTOR = RenderingContext.POLYGON_OFFSET_FACTOR;\nconst int POLYGON_OFFSET_FILL = RenderingContext.POLYGON_OFFSET_FILL;\nconst int POLYGON_OFFSET_UNITS = RenderingContext.POLYGON_OFFSET_UNITS;\nconst int RED_BITS = RenderingContext.RED_BITS;\nconst int RENDERBUFFER = RenderingContext.RENDERBUFFER;\nconst int RENDERBUFFER_ALPHA_SIZE = RenderingContext.RENDERBUFFER_ALPHA_SIZE;\nconst int RENDERBUFFER_BINDING = RenderingContext.RENDERBUFFER_BINDING;\nconst int RENDERBUFFER_BLUE_SIZE = RenderingContext.RENDERBUFFER_BLUE_SIZE;\nconst int RENDERBUFFER_DEPTH_SIZE = RenderingContext.RENDERBUFFER_DEPTH_SIZE;\nconst int RENDERBUFFER_GREEN_SIZE = RenderingContext.RENDERBUFFER_GREEN_SIZE;\nconst int RENDERBUFFER_HEIGHT = RenderingContext.RENDERBUFFER_HEIGHT;\nconst int RENDERBUFFER_INTERNAL_FORMAT = RenderingContext.RENDERBUFFER_INTERNAL_FORMAT;\nconst int RENDERBUFFER_RED_SIZE = RenderingContext.RENDERBUFFER_RED_SIZE;\nconst int RENDERBUFFER_STENCIL_SIZE = RenderingContext.RENDERBUFFER_STENCIL_SIZE;\nconst int RENDERBUFFER_WIDTH = RenderingContext.RENDERBUFFER_WIDTH;\nconst int RENDERER = RenderingContext.RENDERER;\nconst int REPEAT = RenderingContext.REPEAT;\nconst int REPLACE = RenderingContext.REPLACE;\nconst int RGB = RenderingContext.RGB;\nconst int RGB565 = RenderingContext.RGB565;\nconst int RGB5_A1 = RenderingContext.RGB5_A1;\nconst int RGBA = RenderingContext.RGBA;\nconst int RGBA4 = RenderingContext.RGBA4;\nconst int SAMPLER_2D = RenderingContext.SAMPLER_2D;\nconst int SAMPLER_CUBE = RenderingContext.SAMPLER_CUBE;\nconst int SAMPLES = RenderingContext.SAMPLES;\nconst int SAMPLE_ALPHA_TO_COVERAGE = RenderingContext.SAMPLE_ALPHA_TO_COVERAGE;\nconst int SAMPLE_BUFFERS = RenderingContext.SAMPLE_BUFFERS;\nconst int SAMPLE_COVERAGE = RenderingContext.SAMPLE_COVERAGE;\nconst int SAMPLE_COVERAGE_INVERT = RenderingContext.SAMPLE_COVERAGE_INVERT;\nconst int SAMPLE_COVERAGE_VALUE = RenderingContext.SAMPLE_COVERAGE_VALUE;\nconst int SCISSOR_BOX = RenderingContext.SCISSOR_BOX;\nconst int SCISSOR_TEST = RenderingContext.SCISSOR_TEST;\nconst int SHADER_TYPE = RenderingContext.SHADER_TYPE;\nconst int SHADING_LANGUAGE_VERSION = RenderingContext.SHADING_LANGUAGE_VERSION;\nconst int SHORT = RenderingContext.SHORT;\nconst int SRC_ALPHA = RenderingContext.SRC_ALPHA;\nconst int SRC_ALPHA_SATURATE = RenderingContext.SRC_ALPHA_SATURATE;\nconst int SRC_COLOR = RenderingContext.SRC_COLOR;\nconst int STATIC_DRAW = RenderingContext.STATIC_DRAW;\nconst int STENCIL_ATTACHMENT = RenderingContext.STENCIL_ATTACHMENT;\nconst int STENCIL_BACK_FAIL = RenderingContext.STENCIL_BACK_FAIL;\nconst int STENCIL_BACK_FUNC = RenderingContext.STENCIL_BACK_FUNC;\nconst int STENCIL_BACK_PASS_DEPTH_FAIL = RenderingContext.STENCIL_BACK_PASS_DEPTH_FAIL;\nconst int STENCIL_BACK_PASS_DEPTH_PASS = RenderingContext.STENCIL_BACK_PASS_DEPTH_PASS;\nconst int STENCIL_BACK_REF = RenderingContext.STENCIL_BACK_REF;\nconst int STENCIL_BACK_VALUE_MASK = RenderingContext.STENCIL_BACK_VALUE_MASK;\nconst int STENCIL_BACK_WRITEMASK = RenderingContext.STENCIL_BACK_WRITEMASK;\nconst int STENCIL_BITS = RenderingContext.STENCIL_BITS;\nconst int STENCIL_BUFFER_BIT = RenderingContext.STENCIL_BUFFER_BIT;\nconst int STENCIL_CLEAR_VALUE = RenderingContext.STENCIL_CLEAR_VALUE;\nconst int STENCIL_FAIL = RenderingContext.STENCIL_FAIL;\nconst int STENCIL_FUNC = RenderingContext.STENCIL_FUNC;\nconst int STENCIL_INDEX = RenderingContext.STENCIL_INDEX;\nconst int STENCIL_INDEX8 = RenderingContext.STENCIL_INDEX8;\nconst int STENCIL_PASS_DEPTH_FAIL = RenderingContext.STENCIL_PASS_DEPTH_FAIL;\nconst int STENCIL_PASS_DEPTH_PASS = RenderingContext.STENCIL_PASS_DEPTH_PASS;\nconst int STENCIL_REF = RenderingContext.STENCIL_REF;\nconst int STENCIL_TEST = RenderingContext.STENCIL_TEST;\nconst int STENCIL_VALUE_MASK = RenderingContext.STENCIL_VALUE_MASK;\nconst int STENCIL_WRITEMASK = RenderingContext.STENCIL_WRITEMASK;\nconst int STREAM_DRAW = RenderingContext.STREAM_DRAW;\nconst int SUBPIXEL_BITS = RenderingContext.SUBPIXEL_BITS;\nconst int TEXTURE = RenderingContext.TEXTURE;\nconst int TEXTURE0 = RenderingContext.TEXTURE0;\nconst int TEXTURE1 = RenderingContext.TEXTURE1;\nconst int TEXTURE10 = RenderingContext.TEXTURE10;\nconst int TEXTURE11 = RenderingContext.TEXTURE11;\nconst int TEXTURE12 = RenderingContext.TEXTURE12;\nconst int TEXTURE13 = RenderingContext.TEXTURE13;\nconst int TEXTURE14 = RenderingContext.TEXTURE14;\nconst int TEXTURE15 = RenderingContext.TEXTURE15;\nconst int TEXTURE16 = RenderingContext.TEXTURE16;\nconst int TEXTURE17 = RenderingContext.TEXTURE17;\nconst int TEXTURE18 = RenderingContext.TEXTURE18;\nconst int TEXTURE19 = RenderingContext.TEXTURE19;\nconst int TEXTURE2 = RenderingContext.TEXTURE2;\nconst int TEXTURE20 = RenderingContext.TEXTURE20;\nconst int TEXTURE21 = RenderingContext.TEXTURE21;\nconst int TEXTURE22 = RenderingContext.TEXTURE22;\nconst int TEXTURE23 = RenderingContext.TEXTURE23;\nconst int TEXTURE24 = RenderingContext.TEXTURE24;\nconst int TEXTURE25 = RenderingContext.TEXTURE25;\nconst int TEXTURE26 = RenderingContext.TEXTURE26;\nconst int TEXTURE27 = RenderingContext.TEXTURE27;\nconst int TEXTURE28 = RenderingContext.TEXTURE28;\nconst int TEXTURE29 = RenderingContext.TEXTURE29;\nconst int TEXTURE3 = RenderingContext.TEXTURE3;\nconst int TEXTURE30 = RenderingContext.TEXTURE30;\nconst int TEXTURE31 = RenderingContext.TEXTURE31;\nconst int TEXTURE4 = RenderingContext.TEXTURE4;\nconst int TEXTURE5 = RenderingContext.TEXTURE5;\nconst int TEXTURE6 = RenderingContext.TEXTURE6;\nconst int TEXTURE7 = RenderingContext.TEXTURE7;\nconst int TEXTURE8 = RenderingContext.TEXTURE8;\nconst int TEXTURE9 = RenderingContext.TEXTURE9;\nconst int TEXTURE_2D = RenderingContext.TEXTURE_2D;\nconst int TEXTURE_BINDING_2D = RenderingContext.TEXTURE_BINDING_2D;\nconst int TEXTURE_BINDING_CUBE_MAP = RenderingContext.TEXTURE_BINDING_CUBE_MAP;\nconst int TEXTURE_CUBE_MAP = RenderingContext.TEXTURE_CUBE_MAP;\nconst int TEXTURE_CUBE_MAP_NEGATIVE_X = RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_X;\nconst int TEXTURE_CUBE_MAP_NEGATIVE_Y = RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Y;\nconst int TEXTURE_CUBE_MAP_NEGATIVE_Z = RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Z;\nconst int TEXTURE_CUBE_MAP_POSITIVE_X = RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X;\nconst int TEXTURE_CUBE_MAP_POSITIVE_Y = RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Y;\nconst int TEXTURE_CUBE_MAP_POSITIVE_Z = RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Z;\nconst int TEXTURE_MAG_FILTER = RenderingContext.TEXTURE_MAG_FILTER;\nconst int TEXTURE_MIN_FILTER = RenderingContext.TEXTURE_MIN_FILTER;\nconst int TEXTURE_WRAP_S = RenderingContext.TEXTURE_WRAP_S;\nconst int TEXTURE_WRAP_T = RenderingContext.TEXTURE_WRAP_T;\nconst int TRIANGLES = RenderingContext.TRIANGLES;\nconst int TRIANGLE_FAN = RenderingContext.TRIANGLE_FAN;\nconst int TRIANGLE_STRIP = RenderingContext.TRIANGLE_STRIP;\nconst int UNPACK_ALIGNMENT = RenderingContext.UNPACK_ALIGNMENT;\nconst int UNPACK_COLORSPACE_CONVERSION_WEBGL = RenderingContext.UNPACK_COLORSPACE_CONVERSION_WEBGL;\nconst int UNPACK_FLIP_Y_WEBGL = RenderingContext.UNPACK_FLIP_Y_WEBGL;\nconst int UNPACK_PREMULTIPLY_ALPHA_WEBGL = RenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL;\nconst int UNSIGNED_BYTE = RenderingContext.UNSIGNED_BYTE;\nconst int UNSIGNED_INT = RenderingContext.UNSIGNED_INT;\nconst int UNSIGNED_SHORT = RenderingContext.UNSIGNED_SHORT;\nconst int UNSIGNED_SHORT_4_4_4_4 = RenderingContext.UNSIGNED_SHORT_4_4_4_4;\nconst int UNSIGNED_SHORT_5_5_5_1 = RenderingContext.UNSIGNED_SHORT_5_5_5_1;\nconst int UNSIGNED_SHORT_5_6_5 = RenderingContext.UNSIGNED_SHORT_5_6_5;\nconst int VALIDATE_STATUS = RenderingContext.VALIDATE_STATUS;\nconst int VENDOR = RenderingContext.VENDOR;\nconst int VERSION = RenderingContext.VERSION;\nconst int VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = RenderingContext.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING;\nconst int VERTEX_ATTRIB_ARRAY_ENABLED = RenderingContext.VERTEX_ATTRIB_ARRAY_ENABLED;\nconst int VERTEX_ATTRIB_ARRAY_NORMALIZED = RenderingContext.VERTEX_ATTRIB_ARRAY_NORMALIZED;\nconst int VERTEX_ATTRIB_ARRAY_POINTER = RenderingContext.VERTEX_ATTRIB_ARRAY_POINTER;\nconst int VERTEX_ATTRIB_ARRAY_SIZE = RenderingContext.VERTEX_ATTRIB_ARRAY_SIZE;\nconst int VERTEX_ATTRIB_ARRAY_STRIDE = RenderingContext.VERTEX_ATTRIB_ARRAY_STRIDE;\nconst int VERTEX_ATTRIB_ARRAY_TYPE = RenderingContext.VERTEX_ATTRIB_ARRAY_TYPE;\nconst int VERTEX_SHADER = RenderingContext.VERTEX_SHADER;\nconst int VIEWPORT = RenderingContext.VIEWPORT;\nconst int ZERO = RenderingContext.ZERO;\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLActiveInfo')\nclass ActiveInfo native \"WebGLActiveInfo\" {\n\n  @DomName('WebGLActiveInfo.name')\n  @DocsEditable\n  final String name;\n\n  @DomName('WebGLActiveInfo.size')\n  @DocsEditable\n  final int size;\n\n  @DomName('WebGLActiveInfo.type')\n  @DocsEditable\n  final int type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLBuffer')\nclass Buffer native \"WebGLBuffer\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLCompressedTextureATC')\nclass CompressedTextureAtc native \"WebGLCompressedTextureATC\" {\n\n  static const int COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93;\n\n  static const int COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE;\n\n  static const int COMPRESSED_RGB_ATC_WEBGL = 0x8C92;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLCompressedTexturePVRTC')\nclass CompressedTexturePvrtc native \"WebGLCompressedTexturePVRTC\" {\n\n  static const int COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;\n\n  static const int COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;\n\n  static const int COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;\n\n  static const int COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLCompressedTextureS3TC')\nclass CompressedTextureS3TC native \"WebGLCompressedTextureS3TC\" {\n\n  static const int COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;\n\n  static const int COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;\n\n  static const int COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;\n\n  static const int COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLContextAttributes')\nclass ContextAttributes native \"WebGLContextAttributes\" {\n\n  @DomName('WebGLContextAttributes.alpha')\n  @DocsEditable\n  bool alpha;\n\n  @DomName('WebGLContextAttributes.antialias')\n  @DocsEditable\n  bool antialias;\n\n  @DomName('WebGLContextAttributes.depth')\n  @DocsEditable\n  bool depth;\n\n  @DomName('WebGLContextAttributes.premultipliedAlpha')\n  @DocsEditable\n  bool premultipliedAlpha;\n\n  @DomName('WebGLContextAttributes.preserveDrawingBuffer')\n  @DocsEditable\n  bool preserveDrawingBuffer;\n\n  @DomName('WebGLContextAttributes.stencil')\n  @DocsEditable\n  bool stencil;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLContextEvent')\nclass ContextEvent extends Event native \"WebGLContextEvent\" {\n\n  @DomName('WebGLContextEvent.statusMessage')\n  @DocsEditable\n  final String statusMessage;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLDebugRendererInfo')\nclass DebugRendererInfo native \"WebGLDebugRendererInfo\" {\n\n  static const int UNMASKED_RENDERER_WEBGL = 0x9246;\n\n  static const int UNMASKED_VENDOR_WEBGL = 0x9245;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLDebugShaders')\nclass DebugShaders native \"WebGLDebugShaders\" {\n\n  @DomName('WebGLDebugShaders.getTranslatedShaderSource')\n  @DocsEditable\n  String getTranslatedShaderSource(Shader shader) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLDepthTexture')\nclass DepthTexture native \"WebGLDepthTexture\" {\n\n  static const int UNSIGNED_INT_24_8_WEBGL = 0x84FA;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('EXTDrawBuffers')\nclass ExtDrawBuffers native \"EXTDrawBuffers\" {\n\n  static const int COLOR_ATTACHMENT0_EXT = 0x8CE0;\n\n  static const int COLOR_ATTACHMENT10_EXT = 0x8CEA;\n\n  static const int COLOR_ATTACHMENT11_EXT = 0x8CEB;\n\n  static const int COLOR_ATTACHMENT12_EXT = 0x8CEC;\n\n  static const int COLOR_ATTACHMENT13_EXT = 0x8CED;\n\n  static const int COLOR_ATTACHMENT14_EXT = 0x8CEE;\n\n  static const int COLOR_ATTACHMENT15_EXT = 0x8CEF;\n\n  static const int COLOR_ATTACHMENT1_EXT = 0x8CE1;\n\n  static const int COLOR_ATTACHMENT2_EXT = 0x8CE2;\n\n  static const int COLOR_ATTACHMENT3_EXT = 0x8CE3;\n\n  static const int COLOR_ATTACHMENT4_EXT = 0x8CE4;\n\n  static const int COLOR_ATTACHMENT5_EXT = 0x8CE5;\n\n  static const int COLOR_ATTACHMENT6_EXT = 0x8CE6;\n\n  static const int COLOR_ATTACHMENT7_EXT = 0x8CE7;\n\n  static const int COLOR_ATTACHMENT8_EXT = 0x8CE8;\n\n  static const int COLOR_ATTACHMENT9_EXT = 0x8CE9;\n\n  static const int DRAW_BUFFER0_EXT = 0x8825;\n\n  static const int DRAW_BUFFER10_EXT = 0x882F;\n\n  static const int DRAW_BUFFER11_EXT = 0x8830;\n\n  static const int DRAW_BUFFER12_EXT = 0x8831;\n\n  static const int DRAW_BUFFER13_EXT = 0x8832;\n\n  static const int DRAW_BUFFER14_EXT = 0x8833;\n\n  static const int DRAW_BUFFER15_EXT = 0x8834;\n\n  static const int DRAW_BUFFER1_EXT = 0x8826;\n\n  static const int DRAW_BUFFER2_EXT = 0x8827;\n\n  static const int DRAW_BUFFER3_EXT = 0x8828;\n\n  static const int DRAW_BUFFER4_EXT = 0x8829;\n\n  static const int DRAW_BUFFER5_EXT = 0x882A;\n\n  static const int DRAW_BUFFER6_EXT = 0x882B;\n\n  static const int DRAW_BUFFER7_EXT = 0x882C;\n\n  static const int DRAW_BUFFER8_EXT = 0x882D;\n\n  static const int DRAW_BUFFER9_EXT = 0x882E;\n\n  static const int MAX_COLOR_ATTACHMENTS_EXT = 0x8CDF;\n\n  static const int MAX_DRAW_BUFFERS_EXT = 0x8824;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('EXTTextureFilterAnisotropic')\nclass ExtTextureFilterAnisotropic native \"EXTTextureFilterAnisotropic\" {\n\n  static const int MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;\n\n  static const int TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLFramebuffer')\nclass Framebuffer native \"WebGLFramebuffer\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLLoseContext')\nclass LoseContext native \"WebGLLoseContext\" {\n\n  @DomName('WebGLLoseContext.loseContext')\n  @DocsEditable\n  void loseContext() native;\n\n  @DomName('WebGLLoseContext.restoreContext')\n  @DocsEditable\n  void restoreContext() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('OESElementIndexUint')\nclass OesElementIndexUint native \"OESElementIndexUint\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('OESStandardDerivatives')\nclass OesStandardDerivatives native \"OESStandardDerivatives\" {\n\n  static const int FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('OESTextureFloat')\nclass OesTextureFloat native \"OESTextureFloat\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('OESTextureHalfFloat')\nclass OesTextureHalfFloat native \"OESTextureHalfFloat\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('OESVertexArrayObject')\nclass OesVertexArrayObject native \"OESVertexArrayObject\" {\n\n  static const int VERTEX_ARRAY_BINDING_OES = 0x85B5;\n\n  @JSName('bindVertexArrayOES')\n  @DomName('OESVertexArrayObject.bindVertexArrayOES')\n  @DocsEditable\n  void bindVertexArray(VertexArrayObject arrayObject) native;\n\n  @JSName('createVertexArrayOES')\n  @DomName('OESVertexArrayObject.createVertexArrayOES')\n  @DocsEditable\n  VertexArrayObject createVertexArray() native;\n\n  @JSName('deleteVertexArrayOES')\n  @DomName('OESVertexArrayObject.deleteVertexArrayOES')\n  @DocsEditable\n  void deleteVertexArray(VertexArrayObject arrayObject) native;\n\n  @JSName('isVertexArrayOES')\n  @DomName('OESVertexArrayObject.isVertexArrayOES')\n  @DocsEditable\n  bool isVertexArray(VertexArrayObject arrayObject) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLProgram')\nclass Program native \"WebGLProgram\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLRenderbuffer')\nclass Renderbuffer native \"WebGLRenderbuffer\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLRenderingContext')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@Experimental\nclass RenderingContext extends CanvasRenderingContext native \"WebGLRenderingContext\" {\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.WebGLRenderingContext)');\n\n  static const int ACTIVE_ATTRIBUTES = 0x8B89;\n\n  static const int ACTIVE_TEXTURE = 0x84E0;\n\n  static const int ACTIVE_UNIFORMS = 0x8B86;\n\n  static const int ALIASED_LINE_WIDTH_RANGE = 0x846E;\n\n  static const int ALIASED_POINT_SIZE_RANGE = 0x846D;\n\n  static const int ALPHA = 0x1906;\n\n  static const int ALPHA_BITS = 0x0D55;\n\n  static const int ALWAYS = 0x0207;\n\n  static const int ARRAY_BUFFER = 0x8892;\n\n  static const int ARRAY_BUFFER_BINDING = 0x8894;\n\n  static const int ATTACHED_SHADERS = 0x8B85;\n\n  static const int BACK = 0x0405;\n\n  static const int BLEND = 0x0BE2;\n\n  static const int BLEND_COLOR = 0x8005;\n\n  static const int BLEND_DST_ALPHA = 0x80CA;\n\n  static const int BLEND_DST_RGB = 0x80C8;\n\n  static const int BLEND_EQUATION = 0x8009;\n\n  static const int BLEND_EQUATION_ALPHA = 0x883D;\n\n  static const int BLEND_EQUATION_RGB = 0x8009;\n\n  static const int BLEND_SRC_ALPHA = 0x80CB;\n\n  static const int BLEND_SRC_RGB = 0x80C9;\n\n  static const int BLUE_BITS = 0x0D54;\n\n  static const int BOOL = 0x8B56;\n\n  static const int BOOL_VEC2 = 0x8B57;\n\n  static const int BOOL_VEC3 = 0x8B58;\n\n  static const int BOOL_VEC4 = 0x8B59;\n\n  static const int BROWSER_DEFAULT_WEBGL = 0x9244;\n\n  static const int BUFFER_SIZE = 0x8764;\n\n  static const int BUFFER_USAGE = 0x8765;\n\n  static const int BYTE = 0x1400;\n\n  static const int CCW = 0x0901;\n\n  static const int CLAMP_TO_EDGE = 0x812F;\n\n  static const int COLOR_ATTACHMENT0 = 0x8CE0;\n\n  static const int COLOR_BUFFER_BIT = 0x00004000;\n\n  static const int COLOR_CLEAR_VALUE = 0x0C22;\n\n  static const int COLOR_WRITEMASK = 0x0C23;\n\n  static const int COMPILE_STATUS = 0x8B81;\n\n  static const int COMPRESSED_TEXTURE_FORMATS = 0x86A3;\n\n  static const int CONSTANT_ALPHA = 0x8003;\n\n  static const int CONSTANT_COLOR = 0x8001;\n\n  static const int CONTEXT_LOST_WEBGL = 0x9242;\n\n  static const int CULL_FACE = 0x0B44;\n\n  static const int CULL_FACE_MODE = 0x0B45;\n\n  static const int CURRENT_PROGRAM = 0x8B8D;\n\n  static const int CURRENT_VERTEX_ATTRIB = 0x8626;\n\n  static const int CW = 0x0900;\n\n  static const int DECR = 0x1E03;\n\n  static const int DECR_WRAP = 0x8508;\n\n  static const int DELETE_STATUS = 0x8B80;\n\n  static const int DEPTH_ATTACHMENT = 0x8D00;\n\n  static const int DEPTH_BITS = 0x0D56;\n\n  static const int DEPTH_BUFFER_BIT = 0x00000100;\n\n  static const int DEPTH_CLEAR_VALUE = 0x0B73;\n\n  static const int DEPTH_COMPONENT = 0x1902;\n\n  static const int DEPTH_COMPONENT16 = 0x81A5;\n\n  static const int DEPTH_FUNC = 0x0B74;\n\n  static const int DEPTH_RANGE = 0x0B70;\n\n  static const int DEPTH_STENCIL = 0x84F9;\n\n  static const int DEPTH_STENCIL_ATTACHMENT = 0x821A;\n\n  static const int DEPTH_TEST = 0x0B71;\n\n  static const int DEPTH_WRITEMASK = 0x0B72;\n\n  static const int DITHER = 0x0BD0;\n\n  static const int DONT_CARE = 0x1100;\n\n  static const int DST_ALPHA = 0x0304;\n\n  static const int DST_COLOR = 0x0306;\n\n  static const int DYNAMIC_DRAW = 0x88E8;\n\n  static const int ELEMENT_ARRAY_BUFFER = 0x8893;\n\n  static const int ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;\n\n  static const int EQUAL = 0x0202;\n\n  static const int FASTEST = 0x1101;\n\n  static const int FLOAT = 0x1406;\n\n  static const int FLOAT_MAT2 = 0x8B5A;\n\n  static const int FLOAT_MAT3 = 0x8B5B;\n\n  static const int FLOAT_MAT4 = 0x8B5C;\n\n  static const int FLOAT_VEC2 = 0x8B50;\n\n  static const int FLOAT_VEC3 = 0x8B51;\n\n  static const int FLOAT_VEC4 = 0x8B52;\n\n  static const int FRAGMENT_SHADER = 0x8B30;\n\n  static const int FRAMEBUFFER = 0x8D40;\n\n  static const int FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;\n\n  static const int FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;\n\n  static const int FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;\n\n  static const int FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;\n\n  static const int FRAMEBUFFER_BINDING = 0x8CA6;\n\n  static const int FRAMEBUFFER_COMPLETE = 0x8CD5;\n\n  static const int FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;\n\n  static const int FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;\n\n  static const int FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;\n\n  static const int FRAMEBUFFER_UNSUPPORTED = 0x8CDD;\n\n  static const int FRONT = 0x0404;\n\n  static const int FRONT_AND_BACK = 0x0408;\n\n  static const int FRONT_FACE = 0x0B46;\n\n  static const int FUNC_ADD = 0x8006;\n\n  static const int FUNC_REVERSE_SUBTRACT = 0x800B;\n\n  static const int FUNC_SUBTRACT = 0x800A;\n\n  static const int GENERATE_MIPMAP_HINT = 0x8192;\n\n  static const int GEQUAL = 0x0206;\n\n  static const int GREATER = 0x0204;\n\n  static const int GREEN_BITS = 0x0D53;\n\n  static const int HALF_FLOAT_OES = 0x8D61;\n\n  static const int HIGH_FLOAT = 0x8DF2;\n\n  static const int HIGH_INT = 0x8DF5;\n\n  static const int INCR = 0x1E02;\n\n  static const int INCR_WRAP = 0x8507;\n\n  static const int INT = 0x1404;\n\n  static const int INT_VEC2 = 0x8B53;\n\n  static const int INT_VEC3 = 0x8B54;\n\n  static const int INT_VEC4 = 0x8B55;\n\n  static const int INVALID_ENUM = 0x0500;\n\n  static const int INVALID_FRAMEBUFFER_OPERATION = 0x0506;\n\n  static const int INVALID_OPERATION = 0x0502;\n\n  static const int INVALID_VALUE = 0x0501;\n\n  static const int INVERT = 0x150A;\n\n  static const int KEEP = 0x1E00;\n\n  static const int LEQUAL = 0x0203;\n\n  static const int LESS = 0x0201;\n\n  static const int LINEAR = 0x2601;\n\n  static const int LINEAR_MIPMAP_LINEAR = 0x2703;\n\n  static const int LINEAR_MIPMAP_NEAREST = 0x2701;\n\n  static const int LINES = 0x0001;\n\n  static const int LINE_LOOP = 0x0002;\n\n  static const int LINE_STRIP = 0x0003;\n\n  static const int LINE_WIDTH = 0x0B21;\n\n  static const int LINK_STATUS = 0x8B82;\n\n  static const int LOW_FLOAT = 0x8DF0;\n\n  static const int LOW_INT = 0x8DF3;\n\n  static const int LUMINANCE = 0x1909;\n\n  static const int LUMINANCE_ALPHA = 0x190A;\n\n  static const int MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;\n\n  static const int MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;\n\n  static const int MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;\n\n  static const int MAX_RENDERBUFFER_SIZE = 0x84E8;\n\n  static const int MAX_TEXTURE_IMAGE_UNITS = 0x8872;\n\n  static const int MAX_TEXTURE_SIZE = 0x0D33;\n\n  static const int MAX_VARYING_VECTORS = 0x8DFC;\n\n  static const int MAX_VERTEX_ATTRIBS = 0x8869;\n\n  static const int MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;\n\n  static const int MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;\n\n  static const int MAX_VIEWPORT_DIMS = 0x0D3A;\n\n  static const int MEDIUM_FLOAT = 0x8DF1;\n\n  static const int MEDIUM_INT = 0x8DF4;\n\n  static const int MIRRORED_REPEAT = 0x8370;\n\n  static const int NEAREST = 0x2600;\n\n  static const int NEAREST_MIPMAP_LINEAR = 0x2702;\n\n  static const int NEAREST_MIPMAP_NEAREST = 0x2700;\n\n  static const int NEVER = 0x0200;\n\n  static const int NICEST = 0x1102;\n\n  static const int NONE = 0;\n\n  static const int NOTEQUAL = 0x0205;\n\n  static const int NO_ERROR = 0;\n\n  static const int ONE = 1;\n\n  static const int ONE_MINUS_CONSTANT_ALPHA = 0x8004;\n\n  static const int ONE_MINUS_CONSTANT_COLOR = 0x8002;\n\n  static const int ONE_MINUS_DST_ALPHA = 0x0305;\n\n  static const int ONE_MINUS_DST_COLOR = 0x0307;\n\n  static const int ONE_MINUS_SRC_ALPHA = 0x0303;\n\n  static const int ONE_MINUS_SRC_COLOR = 0x0301;\n\n  static const int OUT_OF_MEMORY = 0x0505;\n\n  static const int PACK_ALIGNMENT = 0x0D05;\n\n  static const int POINTS = 0x0000;\n\n  static const int POLYGON_OFFSET_FACTOR = 0x8038;\n\n  static const int POLYGON_OFFSET_FILL = 0x8037;\n\n  static const int POLYGON_OFFSET_UNITS = 0x2A00;\n\n  static const int RED_BITS = 0x0D52;\n\n  static const int RENDERBUFFER = 0x8D41;\n\n  static const int RENDERBUFFER_ALPHA_SIZE = 0x8D53;\n\n  static const int RENDERBUFFER_BINDING = 0x8CA7;\n\n  static const int RENDERBUFFER_BLUE_SIZE = 0x8D52;\n\n  static const int RENDERBUFFER_DEPTH_SIZE = 0x8D54;\n\n  static const int RENDERBUFFER_GREEN_SIZE = 0x8D51;\n\n  static const int RENDERBUFFER_HEIGHT = 0x8D43;\n\n  static const int RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;\n\n  static const int RENDERBUFFER_RED_SIZE = 0x8D50;\n\n  static const int RENDERBUFFER_STENCIL_SIZE = 0x8D55;\n\n  static const int RENDERBUFFER_WIDTH = 0x8D42;\n\n  static const int RENDERER = 0x1F01;\n\n  static const int REPEAT = 0x2901;\n\n  static const int REPLACE = 0x1E01;\n\n  static const int RGB = 0x1907;\n\n  static const int RGB565 = 0x8D62;\n\n  static const int RGB5_A1 = 0x8057;\n\n  static const int RGBA = 0x1908;\n\n  static const int RGBA4 = 0x8056;\n\n  static const int SAMPLER_2D = 0x8B5E;\n\n  static const int SAMPLER_CUBE = 0x8B60;\n\n  static const int SAMPLES = 0x80A9;\n\n  static const int SAMPLE_ALPHA_TO_COVERAGE = 0x809E;\n\n  static const int SAMPLE_BUFFERS = 0x80A8;\n\n  static const int SAMPLE_COVERAGE = 0x80A0;\n\n  static const int SAMPLE_COVERAGE_INVERT = 0x80AB;\n\n  static const int SAMPLE_COVERAGE_VALUE = 0x80AA;\n\n  static const int SCISSOR_BOX = 0x0C10;\n\n  static const int SCISSOR_TEST = 0x0C11;\n\n  static const int SHADER_TYPE = 0x8B4F;\n\n  static const int SHADING_LANGUAGE_VERSION = 0x8B8C;\n\n  static const int SHORT = 0x1402;\n\n  static const int SRC_ALPHA = 0x0302;\n\n  static const int SRC_ALPHA_SATURATE = 0x0308;\n\n  static const int SRC_COLOR = 0x0300;\n\n  static const int STATIC_DRAW = 0x88E4;\n\n  static const int STENCIL_ATTACHMENT = 0x8D20;\n\n  static const int STENCIL_BACK_FAIL = 0x8801;\n\n  static const int STENCIL_BACK_FUNC = 0x8800;\n\n  static const int STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;\n\n  static const int STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;\n\n  static const int STENCIL_BACK_REF = 0x8CA3;\n\n  static const int STENCIL_BACK_VALUE_MASK = 0x8CA4;\n\n  static const int STENCIL_BACK_WRITEMASK = 0x8CA5;\n\n  static const int STENCIL_BITS = 0x0D57;\n\n  static const int STENCIL_BUFFER_BIT = 0x00000400;\n\n  static const int STENCIL_CLEAR_VALUE = 0x0B91;\n\n  static const int STENCIL_FAIL = 0x0B94;\n\n  static const int STENCIL_FUNC = 0x0B92;\n\n  static const int STENCIL_INDEX = 0x1901;\n\n  static const int STENCIL_INDEX8 = 0x8D48;\n\n  static const int STENCIL_PASS_DEPTH_FAIL = 0x0B95;\n\n  static const int STENCIL_PASS_DEPTH_PASS = 0x0B96;\n\n  static const int STENCIL_REF = 0x0B97;\n\n  static const int STENCIL_TEST = 0x0B90;\n\n  static const int STENCIL_VALUE_MASK = 0x0B93;\n\n  static const int STENCIL_WRITEMASK = 0x0B98;\n\n  static const int STREAM_DRAW = 0x88E0;\n\n  static const int SUBPIXEL_BITS = 0x0D50;\n\n  static const int TEXTURE = 0x1702;\n\n  static const int TEXTURE0 = 0x84C0;\n\n  static const int TEXTURE1 = 0x84C1;\n\n  static const int TEXTURE10 = 0x84CA;\n\n  static const int TEXTURE11 = 0x84CB;\n\n  static const int TEXTURE12 = 0x84CC;\n\n  static const int TEXTURE13 = 0x84CD;\n\n  static const int TEXTURE14 = 0x84CE;\n\n  static const int TEXTURE15 = 0x84CF;\n\n  static const int TEXTURE16 = 0x84D0;\n\n  static const int TEXTURE17 = 0x84D1;\n\n  static const int TEXTURE18 = 0x84D2;\n\n  static const int TEXTURE19 = 0x84D3;\n\n  static const int TEXTURE2 = 0x84C2;\n\n  static const int TEXTURE20 = 0x84D4;\n\n  static const int TEXTURE21 = 0x84D5;\n\n  static const int TEXTURE22 = 0x84D6;\n\n  static const int TEXTURE23 = 0x84D7;\n\n  static const int TEXTURE24 = 0x84D8;\n\n  static const int TEXTURE25 = 0x84D9;\n\n  static const int TEXTURE26 = 0x84DA;\n\n  static const int TEXTURE27 = 0x84DB;\n\n  static const int TEXTURE28 = 0x84DC;\n\n  static const int TEXTURE29 = 0x84DD;\n\n  static const int TEXTURE3 = 0x84C3;\n\n  static const int TEXTURE30 = 0x84DE;\n\n  static const int TEXTURE31 = 0x84DF;\n\n  static const int TEXTURE4 = 0x84C4;\n\n  static const int TEXTURE5 = 0x84C5;\n\n  static const int TEXTURE6 = 0x84C6;\n\n  static const int TEXTURE7 = 0x84C7;\n\n  static const int TEXTURE8 = 0x84C8;\n\n  static const int TEXTURE9 = 0x84C9;\n\n  static const int TEXTURE_2D = 0x0DE1;\n\n  static const int TEXTURE_BINDING_2D = 0x8069;\n\n  static const int TEXTURE_BINDING_CUBE_MAP = 0x8514;\n\n  static const int TEXTURE_CUBE_MAP = 0x8513;\n\n  static const int TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;\n\n  static const int TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;\n\n  static const int TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;\n\n  static const int TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\n\n  static const int TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;\n\n  static const int TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;\n\n  static const int TEXTURE_MAG_FILTER = 0x2800;\n\n  static const int TEXTURE_MIN_FILTER = 0x2801;\n\n  static const int TEXTURE_WRAP_S = 0x2802;\n\n  static const int TEXTURE_WRAP_T = 0x2803;\n\n  static const int TRIANGLES = 0x0004;\n\n  static const int TRIANGLE_FAN = 0x0006;\n\n  static const int TRIANGLE_STRIP = 0x0005;\n\n  static const int UNPACK_ALIGNMENT = 0x0CF5;\n\n  static const int UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;\n\n  static const int UNPACK_FLIP_Y_WEBGL = 0x9240;\n\n  static const int UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;\n\n  static const int UNSIGNED_BYTE = 0x1401;\n\n  static const int UNSIGNED_INT = 0x1405;\n\n  static const int UNSIGNED_SHORT = 0x1403;\n\n  static const int UNSIGNED_SHORT_4_4_4_4 = 0x8033;\n\n  static const int UNSIGNED_SHORT_5_5_5_1 = 0x8034;\n\n  static const int UNSIGNED_SHORT_5_6_5 = 0x8363;\n\n  static const int VALIDATE_STATUS = 0x8B83;\n\n  static const int VENDOR = 0x1F00;\n\n  static const int VERSION = 0x1F02;\n\n  static const int VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;\n\n  static const int VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;\n\n  static const int VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;\n\n  static const int VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;\n\n  static const int VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;\n\n  static const int VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;\n\n  static const int VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;\n\n  static const int VERTEX_SHADER = 0x8B31;\n\n  static const int VIEWPORT = 0x0BA2;\n\n  static const int ZERO = 0;\n\n  @DomName('WebGLRenderingContext.drawingBufferHeight')\n  @DocsEditable\n  final int drawingBufferHeight;\n\n  @DomName('WebGLRenderingContext.drawingBufferWidth')\n  @DocsEditable\n  final int drawingBufferWidth;\n\n  @DomName('WebGLRenderingContext.activeTexture')\n  @DocsEditable\n  void activeTexture(int texture) native;\n\n  @DomName('WebGLRenderingContext.attachShader')\n  @DocsEditable\n  void attachShader(Program program, Shader shader) native;\n\n  @DomName('WebGLRenderingContext.bindAttribLocation')\n  @DocsEditable\n  void bindAttribLocation(Program program, int index, String name) native;\n\n  @DomName('WebGLRenderingContext.bindBuffer')\n  @DocsEditable\n  void bindBuffer(int target, Buffer buffer) native;\n\n  @DomName('WebGLRenderingContext.bindFramebuffer')\n  @DocsEditable\n  void bindFramebuffer(int target, Framebuffer framebuffer) native;\n\n  @DomName('WebGLRenderingContext.bindRenderbuffer')\n  @DocsEditable\n  void bindRenderbuffer(int target, Renderbuffer renderbuffer) native;\n\n  @DomName('WebGLRenderingContext.bindTexture')\n  @DocsEditable\n  void bindTexture(int target, Texture texture) native;\n\n  @DomName('WebGLRenderingContext.blendColor')\n  @DocsEditable\n  void blendColor(num red, num green, num blue, num alpha) native;\n\n  @DomName('WebGLRenderingContext.blendEquation')\n  @DocsEditable\n  void blendEquation(int mode) native;\n\n  @DomName('WebGLRenderingContext.blendEquationSeparate')\n  @DocsEditable\n  void blendEquationSeparate(int modeRGB, int modeAlpha) native;\n\n  @DomName('WebGLRenderingContext.blendFunc')\n  @DocsEditable\n  void blendFunc(int sfactor, int dfactor) native;\n\n  @DomName('WebGLRenderingContext.blendFuncSeparate')\n  @DocsEditable\n  void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) native;\n\n  @DomName('WebGLRenderingContext.bufferData')\n  @DocsEditable\n  void bufferData(int target, data_OR_size, int usage) native;\n\n  @DomName('WebGLRenderingContext.bufferSubData')\n  @DocsEditable\n  void bufferSubData(int target, int offset, data) native;\n\n  @DomName('WebGLRenderingContext.checkFramebufferStatus')\n  @DocsEditable\n  int checkFramebufferStatus(int target) native;\n\n  @DomName('WebGLRenderingContext.clear')\n  @DocsEditable\n  void clear(int mask) native;\n\n  @DomName('WebGLRenderingContext.clearColor')\n  @DocsEditable\n  void clearColor(num red, num green, num blue, num alpha) native;\n\n  @DomName('WebGLRenderingContext.clearDepth')\n  @DocsEditable\n  void clearDepth(num depth) native;\n\n  @DomName('WebGLRenderingContext.clearStencil')\n  @DocsEditable\n  void clearStencil(int s) native;\n\n  @DomName('WebGLRenderingContext.colorMask')\n  @DocsEditable\n  void colorMask(bool red, bool green, bool blue, bool alpha) native;\n\n  @DomName('WebGLRenderingContext.compileShader')\n  @DocsEditable\n  void compileShader(Shader shader) native;\n\n  @DomName('WebGLRenderingContext.compressedTexImage2D')\n  @DocsEditable\n  void compressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, TypedData data) native;\n\n  @DomName('WebGLRenderingContext.compressedTexSubImage2D')\n  @DocsEditable\n  void compressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, TypedData data) native;\n\n  @DomName('WebGLRenderingContext.copyTexImage2D')\n  @DocsEditable\n  void copyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border) native;\n\n  @DomName('WebGLRenderingContext.copyTexSubImage2D')\n  @DocsEditable\n  void copyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) native;\n\n  @DomName('WebGLRenderingContext.createBuffer')\n  @DocsEditable\n  Buffer createBuffer() native;\n\n  @DomName('WebGLRenderingContext.createFramebuffer')\n  @DocsEditable\n  Framebuffer createFramebuffer() native;\n\n  @DomName('WebGLRenderingContext.createProgram')\n  @DocsEditable\n  Program createProgram() native;\n\n  @DomName('WebGLRenderingContext.createRenderbuffer')\n  @DocsEditable\n  Renderbuffer createRenderbuffer() native;\n\n  @DomName('WebGLRenderingContext.createShader')\n  @DocsEditable\n  Shader createShader(int type) native;\n\n  @DomName('WebGLRenderingContext.createTexture')\n  @DocsEditable\n  Texture createTexture() native;\n\n  @DomName('WebGLRenderingContext.cullFace')\n  @DocsEditable\n  void cullFace(int mode) native;\n\n  @DomName('WebGLRenderingContext.deleteBuffer')\n  @DocsEditable\n  void deleteBuffer(Buffer buffer) native;\n\n  @DomName('WebGLRenderingContext.deleteFramebuffer')\n  @DocsEditable\n  void deleteFramebuffer(Framebuffer framebuffer) native;\n\n  @DomName('WebGLRenderingContext.deleteProgram')\n  @DocsEditable\n  void deleteProgram(Program program) native;\n\n  @DomName('WebGLRenderingContext.deleteRenderbuffer')\n  @DocsEditable\n  void deleteRenderbuffer(Renderbuffer renderbuffer) native;\n\n  @DomName('WebGLRenderingContext.deleteShader')\n  @DocsEditable\n  void deleteShader(Shader shader) native;\n\n  @DomName('WebGLRenderingContext.deleteTexture')\n  @DocsEditable\n  void deleteTexture(Texture texture) native;\n\n  @DomName('WebGLRenderingContext.depthFunc')\n  @DocsEditable\n  void depthFunc(int func) native;\n\n  @DomName('WebGLRenderingContext.depthMask')\n  @DocsEditable\n  void depthMask(bool flag) native;\n\n  @DomName('WebGLRenderingContext.depthRange')\n  @DocsEditable\n  void depthRange(num zNear, num zFar) native;\n\n  @DomName('WebGLRenderingContext.detachShader')\n  @DocsEditable\n  void detachShader(Program program, Shader shader) native;\n\n  @DomName('WebGLRenderingContext.disable')\n  @DocsEditable\n  void disable(int cap) native;\n\n  @DomName('WebGLRenderingContext.disableVertexAttribArray')\n  @DocsEditable\n  void disableVertexAttribArray(int index) native;\n\n  @DomName('WebGLRenderingContext.drawArrays')\n  @DocsEditable\n  void drawArrays(int mode, int first, int count) native;\n\n  @DomName('WebGLRenderingContext.drawElements')\n  @DocsEditable\n  void drawElements(int mode, int count, int type, int offset) native;\n\n  @DomName('WebGLRenderingContext.enable')\n  @DocsEditable\n  void enable(int cap) native;\n\n  @DomName('WebGLRenderingContext.enableVertexAttribArray')\n  @DocsEditable\n  void enableVertexAttribArray(int index) native;\n\n  @DomName('WebGLRenderingContext.finish')\n  @DocsEditable\n  void finish() native;\n\n  @DomName('WebGLRenderingContext.flush')\n  @DocsEditable\n  void flush() native;\n\n  @DomName('WebGLRenderingContext.framebufferRenderbuffer')\n  @DocsEditable\n  void framebufferRenderbuffer(int target, int attachment, int renderbuffertarget, Renderbuffer renderbuffer) native;\n\n  @DomName('WebGLRenderingContext.framebufferTexture2D')\n  @DocsEditable\n  void framebufferTexture2D(int target, int attachment, int textarget, Texture texture, int level) native;\n\n  @DomName('WebGLRenderingContext.frontFace')\n  @DocsEditable\n  void frontFace(int mode) native;\n\n  @DomName('WebGLRenderingContext.generateMipmap')\n  @DocsEditable\n  void generateMipmap(int target) native;\n\n  @DomName('WebGLRenderingContext.getActiveAttrib')\n  @DocsEditable\n  ActiveInfo getActiveAttrib(Program program, int index) native;\n\n  @DomName('WebGLRenderingContext.getActiveUniform')\n  @DocsEditable\n  ActiveInfo getActiveUniform(Program program, int index) native;\n\n  @DomName('WebGLRenderingContext.getAttachedShaders')\n  @DocsEditable\n  void getAttachedShaders(Program program) native;\n\n  @DomName('WebGLRenderingContext.getAttribLocation')\n  @DocsEditable\n  int getAttribLocation(Program program, String name) native;\n\n  @DomName('WebGLRenderingContext.getBufferParameter')\n  @DocsEditable\n  Object getBufferParameter(int target, int pname) native;\n\n  @DomName('WebGLRenderingContext.getContextAttributes')\n  @DocsEditable\n  ContextAttributes getContextAttributes() native;\n\n  @DomName('WebGLRenderingContext.getError')\n  @DocsEditable\n  int getError() native;\n\n  @DomName('WebGLRenderingContext.getExtension')\n  @DocsEditable\n  Object getExtension(String name) native;\n\n  @DomName('WebGLRenderingContext.getFramebufferAttachmentParameter')\n  @DocsEditable\n  Object getFramebufferAttachmentParameter(int target, int attachment, int pname) native;\n\n  @DomName('WebGLRenderingContext.getParameter')\n  @DocsEditable\n  @Creates('Null|num|String|bool|=List|Float32List|Int32List|Uint32List|Framebuffer|Renderbuffer|Texture')\n  @Returns('Null|num|String|bool|=List|Float32List|Int32List|Uint32List|Framebuffer|Renderbuffer|Texture')\n  Object getParameter(int pname) native;\n\n  @DomName('WebGLRenderingContext.getProgramInfoLog')\n  @DocsEditable\n  String getProgramInfoLog(Program program) native;\n\n  @DomName('WebGLRenderingContext.getProgramParameter')\n  @DocsEditable\n  Object getProgramParameter(Program program, int pname) native;\n\n  @DomName('WebGLRenderingContext.getRenderbufferParameter')\n  @DocsEditable\n  Object getRenderbufferParameter(int target, int pname) native;\n\n  @DomName('WebGLRenderingContext.getShaderInfoLog')\n  @DocsEditable\n  String getShaderInfoLog(Shader shader) native;\n\n  @DomName('WebGLRenderingContext.getShaderParameter')\n  @DocsEditable\n  Object getShaderParameter(Shader shader, int pname) native;\n\n  @DomName('WebGLRenderingContext.getShaderPrecisionFormat')\n  @DocsEditable\n  ShaderPrecisionFormat getShaderPrecisionFormat(int shadertype, int precisiontype) native;\n\n  @DomName('WebGLRenderingContext.getShaderSource')\n  @DocsEditable\n  String getShaderSource(Shader shader) native;\n\n  @DomName('WebGLRenderingContext.getSupportedExtensions')\n  @DocsEditable\n  List<String> getSupportedExtensions() native;\n\n  @DomName('WebGLRenderingContext.getTexParameter')\n  @DocsEditable\n  Object getTexParameter(int target, int pname) native;\n\n  @DomName('WebGLRenderingContext.getUniform')\n  @DocsEditable\n  Object getUniform(Program program, UniformLocation location) native;\n\n  @DomName('WebGLRenderingContext.getUniformLocation')\n  @DocsEditable\n  UniformLocation getUniformLocation(Program program, String name) native;\n\n  @DomName('WebGLRenderingContext.getVertexAttrib')\n  @DocsEditable\n  Object getVertexAttrib(int index, int pname) native;\n\n  @DomName('WebGLRenderingContext.getVertexAttribOffset')\n  @DocsEditable\n  int getVertexAttribOffset(int index, int pname) native;\n\n  @DomName('WebGLRenderingContext.hint')\n  @DocsEditable\n  void hint(int target, int mode) native;\n\n  @DomName('WebGLRenderingContext.isBuffer')\n  @DocsEditable\n  bool isBuffer(Buffer buffer) native;\n\n  @DomName('WebGLRenderingContext.isContextLost')\n  @DocsEditable\n  bool isContextLost() native;\n\n  @DomName('WebGLRenderingContext.isEnabled')\n  @DocsEditable\n  bool isEnabled(int cap) native;\n\n  @DomName('WebGLRenderingContext.isFramebuffer')\n  @DocsEditable\n  bool isFramebuffer(Framebuffer framebuffer) native;\n\n  @DomName('WebGLRenderingContext.isProgram')\n  @DocsEditable\n  bool isProgram(Program program) native;\n\n  @DomName('WebGLRenderingContext.isRenderbuffer')\n  @DocsEditable\n  bool isRenderbuffer(Renderbuffer renderbuffer) native;\n\n  @DomName('WebGLRenderingContext.isShader')\n  @DocsEditable\n  bool isShader(Shader shader) native;\n\n  @DomName('WebGLRenderingContext.isTexture')\n  @DocsEditable\n  bool isTexture(Texture texture) native;\n\n  @DomName('WebGLRenderingContext.lineWidth')\n  @DocsEditable\n  void lineWidth(num width) native;\n\n  @DomName('WebGLRenderingContext.linkProgram')\n  @DocsEditable\n  void linkProgram(Program program) native;\n\n  @DomName('WebGLRenderingContext.pixelStorei')\n  @DocsEditable\n  void pixelStorei(int pname, int param) native;\n\n  @DomName('WebGLRenderingContext.polygonOffset')\n  @DocsEditable\n  void polygonOffset(num factor, num units) native;\n\n  @DomName('WebGLRenderingContext.readPixels')\n  @DocsEditable\n  void readPixels(int x, int y, int width, int height, int format, int type, TypedData pixels) native;\n\n  @DomName('WebGLRenderingContext.releaseShaderCompiler')\n  @DocsEditable\n  void releaseShaderCompiler() native;\n\n  @DomName('WebGLRenderingContext.renderbufferStorage')\n  @DocsEditable\n  void renderbufferStorage(int target, int internalformat, int width, int height) native;\n\n  @DomName('WebGLRenderingContext.sampleCoverage')\n  @DocsEditable\n  void sampleCoverage(num value, bool invert) native;\n\n  @DomName('WebGLRenderingContext.scissor')\n  @DocsEditable\n  void scissor(int x, int y, int width, int height) native;\n\n  @DomName('WebGLRenderingContext.shaderSource')\n  @DocsEditable\n  void shaderSource(Shader shader, String string) native;\n\n  @DomName('WebGLRenderingContext.stencilFunc')\n  @DocsEditable\n  void stencilFunc(int func, int ref, int mask) native;\n\n  @DomName('WebGLRenderingContext.stencilFuncSeparate')\n  @DocsEditable\n  void stencilFuncSeparate(int face, int func, int ref, int mask) native;\n\n  @DomName('WebGLRenderingContext.stencilMask')\n  @DocsEditable\n  void stencilMask(int mask) native;\n\n  @DomName('WebGLRenderingContext.stencilMaskSeparate')\n  @DocsEditable\n  void stencilMaskSeparate(int face, int mask) native;\n\n  @DomName('WebGLRenderingContext.stencilOp')\n  @DocsEditable\n  void stencilOp(int fail, int zfail, int zpass) native;\n\n  @DomName('WebGLRenderingContext.stencilOpSeparate')\n  @DocsEditable\n  void stencilOpSeparate(int face, int fail, int zfail, int zpass) native;\n\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable\n  void texImage2D(int target, int level, int internalformat, int format_OR_width, int height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, [int format, int type, TypedData pixels]) {\n    if ((border_OR_canvas_OR_image_OR_pixels_OR_video is int || border_OR_canvas_OR_image_OR_pixels_OR_video == null)) {\n      _texImage2D_1(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, format, type, pixels);\n      return;\n    }\n    if ((border_OR_canvas_OR_image_OR_pixels_OR_video is ImageData || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && !?format && !?type && !?pixels) {\n      var pixels_1 = _convertDartToNative_ImageData(border_OR_canvas_OR_image_OR_pixels_OR_video);\n      _texImage2D_2(target, level, internalformat, format_OR_width, height_OR_type, pixels_1);\n      return;\n    }\n    if ((border_OR_canvas_OR_image_OR_pixels_OR_video is ImageElement || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && !?format && !?type && !?pixels) {\n      _texImage2D_3(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);\n      return;\n    }\n    if ((border_OR_canvas_OR_image_OR_pixels_OR_video is CanvasElement || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && !?format && !?type && !?pixels) {\n      _texImage2D_4(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);\n      return;\n    }\n    if ((border_OR_canvas_OR_image_OR_pixels_OR_video is VideoElement || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && !?format && !?type && !?pixels) {\n      _texImage2D_5(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);\n      return;\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  @JSName('texImage2D')\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable\n  void _texImage2D_1(target, level, internalformat, width, height, int border, format, type, TypedData pixels) native;\n  @JSName('texImage2D')\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable\n  void _texImage2D_2(target, level, internalformat, format, type, pixels) native;\n  @JSName('texImage2D')\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable\n  void _texImage2D_3(target, level, internalformat, format, type, ImageElement image) native;\n  @JSName('texImage2D')\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable\n  void _texImage2D_4(target, level, internalformat, format, type, CanvasElement canvas) native;\n  @JSName('texImage2D')\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable\n  void _texImage2D_5(target, level, internalformat, format, type, VideoElement video) native;\n\n  @DomName('WebGLRenderingContext.texParameterf')\n  @DocsEditable\n  void texParameterf(int target, int pname, num param) native;\n\n  @DomName('WebGLRenderingContext.texParameteri')\n  @DocsEditable\n  void texParameteri(int target, int pname, int param) native;\n\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable\n  void texSubImage2D(int target, int level, int xoffset, int yoffset, int format_OR_width, int height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, [int type, TypedData pixels]) {\n    if ((canvas_OR_format_OR_image_OR_pixels_OR_video is int || canvas_OR_format_OR_image_OR_pixels_OR_video == null)) {\n      _texSubImage2D_1(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, type, pixels);\n      return;\n    }\n    if ((canvas_OR_format_OR_image_OR_pixels_OR_video is ImageData || canvas_OR_format_OR_image_OR_pixels_OR_video == null) && !?type && !?pixels) {\n      var pixels_1 = _convertDartToNative_ImageData(canvas_OR_format_OR_image_OR_pixels_OR_video);\n      _texSubImage2D_2(target, level, xoffset, yoffset, format_OR_width, height_OR_type, pixels_1);\n      return;\n    }\n    if ((canvas_OR_format_OR_image_OR_pixels_OR_video is ImageElement || canvas_OR_format_OR_image_OR_pixels_OR_video == null) && !?type && !?pixels) {\n      _texSubImage2D_3(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);\n      return;\n    }\n    if ((canvas_OR_format_OR_image_OR_pixels_OR_video is CanvasElement || canvas_OR_format_OR_image_OR_pixels_OR_video == null) && !?type && !?pixels) {\n      _texSubImage2D_4(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);\n      return;\n    }\n    if ((canvas_OR_format_OR_image_OR_pixels_OR_video is VideoElement || canvas_OR_format_OR_image_OR_pixels_OR_video == null) && !?type && !?pixels) {\n      _texSubImage2D_5(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);\n      return;\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  @JSName('texSubImage2D')\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable\n  void _texSubImage2D_1(target, level, xoffset, yoffset, width, height, int format, type, TypedData pixels) native;\n  @JSName('texSubImage2D')\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable\n  void _texSubImage2D_2(target, level, xoffset, yoffset, format, type, pixels) native;\n  @JSName('texSubImage2D')\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable\n  void _texSubImage2D_3(target, level, xoffset, yoffset, format, type, ImageElement image) native;\n  @JSName('texSubImage2D')\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable\n  void _texSubImage2D_4(target, level, xoffset, yoffset, format, type, CanvasElement canvas) native;\n  @JSName('texSubImage2D')\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable\n  void _texSubImage2D_5(target, level, xoffset, yoffset, format, type, VideoElement video) native;\n\n  @DomName('WebGLRenderingContext.uniform1f')\n  @DocsEditable\n  void uniform1f(UniformLocation location, num x) native;\n\n  @DomName('WebGLRenderingContext.uniform1fv')\n  @DocsEditable\n  void uniform1fv(UniformLocation location, Float32List v) native;\n\n  @DomName('WebGLRenderingContext.uniform1i')\n  @DocsEditable\n  void uniform1i(UniformLocation location, int x) native;\n\n  @DomName('WebGLRenderingContext.uniform1iv')\n  @DocsEditable\n  void uniform1iv(UniformLocation location, Int32List v) native;\n\n  @DomName('WebGLRenderingContext.uniform2f')\n  @DocsEditable\n  void uniform2f(UniformLocation location, num x, num y) native;\n\n  @DomName('WebGLRenderingContext.uniform2fv')\n  @DocsEditable\n  void uniform2fv(UniformLocation location, Float32List v) native;\n\n  @DomName('WebGLRenderingContext.uniform2i')\n  @DocsEditable\n  void uniform2i(UniformLocation location, int x, int y) native;\n\n  @DomName('WebGLRenderingContext.uniform2iv')\n  @DocsEditable\n  void uniform2iv(UniformLocation location, Int32List v) native;\n\n  @DomName('WebGLRenderingContext.uniform3f')\n  @DocsEditable\n  void uniform3f(UniformLocation location, num x, num y, num z) native;\n\n  @DomName('WebGLRenderingContext.uniform3fv')\n  @DocsEditable\n  void uniform3fv(UniformLocation location, Float32List v) native;\n\n  @DomName('WebGLRenderingContext.uniform3i')\n  @DocsEditable\n  void uniform3i(UniformLocation location, int x, int y, int z) native;\n\n  @DomName('WebGLRenderingContext.uniform3iv')\n  @DocsEditable\n  void uniform3iv(UniformLocation location, Int32List v) native;\n\n  @DomName('WebGLRenderingContext.uniform4f')\n  @DocsEditable\n  void uniform4f(UniformLocation location, num x, num y, num z, num w) native;\n\n  @DomName('WebGLRenderingContext.uniform4fv')\n  @DocsEditable\n  void uniform4fv(UniformLocation location, Float32List v) native;\n\n  @DomName('WebGLRenderingContext.uniform4i')\n  @DocsEditable\n  void uniform4i(UniformLocation location, int x, int y, int z, int w) native;\n\n  @DomName('WebGLRenderingContext.uniform4iv')\n  @DocsEditable\n  void uniform4iv(UniformLocation location, Int32List v) native;\n\n  @DomName('WebGLRenderingContext.uniformMatrix2fv')\n  @DocsEditable\n  void uniformMatrix2fv(UniformLocation location, bool transpose, Float32List array) native;\n\n  @DomName('WebGLRenderingContext.uniformMatrix3fv')\n  @DocsEditable\n  void uniformMatrix3fv(UniformLocation location, bool transpose, Float32List array) native;\n\n  @DomName('WebGLRenderingContext.uniformMatrix4fv')\n  @DocsEditable\n  void uniformMatrix4fv(UniformLocation location, bool transpose, Float32List array) native;\n\n  @DomName('WebGLRenderingContext.useProgram')\n  @DocsEditable\n  void useProgram(Program program) native;\n\n  @DomName('WebGLRenderingContext.validateProgram')\n  @DocsEditable\n  void validateProgram(Program program) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib1f')\n  @DocsEditable\n  void vertexAttrib1f(int indx, num x) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib1fv')\n  @DocsEditable\n  void vertexAttrib1fv(int indx, Float32List values) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib2f')\n  @DocsEditable\n  void vertexAttrib2f(int indx, num x, num y) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib2fv')\n  @DocsEditable\n  void vertexAttrib2fv(int indx, Float32List values) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib3f')\n  @DocsEditable\n  void vertexAttrib3f(int indx, num x, num y, num z) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib3fv')\n  @DocsEditable\n  void vertexAttrib3fv(int indx, Float32List values) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib4f')\n  @DocsEditable\n  void vertexAttrib4f(int indx, num x, num y, num z, num w) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib4fv')\n  @DocsEditable\n  void vertexAttrib4fv(int indx, Float32List values) native;\n\n  @DomName('WebGLRenderingContext.vertexAttribPointer')\n  @DocsEditable\n  void vertexAttribPointer(int indx, int size, int type, bool normalized, int stride, int offset) native;\n\n  @DomName('WebGLRenderingContext.viewport')\n  @DocsEditable\n  void viewport(int x, int y, int width, int height) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLShader')\nclass Shader native \"WebGLShader\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLShaderPrecisionFormat')\nclass ShaderPrecisionFormat native \"WebGLShaderPrecisionFormat\" {\n\n  @DomName('WebGLShaderPrecisionFormat.precision')\n  @DocsEditable\n  final int precision;\n\n  @DomName('WebGLShaderPrecisionFormat.rangeMax')\n  @DocsEditable\n  final int rangeMax;\n\n  @DomName('WebGLShaderPrecisionFormat.rangeMin')\n  @DocsEditable\n  final int rangeMin;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLTexture')\nclass Texture native \"WebGLTexture\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLUniformLocation')\nclass UniformLocation native \"WebGLUniformLocation\" {\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('WebGLVertexArrayObjectOES')\nclass VertexArrayObject native \"WebGLVertexArrayObjectOES\" {\n}\n","sdk/lib/web_sql/dart2js/web_sql_dart2js.dart":"/**\n * An API for storing data in the browser that can be queried with SQL.\n *\n * **Caution:** this specification is no longer actively maintained by the Web\n * Applications Working Group and may be removed at any time.\n * See [the W3C Web SQL Database specification](http://www.w3.org/TR/webdatabase/)\n * for more information.\n *\n * The [dart:indexed_db] APIs is a recommended alternatives.\n */\nlibrary dart.dom.web_sql;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:_collection-dev';\nimport 'dart:html';\nimport 'dart:html_common';\nimport 'dart:_js_helper' show convertDartClosureToJS, Creates, JavaScriptIndexingBehavior, JSName;\nimport 'dart:_foreign_helper' show JS;\n// DO NOT EDIT - unless you are editing documentation as per:\n// https://code.google.com/p/dart/wiki/ContributingHTMLDocumentation\n// Auto-generated dart:audio library.\n\n\n\n\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void SqlStatementCallback(SqlTransaction transaction, SqlResultSet resultSet);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void SqlStatementErrorCallback(SqlTransaction transaction, SqlError error);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void SqlTransactionCallback(SqlTransaction transaction);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\ntypedef void SqlTransactionErrorCallback(SqlError error);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('Database')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental\nclass SqlDatabase native \"Database\" {\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.openDatabase)');\n\n  @DomName('Database.version')\n  @DocsEditable\n  final String version;\n\n  /**\n   * Atomically update the database version to [newVersion], asynchronously\n   * running [callback] on the [SqlTransaction] representing this\n   * [changeVersion] transaction.\n   *\n   * If [callback] runs successfully, then [successCallback] is called.\n   * Otherwise, [errorCallback] is called.\n   *\n   * [oldVersion] should match the database's current [version] exactly.\n   *\n   * * [Database.changeVersion](http://www.w3.org/TR/webdatabase/#dom-database-changeversion) from W3C.\n   */\n  @DomName('Database.changeVersion')\n  @DocsEditable\n  void changeVersion(String oldVersion, String newVersion, [SqlTransactionCallback callback, SqlTransactionErrorCallback errorCallback, VoidCallback successCallback]) native;\n\n  @DomName('Database.readTransaction')\n  @DocsEditable\n  void readTransaction(SqlTransactionCallback callback, [SqlTransactionErrorCallback errorCallback, VoidCallback successCallback]) native;\n\n  @DomName('Database.transaction')\n  @DocsEditable\n  void transaction(SqlTransactionCallback callback, [SqlTransactionErrorCallback errorCallback, VoidCallback successCallback]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SQLError')\nclass SqlError native \"SQLError\" {\n\n  static const int CONSTRAINT_ERR = 6;\n\n  static const int DATABASE_ERR = 1;\n\n  static const int QUOTA_ERR = 4;\n\n  static const int SYNTAX_ERR = 5;\n\n  static const int TIMEOUT_ERR = 7;\n\n  static const int TOO_LARGE_ERR = 3;\n\n  static const int UNKNOWN_ERR = 0;\n\n  static const int VERSION_ERR = 2;\n\n  @DomName('SQLError.code')\n  @DocsEditable\n  final int code;\n\n  @DomName('SQLError.message')\n  @DocsEditable\n  final String message;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SQLException')\nclass SqlException native \"SQLException\" {\n\n  static const int CONSTRAINT_ERR = 6;\n\n  static const int DATABASE_ERR = 1;\n\n  static const int QUOTA_ERR = 4;\n\n  static const int SYNTAX_ERR = 5;\n\n  static const int TIMEOUT_ERR = 7;\n\n  static const int TOO_LARGE_ERR = 3;\n\n  static const int UNKNOWN_ERR = 0;\n\n  static const int VERSION_ERR = 2;\n\n  @DomName('SQLException.code')\n  @DocsEditable\n  final int code;\n\n  @DomName('SQLException.message')\n  @DocsEditable\n  final String message;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SQLResultSet')\nclass SqlResultSet native \"SQLResultSet\" {\n\n  @DomName('SQLResultSet.insertId')\n  @DocsEditable\n  final int insertId;\n\n  @DomName('SQLResultSet.rows')\n  @DocsEditable\n  final SqlResultSetRowList rows;\n\n  @DomName('SQLResultSet.rowsAffected')\n  @DocsEditable\n  final int rowsAffected;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SQLResultSetRowList')\nclass SqlResultSetRowList implements JavaScriptIndexingBehavior, List<Map> native \"SQLResultSetRowList\" {\n\n  @DomName('SQLResultSetRowList.length')\n  @DocsEditable\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Map operator[](int index) => this.item(index);\n\n  void operator[]=(int index, Map value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Map> mixins.\n  // Map is the element type.\n\n  // From Iterable<Map>:\n\n  Iterator<Map> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<Map>(this);\n  }\n\n  Map reduce(Map combine(Map value, Map element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n               dynamic combine(dynamic previousValue, Map element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  bool contains(Map element) => IterableMixinWorkaround.contains(this, element);\n\n  void forEach(void f(Map element)) => IterableMixinWorkaround.forEach(this, f);\n\n  String join([String separator = \"\"]) =>\n      IterableMixinWorkaround.joinList(this, separator);\n\n  Iterable map(f(Map element)) =>\n      IterableMixinWorkaround.mapList(this, f);\n\n  Iterable<Map> where(bool f(Map element)) =>\n      IterableMixinWorkaround.where(this, f);\n\n  Iterable expand(Iterable f(Map element)) =>\n      IterableMixinWorkaround.expand(this, f);\n\n  bool every(bool f(Map element)) => IterableMixinWorkaround.every(this, f);\n\n  bool any(bool f(Map element)) => IterableMixinWorkaround.any(this, f);\n\n  List<Map> toList({ bool growable: true }) =>\n      new List<Map>.from(this, growable: growable);\n\n  Set<Map> toSet() => new Set<Map>.from(this);\n\n  bool get isEmpty => this.length == 0;\n\n  Iterable<Map> take(int n) => IterableMixinWorkaround.takeList(this, n);\n\n  Iterable<Map> takeWhile(bool test(Map value)) {\n    return IterableMixinWorkaround.takeWhile(this, test);\n  }\n\n  Iterable<Map> skip(int n) => IterableMixinWorkaround.skipList(this, n);\n\n  Iterable<Map> skipWhile(bool test(Map value)) {\n    return IterableMixinWorkaround.skipWhile(this, test);\n  }\n\n  Map firstWhere(bool test(Map value), { Map orElse() }) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  Map lastWhere(bool test(Map value), {Map orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  Map singleWhere(bool test(Map value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  Map elementAt(int index) {\n    return this[index];\n  }\n\n  // From Collection<Map>:\n\n  void add(Map value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<Map> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<Map>:\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  void clear() {\n    throw new UnsupportedError(\"Cannot clear immutable List.\");\n  }\n\n  Iterable<Map> get reversed {\n    return IterableMixinWorkaround.reversedList(this);\n  }\n\n  void sort([int compare(Map a, Map b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  int indexOf(Map element, [int start = 0]) =>\n      Lists.indexOf(this, element, start, this.length);\n\n  int lastIndexOf(Map element, [int start]) {\n    if (start == null) start = length - 1;\n    return Lists.lastIndexOf(this, element, start);\n  }\n\n  Map get first {\n    if (this.length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  Map get last {\n    if (this.length > 0) return this[this.length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  Map get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void insert(int index, Map element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<Map> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<Map> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Map removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  Map removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(Map element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(Map element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<Map> iterable, [int skipCount=0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<Map> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [Map fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  Iterable<Map> getRange(int start, int end) =>\n    IterableMixinWorkaround.getRangeList(this, start, end);\n\n  List<Map> sublist(int start, [int end]) {\n    if (end == null) end = length;\n    return Lists.getRange(this, start, end, <Map>[]);\n  }\n\n  Map<int, Map> asMap() =>\n    IterableMixinWorkaround.asMapList(this);\n\n  String toString() {\n    StringBuffer buffer = new StringBuffer('[');\n    buffer.writeAll(this, ', ');\n    buffer.write(']');\n    return buffer.toString();\n  }\n\n  // -- end List<Map> mixins.\n\n  @DomName('SQLResultSetRowList.item')\n  @DocsEditable\n  @Creates('=Object')\n  Map item(int index) {\n    return convertNativeToDart_Dictionary(_item_1(index));\n  }\n  @JSName('item')\n  @DomName('SQLResultSetRowList.item')\n  @DocsEditable\n  @Creates('=Object')\n  _item_1(index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SQLTransaction')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental\nclass SqlTransaction native \"SQLTransaction\" {\n\n  @DomName('SQLTransaction.executeSql')\n  @DocsEditable\n  void executeSql(String sqlStatement, List arguments, [SqlStatementCallback callback, SqlStatementErrorCallback errorCallback]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable\n@DomName('SQLTransactionSync')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental\nabstract class _SQLTransactionSync native \"SQLTransactionSync\" {\n}\n"}
